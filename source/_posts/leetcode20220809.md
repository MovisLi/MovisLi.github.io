---
title: LeetCode 496
date: 2022-08-09 01:20:13
categories: [ComputerScience, Algorithm, LeetCode]
tags: [python, hash]
---

# 496. 下一个更大元素 I

首先很容易想到暴力法：

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = []
        nums2_len = len(nums2)
        for i in nums1:
            j = nums2.index(i)+1
            flag = False
            for v in range(j, nums2_len):
                if nums2[v] > i:
                    res.append(nums2[v])
                    flag = True
                    break
            if not flag:
                res.append(-1)
        return res
```

不过很慢。很明显，从慢的时间上来讲，肯定是算法不够好而不是没有优化。然后观察上面的算法可以发现，其实慢就慢在 `j = nums2.index(i)+1` 这里。每次都得重新去寻找元素的下标，这个时候就会想到空间换时间这种方法，就会想到 `dict` ，也就是哈希：

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = []
        hashmap = {}
        nums2_len = len(nums2)
        for i,v in enumerate(nums2):
            hashmap[v] = i
        for i in nums1:
            j = hashmap[i]+1
            flag = False
            while j<nums2_len:
                if nums2[j] > i:
                    res.append(nums2[j])
                    flag = True
                    break
                j += 1
            if not flag:
                res.append(-1)
        return res
```




<!DOCTYPE html>
<html lang="en" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#414142">
  <meta name="author" content="MovisLi">
  <meta name="keywords" content="ComputerScience, DataScience, Economics&amp;Finance, Management">
  
    <meta name="description" content="算法入门 二分查找 704. 二分查找 经典二分查找。 class Solution:     def search(self, nums: List[int], target: int) -&gt; int:         left &#x3D; 0         right &#x3D; len(nums) - 1         while left &lt;&#x3D; right:">
<meta property="og:type" content="article">
<meta property="og:title" content="「算法」 - 学习计划">
<meta property="og:url" content="https://movisli.github.io/2022/02/16/leetcode%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="movis">
<meta property="og:description" content="算法入门 二分查找 704. 二分查找 经典二分查找。 class Solution:     def search(self, nums: List[int], target: int) -&gt; int:         left &#x3D; 0         right &#x3D; len(nums) - 1         while left &lt;&#x3D; right:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-15T17:48:12.000Z">
<meta property="article:modified_time" content="2024-06-07T08:32:58.968Z">
<meta property="article:author" content="MovisLi">
<meta property="article:tag" content="python">
<meta property="article:tag" content="point">
<meta property="article:tag" content="binary search">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>「算法」 - 学习计划 - movis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"movisli.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Movis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="「算法」 - 学习计划"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        MovisLi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-16 01:48" pubdate>
          February 16, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k words
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">「算法」 - 学习计划</h1>
            
            <div class="markdown-body">
              
              <h1 id="算法入门">算法入门</h1>
<h2 id="二分查找">二分查找</h2>
<h3 id="二分查找-1">704. 二分查找</h3>
<p>经典二分查找。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        left = <span class="hljs-number">0</span>
        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> left &lt;= right:
            mid = (left + right) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid] == target:
                <span class="hljs-keyword">return</span> mid
            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:
                right = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                left = mid + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>
<h3 id="第一个错误的版本">278. 第一个错误的版本</h3>
<p>第一个错误的版本就是左边是正确的版本，右边是错误的版本时的右边的版本，也就是满足这个条件的时候就该跳出循环。</p>
<p>因此我们可以二分去查找，但是注意如果 <code>mid</code>
是错误的版本，<code>right</code> 等于它，反之 <code>left</code>
等于它。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        left = <span class="hljs-number">0</span>
        right = n
        <span class="hljs-keyword">while</span> right-left != <span class="hljs-number">1</span>:
            mid = (left+right) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> isBadVersion(mid):
                right = mid
            <span class="hljs-keyword">else</span>:
                left = mid
        <span class="hljs-keyword">return</span> right</code></pre></div>
<h3 id="搜索插入位置">35. 搜索插入位置</h3>
<p>经典二分法，搜不到的时候左指针就是该插入的位置。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        left = <span class="hljs-number">0</span>
        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> left &lt;= right:
            mid = (left+right) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid] == target:
                <span class="hljs-keyword">return</span> mid
            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:
                right = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                left = mid + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> left</code></pre></div>
<h2 id="双指针">双指针</h2>
<h3 id="有序数组的平方">977. 有序数组的平方</h3>
<p>这道题在解释里面是先平方再排序，也就是 <code>O(NlogN)</code>
的时间复杂度。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x*x, nums))</code></pre></div>
<p>这里我就不展开写排序算法了因为 <code>Python</code>
有的时候算法比内置函数慢在内置是用 <code>C</code> 写的。</p>
<p>也可以像二分查找的一样类似每遍历一个元素，平方，再搜索插入位置。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
            left = <span class="hljs-number">0</span>
            right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> left &lt;= right:
                mid = (left+right) // <span class="hljs-number">2</span>
                <span class="hljs-keyword">if</span> nums[mid] == target:
                    <span class="hljs-keyword">return</span> mid
                <span class="hljs-keyword">elif</span> nums[mid] &gt; target:
                    right = mid - <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    left = mid + <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> left
        
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            temp = i*i
            res.insert(searchInsert(res, temp), temp)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>然而这个时间真的是慢得不行。</p>
<h3 id="轮转数组">189. 轮转数组</h3>
<p>在我的印象里这道题就是反转三次解决的题：</p>
<ol type="1">
<li>反转素有元素</li>
<li>(0, k-1) 反转</li>
<li>(k, n-1) 反转</li>
</ol>
<p>此外我们需要考虑下 <code>k &gt;= n</code> ：</p>
<ul>
<li>k = n 时 - 结果和不移动一样。</li>
<li>k &gt; n 时 - 结果和 <code>k%n</code> 一样。</li>
</ul>
<p>因此：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        n = <span class="hljs-built_in">len</span>(nums)
        k %= n
        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n//<span class="hljs-number">2</span>):
            nums[i], nums[n-i-<span class="hljs-number">1</span>] = nums[n-i-<span class="hljs-number">1</span>], nums[i]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k//<span class="hljs-number">2</span>):
            nums[i], nums[k-i-<span class="hljs-number">1</span>] = nums[k-i-<span class="hljs-number">1</span>], nums[i]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k, (k+n)//<span class="hljs-number">2</span>):
            nums[i], nums[n-i-<span class="hljs-number">1</span>+k] = nums[n-i-<span class="hljs-number">1</span>+k], nums[i]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>但是这道题对 Python 的意义应该是深入理解切片的使用。</p>
<ul>
<li><code>[start:stop：step]</code>
<ul>
<li>表示从下标 <code>start</code> 开始取到 <code>stop</code>
为止（不包括下标 <code>stop</code> 的值）的值，也就是前闭后开。</li>
<li><code>step</code> 为正代表向右取数，<code>step</code>
为负代表向左取数，如果取不到结果就返回空子集（字符串是 <code>''</code>
，列表是 <code>[]</code>，元组是 <code>()</code> ），举个例子，字符串
<code>temp = "string"</code> ：
<ul>
<li><code>temp[-1:1]</code> - 1 元素在 -1 元素右边，取不到。</li>
<li><code>temp[-2:4]</code> - 等同于 <code>temp[4:4]</code>
，取不到因为不包括右边的值。</li>
</ul></li>
<li><code>step</code> 为 1 时可以省略 <code>step</code> 。对于
<code>start</code> 和 <code>stop</code>
来讲，省略相当于在这个方向上无限取数，这个方向和 <code>step</code>
有关。</li>
</ul></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        k %= <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        nums[::] = nums[::-<span class="hljs-number">1</span>]
        nums[k::] = nums[:k-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]
        nums[:k:] = nums[k-<span class="hljs-number">1</span>::-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>不过对于切片来讲，这道题其实可以一次切完。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        n = <span class="hljs-built_in">len</span>(nums)
        k %= n
        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        nums[:k], nums[k:] = nums[n-k:], nums[:n-k]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="移动零">283. 移动零</h3>
<p>快慢指针问题，分两步：</p>
<ol type="1">
<li>填非零值，快指针负责遍历数组找到非零值，填入慢指针指向位置，然而慢指针前进一位，否则不处理。</li>
<li>填零值，从慢指针开始移动到数组尾端都填 0 。</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:
        slow = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> fast, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):
            <span class="hljs-keyword">if</span> value:
                nums[slow] = value
                slow += <span class="hljs-number">1</span>
        nums[slow::] = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(slow, <span class="hljs-built_in">len</span>(nums))]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="两数之和-ii---输入有序数组">167. 两数之和 II - 输入有序数组</h3>
<p>其实和第一题 <code>两数之和</code> 还是挺像的，依然是用
<code>dict</code> 记录是否存在满足条件的数。两个小坑，第一个 index 从 1
开始，第二个说不能使用重复的元素是指不能用同一个数而不是同一个值（如果数组里有两个一样的依然可以用）。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numbers):
            <span class="hljs-keyword">if</span> target-v <span class="hljs-keyword">in</span> hashmap:
                <span class="hljs-keyword">return</span> [hashmap[target-v]+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span>:
                hashmap[v] = i
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="反转字符串">344. 反转字符串</h3>
<p>这是真的经典双指针，一个指向头一个指向尾，然后交换值再都向对方移动一位，直到相遇。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:
        left = <span class="hljs-number">0</span>
        right = <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> left&lt;right:
            s[left], s[right] = s[right], s[left]
            left += <span class="hljs-number">1</span>
            right -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>或者用 <code>for</code> 循环。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:
        s_len = <span class="hljs-built_in">len</span>(s)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len//<span class="hljs-number">2</span>):
            s[i], s[s_len-i-<span class="hljs-number">1</span>] = s[s_len-i-<span class="hljs-number">1</span>], s[i]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>当然 Python 里面用切片是最方便的：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:
        s[:] = s[::-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="反转字符串中的单词-iii">557. 反转字符串中的单词 III</h3>
<p><code>join()</code> 加列表生成式加切片。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        s_lst = s.split()
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join([i[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s_lst])</code></pre></div>
<h3 id="链表的中间结点">876. 链表的中间结点</h3>
<p>这道题被归到双指针题目里面，显然就是一道快慢指针的问题，逻辑很简单，快指针走两次，慢指针走一次。最后慢指针的位置就是中间结点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        slow = head
        fast = head
        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:
            slow = slow.<span class="hljs-built_in">next</span>
            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> slow</code></pre></div>
<h3 id="删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</h3>
<p>第一种思路，一次扫描，之后再删。注意要删一个结点需要找到的是它的前序结点（而不是它自己）。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        counter = <span class="hljs-number">0</span>
        node = head
        <span class="hljs-keyword">while</span> node:
            node = node.<span class="hljs-built_in">next</span>
            counter += <span class="hljs-number">1</span>
        dummy = ListNode(<span class="hljs-number">0</span>, head)
        node = dummy
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter-n):
            node = node.<span class="hljs-built_in">next</span>
        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>这里我感觉有个坑就是测试用例好像是异步跑的 。我曾经想过用：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        counter = <span class="hljs-number">0</span>
        node = head
        <span class="hljs-keyword">while</span> node:
            node = node.<span class="hljs-built_in">next</span>
            counter += <span class="hljs-number">1</span>
        node = head
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter-n-<span class="hljs-number">1</span>):
            node = node.<span class="hljs-built_in">next</span>
        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> head</code></pre></div>
<p>会得到如下报错，假如你打印错误的话你会很迷，其实这是第二个测试用例的错误。</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212171014954.png" srcset="/img/loading.gif" lazyload /></p>
<p>应该写成：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        counter = <span class="hljs-number">0</span>
        node = head
        <span class="hljs-keyword">while</span> node:
            node = node.<span class="hljs-built_in">next</span>
            counter += <span class="hljs-number">1</span>
        node = head
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter-n-<span class="hljs-number">1</span>):
            node = node.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.<span class="hljs-built_in">next</span>:
            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span>
        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> head</code></pre></div>
<p>第二种是快慢指针的方式：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode(<span class="hljs-number">0</span>, head)
        fast = head
        slow = dummy
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            fast = fast.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">while</span> fast:
            fast = fast.<span class="hljs-built_in">next</span>
            slow = slow.<span class="hljs-built_in">next</span>
        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h2 id="滑动窗口">滑动窗口</h2>
<h3 id="无重复字符的最长子串">3. 无重复字符的最长子串</h3>
<p>我们采用队列来实现滑动窗口，遍历字符串，当队里没有当前字符时，当前字符入队；当队里有当前字符时，先统计队列长度进而看情况更新最大子字符串，出队直到队里没有当前字符，再添加当前字符到队尾。考虑到字符串字符都不一样的情况，也就是没有更新最大子字符串长度，遍历完之后还应该更新一次。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        queue = []
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> queue:
                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">len</span>(queue))
                <span class="hljs-keyword">while</span> queue[<span class="hljs-number">0</span>] != i:
                    <span class="hljs-keyword">del</span> queue[<span class="hljs-number">0</span>]
                <span class="hljs-keyword">del</span> queue[<span class="hljs-number">0</span>]
            queue.append(i)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">len</span>(queue))</code></pre></div>
<h3 id="字符串的排列">567. 字符串的排列</h3>
<p><code>s1</code> 排列之一是 <code>s2</code> 的字串，这句话的意思就是
<code>s1</code> 的 <code>dict</code> 计数结果和 <code>s2</code> 的某字串
<code>dict</code> 计数结果是一样的，那么显然 <code>s2</code>
这个字串长度和 <code>s1</code>
也就一样了。所以我们可以模拟这个计数过程。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        s1_dict = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s1:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1_dict:
                s1_dict[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                s1_dict[i] += <span class="hljs-number">1</span>
        s1_len = <span class="hljs-built_in">len</span>(s1)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s2)-s1_len+<span class="hljs-number">1</span>):
            subs = s2[i:i+s1_len]
            subs_dict = &#123;&#125;
            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> subs:
                <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> subs_dict:
                    subs_dict[v] = <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    subs_dict[v] += <span class="hljs-number">1</span>
            flag = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> subs_dict.items():
                <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1_dict <span class="hljs-keyword">or</span> v != s1_dict[k]:
                    flag = <span class="hljs-literal">False</span>
                    <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> flag:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>那么上面的代码是很慢的，我们可以发现根本没有必要每次创建
<code>dict</code> ，维护一个 <code>dict</code> 就行了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        s1_len = <span class="hljs-built_in">len</span>(s1)
        s2_len = <span class="hljs-built_in">len</span>(s2)
        <span class="hljs-keyword">if</span> s1_len &gt; s2_len:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        s1_dict = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s1:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1_dict:
                s1_dict[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                s1_dict[i] += <span class="hljs-number">1</span>
        s2_dict = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s1_len):
            <span class="hljs-keyword">if</span> s2[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict:
                s2_dict[s2[i]] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                s2_dict[s2[i]] += <span class="hljs-number">1</span>
        flag = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> s1_dict.items():
            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict <span class="hljs-keyword">or</span> v != s2_dict[k]:
                flag = <span class="hljs-literal">False</span>
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> flag:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s1_len, s2_len):
            s2_dict[s2[i-s1_len]] -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> s2[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict:
                s2_dict[s2[i]] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                s2_dict[s2[i]] += <span class="hljs-number">1</span>
            flag = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> s1_dict.items():
                <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict <span class="hljs-keyword">or</span> v != s2_dict[k]:
                    flag = <span class="hljs-literal">False</span>
                    <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> flag:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>如果用 collections 的 Counter 看起来就很简洁，但是似乎变慢了：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        s1_len = <span class="hljs-built_in">len</span>(s1)
        s1_dict = collections.Counter(s1)
        s2_dict = collections.Counter(s2[:s1_len])
        <span class="hljs-keyword">if</span> s1_dict == s2_dict:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s1_len, <span class="hljs-built_in">len</span>(s2)):
            s2_dict[s2[i-s1_len]] -= <span class="hljs-number">1</span>
            s2_dict.update(&#123;s2[i]:<span class="hljs-number">1</span>&#125;)
            <span class="hljs-keyword">if</span> s1_dict == s2_dict:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h2 id="广度优先搜索-深度优先搜索">广度优先搜索 / 深度优先搜索</h2>
<h3 id="图像渲染">733. 图像渲染</h3>
<p>深度优先搜索的递归解法。为了防止无限循环，我们需要一个
<code>record</code> 数组来记录已经遍历过的点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">floodFill</span>(<span class="hljs-params">self, image: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sr: <span class="hljs-built_in">int</span>, sc: <span class="hljs-built_in">int</span>, color: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m = <span class="hljs-built_in">len</span>(image)
        n = <span class="hljs-built_in">len</span>(image[<span class="hljs-number">0</span>])
        record = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_floodFill</span>(<span class="hljs-params">image, sr, sc</span>):
            <span class="hljs-keyword">if</span> record[sr][sc]:
                temp, image[sr][sc], record[sr][sc] = image[sr][sc], color, <span class="hljs-number">0</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> image
            <span class="hljs-keyword">if</span> sr&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[sr-<span class="hljs-number">1</span>][sc]==temp:
                image = _floodFill(image, sr-<span class="hljs-number">1</span>, sc)
            <span class="hljs-keyword">if</span> sr+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> image[sr+<span class="hljs-number">1</span>][sc]==temp:
                image = _floodFill(image, sr+<span class="hljs-number">1</span>, sc)
            <span class="hljs-keyword">if</span> sc&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[sr][sc-<span class="hljs-number">1</span>]==temp:
                image = _floodFill(image, sr, sc-<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> sc+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> image[sr][sc+<span class="hljs-number">1</span>]==temp:
                image = _floodFill(image, sr, sc+<span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> image
        image = _floodFill(image, sr, sc)
        <span class="hljs-keyword">return</span> image</code></pre></div>
<p>当然我们也可以用栈来实现非递归算法。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">floodFill</span>(<span class="hljs-params">self, image: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sr: <span class="hljs-built_in">int</span>, sc: <span class="hljs-built_in">int</span>, color: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m = <span class="hljs-built_in">len</span>(image)
        n = <span class="hljs-built_in">len</span>(image[<span class="hljs-number">0</span>])
        record = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        stack = [(sr,sc)]
        <span class="hljs-keyword">while</span> stack:
            i,j = stack.pop()
            <span class="hljs-keyword">if</span> record[i][j]:
                temp, image[i][j], record[i][j] = image[i][j], color, <span class="hljs-number">0</span>
                <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> image[i][j+<span class="hljs-number">1</span>] == temp:
                    stack.append((i, j+<span class="hljs-number">1</span>))
                <span class="hljs-keyword">if</span> j&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[i][j-<span class="hljs-number">1</span>] == temp:
                    stack.append((i, j-<span class="hljs-number">1</span>))
                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> image[i+<span class="hljs-number">1</span>][j] == temp:
                    stack.append((i+<span class="hljs-number">1</span>, j))
                <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[i-<span class="hljs-number">1</span>][j] == temp:
                    stack.append((i-<span class="hljs-number">1</span>, j))
        <span class="hljs-keyword">return</span> image</code></pre></div>
<h3 id="岛屿的最大面积">695. 岛屿的最大面积</h3>
<p>与上题相似，我们需要一个 <code>record</code>
来记录某个点是否被算过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxAreaOfIsland</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        m = <span class="hljs-built_in">len</span>(grid)
        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])
        record = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        max_count = <span class="hljs-number">0</span>

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):
            stack = [(i, j)]
            res = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> stack:
                i,j = stack.pop()
                <span class="hljs-keyword">if</span> record[i][j]:
                    record[i][j] = <span class="hljs-number">0</span>
                    res += <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> grid[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>:
                        stack.append((i, j+<span class="hljs-number">1</span>))
                    <span class="hljs-keyword">if</span> j&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> grid[i][j-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>:
                        stack.append((i, j-<span class="hljs-number">1</span>))
                    <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> grid[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>:
                        stack.append((i+<span class="hljs-number">1</span>, j))
                    <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> grid[i-<span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>:
                        stack.append((i-<span class="hljs-number">1</span>, j))
            <span class="hljs-keyword">return</span> res

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:
                    max_count = <span class="hljs-built_in">max</span>(max_count, dfs(i, j))

        <span class="hljs-keyword">return</span> max_count</code></pre></div>
<h3 id="合并二叉树">617. 合并二叉树</h3>
<p>深度优先搜索，递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1: <span class="hljs-type">Optional</span>[TreeNode], root2: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">and</span> root2:
            root1.val += root2.val
            root1.left = self.mergeTrees(root1.left, root2.left)
            root1.right = self.mergeTrees(root1.right, root2.right)
            <span class="hljs-keyword">return</span> root1
        <span class="hljs-keyword">return</span> root1 <span class="hljs-keyword">or</span> root2</code></pre></div>
<p>也可以不用递归，这时我们需要栈。假设我们的目的是把 <code>root2</code>
合并到 <code>root1</code> 里，我们会有如下情况：</p>
<ul>
<li>首先我们需要出栈拿到 <code>root1</code> , <code>root2</code>
的节点。</li>
<li>将 <code>root1</code> 和 <code>root2</code>
的值相加，这里我们需要保证除非根节点是空的，否则不会遇到
<code>root1</code> 或 <code>root2</code> 为空的情况。</li>
<li>如果 <code>root1</code> 和 <code>root2</code>
都有右子树或都有左子树，则我们按顺序进行压栈。</li>
<li>如果 <code>root1</code> 没有右子树或者没有左子树而
<code>root2</code> 有，只需要把 <code>root2</code>
的接过来，不需要进栈操作。</li>
<li>剩余情况我们都不用做处理。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1: <span class="hljs-type">Optional</span>[TreeNode], root2: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> root1 <span class="hljs-keyword">or</span> root2
        stack = [(root1, root2)]
        <span class="hljs-keyword">while</span> stack:
            t1, t2 = stack.pop()
            <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">and</span> t2:
                t1.val += t2.val
            <span class="hljs-keyword">if</span> t1.right <span class="hljs-keyword">and</span> t2.right:
                stack.append((t1.right, t2.right))
            <span class="hljs-keyword">elif</span> t1.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                t1.right = t2.right
            <span class="hljs-keyword">if</span> t1.left <span class="hljs-keyword">and</span> t2.left:
                stack.append((t1.left, t2.left))
            <span class="hljs-keyword">elif</span> t1.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                t1.left = t2.left
        <span class="hljs-keyword">return</span> root1</code></pre></div>
<p>广度优先搜索。其实改动非常小，因为这道题本身就跟顺序没什么关系。把上面代码的
<code>pop()</code> （出栈）换成 <code>pop(0)</code>（出队）就行了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1: <span class="hljs-type">Optional</span>[TreeNode], root2: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> root1 <span class="hljs-keyword">or</span> root2
        queue = [(root1, root2)]
        <span class="hljs-keyword">while</span> queue:
            t1, t2 = queue.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">and</span> t2:
                t1.val += t2.val
            <span class="hljs-keyword">if</span> t1.right <span class="hljs-keyword">and</span> t2.right:
                queue.append((t1.right, t2.right))
            <span class="hljs-keyword">elif</span> t1.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                t1.right = t2.right
            <span class="hljs-keyword">if</span> t1.left <span class="hljs-keyword">and</span> t2.left:
                queue.append((t1.left, t2.left))
            <span class="hljs-keyword">elif</span> t1.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                t1.left = t2.left
        <span class="hljs-keyword">return</span> root1</code></pre></div>
<h3 id="填充每个节点的下一个右侧节点指针">116.
填充每个节点的下一个右侧节点指针</h3>
<p>这个填充其实是父节点在填充子节点的指针。分为左右子节点两种情况：</p>
<ul>
<li>左子节点，<code>next</code>
指针指向位置其实就是右子节点的位置。</li>
<li>右子节点，<code>next</code> 指针指向位置是此节点 <code>next</code>
指针指向节点的左子节点。</li>
</ul>
<p>想明白这个，用递归实现就很简单了：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[Node]</span>) -&gt; <span class="hljs-type">Optional</span>[Node]:
        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">and</span> root.left <span class="hljs-keyword">and</span> root.right:
            root.left.<span class="hljs-built_in">next</span> = root.right
            <span class="hljs-keyword">if</span> root.<span class="hljs-built_in">next</span>:
                root.right.<span class="hljs-built_in">next</span> = root.<span class="hljs-built_in">next</span>.left
            root.left = self.connect(root.left)
            root.right = self.connect(root.right)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>对于非递归来讲，采用广度优先搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[Node]</span>) -&gt; <span class="hljs-type">Optional</span>[Node]:
        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> root
        queue = [root]
        <span class="hljs-keyword">while</span> queue:
            t = queue.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> t.left <span class="hljs-keyword">and</span> t.right:
                t.left.<span class="hljs-built_in">next</span> = t.right
                <span class="hljs-keyword">if</span> t.<span class="hljs-built_in">next</span>:
                    t.right.<span class="hljs-built_in">next</span> = t.<span class="hljs-built_in">next</span>.left
                queue.append(t.left)
                queue.append(t.right)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>也可以一直找最左节点与 <code>next</code> 指针：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[Node]</span>) -&gt; <span class="hljs-type">Optional</span>[Node]:
        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> root
        leftmost = root
        <span class="hljs-keyword">while</span> leftmost.left:
            node = leftmost
            <span class="hljs-keyword">while</span> node:
                node.left.<span class="hljs-built_in">next</span> = node.right
                <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>:
                    node.right.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.left
                node = node.<span class="hljs-built_in">next</span>
            leftmost = leftmost.left
        <span class="hljs-keyword">return</span> root</code></pre></div>
<h3 id="矩阵">542. 01 矩阵</h3>
<p>这道题第一眼应该是一道广度优先搜索的题目，然而居然超时了。</p>
<p>然后又想到一招，先记录 0 的位置，之后直接遍历距离 0
的最小值，毕竟这个距离可以用 <code>abs(x1-x0)+abs(y1-y0)</code>
得到，比上一个好像快了一点，但是依然超时。</p>
<p>然后可以转换一下，从找每个点到 0 的距离变成 0
到每个点的距离，也就是所谓的多源广度优先搜索，把 0
看作一个整体，首先找距它们 0 个位置的点（自身），再找距它们 1
个位置的点，以此类推直到找到所有点。然后我成功 AC 了一次。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m = <span class="hljs-built_in">len</span>(mat)
        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        res = [[-<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        queue = []
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mat[r][c]:
                    queue.append((r, c, <span class="hljs-number">0</span>))
        <span class="hljs-keyword">while</span> queue:
            i, j, count = queue.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> res[i][j] == -<span class="hljs-number">1</span>:
                res[i][j] = count
                <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):
                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> res[ni][nj] == -<span class="hljs-number">1</span>:
                        queue.append((ni, nj, count+<span class="hljs-number">1</span>))
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>这个通过时间显然是哪里有问题。然后打印了一下循环的信息，我发现这里有个问题，我用
<code>res</code> 去分辨哪些点的值被搜索过，而 <code>res</code>
是在出队的时候更改搜索信息的，因此，同一层（离多个 0
同一距离）的点可能会被重复添加，也就是说除了 <code>res</code>
之外，我们最好再来一个记录值是否被搜索过的，比如 <code>set</code> ？</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m = <span class="hljs-built_in">len</span>(mat)
        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        queue = []
        searched = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mat[r][c]:
                    queue.append((r, c, <span class="hljs-number">0</span>))
                    searched.add((r,c))
        <span class="hljs-keyword">while</span> queue:
            i, j, count = queue.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> (ni, nj) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:
                    res[ni][nj] = count+<span class="hljs-number">1</span>
                    queue.append((ni, nj, count+<span class="hljs-number">1</span>))
                    searched.add((ni, nj))
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>优化一下代码：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m = <span class="hljs-built_in">len</span>(mat)
        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        queue = [(r,c) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> mat[r][c]==<span class="hljs-number">0</span>]
        searched = <span class="hljs-built_in">set</span>(queue)
        <span class="hljs-keyword">while</span> queue:
            i, j = queue.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> (ni, nj) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:
                    res[ni][nj] = res[i][j]+<span class="hljs-number">1</span>
                    queue.append((ni, nj))
                    searched.add((ni, nj))
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>仍然很慢，难道是 <code>list</code> 的问题？数据量大之后
<code>list</code> 不够高效？把 <code>list</code> 换成
<code>collections.deque()</code> 双端队列。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m, n = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        queue = collections.deque()
        searched = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:
                    queue.append((i, j))
                    searched[i][j] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> queue:
            i, j = queue.popleft()
            <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[ni][nj]:
                    res[ni][nj] = res[i][j]+<span class="hljs-number">1</span>
                    queue.append((ni, nj))
                    searched[ni][nj] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>还真是，应该是 <code>list.pop(0)</code> 这个方法的事件复杂度是
<code>O(n)</code> 。</p>
<p>看了一下官解里提的动态规划方法，原理。</p>
<p>状态转移方程： <span class="math display">\[
f(i,j)=\begin{cases}
1+min(f(i-1,j), f(i+1,j), f(i,j-1),f(i,j+1))\ \ \ \ if\ (i,j)=1
\\0\ \ \ \ if\ (i,j)=0
\end{cases}
\]</span> 这个是很好理解的，毕竟一个点可以由他上下左右四个点离 0
最近的位置决定。</p>
<p>但是 <code>for i in range(m) for j in range(n)</code>
这个循环相当于是从左上开始往右下遍历，也就是说这次遍历只会包含
<code>f(i-1,j), f(i,j-1)</code>
两个点的真实值，所以还需要一次从右下角开始的遍历，稍有不同的是右下角遍历的时候还可以同时处理下左上角遍历时的结果。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        m, n = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        res = [[<span class="hljs-number">2e4</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:
                    res[i][j] = <span class="hljs-number">0</span>
                <span class="hljs-keyword">else</span>:
                    top, left = <span class="hljs-number">1e4</span>, <span class="hljs-number">1e4</span>
                    <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span>: top = res[i-<span class="hljs-number">1</span>][j]
                    <span class="hljs-keyword">if</span> j&gt;<span class="hljs-number">0</span>: left = res[i][j-<span class="hljs-number">1</span>]
                    res[i][j] = <span class="hljs-built_in">min</span>(top+<span class="hljs-number">1</span>, left+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:
                    res[i][j] = <span class="hljs-number">0</span>
                <span class="hljs-keyword">else</span>:
                    bottom, right = <span class="hljs-number">1e4</span>, <span class="hljs-number">1e4</span>
                    <span class="hljs-keyword">if</span> i&lt;m-<span class="hljs-number">1</span>: bottom = res[i+<span class="hljs-number">1</span>][j]
                    <span class="hljs-keyword">if</span> j&lt;n-<span class="hljs-number">1</span>: right = res[i][j+<span class="hljs-number">1</span>]
                    res[i][j] = <span class="hljs-built_in">min</span>(res[i][j], bottom+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="腐烂的橘子">994. 腐烂的橘子</h3>
<p>方法一，模拟橘子腐烂的过程，每分钟遍历一次，这里要注意在这分钟腐烂的橘子这分钟不会影响到其他橘子。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orangesRotting</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])
        fresh = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:
                    fresh += <span class="hljs-number">1</span>
        minute = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> fresh != <span class="hljs-number">0</span>:
            minute += <span class="hljs-number">1</span>
            temp_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                    <span class="hljs-keyword">if</span> grid[i][j] &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (i,j) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> temp_set:
                        <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):
                            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> grid[ni][nj] == <span class="hljs-number">1</span>:
                                grid[ni][nj] = <span class="hljs-number">2</span>
                                temp_set.add((ni,nj))
                                fresh -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp_set)==<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> minute</code></pre></div>
<p>方法二，腐烂橘子的广度优先搜索，这里需要注意的是这分钟能感染的橘子下分钟不能再感染了（因为周围被感染过）。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orangesRotting</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])
        fresh = <span class="hljs-number">0</span>
        queue = collections.deque()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:
                    fresh += <span class="hljs-number">1</span>
                <span class="hljs-keyword">elif</span> grid[i][j] == <span class="hljs-number">2</span>:
                    queue.append((i,j))
        minute = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> fresh != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> queue:
            minute += <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                i, j = queue.popleft()
                <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>,j), (i+<span class="hljs-number">1</span>,j), (i,j-<span class="hljs-number">1</span>), (i,j+<span class="hljs-number">1</span>)):
                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; n <span class="hljs-keyword">and</span> grid[ni][nj] == <span class="hljs-number">1</span>:
                        grid[ni][nj] = <span class="hljs-number">2</span>
                        queue.append((ni, nj))
                        fresh -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> fresh != <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> minute</code></pre></div>
<h2 id="递归-回溯">递归 / 回溯</h2>
<h3 id="合并两个有序链表">21. 合并两个有序链表</h3>
<p>这道题用递归其实就 4 种情况：</p>
<ul>
<li><code>list1</code> 节点为空 - 返回 <code>list2</code></li>
<li><code>list2</code> 节点为空 - 返回 <code>list1</code></li>
<li>都非空 <code>list1</code> 节点值小于等于 <code>list2</code> -
递归，返回 <code>list1</code> 。</li>
<li>都非空 <code>list2</code> 节点值小于 <code>list1</code> - 递归，返回
<code>list2</code> 。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> list2
        <span class="hljs-keyword">elif</span> list2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> list1
        <span class="hljs-keyword">elif</span> list1.val &lt;= list2.val:
            list1.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1.<span class="hljs-built_in">next</span>, list2)
            <span class="hljs-keyword">return</span> list1
        <span class="hljs-keyword">else</span>:
            list2.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="hljs-built_in">next</span>)
            <span class="hljs-keyword">return</span> list2</code></pre></div>
<p>非递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        pre = dummy
        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:
            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:
                pre.<span class="hljs-built_in">next</span> = list1
                list1 = list1.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                pre.<span class="hljs-built_in">next</span> = list2
                list2 = list2.<span class="hljs-built_in">next</span>
            pre = pre.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list1:
            pre.<span class="hljs-built_in">next</span> = list2
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list2:
            pre.<span class="hljs-built_in">next</span> = list1
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="反转链表">206. 反转链表</h3>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> head
        cur = self.reverseList(head.<span class="hljs-built_in">next</span>)
        head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head
        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">return</span> cur</code></pre></div>
<p>非递归。可以用栈去遍历节点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        stack = []
        <span class="hljs-keyword">while</span> head:
            temp = head.<span class="hljs-built_in">next</span>
            head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
            stack.append(head)
            head = temp
        pre = dummy
        <span class="hljs-keyword">while</span> stack:
            node = stack.pop()
            pre.<span class="hljs-built_in">next</span> = node
            pre = pre.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>非递归，也能用三指针去遍历，因为对一个节点的 <code>next</code>
指针逆序与他前后节点和自身都有关系。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        pre = <span class="hljs-literal">None</span>
        dummy = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> head:
            temp = head.<span class="hljs-built_in">next</span>
            dummy = head
            head.<span class="hljs-built_in">next</span> = pre
            head = temp
            pre = dummy
        <span class="hljs-keyword">return</span> dummy</code></pre></div>
<h3 id="组合">77. 组合</h3>
<p>Python 里的 <code>itertools.combinations()</code> 函数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(itertools.combinations(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>), k))</code></pre></div>
<p>从 <a
target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录
- 回溯算法</a> 前辈这里学习的回溯算法。</p>
<p>相当于把从 n 个数里找满足条件的 k 个数分解成 <code>for</code>
循环（横向遍历 n ）与递归（纵向遍历 <code>k</code> ）这样的结构。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        path = []

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinations</span>(<span class="hljs-params">n, k, i</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:
                res.append(path[:])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n+<span class="hljs-number">1</span>):
                path.append(j)
                combinations(n, k, j+<span class="hljs-number">1</span>)
                path.pop()

        combinations(n, k, <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>上面的代码并不快，这就引申出了剪枝这个概念。</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212230903768.png" srcset="/img/loading.gif" lazyload /></p>
<p>有的步骤是多余的，在于取完 x 个数之后，剩下数量必须大于等于 k-x
个，否则没有意义。</p>
<p>这个 x 就是 path 的元素个数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        path = []

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinations</span>(<span class="hljs-params">n, k, i</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:
                res.append(path[:])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n-(k-<span class="hljs-built_in">len</span>(path))+<span class="hljs-number">2</span>):
                path.append(j)
                combinations(n, k, j+<span class="hljs-number">1</span>)
                path.pop()

        combinations(n, k, <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>其实这个这个递归函数不需要传 n，k，我们稍微简化一下：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        path = []

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinations</span>(<span class="hljs-params">i</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:
                res.append(path[:])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n-(k-<span class="hljs-built_in">len</span>(path))+<span class="hljs-number">2</span>):
                path.append(j)
                combinations(j+<span class="hljs-number">1</span>)
                path.pop()

        combinations(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="全排列">46. 全排列</h3>
<p>Python 里的 <code>itertools.permutations()</code> 函数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(itertools.permutations(nums, <span class="hljs-built_in">len</span>(nums)))</code></pre></div>
<p>这道题的树图我们可以画出：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212230951840.png" srcset="/img/loading.gif" lazyload /></p>
<p>我们可以用一个 <code>used</code>
数组来记录哪些元素被使用过，但其实，使用过的元素已经在 <code>path</code>
里了，因此也不需要记录。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        path = []

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">permutations</span>():
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums):
                res.append(path[:])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> path:
                    path.append(i)
                    permutations()
                    path.pop()
        
        permutations()
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="字母大小写全排列">784. 字母大小写全排列</h3>
<p>这道题其实是求 0（设为小写），1（设为大写）可重复取数共取 k（ k
为字符串种字母的数量）个数的全排列。</p>
<p>我们可以按照上面的老套路，不过既然可以重复取数就没有限制条件了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        s_lst = <span class="hljs-built_in">list</span>(s)
        letter_index = []
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s_lst):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v.isdigit():
                letter_index.append(i)
        res = []
        path = []
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">permutations</span>():
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(letter_index):
                res.append(path[:])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>):
                path.append(i)
                permutation()
                path.pop()
        permutation()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(res[i], letter_index):
                <span class="hljs-keyword">if</span> j[<span class="hljs-number">0</span>]:
                    s_lst[j[<span class="hljs-number">1</span>]] = s_lst[j[<span class="hljs-number">1</span>]].upper()
                <span class="hljs-keyword">else</span>:
                    s_lst[j[<span class="hljs-number">1</span>]] = s_lst[j[<span class="hljs-number">1</span>]].lower()
            res[i] = <span class="hljs-string">&#x27;&#x27;</span>.join(s_lst)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>Python 的一行代码。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-string">&#x27;&#x27;</span>.join, itertools.product(*<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:(x.lower(), x.upper()) <span class="hljs-keyword">if</span> x.isalpha() <span class="hljs-keyword">else</span> x, s))))</code></pre></div>
<h2 id="动态规划">动态规划</h2>
<h3 id="爬楼梯">70. 爬楼梯</h3>
<p>状态转移方程： <span class="math display">\[
dp[i]=\begin{cases}dp[i-1]+dp[i-2]\ \ \ \ if\ i&gt;2\\i\ \ \ \ if\ i=1\
or i=2\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
        dp = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n):
            dp.append(dp[i-<span class="hljs-number">1</span>]+dp[i-<span class="hljs-number">2</span>])
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="打家劫舍">198. 打家劫舍</h3>
<p>状态转移方程： <span class="math display">\[
dp[i]=\begin{cases}max(dp[i-2]+nums[i], dp[i-1])\ \ \ \ if\ i&gt;2
\\max(nums[i], nums[i-1])\ \ \ \ if\ i=2
\\nums[i]\ \ \ \ if\ i=1\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        n = <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])
        dp = [nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):
            dp.append(<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">2</span>]+nums[i], dp[i-<span class="hljs-number">1</span>]))
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="三角形最小路径和">120. 三角形最小路径和</h3>
<p>状态转移方程 <span class="math display">\[
\begin{cases}
min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]\ \ \ \ if\ i&gt;=1\ and\
i&gt;j&gt;=1\\
dp[i-1][j]+triangle[i][j]\ \ \ \ if\ i&gt;=1\ and\ j=0\\
dp[i-1][j-1]+triangle[i][j]\ \ \ \ if\ i&gt;=1\ and\ i=j\\
triangle[i][j]\ \ \ \ if\ i=0
\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotal</span>(<span class="hljs-params">self, triangle: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        n = <span class="hljs-built_in">len</span>(triangle)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        dp = [[triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):
            temp = []
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> j==<span class="hljs-number">0</span>:
                    temp.append(dp[i-<span class="hljs-number">1</span>][j]+triangle[i][j])
                <span class="hljs-keyword">elif</span> j==i:
                    temp.append(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+triangle[i][j])
                <span class="hljs-keyword">else</span>:
                    temp.append(<span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])+triangle[i][j])
            dp.append(temp)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[-<span class="hljs-number">1</span>])</code></pre></div>
<h2 id="位运算">位运算</h2>
<h3 id="的幂">231. 2 的幂</h3>
<p>2 的幂首先是大于 0 的，其次在二进制表示中只有 1 个 1 ，所以我们可以用
<code>n&amp;(n-1)</code> 把最后一个 1 消去看是否结果为 0 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n&amp;(n-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div>
<p>另外 <span class="math inline">\(2^{31}\)</span> 去取余任何 2
的幂结果应该都为 0 ，所以也可以利用这个性质。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">31</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="位1的个数">191. 位1的个数</h3>
<p>跟上题一样，用 <code>n&amp;(n-1)</code> 的方式统计计数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> n:
            n &amp;= n-<span class="hljs-number">1</span>
            res += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="颠倒二进制位">190. 颠倒二进制位</h3>
<p>使用字符串去操作。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>(n)[:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;0&#x27;</span>), <span class="hljs-number">2</span>))</code></pre></div>
<p>逐位颠倒累加。原理有点类似与比如一个字符串 <code>1234</code> ，要转成
10 进制数，如果要从前往后遍历的话，每一步都是
<code>res = res*10 + string[i]</code> ，相当于经历 0+1， 10+2， 120+3，
1230+4 这个过程。这里可以累加 32 次。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):
            res = (res&lt;&lt;<span class="hljs-number">1</span>)|(n&amp;<span class="hljs-number">1</span>)
            n &gt;&gt;= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="只出现一次的数字">136. 只出现一次的数字</h3>
<p>这道题主要是位运算 异或
这个操作的理解，将所有元素做异或运算，出现两次的元素异或结果为 0
，最后得到的就是只出现一次的数字。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            res = res^i
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>或者用 <code>reduce</code> 函数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y:x^y, nums)</code></pre></div>
<h1 id="算法基础">算法基础</h1>
<h2 id="二分查找-2">二分查找</h2>
<h3 id="在排序数组中查找元素的第一个和最后一个位置">34.
在排序数组中查找元素的第一个和最后一个位置</h3>
<p>用二分法模拟过程就行。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        nums_len = <span class="hljs-built_in">len</span>(nums)
        left = <span class="hljs-number">0</span>
        right = nums_len - <span class="hljs-number">1</span>
        start = -<span class="hljs-number">1</span>
        end = -<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> left &lt;= right:
            mid = (left+right) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid] == target:
                t_s = mid
                t_e = mid
                <span class="hljs-keyword">while</span> t_s&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[t_s] == target:
                    t_s -= <span class="hljs-number">1</span>
                <span class="hljs-keyword">while</span> t_e&lt;nums_len <span class="hljs-keyword">and</span> nums[t_e] == target:
                    t_e += <span class="hljs-number">1</span>
                start = t_s + <span class="hljs-number">1</span>
                end = t_e - <span class="hljs-number">1</span>
                <span class="hljs-keyword">return</span> [start, end]
            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:
                right = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                left = mid + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> [start, end]</code></pre></div>
<h3 id="搜索旋转排序数组">33. 搜索旋转排序数组</h3>
<p>第一种解法是暴力。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        res = -<span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):
            <span class="hljs-keyword">if</span> v == target:
                res = i
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>第二种解法，先用二分法找出 <code>k</code> 值，再用二分法找出
<code>target</code> 目标值。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
        k = <span class="hljs-number">0</span>
        nums_len = <span class="hljs-built_in">len</span>(nums)
        l = <span class="hljs-number">0</span>
        r = nums_len - <span class="hljs-number">1</span>
        lv = nums[l]
        rv = nums[r]
        <span class="hljs-keyword">while</span> r != l+<span class="hljs-number">1</span>:
            mid = (l+r) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid] &gt; lv:
                l = mid
            <span class="hljs-keyword">elif</span> nums[mid] &lt; rv:
                r = mid
        k = r <span class="hljs-keyword">if</span> nums[r]&lt;nums[l] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        nums = nums[k:]+nums[:k] <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> nums
        l = <span class="hljs-number">0</span>
        r = nums_len - <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> l&lt;=r:
            mid = (l+r) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid] == target:
                res = mid + k <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> mid
                <span class="hljs-keyword">if</span> res &gt;= nums_len:
                    res -= nums_len
                <span class="hljs-keyword">return</span> res
            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:
                r = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                l = mid + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>
<h3 id="搜索二维矩阵">74. 搜索二维矩阵</h3>
<p>矩阵的二分法，重点在于建立 <code>row, col</code> 与
<code>index</code> 的对应关系。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        m = <span class="hljs-built_in">len</span>(matrix)
        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])
        l = <span class="hljs-number">0</span>
        r = m*n-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> l &lt;= r:
            mid = (l+r) // <span class="hljs-number">2</span>
            row = mid//n
            col = mid%n
            <span class="hljs-keyword">if</span> matrix[row][col] == target:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">elif</span> matrix[row][col] &gt; target:
                r = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                l = mid + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h3>
<p>其实相当于 <a href="###33.%20搜索旋转排序数组">33.
搜索旋转排序数组</a> 的寻找 <code>k</code> 值。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
        k = <span class="hljs-number">0</span>
        nums_len = <span class="hljs-built_in">len</span>(nums)
        l = <span class="hljs-number">0</span>
        r = nums_len - <span class="hljs-number">1</span>
        lv = nums[l]
        rv = nums[r]
        <span class="hljs-keyword">while</span> r != l+<span class="hljs-number">1</span>:
            mid = (l+r) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid] &gt; lv:
                l = mid
            <span class="hljs-keyword">elif</span> nums[mid] &lt; rv:
                r = mid
        k = r <span class="hljs-keyword">if</span> nums[r]&lt;nums[l] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> nums[k]</code></pre></div>
<h3 id="寻找峰值">162. 寻找峰值</h3>
<p>可以理解为找函数 <code>y=nums[x]</code>
的极值点。我们采用二分搜索的策略，为了避免极值点在边界，我们左右两端各添加一个
<code>float('-inf')</code>
负无穷。我们可以通过左右指针循环查找，这里的重点是控制指针的变化。</p>
<ul>
<li>当 <code>mid</code> 比 <code>mid-1</code> , <code>mid+1</code>
都大时，返回它（当然由于预处理，应该返回 <code>mid-1</code> ）。</li>
<li>如果 <code>mid-1</code> , <code>mid</code> , <code>mid+1</code>
呈现单调递增趋势，说明极值点在右边。</li>
<li>否则说明极值点在左边。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        nums = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)] + nums + [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)]
        l, r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> l&lt;=r:
            mid = (l+r) // <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid]&gt;nums[mid-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">return</span> mid-<span class="hljs-number">1</span>
            <span class="hljs-keyword">elif</span> nums[mid+<span class="hljs-number">1</span>]&gt;=nums[mid]&gt;=nums[mid-<span class="hljs-number">1</span>]:
                l = mid + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                r = mid - <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h2 id="双指针-1">双指针</h2>
<h3 id="删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素
II</h3>
<p>数据结构里做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        node = dummy
        <span class="hljs-keyword">while</span> head:
            temp = head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp <span class="hljs-keyword">or</span> temp.val != head.val:
                node.<span class="hljs-built_in">next</span> = head
                head = head.<span class="hljs-built_in">next</span>
                node = node.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">while</span> temp <span class="hljs-keyword">and</span> temp.val == head.val:
                    temp = temp.<span class="hljs-built_in">next</span>
                head = temp
        node.<span class="hljs-built_in">next</span> = head
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="三数之和">15. 三数之和</h3>
<p>数据结构里做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        nums = <span class="hljs-built_in">sorted</span>(nums)
        nums_len = <span class="hljs-built_in">len</span>(nums)
        res = []
        <span class="hljs-keyword">if</span> nums_len &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums[-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> res
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len-<span class="hljs-number">2</span>):
            <span class="hljs-keyword">if</span> nums[i]&gt;<span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">continue</span>
            left = i+<span class="hljs-number">1</span>
            right = nums_len-<span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> left&lt;right:
                temp_sum = nums[i]+nums[left]+nums[right]
                <span class="hljs-keyword">if</span> temp_sum &gt; <span class="hljs-number">0</span>:
                    right -= <span class="hljs-number">1</span>
                <span class="hljs-keyword">elif</span> temp_sum &lt; <span class="hljs-number">0</span>:
                    left += <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    res.append([nums[i], nums[left], nums[right]])
                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[left] == nums[left+<span class="hljs-number">1</span>]: left += <span class="hljs-number">1</span>
                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[right] == nums[right-<span class="hljs-number">1</span>]: right -= <span class="hljs-number">1</span>
                    left += <span class="hljs-number">1</span>
                    right -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="比较含退格的字符串">844. 比较含退格的字符串</h3>
<p>用栈模拟整个过程，遇到 <code>#</code>
时，如果栈非空就出栈，否则不管，如果遇到其它字符则进栈。最后比较两个栈是否一致。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backspaceCompare</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        stack_s = []
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:
                <span class="hljs-keyword">if</span> stack_s:
                    stack_s.pop()
            <span class="hljs-keyword">else</span>:
                stack_s.append(c)
        stack_t = []
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:
            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:
                <span class="hljs-keyword">if</span> stack_t:
                    stack_t.pop()
            <span class="hljs-keyword">else</span>:
                stack_t.append(c)
        <span class="hljs-keyword">return</span> stack_s == stack_t</code></pre></div>
<h3 id="区间列表的交集">986. 区间列表的交集</h3>
<p>用双指针分别控制当前遍历的 A、B
两个列表的区间。如果区间不相交，将靠后区间的指针移到下个区间。如果区间相交，那么相交起始位置就是更大的
<code>start</code> ，结束位置是更小的 <code>end</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intervalIntersection</span>(<span class="hljs-params">self, firstList: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], secondList: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        firstList_len = <span class="hljs-built_in">len</span>(firstList)
        secondList_len = <span class="hljs-built_in">len</span>(secondList)
        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        res = []
        <span class="hljs-keyword">while</span> l&lt;firstList_len <span class="hljs-keyword">and</span> r&lt;secondList_len:
            <span class="hljs-keyword">if</span> firstList[l][<span class="hljs-number">0</span>] &gt; secondList[r][<span class="hljs-number">1</span>]:
                r += <span class="hljs-number">1</span>
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> secondList[r][<span class="hljs-number">0</span>] &gt; firstList[l][<span class="hljs-number">1</span>]:
                l += <span class="hljs-number">1</span>
                <span class="hljs-keyword">continue</span>
            start = <span class="hljs-built_in">max</span>(firstList[l][<span class="hljs-number">0</span>], secondList[r][<span class="hljs-number">0</span>])
            <span class="hljs-keyword">if</span> firstList[l][<span class="hljs-number">1</span>] &lt; secondList[r][<span class="hljs-number">1</span>]:
                end = firstList[l][<span class="hljs-number">1</span>]
                l += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                end = secondList[r][<span class="hljs-number">1</span>]
                r += <span class="hljs-number">1</span>
            res.append([start, end])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="盛最多水的容器">11. 盛最多水的容器</h3>
<p>双指针逐渐向中间移动，优先移动高度更低的指针。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        height_len = <span class="hljs-built_in">len</span>(height)
        l, r = <span class="hljs-number">0</span>, height_len-<span class="hljs-number">1</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> l&lt;r:
            <span class="hljs-keyword">if</span> height[l] &lt;= height[r]:
                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[l])
                l += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[r])
                r -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>这道题其实有一个可以优化的地方，当移动到某个程度时就不需要移动了，因为有个理论最大值，面积等于两个线中短线的高度乘两线距离，如果当前面积比理论最大高度乘两线距离还大，就可以直接返回结果了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        height_len = <span class="hljs-built_in">len</span>(height)
        height_max = <span class="hljs-built_in">max</span>(height)
        l, r = <span class="hljs-number">0</span>, height_len-<span class="hljs-number">1</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> l&lt;r:
            <span class="hljs-keyword">if</span> height[l] &lt;= height[r]:
                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[l])
                l += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[r])
                r -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> res &gt;= height_max*(r-l):		<span class="hljs-comment"># 剪枝</span>
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h2 id="滑动窗口-1">滑动窗口</h2>
<h3 id="找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h3>
<p>在编程能力里做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        s_len = <span class="hljs-built_in">len</span>(s)
        l, r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(p)
        p_count = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> p:
            p_count[<span class="hljs-built_in">ord</span>(t)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>
        count = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> s[l:r]:
            count[<span class="hljs-built_in">ord</span>(t)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>
        res = []
        <span class="hljs-keyword">while</span> r&lt;s_len+<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> count == p_count:
                res.append(l)
            <span class="hljs-keyword">if</span> r&lt;s_len:
                count[<span class="hljs-built_in">ord</span>(s[l])-<span class="hljs-number">97</span>] -= <span class="hljs-number">1</span>
                count[<span class="hljs-built_in">ord</span>(s[r])-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>
            l += <span class="hljs-number">1</span>
            r += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="乘积小于-k-的子数组">713. 乘积小于 K 的子数组</h3>
<p>在编程能力里做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSubarrayProductLessThanK</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        res, left, temp = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> right, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):
            temp *= value
            <span class="hljs-keyword">while</span> temp&gt;=k:
                temp //= nums[left]
                left += <span class="hljs-number">1</span>
            res += right-left+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="长度最小的子数组">209. 长度最小的子数组</h3>
<p>与上题有点相似，总的来说也属于双指针问题。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        nums_sum = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">if</span> nums_sum &gt;= target:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        res, nums_len = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>), <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">while</span> r&lt;nums_len:
            <span class="hljs-keyword">if</span> nums_sum&lt;target:
                r += <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> r&lt;nums_len:
                    nums_sum += nums[r]
            <span class="hljs-keyword">else</span>:
                res = <span class="hljs-built_in">min</span>(res, r-l+<span class="hljs-number">1</span>)
                nums_sum -= nums[l]
                l += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></code></pre></div>
<p>或者更 Pythonic 一点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        res, left, temp_sum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> right, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):
            temp_sum += value
            <span class="hljs-keyword">while</span> temp_sum &gt;= target:
                temp_sum -= nums[left]
                res = <span class="hljs-built_in">min</span>(res, right-left+<span class="hljs-number">1</span>)
                left += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></code></pre></div>
<h2 id="广度优先搜索-深度优先搜索-1">广度优先搜索 / 深度优先搜索</h2>
<h3 id="岛屿数量">200. 岛屿数量</h3>
<p>这道题这个字符串是真有点坑，实际是个简单的搜索，深度优先搜索或广度优先搜索都可以。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        m = <span class="hljs-built_in">len</span>(grid)
        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])
        searched = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> grid[row][col]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[row][col]:
                    res += <span class="hljs-number">1</span>
                    stack = [(row, col)]
                    <span class="hljs-keyword">while</span> stack:
                        r, c = stack.pop()
                        searched[r][c] = <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> r&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> grid[r-<span class="hljs-number">1</span>][c]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r-<span class="hljs-number">1</span>][c]: stack.append((r-<span class="hljs-number">1</span>, c))
                        <span class="hljs-keyword">if</span> r+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> grid[r+<span class="hljs-number">1</span>][c]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r+<span class="hljs-number">1</span>][c]: stack.append((r+<span class="hljs-number">1</span>, c))
                        <span class="hljs-keyword">if</span> c&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> grid[r][c-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r][c-<span class="hljs-number">1</span>]: stack.append((r, c-<span class="hljs-number">1</span>))
                        <span class="hljs-keyword">if</span> c+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> grid[r][c+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r][c+<span class="hljs-number">1</span>]: stack.append((r, c+<span class="hljs-number">1</span>))
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="省份数量">547. 省份数量</h3>
<p>这个属于是换了一种图存储方式的搜索，本质还是深度优先搜索或广度优先搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        n = <span class="hljs-built_in">len</span>(isConnected)
        searched = [<span class="hljs-number">0</span>]*n
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">if</span> searched[l]:
                <span class="hljs-keyword">continue</span>
            res += <span class="hljs-number">1</span>
            searched[l] = <span class="hljs-number">1</span>
            stack = [l]
            <span class="hljs-keyword">while</span> stack:
                left = stack.pop()
                <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                    <span class="hljs-keyword">if</span> isConnected[left][right] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[right]:
                        searched[right] = <span class="hljs-number">1</span>
                        stack.append(right)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="填充每个节点的下一个右侧节点指针-ii">117.
填充每个节点的下一个右侧节点指针 II</h3>
<p>二叉树的层次遍历思想，首先想到的是用一个 <code>list</code>
来存储每一层的节点，第一个节点指向第二个节点，第二个节点指向第三个节点，依次类推，最后一个节点指向
<code>None</code> 不用管。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:
        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> root
        queue = [root]
        <span class="hljs-keyword">while</span> queue:
            temp = []
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.pop(<span class="hljs-number">0</span>)
                temp.append(node)
                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp)-<span class="hljs-number">1</span>):
                temp[i].<span class="hljs-built_in">next</span> = temp[i+<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>上面是很有优化空间的，实际上在出队的时候就可以判断有没有节点的
<code>next</code> 指向出队那个节点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:
        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> root
        queue = [root]
        <span class="hljs-keyword">while</span> queue:
            temp = <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.pop(<span class="hljs-number">0</span>)
                <span class="hljs-keyword">if</span> temp:
                    temp.<span class="hljs-built_in">next</span> = node
                temp = node
                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<h3 id="另一棵树的子树">572. 另一棵树的子树</h3>
<p>一棵树是另一棵树的子树，满足以下三种情况之一：</p>
<ul>
<li>两棵树相同。</li>
<li>这棵树是另一棵树左子树的子树。</li>
<li>这棵树是另一棵树右子树的子树。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubtree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], subRoot: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSametree</span>(<span class="hljs-params">roota, rootb</span>):
            <span class="hljs-keyword">if</span> roota <span class="hljs-keyword">and</span> rootb:
                <span class="hljs-keyword">return</span> roota.val == rootb.val <span class="hljs-keyword">and</span> isSametree(roota.left, rootb.left) <span class="hljs-keyword">and</span> isSametree(roota.right, rootb.right)
            <span class="hljs-keyword">if</span> roota <span class="hljs-keyword">or</span> rootb:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (root <span class="hljs-keyword">or</span> subRoot):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">and</span> subRoot:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> isSametree(root, subRoot) <span class="hljs-keyword">or</span> self.isSubtree(root.left, subRoot) <span class="hljs-keyword">or</span> self.isSubtree(root.right, subRoot)</code></pre></div>
<p>其实这个很类似字符串匹配，因为我们显然也可以通过稍加修改的遍历去转换成一个字符串匹配的问题，这个稍加修改就是空节点的值要记为空。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubtree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], subRoot: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">root</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;()&#x27;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;(<span class="hljs-subst">&#123;serialize(root.left)&#125;</span><span class="hljs-subst">&#123;root.val&#125;</span><span class="hljs-subst">&#123;serialize(root.right)&#125;</span>)&#x27;</span>
        
        <span class="hljs-keyword">return</span> serialize(subRoot) <span class="hljs-keyword">in</span> serialize(root)</code></pre></div>
<h3 id="二进制矩阵中的最短路径">1091. 二进制矩阵中的最短路径</h3>
<p>广度优先搜索，不过这道题让我印象更深刻的不是广搜。而是可变类型与不可变类型，这道题我建立
<code>visited</code> 时最开始用的 <code>[[0]*n]*n</code>
发现怎么也不对。因为这里内层 <code>n</code> 个列表都是同一个列表。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> grid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        queue = collections.deque()
        queue.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
        direction = ((-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))
        n = <span class="hljs-built_in">len</span>(grid)
        visited = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> queue:
            r, c, count = queue.popleft()
            <span class="hljs-keyword">if</span> r==n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c==n-<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> count
            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> direction:
                x = r+dx
                y = c+dy
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=x&lt;n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=y&lt;n <span class="hljs-keyword">and</span> grid[x][y]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> visited[x][y]==<span class="hljs-number">0</span>:
                    queue.append((x, y, count+<span class="hljs-number">1</span>))
                    visited[x][y] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>
<h3 id="被围绕的区域">130. 被围绕的区域</h3>
<p>从边框上的 <code>O</code> 点开始广度优先搜索， 4
个方向上下左右，能搜索到的 <code>O</code> 点记录下来，其它点改为
<code>X</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])
        direction = ((-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
        border = [(i,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]+[(i,n-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]+[(<span class="hljs-number">0</span>,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]+[(m-<span class="hljs-number">1</span>,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        <span class="hljs-keyword">for</span> r,c <span class="hljs-keyword">in</span> border:
            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-keyword">and</span> (r,c) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                queue = collections.deque()
                queue.append((r,c))
                hashset.add((r,c))
                <span class="hljs-keyword">while</span> queue:
                    row, col = queue.popleft()
                    <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> direction:
                        x = row+dx
                        y = col+dy
                        <span class="hljs-keyword">if</span> -<span class="hljs-number">1</span>&lt;x&lt;m <span class="hljs-keyword">and</span> -<span class="hljs-number">1</span>&lt;y&lt;n <span class="hljs-keyword">and</span> board[x][y]==<span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-keyword">and</span> (x,y) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                            queue.append((x,y))
                            hashset.add((x,y))
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> (r,c) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                    board[r][c] = <span class="hljs-string">&#x27;X&#x27;</span></code></pre></div>
<h3 id="所有可能的路径">797. 所有可能的路径</h3>
<p>广度优先搜索并记录。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allPathsSourceTarget</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        queue = collections.deque()
        queue.append((<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]))
        n = <span class="hljs-built_in">len</span>(graph)
        res = []
        <span class="hljs-keyword">while</span> queue:
            node, path = queue.popleft()
            <span class="hljs-keyword">for</span> _<span class="hljs-built_in">next</span> <span class="hljs-keyword">in</span> graph[node]:
                <span class="hljs-keyword">if</span> _<span class="hljs-built_in">next</span> == n-<span class="hljs-number">1</span>:
                    res.append(path+[n-<span class="hljs-number">1</span>])
                <span class="hljs-keyword">else</span>:
                    queue.append((_<span class="hljs-built_in">next</span>, path+[_<span class="hljs-built_in">next</span>]))
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>深度优先搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allPathsSourceTarget</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        n = <span class="hljs-built_in">len</span>(graph)
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):
            <span class="hljs-keyword">if</span> node == n-<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> [[node]]
            res = []
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> graph[node]:
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dfs(t):
                    res.append([node]+i)
            <span class="hljs-keyword">return</span> res
        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>)</code></pre></div>
<h2 id="递归-回溯-1">递归 / 回溯</h2>
<h3 id="子集">78. 子集</h3>
<p>求出所有可能长度的组合，因此可以使用
<code>itertools.combinations</code> 来根据不同长度求出组合。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = [[]]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>):
            temp = itertools.combinations(nums, i)
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> temp:
                res.append(<span class="hljs-built_in">list</span>(t))
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>回溯。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        n = <span class="hljs-built_in">len</span>(nums)
        
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path</span>):
            res.append(path)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):
                backtrack(i+<span class="hljs-number">1</span>, path+[nums[i]])
                
        backtrack(<span class="hljs-number">0</span>, [])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="子集-ii">90. 子集 II</h3>
<p>与上题不一样之处在于通过排序达到去重效果。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsetsWithDup</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        n = <span class="hljs-built_in">len</span>(nums)
        nums = <span class="hljs-built_in">sorted</span>(nums)

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path</span>):
            res.append(path)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):
                <span class="hljs-keyword">if</span> i &gt; start <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">continue</span>
                backtracking(i+<span class="hljs-number">1</span>, path+[nums[i]])

        backtracking(<span class="hljs-number">0</span>, [])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="全排列-ii">47. 全排列 II</h3>
<p>调用 <code>itertools.permutations</code>
函数，如果不重复就添加到结果里。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> itertools.permutations(nums):
            temp = <span class="hljs-built_in">list</span>(t)
            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:
                res.append(temp)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>添加一个 <code>used</code>
数组记录此次递归元素是否被使用，进而保证没有重复的全排列。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        n = <span class="hljs-built_in">len</span>(nums)
        used = [<span class="hljs-number">0</span>]*n
        nums = <span class="hljs-built_in">sorted</span>(nums)

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">used, path</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == n:
                res.append(path)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> used[i]:
                    <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> used[i-<span class="hljs-number">1</span>]:
                        <span class="hljs-keyword">continue</span>
                    used[i] = <span class="hljs-number">1</span>
                    backtracking(used, path+[nums[i]])
                    used[i] = <span class="hljs-number">0</span>
        
        backtracking(used, [])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="组合总和">39. 组合总和</h3>
<p>回溯的时候可以重复取数，如果当前和大于目标值就进行剪枝。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        n = <span class="hljs-built_in">len</span>(candidates)

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path, temp_sum</span>):
            <span class="hljs-keyword">if</span> temp_sum == target:
                res.append(path)
            <span class="hljs-keyword">if</span> temp_sum &gt; target:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):
                backtracking(i, path+[candidates[i]], temp_sum+candidates[i])

        backtracking(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="组合总和-ii">40. 组合总和 II</h3>
<p>与上题不一样的地方在于针对重复情况做特殊处理。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum2</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        n = <span class="hljs-built_in">len</span>(candidates)
        candidates = <span class="hljs-built_in">sorted</span>(candidates)

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bcaktracking</span>(<span class="hljs-params">start, path, temp_sum</span>):
            <span class="hljs-keyword">if</span> temp_sum == target:
                res.append(path)
            <span class="hljs-keyword">if</span> temp_sum &gt; target:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):
                <span class="hljs-keyword">if</span> i&gt;start <span class="hljs-keyword">and</span> candidates[i] == candidates[i-<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">continue</span>
                bcaktracking(i+<span class="hljs-number">1</span>, path+[candidates[i]], temp_sum+candidates[i])

        bcaktracking(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="电话号码的字母组合">17. 电话号码的字母组合</h3>
<p>回溯的实际应用。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        hashmap = &#123;
            <span class="hljs-string">&#x27;2&#x27;</span>: (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>),
            <span class="hljs-string">&#x27;3&#x27;</span>: (<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>),
            <span class="hljs-string">&#x27;4&#x27;</span>: (<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>),
            <span class="hljs-string">&#x27;5&#x27;</span>: (<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>),
            <span class="hljs-string">&#x27;6&#x27;</span>: (<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>),
            <span class="hljs-string">&#x27;7&#x27;</span>: (<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>),
            <span class="hljs-string">&#x27;8&#x27;</span>: (<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>),
            <span class="hljs-string">&#x27;9&#x27;</span>: (<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>)
        &#125;
        res = []
        n = <span class="hljs-built_in">len</span>(digits)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> res

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == n:
                res.append(<span class="hljs-string">&#x27;&#x27;</span>.join(path))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):
                <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> hashmap[digits[i]]:
                    backtracking(i+<span class="hljs-number">1</span>, path+[t])
        
        backtracking(<span class="hljs-number">0</span>, [])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="括号生成">22. 括号生成</h3>
<p>这次递归点在于去生成左括号还是右括号，而不是一对括号。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        res = []
        
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">l_count, r_count, path</span>):
            <span class="hljs-keyword">if</span> l_count&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r_count&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r_count&lt;l_count:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">if</span> l_count == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r_count == <span class="hljs-number">0</span>:
                res.append(path)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            backtracking(l_count-<span class="hljs-number">1</span>, r_count, path+<span class="hljs-string">&#x27;(&#x27;</span>)
            backtracking(l_count, r_count-<span class="hljs-number">1</span>, path+<span class="hljs-string">&#x27;)&#x27;</span>)

        backtracking(n, n, <span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="单词搜索">79. 单词搜索</h3>
<p>对每个点递归搜索，对特定情况进行剪枝。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        m = <span class="hljs-built_in">len</span>(board)
        n = <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])
        word_len = <span class="hljs-built_in">len</span>(word)
        searched = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">r, c, loc</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=r&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=c&lt;n <span class="hljs-keyword">and</span> loc&lt;word_len <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r][c] <span class="hljs-keyword">and</span> board[r][c]==word[loc]:
                <span class="hljs-keyword">if</span> loc == word_len-<span class="hljs-number">1</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
                <span class="hljs-keyword">else</span>:
                    loc += <span class="hljs-number">1</span>
                    searched[r][c] = <span class="hljs-number">1</span>
                    res = backtracking(r-<span class="hljs-number">1</span>, c, loc) <span class="hljs-keyword">or</span> backtracking(r+<span class="hljs-number">1</span>, c, loc) <span class="hljs-keyword">or</span> backtracking(r, c-<span class="hljs-number">1</span>, loc) <span class="hljs-keyword">or</span> backtracking(r, c+<span class="hljs-number">1</span>, loc)
                    searched[r][c] = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">return</span> res
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> backtracking(r, c, <span class="hljs-number">0</span>):
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h2 id="动态规划-1">动态规划</h2>
<h3 id="打家劫舍-ii">213. 打家劫舍 II</h3>
<p>分两种情况讨论。分别是取头不取尾和取尾不取头这两种情况。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)
        
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob1</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
            n = <span class="hljs-built_in">len</span>(nums)
            <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])
            dp = [nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])]
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):
                dp.append(<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">2</span>]+nums[i], dp[i-<span class="hljs-number">1</span>]))
            <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]
       
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(rob1(nums[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>]), rob1(nums[<span class="hljs-number">1</span>:]))</code></pre></div>
<h3 id="跳跃游戏">55. 跳跃游戏</h3>
<p>动态更新当前位置能够到达的最远位置，然后移动当前位置，但是当前位置有一个条件就是要小于上一个当前位置能够到达的最远位置。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canJump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        n = <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        max_len = nums[<span class="hljs-number">0</span>]
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &lt;= max_len:
            <span class="hljs-keyword">if</span> i+nums[i] &gt; max_len:
                max_len = i+nums[i]
            <span class="hljs-keyword">if</span> max_len &gt;= n-<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="跳跃游戏-ii">45. 跳跃游戏 II</h3>
<p>将步数和覆盖范围联系起来，求相同覆盖范围覆盖当前位置的最小步数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        n = <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        max_len = <span class="hljs-number">0</span>
        cur_len = <span class="hljs-number">0</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            max_len = <span class="hljs-built_in">max</span>(max_len, i+nums[i])
            <span class="hljs-keyword">if</span> i == cur_len:
                <span class="hljs-keyword">if</span> cur_len != n-<span class="hljs-number">1</span>:
                    res += <span class="hljs-number">1</span>
                    cur_len = max_len
                    <span class="hljs-keyword">if</span> cur_len &gt;= n-<span class="hljs-number">1</span>:
                        <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="不同路径">62. 不同路径</h3>
<p>最开始尝试了下深度优先搜索，超时了。</p>
<p>很显然这道题不需要搜索，而是一道动态规划，状态转移方程如下： <span
class="math display">\[
dp[i][j]=\begin{cases}dp[i-1][j]+dp[i][j-1]\ \ \ \
i&gt;0\&amp;j&gt;0\\1\ \ \ \ i=0|j=0\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        dp = [[<span class="hljs-number">1</span>]*n] + [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m): dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):
                dp[r][c] = dp[r-<span class="hljs-number">1</span>][c]+dp[r][c-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="最长回文子串">5. 最长回文子串</h3>
<p>数据结构里做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        s_len = <span class="hljs-built_in">len</span>(s)
        dp = [[<span class="hljs-literal">False</span>]*s_len <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):
            dp[i][i] = <span class="hljs-literal">True</span>
        start, max_len = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> c_len <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,s_len+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-c_len+<span class="hljs-number">1</span>):
                j = i+c_len-<span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> s[i] != s[j]:
                    dp[i][j] = <span class="hljs-literal">False</span>
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> j&gt;i+<span class="hljs-number">1</span>:
                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]
                    <span class="hljs-keyword">else</span>:
                        dp[i][j] = <span class="hljs-literal">True</span>
                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> c_len&gt;max_len:
                    start = i
                    max_len = c_len
        <span class="hljs-keyword">return</span> s[start:start+max_len]</code></pre></div>
<h3 id="等差数列划分">413. 等差数列划分</h3>
<p>假设一个数组为等差数列的数组，那么它的等差数列子数组的个数等于 <span
class="math inline">\(\sum_{1}^{nums\_len-3}\)</span>
。对于一个不是等差数列的数组，这个数组等差数列子数组则等于其中所有最长等差数列子数组的等差数列子数组个数的和，可能有点难理解，举例，<code>[1,3,5,10,12,13,14]</code>
这个数组的等差数列子数组和是等于 <code>[1,3,5]</code> 的等差数列子数组 1
加上 <code>[12,13,14]</code> 的等差数列子数组 1 等于 2 的。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfArithmeticSlices</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        nums_len = <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">if</span> nums_len &lt; <span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        temp = <span class="hljs-number">0</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,nums_len):
            <span class="hljs-keyword">if</span> nums[i]+nums[i-<span class="hljs-number">2</span>] == nums[i-<span class="hljs-number">1</span>]+nums[i-<span class="hljs-number">1</span>]:
                temp += <span class="hljs-number">1</span>
                res += temp
            <span class="hljs-keyword">else</span>:    
                temp = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="解码方法">91. 解码方法</h3>
<p>需要对 5 种情况进行处理：</p>
<ul>
<li>当前字符是 1 或 2 ，此时有点像是斐波那契数列。</li>
<li>当前字符是 0 ，前面字符是 1 或 2
，会导致前面那个字符衍生的结果被影响。</li>
<li>当前字符是 0 ，前面字符不是 1 或 2 ，解码不了。</li>
<li>当前字符是其他数字，如果这一位和上一位的组合起来比 26
大，那么这一位相当于是独立的，不会有衍生结果。</li>
<li>当前字符是其他数字，并且不是上面那种情况，这一位参与斐波那契式计算并添加至结果。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numDecodings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        s_len = <span class="hljs-built_in">len</span>(s)
        temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
        res = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):
            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> s[i] == <span class="hljs-string">&#x27;2&#x27;</span>:
                temp.append(temp[-<span class="hljs-number">1</span>]+temp[-<span class="hljs-number">2</span>])
            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;0&#x27;</span>:
                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>&#125;:
                    res *= temp[-<span class="hljs-number">2</span>]
                    temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">and</span> s[i] &gt; <span class="hljs-string">&#x27;6&#x27;</span>:
                    res *= temp[-<span class="hljs-number">1</span>]
                    temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    res *= temp[-<span class="hljs-number">1</span>]+temp[-<span class="hljs-number">2</span>]
                    temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
        <span class="hljs-keyword">if</span> temp[-<span class="hljs-number">1</span>] != <span class="hljs-number">1</span>:
            res *= temp[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="单词拆分">139. 单词拆分</h3>
<p>状态转移方程，dp[i] 代表字符串第 i 位及之前能够由字典的单词拼接成：
<span class="math display">\[
dp[j]=\begin{cases}True\ \ \ \ if\ dp[i]\&amp;s[i:j]\in
wordDict\\False\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        s_len = <span class="hljs-built_in">len</span>(s)
        dp=[<span class="hljs-literal">True</span>]+[<span class="hljs-literal">False</span>]*s_len
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, s_len+<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> dp[i] <span class="hljs-keyword">and</span> s[i:j] <span class="hljs-keyword">in</span> wordDict:
                    dp[j] = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="最长递增子序列">300. 最长递增子序列</h3>
<p>状态转移方程为，这里 dp[i] 指的是包含第 i 个元素的状态： <span
class="math display">\[
dp[i]=\begin{cases}max(dp[x],x\in[0,i-1]\&amp;nums[x]&lt;nums[i])+1\\1\
\ \ \ if\ i=0\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        nums_len = <span class="hljs-built_in">len</span>(nums)
        dp = [<span class="hljs-number">1</span>]*nums_len
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,nums_len):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):
                <span class="hljs-keyword">if</span> nums[j]&lt;nums[i]:
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)</code></pre></div>
<h3 id="最长递增子序列的个数">673. 最长递增子序列的个数</h3>
<p>相对于上道题，这道题多了一个计数，每次增长序列时，需要重置计数，每次遇到另一组当前最长序列时，需要累加计数。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findNumberOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        nums_len = <span class="hljs-built_in">len</span>(nums)
        dp = [<span class="hljs-number">1</span>]*nums_len
        count = [<span class="hljs-number">1</span>]*nums_len
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,nums_len):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):
                <span class="hljs-keyword">if</span> nums[j]&lt;nums[i]:
                    <span class="hljs-keyword">if</span> dp[j]+<span class="hljs-number">1</span>&gt;dp[i]:
                        dp[i] = dp[j]+<span class="hljs-number">1</span>
                        count[i] = count[j]
                    <span class="hljs-keyword">elif</span> dp[j]+<span class="hljs-number">1</span>==dp[i]:
                        count[i] += count[j]
        max_seq = <span class="hljs-built_in">max</span>(dp)
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len):
            <span class="hljs-keyword">if</span> max_seq == dp[i]:
                res += count[i]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="最长公共子序列">1143. 最长公共子序列</h3>
<p>动态规划，二维状态转移方程： <span class="math display">\[
dp[i][j]=\begin{cases}max(dp[i][j-1],dp[i-1][j],dp[i-1][j-1]+1\ \ when\
text_i=text_j)\ \ \ \ if\ i&gt;0\&amp;j&gt;0
\\dp[i-1][j]\ or\ dp[i][j-1]\ \ \ \ if\ i=0|j=0\ \&amp;text_i\ne text_j
\\dp[i-1][j]+1\ or\ dp[i][j-1]+1\ \ \ \ if\ i=0|j=0\ \&amp;text_i=text_j
\\1 or 0\ if\ i=0\&amp;j=0\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        len1 = <span class="hljs-built_in">len</span>(text1)
        len2 = <span class="hljs-built_in">len</span>(text2)
        dp = [[<span class="hljs-number">0</span>]*(len2+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2):
                <span class="hljs-keyword">if</span> text1[i] == text2[j]:
                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]+<span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])  
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="两个字符串的删除操作">583. 两个字符串的删除操作</h3>
<p>跟上题基本一样，重点就在于找到最长公共子序列。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        len1 = <span class="hljs-built_in">len</span>(word1)
        len2 = <span class="hljs-built_in">len</span>(word2)
        dp = [[<span class="hljs-number">0</span>]*(len2+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2):
                <span class="hljs-keyword">if</span> word1[i] == word2[j]:
                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]+<span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])  
        <span class="hljs-keyword">return</span> len1+len2-<span class="hljs-number">2</span>*dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="编辑距离">72. 编辑距离</h3>
<p>状态转移方程： <span class="math display">\[
dp[i][j]=\begin{cases}dp[i-1][j-1]，此时两个字母相同所以不用操作\\min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1，此时两个字母不同，选择增删改里最优方式执行\end{cases}
\]</span></p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        len1 = <span class="hljs-built_in">len</span>(word1)
        len2 = <span class="hljs-built_in">len</span>(word2)
        dp = [[<span class="hljs-number">0</span>]*(len2+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>): dp[i][<span class="hljs-number">0</span>] = i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2+<span class="hljs-number">1</span>): dp[<span class="hljs-number">0</span>][j] = j
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2):
                <span class="hljs-keyword">if</span> word1[i] == word2[j]:
                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]
                <span class="hljs-keyword">else</span>:
                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j], dp[i][j])+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="零钱兑换">322. 零钱兑换</h3>
<p>做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], amount: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        dp = [-<span class="hljs-number">1</span>]*(amount+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, amount+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> coins:
                dp[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                temp = []
                <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:
                    <span class="hljs-keyword">if</span> i-coin&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dp[i-coin] != -<span class="hljs-number">1</span>:
                        temp.append(dp[i-coin])
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp) != <span class="hljs-number">0</span>:
                    dp[i] = <span class="hljs-built_in">min</span>(temp)+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="整数拆分">343. 整数拆分</h3>
<p>我感觉这道题是在做数学题，找规律，找到 10 左右应该能发现规律。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">integerBreak</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        dp=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">6</span>):
            dp.append(<span class="hljs-number">3</span>*dp[-<span class="hljs-number">3</span>])
        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">2</span>]</code></pre></div>
<h2 id="位运算-1">位运算</h2>
<h3 id="数字范围按位与">201. 数字范围按位与</h3>
<p>问题的本质在于找最长公共前缀。所以假设两个数位长度不一样显然公共前缀都为
0 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(left)) != <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(right)):
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        res = left
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>):
            res &amp;= i
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>正常找最长前缀当然也可以。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        shift = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> left != right:
            left &gt;&gt;= <span class="hljs-number">1</span>
            right &gt;&gt;= <span class="hljs-number">1</span>
            shift += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> right&lt;&lt;shift</code></pre></div>
<p>或者利用 Brian Kernighan 算法，一直消去 <code>right</code> 的最后一个
1 使 <code>right</code> 小于等于 <code>left</code> ，此时
<code>right</code> 就是答案。</p>
<blockquote>
<p>Brian Kernighan's Algorithm</p>
<p>通过 n&amp;(n-1) 可以使 n 最后一位上的 1 变成 0 。</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">while</span> left&lt;right:
            right = right&amp;(right-<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> right</code></pre></div>
<h2 id="其他">其他</h2>
<h3 id="打乱数组">384. 打乱数组</h3>
<p><code>random</code> 类里 <code>sample</code> 和 <code>shuffle</code>
方法的使用。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):
        <span class="hljs-keyword">import</span> random
        self.nums = nums

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        <span class="hljs-keyword">return</span> self.nums

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        <span class="hljs-keyword">return</span> random.sample(self.nums, <span class="hljs-built_in">len</span>(self.nums))</code></pre></div>
<p>或是</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):
        <span class="hljs-keyword">import</span> random
        self.nums = nums

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        <span class="hljs-keyword">return</span> self.nums

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = self.nums.copy()
        random.shuffle(res)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="快乐数">202. 快乐数</h3>
<p>找规律题。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        num_set = &#123;n&#125;
        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span>:
            temp = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> n!=<span class="hljs-number">0</span>:
                temp += (n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>)
                n //= <span class="hljs-number">10</span>
            n = temp
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> num_set:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">else</span>:
                num_set.add(n)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h3 id="直线上最多的点数">149. 直线上最多的点数</h3>
<p>暴力。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPoints</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        points_len = <span class="hljs-built_in">len</span>(points)
        <span class="hljs-keyword">if</span> points_len &lt;= <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> points_len
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(points_len):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, points_len):
                x1,y1,x2,y2 = points[i][<span class="hljs-number">0</span>],points[i][<span class="hljs-number">1</span>],points[j][<span class="hljs-number">0</span>],points[j][<span class="hljs-number">1</span>]
                count = <span class="hljs-number">2</span>
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j+<span class="hljs-number">1</span>, points_len):
                    x,y = points[k][<span class="hljs-number">0</span>], points[k][<span class="hljs-number">1</span>]
                    <span class="hljs-keyword">if</span> (y-y1)*(x2-x1) == (y2-y1)*(x-x1): count+=<span class="hljs-number">1</span>
                res = <span class="hljs-built_in">max</span>(res, count)
        <span class="hljs-keyword">return</span> res</code></pre></div>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ComputerScience/" class="category-chain-item">ComputerScience</a>
  
  
    <span>></span>
    
  <a href="/categories/ComputerScience/Algorithm/" class="category-chain-item">Algorithm</a>
  
  
    <span>></span>
    
  <a href="/categories/ComputerScience/Algorithm/LeetCode/" class="category-chain-item">LeetCode</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/python/">#python</a>
      
        <a href="/tags/point/">#point</a>
      
        <a href="/tags/binary-search/">#binary search</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>「算法」 - 学习计划</div>
      <div>https://movisli.github.io/2022/02/16/leetcode算法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>MovisLi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 16, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/03/leetcode20220503/" title="LeetCode 1 9">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 1 9</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://unpkg.com/mathjax@3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>

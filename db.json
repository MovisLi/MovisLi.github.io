{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/img/default.png","path":"img/default.png","modified":1,"renderable":0},{"_id":"source/img/logo.jpg","path":"img/logo.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"acb7316a6652b30255a960a22ad963ce7fba06e8","modified":1660232587523},{"_id":"source/_posts/MySQL基础.md","hash":"4b60493c42360ea98823486aeaca693a4e1001e6","modified":1660232587523},{"_id":"source/_posts/leetcode20220503.md","hash":"f24c0354a2ac7cfa2a1e71e8feb4605c737ae589","modified":1660232587523},{"_id":"source/_posts/leetcode20220504.md","hash":"72806d86592d80e82e4dadb5e406ffa3abd6d77e","modified":1660232587523},{"_id":"source/_posts/leetcode20220505.md","hash":"fea8426411dd83a2f3a70655f0f671f531bb32d2","modified":1660232587523},{"_id":"source/_posts/leetcode20220506.md","hash":"0bdeb10c0c673419ee15110a024e65c1907eda53","modified":1660232587524},{"_id":"source/_posts/leetcode20220507.md","hash":"06df2043866aa43fb0f405f64e00bdc3365793d3","modified":1660232587524},{"_id":"source/_posts/leetcode20220509.md","hash":"aa16ca628ed1f5db3aa78fc926d398630d9843a0","modified":1660232587524},{"_id":"source/_posts/leetcode20220510.md","hash":"5affbdf8745bce7f585a8155fdf427df4cfe37f6","modified":1660232587524},{"_id":"source/_posts/leetcode20220511.md","hash":"0dc6a975fce793d9eab96c1d57b4b5c7044ff439","modified":1660232587524},{"_id":"source/_posts/leetcode20220513.md","hash":"461b6a0c831e8fd8aab63e42339d031826621e27","modified":1660232587524},{"_id":"source/_posts/leetcode20220515.md","hash":"bead3abb8a38552c91b7729732398a0041ddd36e","modified":1660232587524},{"_id":"source/_posts/leetcode20220516.md","hash":"1b63b5b22a27a5d383dafaddd57da990de4994fa","modified":1660232587525},{"_id":"source/_posts/leetcode20220518.md","hash":"84aff0b4ef4d3794f6f457ca382ec05d5cbeec7d","modified":1660232587525},{"_id":"source/_posts/leetcode20220519.md","hash":"572711d07b9cd31b2be367faacf03c25e10401c1","modified":1660232587525},{"_id":"source/_posts/leetcode20220524.md","hash":"162d8f5c96885d4b1078db4ced20d46a28df98cb","modified":1660232587525},{"_id":"source/_posts/leetcode20220525.md","hash":"5fdeb5625fe511586c1f0d7c9614a6df0a2c25ae","modified":1660232587525},{"_id":"source/_posts/leetcode20220526.md","hash":"54cbfa0393cf0b15a21af45787852a886dd49a25","modified":1660232587525},{"_id":"source/_posts/leetcode20220527.md","hash":"e43ca307c234bd680239f83c4bf974904a219f2b","modified":1660232587525},{"_id":"source/_posts/leetcode20220529.md","hash":"0b6f4c924eb15b39c24c6f1ba981da6de1e203c1","modified":1660232587525},{"_id":"source/_posts/leetcode20220603.md","hash":"096e638720a0c86c93050880b32988ac7612935f","modified":1660232587526},{"_id":"source/_posts/leetcode20220605.md","hash":"413d90428d730f04a1ffb02d8f4f81d64909a2b2","modified":1660232587526},{"_id":"source/_posts/leetcode20220606.md","hash":"cb95cec3366441e63376c02e1de3e1066d5753a4","modified":1660232587526},{"_id":"source/_posts/leetcode20220607.md","hash":"d1229d63a429ff995635b36f9152615d70affeb2","modified":1660232587526},{"_id":"source/_posts/leetcode20220617.md","hash":"6ee26d6401df5d4cb746553207ee26edb575cb57","modified":1660232587526},{"_id":"source/_posts/leetcode20220625.md","hash":"c09dd2157a7a5f1978946a1be8a7092701a12a06","modified":1660232587526},{"_id":"source/_posts/leetcode20220627.md","hash":"6943953523d0b212692d212aea35098b18e6a095","modified":1660232587527},{"_id":"source/_posts/leetcode20220629.md","hash":"00be9053002b465a3376344fbf3afe5329e1b5c3","modified":1660232587527},{"_id":"source/_posts/leetcode20220628.md","hash":"561c947eade4a8e16a2ce17f74dabee495cc12c4","modified":1660232587527},{"_id":"source/_posts/leetcode20220710.md","hash":"7ecb678d7b1b8163144745e2dce62223069d4c26","modified":1660232587527},{"_id":"source/_posts/leetcode20220630.md","hash":"507ea4e866e809fb9acfc82c26d71a34bfc810fb","modified":1660232587527},{"_id":"source/_posts/leetcode20220715.md","hash":"c8e0dd1534e76e7e4660e18bcda964b3bf17af2f","modified":1660232587527},{"_id":"source/_posts/leetcode20220719.md","hash":"c9a3f61c3a7a0b79c293283f78104d10438504d4","modified":1660232587527},{"_id":"source/_posts/leetcode20220802-2.md","hash":"0335598548bfd0fca519ba86f3afcef50eaa635e","modified":1660232587528},{"_id":"source/_posts/leetcode20220725.md","hash":"f132c3d1f035042341356ef9bacff72584e18c29","modified":1660232587527},{"_id":"source/_posts/leetcode20220802.md","hash":"0f372e97430e5a6ec79b9e39a6423d3576d5c874","modified":1660232587528},{"_id":"source/_posts/leetcode20220811.md","hash":"e49afa88fd657652149454cf589a3f80209ebe07","modified":1660232587528},{"_id":"source/_posts/ssh隧道实现bi连接数据库.md","hash":"ee180cd7d23455a3cbc55a763fa212a83900babb","modified":1660232587528},{"_id":"source/_posts/test.md","hash":"6bc3c8c6dcbbf8179d5b7278abf0e7c6f7c6ee76","modified":1660232587528},{"_id":"source/_posts/《信用评分工具：自动化信用管理的理论与实践》.md","hash":"ded30c93cdadd5576bfb26247774f7c2935fec20","modified":1660232587529},{"_id":"source/_posts/《敏捷实战指南》.md","hash":"6ae03f60b7d097a4fa3cfdf5480deaeb97b305fe","modified":1660232587529},{"_id":"source/_posts/《消费信用模型：定价、利润与组合》.md","hash":"21d44f753fbf3925bc228a67a7fdcc86470c4292","modified":1660232587529},{"_id":"source/about/index.md","hash":"9faf04d9ff87bb63f1c702b496d8a67271526d94","modified":1660232587529},{"_id":"source/_posts/leetcode20220601.md","hash":"731cb28e1df5274efd002ffb65d58e12e27178af","modified":1660232587526},{"_id":"source/_posts/leetcode20220809.md","hash":"58392150d094a20aa9157a7e9ab746289aaa06b4","modified":1660232587528},{"_id":"source/img/logo.jpg","hash":"fb0534db915d457a2458f3da406cb5202d5e4a4e","modified":1660232587533},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660232586676},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"d5ed15fd87806915a5d1ca822d2218862f788a95","modified":1660232586639},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"980a730164d9f145a3271ed64d7122b7cee6d590","modified":1660232586656},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1660232586638},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1660232586640},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1660232586640},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1660232586640},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1660232586641},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1660232586641},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1660232586641},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1660232586641},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1660232586641},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1660232586642},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":1660232586642},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"23e5db06cfdc1cb26503204f074db58647adfbf3","modified":1660232586654},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1660232586654},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1660232586654},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1660232586654},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"952d3f27cd7a245848fa1c4a1f5c8912500c2ee1","modified":1660232586655},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"1452acee33611685b199c50e1bd4ecddbf6424e3","modified":1660232586655},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"edcbef65037759c3a7b3539f2edcd72b082267e9","modified":1660232586655},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"a4a6b184bd91d9fe090da28891e74afc3b71c7fd","modified":1660232586655},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"3a812de943457c0c544832daa1957420883aca96","modified":1660232586655},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1660232586656},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1660232586656},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":1660232586656},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":1660232586665},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1660232586642},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1660232586643},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1660232586638},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"eb2c46aa2508ea65d6e5c397c4bc20d05761d754","modified":1660232586647},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1660232586646},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1660232586642},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"536eedc03faae3b35dc69abd478634d453061a0a","modified":1660232586647},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1660232586649},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1660232586642},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1660232586654},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"3d8912b68fcf51c38f6e1c5dd2bd74657bb3b7fb","modified":1660232586653},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1660232586657},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":1660232586657},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1660232586659},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1660232586659},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1660232586659},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1660232586659},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1660232586659},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1660232586660},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1660232586660},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1660232586660},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1660232586660},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1660232586661},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1660232586661},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1660232586661},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1660232586661},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1660232586661},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1660232586662},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1660232586662},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1660232586662},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1660232586662},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1660232586663},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1660232586646},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1660232586663},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1660232586663},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1660232586664},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1660232586664},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1660232586664},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1660232586664},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1660232586677},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1660232586677},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1660232586677},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1660232586677},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1660232586678},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1660232586678},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1660232586680},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1660232586680},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1660232586680},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1660232586681},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1660232586680},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1660232586681},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1660232586681},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1660232586682},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1660232586681},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1660232586682},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1660232586682},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1660232586682},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1660232586643},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1660232586644},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1660232586643},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1660232586644},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1660232586645},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1660232586645},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1660232586645},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1660232586645},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1660232586645},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1660232586646},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1660232586647},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1660232586647},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"57358e2164284f33f3bc81d5f602c620aeab942f","modified":1660232586648},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1660232586648},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"ef56f0903762a7a2c853417dfa6b0463440295e0","modified":1660232586649},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1660232586649},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"129a8b19ab26efd02ff1806ff4012376d2cd3497","modified":1660232586649},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1660232586650},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1660232586650},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"c80bdc171aa53eb7205dcdc77764cec87a1dafd6","modified":1660232586650},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1660232586650},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1660232586650},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1660232586651},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":1660232586651},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"359cbcb0e222c23c8a0c5a99034a8a51f667a9ce","modified":1660232586651},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1660232586651},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1660232586652},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1660232586652},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1660232586652},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1660232586653},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"54933c294d9b469a76a5ed36328e778ed740158f","modified":1660232586657},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1660232586657},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1660232586658},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"cb78296da15c7a8a6957cff2129294cc4815513b","modified":1660232586658},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1660232586658},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1660232586658},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1660232586658},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1660232586665},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1660232586665},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1660232586676},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"2465f604eea63b14cd2b0cc142769d963a0193a0","modified":1660232586676},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1660232586666},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1660232586666},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1660232586670},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1660232586670},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1660232586670},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1660232586671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1660232586671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1660232586671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1660232586671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"5f4a17a20ddbf18c8ea6c66638b764905e4386b3","modified":1660232586672},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1660232586672},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"e24cd1186aae10bf897eed9cfd5278247b6300eb","modified":1660232586675},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"e6e48d6ba2951ce4abc2876600f85eef64095338","modified":1660232586675},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"078e5496a1852952ce4ee49016e86b9f70d31908","modified":1660232586675},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1660232586672},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1660232586676},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1660232586676},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1660232586666},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1660232586666},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1660232586667},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1660232586667},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1660232586667},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1660232586668},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1660232586668},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1660232586668},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1660232586668},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1660232586668},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1660232586669},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1660232586669},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"696e429284bda7ae0fffe62ca84cb01a9243ecf0","modified":1660232586669},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1660232586670},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1660232586670},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1660232586669},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1660232586679},{"_id":"source/img/default.png","hash":"119888e0f355a454a249c6fedac9e91894c302b9","modified":1660232587533},{"_id":"public/local-search.xml","hash":"6c1b24f71ee0a5f1b939e758e057a292bb531cea","modified":1660232906286},{"_id":"public/about/index.html","hash":"ef03023796ee63d14e816c801021f8439d97706f","modified":1660232906286},{"_id":"public/categories/ComputerScience/index.html","hash":"af143c48407c6b19dbb632c7a6d9ff42857f2a34","modified":1660232906286},{"_id":"public/categories/DataScience/index.html","hash":"e23d7b470e2cece5e59f248500c5d6a23cd4919e","modified":1660232906286},{"_id":"public/categories/ComputerScience/page/2/index.html","hash":"85528c6f792b4f2345dfcb38aac4235aaad87105","modified":1660232906286},{"_id":"public/categories/ComputerScience/page/3/index.html","hash":"455cccd93d8b75f33412f36fad5e0b3e33e5372a","modified":1660232906286},{"_id":"public/categories/DataScience/Database/index.html","hash":"5ec7dff161dde3d99daa73b9e85fd4e9155e17a9","modified":1660232906286},{"_id":"public/categories/ComputerScience/Algorithm/index.html","hash":"058dd499880a5d60cee52dbd0b031e51e2a80e55","modified":1660232906286},{"_id":"public/categories/ComputerScience/Algorithm/page/2/index.html","hash":"49d40a276796c069b5066e0c0f5fef0dffe1d11e","modified":1660232906286},{"_id":"public/categories/ComputerScience/Algorithm/page/3/index.html","hash":"340636d2a748e0beef683ae29f107229743ec363","modified":1660232906286},{"_id":"public/categories/ComputerScience/Algorithm/LeetCode/index.html","hash":"4f048a0a95b9d481c6f30e862e0bed2eaff3abbf","modified":1660232906286},{"_id":"public/categories/ComputerScience/Algorithm/LeetCode/page/2/index.html","hash":"fc26e59c325ab1aa0c577dfc202d0eab7720737e","modified":1660232906286},{"_id":"public/categories/ComputerScience/Algorithm/LeetCode/page/3/index.html","hash":"3cde14af26c0d03ffeb2286883adbe6be1024f51","modified":1660232906286},{"_id":"public/categories/Economics-Finance/index.html","hash":"f11b7d1ce1d1d9072b75891fedde023931ec4bba","modified":1660232906286},{"_id":"public/categories/Management/index.html","hash":"be8308156c567d54a15db81d4665f833c4a1e14c","modified":1660232906286},{"_id":"public/categories/Economics-Finance/RiskControl/index.html","hash":"5d7d45574b96b579871c200fc9cbbe7e481abb6b","modified":1660232906286},{"_id":"public/archives/index.html","hash":"81303064555dbd6e49fbdf581f22086c2eb4aa99","modified":1660232906286},{"_id":"public/archives/page/2/index.html","hash":"c8fec81cdac516c4a2a7a6b9056b8576e3b45282","modified":1660232906286},{"_id":"public/archives/page/3/index.html","hash":"56df7862389e83fa90023e7584f6829266d1ad65","modified":1660232906286},{"_id":"public/archives/2022/index.html","hash":"218b1f2d7923a522d909932f37213413088ccbc6","modified":1660232906286},{"_id":"public/archives/2022/page/2/index.html","hash":"c85663508e0cd7d87182bbf3b1241888c936efd5","modified":1660232906286},{"_id":"public/archives/2022/page/3/index.html","hash":"0cfc51dd8d5734813ba06d0369c6fb53c5f83644","modified":1660232906286},{"_id":"public/archives/2022/05/index.html","hash":"73a604fbf2b1e1bd88f1eaea9fef3538bdda21f8","modified":1660232906286},{"_id":"public/archives/2022/05/page/2/index.html","hash":"e840175dcfbb52cae03d7a56d4ef6805b1ea70e2","modified":1660232906286},{"_id":"public/archives/2022/06/index.html","hash":"50d7d60624d138ace843d3cb1d3d5971b915f78a","modified":1660232906286},{"_id":"public/archives/2022/07/index.html","hash":"01b491965dd951e687accd8a7c1924ff09a3a71e","modified":1660232906286},{"_id":"public/archives/2022/08/index.html","hash":"f03a96f9395d95521ae15cb3fbde44ae5f631112","modified":1660232906286},{"_id":"public/tags/sololearn/index.html","hash":"351064b74e36a5ce3f46f0ae989503e333998afa","modified":1660232906286},{"_id":"public/tags/mysql/index.html","hash":"1ab0b14e2e206d0fcfc4ac3d9f7537c59f668c17","modified":1660232906286},{"_id":"public/tags/python/index.html","hash":"8fd2ef646ba332050c97266374689bae6e9f3e02","modified":1660232906286},{"_id":"public/tags/python/page/2/index.html","hash":"d7c90c289009a2e06e4d1054a74432e2ab31c10d","modified":1660232906286},{"_id":"public/tags/python/page/3/index.html","hash":"cb49dcc980ffbb014df03b48bbdcade1463e2632","modified":1660232906286},{"_id":"public/tags/hash/index.html","hash":"5a3437268e8e4b1945719b69d88c7e72106823d4","modified":1660232906286},{"_id":"public/tags/hash/page/2/index.html","hash":"5b3efa16001b9b902cba49f6bf22535a397fc30b","modified":1660232906286},{"_id":"public/tags/point/index.html","hash":"53a4ec3c9bbdeaf3b2f0fa8a57c253434c04f09f","modified":1660232906286},{"_id":"public/tags/stack/index.html","hash":"a338e1caadf8f8830f32c4359b1ff30f160149b2","modified":1660232906286},{"_id":"public/tags/linked-list/index.html","hash":"ee5f7c778ab007cf93b08f777e0e3a270f85c93f","modified":1660232906286},{"_id":"public/tags/string/index.html","hash":"c15d3ff8c1d0b9f004dc2cbcc3704e7a192331f7","modified":1660232906286},{"_id":"public/tags/binary-search/index.html","hash":"9fb5f26c3bf13128e4d1a2ae9ee80611b0a8c386","modified":1660232906286},{"_id":"public/tags/dp/index.html","hash":"d7fc7387544dc3da8c94bdd02df4108354642877","modified":1660232906286},{"_id":"public/tags/loop/index.html","hash":"7a0ccce07ee894f87990271786a6352a204f134d","modified":1660232906286},{"_id":"public/tags/Newton-s-method/index.html","hash":"315cdd7fd75865a95679adf4ba2f40fbc8c563aa","modified":1660232906286},{"_id":"public/tags/recursion/index.html","hash":"ef36123c5b9eadb5c45ee9c069bad0d29cfea948","modified":1660232906286},{"_id":"public/tags/array/index.html","hash":"0772c44f565a8afac6a8d32e721d124cf427575a","modified":1660232906286},{"_id":"public/tags/binary-tree/index.html","hash":"9fbc1ae4397727918f5e2a8c3d237e03dbfea70b","modified":1660232906286},{"_id":"public/tags/sql/index.html","hash":"64542ba9c8feef3475d5e3bd0ce863f11fbd7eca","modified":1660232906286},{"_id":"public/tags/ascii/index.html","hash":"9535804c8dc996c9fbd3ec949d62404242460140","modified":1660232906286},{"_id":"public/tags/bit/index.html","hash":"ccf6e940d021c29ea4612f4317d4294d45f77cad","modified":1660232906286},{"_id":"public/tags/math/index.html","hash":"039b03426051a823c519a0effc57abbd8342a104","modified":1660232906286},{"_id":"public/tags/sort/index.html","hash":"55fc7701effe4a95a575b1a70c643a8720c1c3a1","modified":1660232906286},{"_id":"public/tags/bubble/index.html","hash":"d43a50d4232f5b0cf20c0891e9c12f4324367489","modified":1660232906286},{"_id":"public/tags/enumerate/index.html","hash":"f029449c9216e572166e7f19e1b9bff1827f7234","modified":1660232906286},{"_id":"public/tags/greedy/index.html","hash":"bffc140d0a91c4fe37897d3ac278f96a5205fac1","modified":1660232906286},{"_id":"public/tags/ssh-tunnel/index.html","hash":"50c18995bca53ef535d5594bff10f7c217790566","modified":1660232906286},{"_id":"public/tags/powerbi/index.html","hash":"f97ed0416edd3a7d4dceee92a764a86fb3e46f24","modified":1660232906286},{"_id":"public/tags/tableau/index.html","hash":"f4c533c33d3cd43bd8d411cd059baf788b1198ec","modified":1660232906286},{"_id":"public/tags/credit/index.html","hash":"0e3702767e9dcdc4d9f44250941638a9c3000972","modified":1660232906286},{"_id":"public/tags/decision/index.html","hash":"8fb049e593d56e1caffc4564d62f9321dc74f720","modified":1660232906286},{"_id":"public/tags/economics/index.html","hash":"b8673e3bc8649660c58f347b37a3961ad3069fd6","modified":1660232906286},{"_id":"public/tags/management/index.html","hash":"7bfa6e3b491833a488a83fe53c5d18762fe68f90","modified":1660232906286},{"_id":"public/tags/develop/index.html","hash":"6692cf6d7cc81b3ec58156553abbcd6fa5bc0383","modified":1660232906286},{"_id":"public/tags/scrum/index.html","hash":"af44ea25a3cc646dab946afc75819ca3a9dfca5d","modified":1660232906286},{"_id":"public/tags/scorecard/index.html","hash":"741c15f7a7c2560432694834a39e0c71d6f8b0d6","modified":1660232906286},{"_id":"public/tags/risk-control/index.html","hash":"db1361f6ea1be21bae8e4714b8584d76ceb11e8a","modified":1660232906286},{"_id":"public/404.html","hash":"c956ae369f51e1398e1d71593ff6a58e65daab09","modified":1660232906286},{"_id":"public/tags/index.html","hash":"e7ac8c90a8a01d421cf6e6506459733b2c308bd1","modified":1660232906286},{"_id":"public/2022/08/11/test/index.html","hash":"a41b3628c303ead6a03195acfd3c74771b747162","modified":1660232906286},{"_id":"public/2022/08/11/leetcode20220811/index.html","hash":"d02ced16b36bc640c19a1c7f705d64c8444bbb19","modified":1660232906286},{"_id":"public/2022/08/09/leetcode20220809/index.html","hash":"86226a2b0f2f308e15d97a583ff2061470303240","modified":1660232906286},{"_id":"public/2022/08/04/MySQL基础/index.html","hash":"bbb26b382532ea15e40c04e1bbf69256a178c3c3","modified":1660232906286},{"_id":"public/2022/08/02/leetcode20220802-2/index.html","hash":"23c4b955fa60772d8f1a73454f937cd870099046","modified":1660232906286},{"_id":"public/2022/08/02/leetcode20220802/index.html","hash":"f4edf61534aeb91e4353a92a865f67a3409632e9","modified":1660232906286},{"_id":"public/2022/07/25/《敏捷实战指南》/index.html","hash":"b56609a9976e18caff671d5ab3ddfa2b1986e93c","modified":1660232906286},{"_id":"public/2022/07/25/leetcode20220725/index.html","hash":"f50f721ba388f118c04df966ab61050d7b5a9386","modified":1660232906286},{"_id":"public/2022/07/19/leetcode20220719/index.html","hash":"e8b9ad8f01fa9866beea14cb0442604429f10a13","modified":1660232906286},{"_id":"public/2022/07/15/leetcode20220715/index.html","hash":"3402997237562cb171d6b1949f110ae900aa6477","modified":1660232906286},{"_id":"public/2022/07/10/leetcode20220710/index.html","hash":"46faa35a0bb34b8eeb045c65c8fe3403bec45b44","modified":1660232906286},{"_id":"public/2022/06/30/leetcode20220630/index.html","hash":"b1054ca6dbbf5f25d435a9ef65c0d013f7b68f65","modified":1660232906286},{"_id":"public/2022/06/29/leetcode20220629/index.html","hash":"e9f5246d4e6e3959eef72ac073aaa4eda6d90cb0","modified":1660232906286},{"_id":"public/2022/06/28/leetcode20220628/index.html","hash":"d319824eca7255b35a9b0fbf64e93fa870a73238","modified":1660232906286},{"_id":"public/2022/06/27/leetcode20220627/index.html","hash":"d6e4509cbe3537fdc5a9f0a2063d277a647d1e30","modified":1660232906286},{"_id":"public/2022/06/25/leetcode20220625/index.html","hash":"ca98ef90bc08f2454dadced12a7eb93619f5ab0b","modified":1660232906286},{"_id":"public/2022/06/19/ssh隧道实现bi连接数据库/index.html","hash":"cc20eedaadcbbad7c3bac4af298147284d661454","modified":1660232906286},{"_id":"public/2022/06/19/《信用评分工具：自动化信用管理的理论与实践》/index.html","hash":"87b9f5bc01c6dc3d6582d2d628d5adf4c8a08949","modified":1660232906286},{"_id":"public/2022/06/17/leetcode20220617/index.html","hash":"6733da101ba173d5ebf446bd4ba430cc6063d845","modified":1660232906286},{"_id":"public/2022/06/10/《消费信用模型：定价、利润与组合》/index.html","hash":"fa0c5839449af2fa63d73ae09f569e0141d88090","modified":1660232906286},{"_id":"public/2022/06/07/leetcode20220607/index.html","hash":"c13f5116c80b99e17436733cb79da92e78a2e8a4","modified":1660232906286},{"_id":"public/2022/06/06/leetcode20220606/index.html","hash":"37ef714c6ef84d601ccb16769bbb177d04f30c0c","modified":1660232906286},{"_id":"public/2022/06/05/leetcode20220605/index.html","hash":"0a01774cfaa62ddef44bb19f6ca60eddc3eacbfd","modified":1660232906286},{"_id":"public/2022/06/04/leetcode20220603/index.html","hash":"b6ddced5cc97d0cbd85a4150415ada6aa7b4c2ba","modified":1660232906286},{"_id":"public/2022/06/01/leetcode20220601/index.html","hash":"7cd07e8b8f3a98c8e88f739812e25151a1984f48","modified":1660232906286},{"_id":"public/2022/05/29/leetcode20220529/index.html","hash":"3a8d85c450f1ba68061edda5f8a33161e902d12d","modified":1660232906286},{"_id":"public/2022/05/27/leetcode20220527/index.html","hash":"5e455508ab67f13ed4649f899cbc9970d76c7bc9","modified":1660232906286},{"_id":"public/2022/05/26/leetcode20220526/index.html","hash":"d814424b7bb411e0b3db8c0f7e251d23260ccbc4","modified":1660232906286},{"_id":"public/2022/05/25/leetcode20220525/index.html","hash":"fccaeb3db8586d5264937e6b1c6770f637a6e7d0","modified":1660232906286},{"_id":"public/2022/05/24/leetcode20220524/index.html","hash":"d2254b6cf8f857b32b3813b07d1c5805dbb8fbed","modified":1660232906286},{"_id":"public/2022/05/19/leetcode20220519/index.html","hash":"7b279cd66052ad27047e93c6dbf87bc34453d74a","modified":1660232906286},{"_id":"public/2022/05/18/leetcode20220518/index.html","hash":"8fc99d17e7ab13d64803bcb837f4ecaa39fd3d63","modified":1660232906286},{"_id":"public/2022/05/16/leetcode20220516/index.html","hash":"fc5aca53b31f7bf74b4e5f15324f65b6c3f24dff","modified":1660232906286},{"_id":"public/2022/05/15/leetcode20220515/index.html","hash":"a5c7b76ca148b3c64a677ea933f57f915dac585d","modified":1660232906286},{"_id":"public/2022/05/13/leetcode20220513/index.html","hash":"48e95ed9d38d25050842d9f286bd3ca29ab923ba","modified":1660232906286},{"_id":"public/2022/05/11/leetcode20220511/index.html","hash":"eb460e5465060ed208a2f3ef1b72c2de4e2d2ecc","modified":1660232906286},{"_id":"public/2022/05/10/leetcode20220510/index.html","hash":"e07336ab79b259dec71b3fd19e7f01ed69d712e2","modified":1660232906286},{"_id":"public/2022/05/09/leetcode20220509/index.html","hash":"8aee8388e6311a3e3291bcafa97237b6f5b989aa","modified":1660232906286},{"_id":"public/2022/05/07/leetcode20220507/index.html","hash":"38f72fbbac867e3dbcddba54de96354de5f2e9b7","modified":1660232906286},{"_id":"public/2022/05/06/leetcode20220506/index.html","hash":"f9211b13ee82ad843eaf1bf75d3f6b2a38c33ba5","modified":1660232906286},{"_id":"public/2022/05/05/leetcode20220505/index.html","hash":"4f576e28170689ed94d2ce92b033b3ce64e9399b","modified":1660232906286},{"_id":"public/2022/05/04/leetcode20220504/index.html","hash":"6e185cb72a189241309d6e3ac83771d4b6a0b636","modified":1660232906286},{"_id":"public/2022/05/03/leetcode20220503/index.html","hash":"8daee08477b76e298709af76b29b143e2251e1f9","modified":1660232906286},{"_id":"public/index.html","hash":"e860269e717f45f9b37602c5411971708c3a008d","modified":1660232906286},{"_id":"public/page/3/index.html","hash":"e3f4b0824dc167b9061a63b496f0824c2f52afb4","modified":1660232906286},{"_id":"public/page/4/index.html","hash":"d4090a821c11aec0af017b0ac66ae69dad43389a","modified":1660232906286},{"_id":"public/page/2/index.html","hash":"172f05ad5c3313b7149c76bf32285b6107754d04","modified":1660232906286},{"_id":"public/page/5/index.html","hash":"7dde00e66d9ea04a5314b4a2705b635b09cf0368","modified":1660232906286},{"_id":"public/categories/index.html","hash":"356d66d35205f84b818e3c5ae94c1aab61280478","modified":1660232906286},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1660232906286},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1660232906286},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1660232906286},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1660232906286},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1660232906286},{"_id":"public/img/logo.jpg","hash":"fb0534db915d457a2458f3da406cb5202d5e4a4e","modified":1660232906286},{"_id":"public/css/highlight-dark.css","hash":"51787e58f63bc2edc2eb13d5d5e5e8a667bf0474","modified":1660232906286},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1660232906286},{"_id":"public/css/highlight.css","hash":"e19bc7c245e78c471e647e61c55100ba906e8f7b","modified":1660232906286},{"_id":"public/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1660232906286},{"_id":"public/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1660232906286},{"_id":"public/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1660232906286},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1660232906286},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1660232906286},{"_id":"public/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1660232906286},{"_id":"public/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1660232906286},{"_id":"public/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1660232906286},{"_id":"public/css/main.css","hash":"e13c2aa20b8bd507c0859091e714caf63de5329e","modified":1660232906286},{"_id":"public/img/default.png","hash":"119888e0f355a454a249c6fedac9e91894c302b9","modified":1660232906286}],"Category":[{"name":"DataScience","_id":"cl6p7t1fb0003142pepxm0lu6"},{"name":"ComputerScience","_id":"cl6p7t1ff0008142pebyn8cgn"},{"name":"Database","parent":"cl6p7t1fb0003142pepxm0lu6","_id":"cl6p7t1fm000m142pbkb05jlc"},{"name":"Algorithm","parent":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1fq000v142p91vk9g51"},{"name":"LeetCode","parent":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gc0038142pcbfpbk3s"},{"name":"Economics&Finance","_id":"cl6p7t1hb00ak142pdqx819zk"},{"name":"Management","_id":"cl6p7t1hc00an142pbf36hx6j"},{"name":"RiskControl","parent":"cl6p7t1hb00ak142pdqx819zk","_id":"cl6p7t1hd00ar142p7mp4hwqs"}],"Data":[],"Page":[{"title":"about Me","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about Me\nlayout: about\n---\n","date":"2022-08-11T15:43:07.529Z","updated":"2022-08-11T15:43:07.529Z","path":"about/index.html","comments":1,"_id":"cl6p7t1f40000142peo2a3di3","content":"\n","site":{"data":{}},"wordcount":0,"excerpt":"","more":"\n"}],"Post":[{"title":"MySQL 基础","date":"2022-08-04T15:34:22.000Z","_content":"\n> 参考资料：\n>\n> [Learn SQL | Sololearn](https://www.sololearn.com/learning/1060)\n>\n> 《SQL 必知必会》（第 5 版）\n\n# 基础概念\n\n## 数据库介绍\n\n数据库是一个以便于访问、高效管理与更新的方式组织起来的数据集合。\n\n数据库由存储相关信息的表组成。\n\n表以行和列的格式存储并展示信息，就像 Excel 表格一样。\n\n数据库通常包含多个表，每个表都因特定的目的而设计。\n\n**表可拥有任意数量的行，但只能拥有一定数量的列。**\n\n> MySQL Server 最多只允许 4096 个字段\n>\n> InnoDB 最多只能有 1017 个字段\n>\n> [MySQL :: MySQL 8.0 Reference Manual :: 8.4.7 Limits on Table Column Count and Row Size](https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html)\n\n## 主键 - Primary Keys\n\n主键是表中唯一标识表记录的字段。它关键的两个特点：\n\n- 每行值唯一。\n- 非空。\n\n每张表最多只能有一个主键（也可以没有）。\n\n## SQL - Structured Query Language\n\nSQL 中文叫结构化查询语言。\n\n它用于访问和操作数据库。\n\n> SQL 是 ANSI（美国国家标准协会）标准，但 SQL 语言有不同的版本。\n>\n> 除了 SQL 标准之外，大多数 SQL 数据库程序都有自己的专有扩展，但它们都支持主要命令。\n>\n> MySQL 是其中的一种。\n\n最主要的 4 大功能：**增删查改**。\n\n## 基础 SQL 命令\n\n### SHOW DATABASES\n\n```mysql\nSHOW DATABASES\n```\n\n列出了服务器管理的数据库。\n\n### SHOW TABLES\n\n```mysql\nSHOW TABLES\n```\n\n列出当前数据库里所有表。\n\n### SHOW COLUMNS FROM\n\n```mysql\nSHOW COLUMNS FROM 表名\n```\n\n列出表里的所有字段的详细信息。\n\n如结果可能是\n\n| Field | Type        | Null | Key  | Default | Extra          |\n| ----- | ----------- | ---- | ---- | ------- | -------------- |\n| id    | int(11)     | NO   | PRI  | NULL    | auto_increment |\n| name  | varchar(30) | YES  |      | NULL    |                |\n\n- Field - 列名，字段名。\n- Type - 列数据类型。\n- Null - 字段可否是空值。\n- Key - 指示列是否被索引。\n- Default - 分配给该列的默认值。\n- Extra - 可能包含有关给定列的任何其他可用信息。\n\n# 查询\n\n### SELECT\n\n```mysql\nSELECT 列名 FROM 表名;\n```\n\n从一个表中查询指定的列。\n\n```mysql\nSELECT 列名1, 列名2 FROM 表名;\n```\n\n从一个表里查询多列的数据，列名之间用 `,` 分隔。\n\n```mysql\nSELECT * FROM 表名;\n```\n\n如果要查询所有列的数据，可以用 `*` 。\n\n- 对于多条 SQL ，每条后需要添加 `;` 。\n- SQL 语言不区分大小写。\n- SQL 中忽略空格和多行。\n  - 结合适当的间距和缩进，将命令分成逻辑行将使 SQL 语句更易于阅读和维护。\n\n```mysql\nSELECT 表名.列名 FROM 表名;\n```\n\n同样也可以指定查询某张表的某一列，在表名和列名之间加上 `.` ，当处理可能共享相同列名的多个表时，这种书写形式特别有用。\n\n### DISTINCT\n\n```mysql\nSELECT DISTINCT\n\t列名\nFROM\n\t表名;\n```\n\nDISTINCT 关键字可以达到去重的效果。\n\n### LIMIT\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nLIMIT 数量;\n```\n\nLIMIT 关键字可以指定返回结果的数量。\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nOFFSET 数量\nLIMIT 数量;\n```\n\n可以使用 OFFSET 关键字对所取结果中作筛选偏移，可以理解为 OFFSET 几条就是前几条不要。\n\n### ORDER BY\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nORDER BY\n\t列名;\n```\n\nORDER BY 关键字可以将结果排序后再返回。\n\n如果是数值型列，默认返回从小到大；如果是字符型列，默认返回字母顺序升序。\n\n```mysql\nSELECT\n\t*\nFROM\n\t表名\nORDER BY\n\t列名1, 列名2;\n```\n\nORDER BY 后可以跟两列，像这句一样。这样首先满足 `列名1` 的顺序，再满足 `列名2` 的顺序。\n\n- ASC - 升序。\n\n- DESC - 降序。\n\n# 筛选\n\n### WHERE\n\n```mysql\nSELECT\n\t表名\nFROM\n\t列名\nWHERE\n\t条件;\n```\n\nWHERE 语句可用于按条件筛选返回结果。\n\n使用文本列时，用单引号 `'` 将语句中出现的任何文本括起来。\n\n并且如果字符串内部有单引号，可以使用单引号来转义。例如：\n\n我有一个查询条件 `值 = I'm` ，写成：\n\n```mysql\nWHERE\n\t列名 = 'I''m'\n```\n\n使用比较运算符和逻辑运算符来过滤要选择的数据。\n\n| 比较运算符 | 描述                    |\n| ---------- | ----------------------- |\n| =          | 等于                    |\n| !=         | 不等于                  |\n| >          | 大于                    |\n| <          | 小于                    |\n| >=         | 大于等于                |\n| <=         | 小于等于                |\n| BETWEEN    | 和 AND 一起筛选一个范围 |\n\n### BETWEEN\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 BETWEEN 值1 AND 值2;\n```\n\nBETWEEN 运算符选择范围内的值。第一个值必须是下限，第二个值必须是上限。**这两个值都会被包括进去。**\n\n### 逻辑运算符\n\n| 逻辑运算符 | 描述                         |\n| ---------- | ---------------------------- |\n| AND        | 返回左右两个条件的交集       |\n| OR         | 返回左右两个条件的并集       |\n| IN         | 返回值在后面跟的括号里的结果 |\n| NOT        | 对条件取反                   |\n\n在上述逻辑运算符中，`AND` 优先级是要比 `OR` 高的。\n\n所以 如果要同时用 `AND` 和 `OR` ，最好用括号 `()` 把 `OR` 的括起来以免出错。\n\n### IN\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 IN (值1， 值2);\n```\n\n比较一个列与多个值时，使用 IN 运算符。其效果等同于：\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名=值1 OR 列名=值2;\n```\n\n### AS\n\n```mysql\nSELECT\n\t列名 AS 新列名\nFROM\n\t表名;\n```\n\n用 AS 关键字能够将列名的结果以新列名的标题返回。\n\n### 算术运算符\n\n```mysql\nSELECT\n\t列名+值 AS 列名\nFROM\n\t表名;\n```\n\n可以使用算术运算符将每列的值都做运算。\n\n包括四则运算 `+-*/` 和括号，括号可用于强制操作优先于任何其他运算符，还用于提高代码的可读性。\n\n| 操作符 | 说明 |\n| ------ | ---- |\n| +      | 加   |\n| -      | 减   |\n| *      | 乘   |\n| /      | 除   |\n\n### LIKE\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 LIKE 搜索条件;\n```\n\n使用 `_` 匹配任何单个字符，使用 `%` 匹配任意数量的字符（包括零个字符）。\n\n- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。\n- 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。\n- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。\n\n# 函数\n\n> SELECT 语句为测试、检验函数和计算提供了很好的方法。\n>\n> 虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM 子句后就是简单地访问和 处理表达式，例如 ：\n>\n> SELECT 3 * 2;将返回 6，\n>\n> SELECT Trim(' abc '); 将返回 abc，\n>\n> SELECT Curdate();使用 Curdate()函数返回当前日期和时间。\n>\n> 可以根据需要使用 SELECT 语句进行检验。\n\n## 文本处理函数\n\n### CONCAT\n\n```mysql\nSELECT\n\tCONCAT(列名1, ',', 列名2)\nFROM\n\t表名;\n```\n\nCONCAT 函数用于连接两个或多个文本值并返回连接的字符串。\n\n### RTRIM\n\n```mysql\nSELECT\n\tRTRIM(列名)\nFROM\n\t表名;\n```\n\nRTRIM 函数用于去除所取列的值右边所有的空格。\n\n### LTRIM\n\n```mysql\nSELECT\n\tLTRIM(列名)\nFROM\n\t表名;\n```\n\nRTRIM 函数用于去除所取列的值**左边**所有的空格。\n\n### TRIM\n\n```mysql\nSELECT\n\tTRIM(列名)\nFROM\n\t表名;\n```\n\nRTRIM 函数用于去除所取列的值**左右两边**所有的空格。\n\n### **UPPER**\n\n```mysql\nSELECT\n\tUPPER(列名)\nFROM\n\t表名;\n```\n\nUPPER 函数将指定字符串中的所有字母转换为大写。 \n\n### LOWER\n\n```mysql\nSELECT\n\tLOWER(列名)\nFROM\n\t表名;\n```\n\nLOWER 函数将字符串转换为小写。\n\n> 如果字符串中有不是字母的字符，这个函数对它们不起作用。\n\n### LEFT\n\n```mysql\nSELECT\n\tLEFT(列名, 数字)\nFROM\n\t表名\n```\n\nLEFT 函数将取到该列中值的前 n 个字符。\n\n### RIGHT\n\n```mysql\nSELECT\n\tRIGHT(列名, 数字)\nFROM\n\t表名\n```\n\nRIGHT 函数将取到该列中值的后 n 个字符。\n\n### SUBSTRING\n\n```mysql\nSELECT\n\tSUBSTRING(列名 FROM 数字1 FOR 数字2)\nFROM\n\t表名\n```\n\n从 `数字1` 开始（字符串下标从 1 开始而不是 0），取 `数字2` 个数字。\n\n### SOUNDEX\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\tSOUNDEX(列名) = SOUNDEX(字符串)\n```\n\n返回与字符串发音相同的列名里的值。\n\n## 数值处理函数\n\n### SQRT\n\n```mysql\nSELECT\n\tSQRT(列名)\nFROM\n\t表名;\n```\n\nSQRT 函数返回该列中给定值的平方根。\n\n### ABS\n\n```mysql\nSELECT\n\tABS(列名)\nFROM\n\t表名;\n```\n\nABS 函数返回该列中给定值的绝对值。\n\n### SIN、COS、TAN、PI、EXP\n\n| 函数 | 说明                       |\n| ---- | -------------------------- |\n| SIN  | 返回一个角度的正弦         |\n| COS  | 返回一个角度的余弦         |\n| TAN  | 返回一个角度的正切         |\n| PI   | 返回圆周率 $\\pi$ 的值      |\n| EXP  | 返回一个数的指数值 $e^{x}$ |\n\n## 聚集函数\n\n**这种函数只会返回一个值，此所谓聚集的意思。**\n\n### AVG\n\n```mysql\nSELECT\n\tAVG(列名)\nFROM\n\t表名;\n```\n\nAVG 函数返回该列的平均值。\n\n> AVG 函数忽略列值为 NULL 的行。\n\n### COUNT\n\n```mysql\nSELECT\n\tCOUNT(列名)\nFROM\n\t表名;\n```\n\nCOUNT 函数返回该列的行数。\n\n> 如果指定列名，则 COUNT 函数会忽略指定列的值为 NULL 的行，但 如果 COUNT 函数中用的是星号 `*` ，则不忽略。DISTINCT 不能用于 COUNT(*) 。\n\n### MAX\n\n```mysql\nSELECT\n\tMAX(列名)\nFROM\n\t表名;\n```\n\nMAX 函数返回该列的最大值。\n\n> MAX 函数忽略列值为 NULL 的行。\n\n### MIN\n\n```mysql\nSELECT\n\tMIN(列名)\nFROM\n\t表名;\n```\n\nMIN 函数返回该列的最小值。\n\n> MIN 函数忽略列值为 NULL 的行。\n\n### SUM\n\n```mysql\nSELECT\n\tSUM(列名)\nFROM\n\t表名;\n```\n\nSUM 函数返回该列的和。\n\n> SUM 函数忽略列值为 NULL 的行。\n\n# 分组数据\n\n使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。\n\n## GROUP BY\n\n```mysql\nSELECT\n\t列名, 聚集函数(*)\nFROM\n\t表名\nGROUP BY\n\t列名;\n```\n\nGROUP BY 子句指示 DBMS分组数据，然后对每个组而不是整 个结果集进行聚集。\n\n## HAVING\n\n# 子查询\n\n子查询是另一个查询中的查询。它的末尾没有分号。\n\n> 作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回 错误。\n\n```mysql\nSELECT\n\t(子查询)\nFROM\n\t表名;\n```\n\n子查询作为查询结果。\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 in (子查询);\n```\n\n子查询作为筛选条件。\n\n# 连接\n\n**在引用的列可能出现歧义时，必须使用完全限定列名（用一个句点分隔表名和列名， `表名.列名` 的形式）。如果引用一个没有用表名限制的具有歧义的列名，数据库会报错。**\n\n> DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害。\n\n## 等值连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t表名1, 表名2\nWHERE\n\t表名1.列名1 = 表名2.列名2;\n```\n\n这样会返回两个表的笛卡尔积，使用 WHERE 语句。\n\n## 内连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t表名1\n\tINNER JOIN 表名2 ON 表名1.列名1=表名2.列名2;\n```\n\n![](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081810684.png)\n\n## 自连接\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名 AS 别名1, 表名 AS 别名2\nWHERE\n\t别名1.列名 = 别名2.列名;\n```\n\n或\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名 AS 别名1\n\tINNER JOIN 表名 AS 别名2 ON 别名1.列名=别名2.列名;\n```\n\n> 自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。\n>\n> 虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。\n>\n> 应该试一下两种方法，以确定哪一种的性能更好。\n\n## 自然连接\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名1\n\tNATURAL JOIN 表名2;\n```\n\n自然连接是一种特殊的内连接，它不需要指定连接条件，重复的列会被去掉。\n\n## 外连接\n\n许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行。\n\n### 左连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tLEFT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;\n```\n\n![](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081845615.png)\n\n### 右连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tRIGHT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;\n```\n\n![](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081847770.png)\n\n# 组合查询\n\n> 多数 SQL查询只包含从一个或多个表中返回数据的单条 SELECT 语句。但是，SQL也允许执行多个查询（多条  SELECT 语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（ union ）或复合查询（ compound query ）。\n\n```mysql\n查询1\nUNION\n查询2;\n```\n\nUNION 返回的结果已经是去重了的，如果不需要去重，用 UNION ALL ，并且 UNION ALL 也更快\n\n```mysql\n查询1\nUNION ALL\n查询2;\n```\n\n- 在用 UNION 组合查询时，只能使用一条 **ORDER BY** 子句，它必须位于最后一条 SELECT 语句之后。\n\n- 如果列在所有查询中不完全匹配，可以使用 NULL（或任何其他）值（**说明组合查询要求列的数量完全匹配，最终列名会按第一个查询的列名来展示结果**），例如：\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t表名1\nUNION\nSELECT\n\t列名1, NULL\nFROM\n\t表名2;\n```\n\n# 插入数据\n\n## 插入完整的行\n\n```mysql\nINSERT INTO\n\t表名\nVALUES\n\t(值1, 值2);\n```\n\n这种写法能够实现插入功能，但是依赖列的顺序，很不安全，不推荐使用。\n\n推荐使用下面的写法：\n\n```mysql\nINSERT INTO\n\t表名(列名1, 列名2)\nVALUES\n\t(值1, 值2);\n```\n\n## 插入部分行\n\n其实就是使用写列名加值的写法。但是省略的列必须满足以下两个条件之一：\n\n- 该列定义允许 NULL 值。\n- 该列在表定义种给出默认值。\n\n## 插入检索出的数据\n\n```mysql\nINSERT INTO\n\t表名1(列名)\nSELECT\n\t列名\nFROM\n\t表名2;\n```\n\n一般用于表的迁移或合并。**并不要求插入的列名和查询的列名一致，DBMS 使用列的位置来插入。**\n\n## 复制表\n\n当然对于迁移到全新的表，也可以选择复制表。\n\n```mysql\nCREATE TABLE\n\t新表名 AS\nSELECT\n\t*\nFROM\n\t旧表名;\n```\n\n# 修改数据\n\n```mysql\nUPDATE\n\t表名\nSET\n\t列名1=值名1, 列名2=值名2\nWHERE\n\t条件;\n```\n\n**如果不加 WHERE 条件的话，就会更新所有行。**\n\n# 删除数据\n\n```mysql\nDELETE FROM\n\t表名\nWHERE\n\t条件;\n```\n\n与更新数据一样，**如果不加 WHERE 条件的话，就会删除所有行。**\n\n# 创建表\n\n```mysql\nCREATE TABLE\n\t表名\n(\n\t列名1 数据类型 NOT NULL DEFAULT 默认值,\n\t列名2 数据类型 NULL,\n    列名3 INT NOT NULL AUTO_INCREMENT,\n    PRIMARY KET(列名)\n);\n```\n\n## 数据类型\n\n常用数据类型如下：\n\n| 列种类     | 数据类型     | 说明                                                         |\n| ---------- | ------------ | ------------------------------------------------------------ |\n| 数值型     | INT          | 有符号或无符号的正常大小的整数。                             |\n|            | FLOAT(M, D)  | 有符号的浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。    |\n|            | DOUBLE(M, D) | 有符号的双精度浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。 |\n| 日期与时间 | DATE         | YYYY-MM-DD 格式的日期。                                      |\n|            | DATETIME     | YYYY-MM-DD HH:MM:SS 格式的日期和时间组合。                   |\n|            | TIMESTAMP    | 时间戳，从 1970 年 1 月 1 日午夜开始计算。                   |\n|            | TIME         | 以 HH:MM:SS 格式存储时间。                                   |\n| 字符型     | CHAR(M)      | 定长字符串。大小在括号中指定。最大 255 字节。                |\n|            | VARCHAR(M)   | 变长字符串。最大尺寸在括号中指定。                           |\n|            | BLOB         | “二进制大对象”，用于存储大量二进制数据，例如图像或其他类型的文件。 |\n|            | TEXT         | 大量的文本数据。                                             |\n\n## 约束\n\n常用约束如下：\n\n| 约束               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| NOT NULL           | 指示列不能包含任何 NULL 值。                                 |\n| UNIQUE             | 不允许在列中插入重复值。 UNIQUE 约束保持表中列的唯一性。一个表中可以使用多个 UNIQUE 列。 |\n| PRIMARY KEY        | 强制表接受特定列的唯一数据，并且此约束创建唯一索引以更快地访问表。 |\n| CHECK              | 根据逻辑表达式确定值是否有效。                               |\n| DEFAULT            | 在向表中插入数据时，如果没有为列提供值，则该列将获取设置为 DEFAULT 的值。 |\n| **AUTO_INCREMENT** | 自增。                                                       |\n\n# 更新表\n\n## 增加列\n\n```mysql\nALTER TABLE\n\t表名\nADD COLUMN\n\t列名 数据类型;\n```\n\n## 删除列\n\n```mysql\nALTER TABLE\n\t表名\nDROP COLUMN\n\t列名;\n```\n\n## 重命名\n\n```mysql\nALTER TABLE\n\t表名\nRENAME\n\t旧列名\nTO\n\t新列名;\n```\n\n重命名列。\n\n```mysql\nRENAME TABLE\n\t旧表名\nTO\n\t新表名;\n```\n\n重命名表。\n\n# 删除表\n\n```mysql\nDROP TABLE\n\t表名;\n```\n\n# 视图\n\n在 SQL 中，视图是一个基于 SQL 语句结果集的虚拟表。每次访问视图都会重新查询，因此视图其实可能会导致性能下降得特别厉害。它的优点在于封装了底层查询，同时也可用作权限的管理。\n\n## 创建视图\n\n```mysql\nCREATE VIEW\n\t视图名 AS\n查询;\n```\n\n## 更新视图\n\n```mysql\nCREATE OR REPLACE VIEW\n\t视图名 AS\n查询;\n```\n\n不太推荐，直接删掉重新创建就行了。\n\n## 删除视图\n\n```mysql\nDROP VIEW\n\t视图名;\n```\n\n","source":"_posts/MySQL基础.md","raw":"---\ntitle: MySQL 基础\ndate: 2022-08-04 23:34:22\ncategories: [DataScience, Database]\ntags: [mysql, sololearn]\n---\n\n> 参考资料：\n>\n> [Learn SQL | Sololearn](https://www.sololearn.com/learning/1060)\n>\n> 《SQL 必知必会》（第 5 版）\n\n# 基础概念\n\n## 数据库介绍\n\n数据库是一个以便于访问、高效管理与更新的方式组织起来的数据集合。\n\n数据库由存储相关信息的表组成。\n\n表以行和列的格式存储并展示信息，就像 Excel 表格一样。\n\n数据库通常包含多个表，每个表都因特定的目的而设计。\n\n**表可拥有任意数量的行，但只能拥有一定数量的列。**\n\n> MySQL Server 最多只允许 4096 个字段\n>\n> InnoDB 最多只能有 1017 个字段\n>\n> [MySQL :: MySQL 8.0 Reference Manual :: 8.4.7 Limits on Table Column Count and Row Size](https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html)\n\n## 主键 - Primary Keys\n\n主键是表中唯一标识表记录的字段。它关键的两个特点：\n\n- 每行值唯一。\n- 非空。\n\n每张表最多只能有一个主键（也可以没有）。\n\n## SQL - Structured Query Language\n\nSQL 中文叫结构化查询语言。\n\n它用于访问和操作数据库。\n\n> SQL 是 ANSI（美国国家标准协会）标准，但 SQL 语言有不同的版本。\n>\n> 除了 SQL 标准之外，大多数 SQL 数据库程序都有自己的专有扩展，但它们都支持主要命令。\n>\n> MySQL 是其中的一种。\n\n最主要的 4 大功能：**增删查改**。\n\n## 基础 SQL 命令\n\n### SHOW DATABASES\n\n```mysql\nSHOW DATABASES\n```\n\n列出了服务器管理的数据库。\n\n### SHOW TABLES\n\n```mysql\nSHOW TABLES\n```\n\n列出当前数据库里所有表。\n\n### SHOW COLUMNS FROM\n\n```mysql\nSHOW COLUMNS FROM 表名\n```\n\n列出表里的所有字段的详细信息。\n\n如结果可能是\n\n| Field | Type        | Null | Key  | Default | Extra          |\n| ----- | ----------- | ---- | ---- | ------- | -------------- |\n| id    | int(11)     | NO   | PRI  | NULL    | auto_increment |\n| name  | varchar(30) | YES  |      | NULL    |                |\n\n- Field - 列名，字段名。\n- Type - 列数据类型。\n- Null - 字段可否是空值。\n- Key - 指示列是否被索引。\n- Default - 分配给该列的默认值。\n- Extra - 可能包含有关给定列的任何其他可用信息。\n\n# 查询\n\n### SELECT\n\n```mysql\nSELECT 列名 FROM 表名;\n```\n\n从一个表中查询指定的列。\n\n```mysql\nSELECT 列名1, 列名2 FROM 表名;\n```\n\n从一个表里查询多列的数据，列名之间用 `,` 分隔。\n\n```mysql\nSELECT * FROM 表名;\n```\n\n如果要查询所有列的数据，可以用 `*` 。\n\n- 对于多条 SQL ，每条后需要添加 `;` 。\n- SQL 语言不区分大小写。\n- SQL 中忽略空格和多行。\n  - 结合适当的间距和缩进，将命令分成逻辑行将使 SQL 语句更易于阅读和维护。\n\n```mysql\nSELECT 表名.列名 FROM 表名;\n```\n\n同样也可以指定查询某张表的某一列，在表名和列名之间加上 `.` ，当处理可能共享相同列名的多个表时，这种书写形式特别有用。\n\n### DISTINCT\n\n```mysql\nSELECT DISTINCT\n\t列名\nFROM\n\t表名;\n```\n\nDISTINCT 关键字可以达到去重的效果。\n\n### LIMIT\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nLIMIT 数量;\n```\n\nLIMIT 关键字可以指定返回结果的数量。\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nOFFSET 数量\nLIMIT 数量;\n```\n\n可以使用 OFFSET 关键字对所取结果中作筛选偏移，可以理解为 OFFSET 几条就是前几条不要。\n\n### ORDER BY\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nORDER BY\n\t列名;\n```\n\nORDER BY 关键字可以将结果排序后再返回。\n\n如果是数值型列，默认返回从小到大；如果是字符型列，默认返回字母顺序升序。\n\n```mysql\nSELECT\n\t*\nFROM\n\t表名\nORDER BY\n\t列名1, 列名2;\n```\n\nORDER BY 后可以跟两列，像这句一样。这样首先满足 `列名1` 的顺序，再满足 `列名2` 的顺序。\n\n- ASC - 升序。\n\n- DESC - 降序。\n\n# 筛选\n\n### WHERE\n\n```mysql\nSELECT\n\t表名\nFROM\n\t列名\nWHERE\n\t条件;\n```\n\nWHERE 语句可用于按条件筛选返回结果。\n\n使用文本列时，用单引号 `'` 将语句中出现的任何文本括起来。\n\n并且如果字符串内部有单引号，可以使用单引号来转义。例如：\n\n我有一个查询条件 `值 = I'm` ，写成：\n\n```mysql\nWHERE\n\t列名 = 'I''m'\n```\n\n使用比较运算符和逻辑运算符来过滤要选择的数据。\n\n| 比较运算符 | 描述                    |\n| ---------- | ----------------------- |\n| =          | 等于                    |\n| !=         | 不等于                  |\n| >          | 大于                    |\n| <          | 小于                    |\n| >=         | 大于等于                |\n| <=         | 小于等于                |\n| BETWEEN    | 和 AND 一起筛选一个范围 |\n\n### BETWEEN\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 BETWEEN 值1 AND 值2;\n```\n\nBETWEEN 运算符选择范围内的值。第一个值必须是下限，第二个值必须是上限。**这两个值都会被包括进去。**\n\n### 逻辑运算符\n\n| 逻辑运算符 | 描述                         |\n| ---------- | ---------------------------- |\n| AND        | 返回左右两个条件的交集       |\n| OR         | 返回左右两个条件的并集       |\n| IN         | 返回值在后面跟的括号里的结果 |\n| NOT        | 对条件取反                   |\n\n在上述逻辑运算符中，`AND` 优先级是要比 `OR` 高的。\n\n所以 如果要同时用 `AND` 和 `OR` ，最好用括号 `()` 把 `OR` 的括起来以免出错。\n\n### IN\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 IN (值1， 值2);\n```\n\n比较一个列与多个值时，使用 IN 运算符。其效果等同于：\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名=值1 OR 列名=值2;\n```\n\n### AS\n\n```mysql\nSELECT\n\t列名 AS 新列名\nFROM\n\t表名;\n```\n\n用 AS 关键字能够将列名的结果以新列名的标题返回。\n\n### 算术运算符\n\n```mysql\nSELECT\n\t列名+值 AS 列名\nFROM\n\t表名;\n```\n\n可以使用算术运算符将每列的值都做运算。\n\n包括四则运算 `+-*/` 和括号，括号可用于强制操作优先于任何其他运算符，还用于提高代码的可读性。\n\n| 操作符 | 说明 |\n| ------ | ---- |\n| +      | 加   |\n| -      | 减   |\n| *      | 乘   |\n| /      | 除   |\n\n### LIKE\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 LIKE 搜索条件;\n```\n\n使用 `_` 匹配任何单个字符，使用 `%` 匹配任意数量的字符（包括零个字符）。\n\n- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。\n- 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。\n- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。\n\n# 函数\n\n> SELECT 语句为测试、检验函数和计算提供了很好的方法。\n>\n> 虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM 子句后就是简单地访问和 处理表达式，例如 ：\n>\n> SELECT 3 * 2;将返回 6，\n>\n> SELECT Trim(' abc '); 将返回 abc，\n>\n> SELECT Curdate();使用 Curdate()函数返回当前日期和时间。\n>\n> 可以根据需要使用 SELECT 语句进行检验。\n\n## 文本处理函数\n\n### CONCAT\n\n```mysql\nSELECT\n\tCONCAT(列名1, ',', 列名2)\nFROM\n\t表名;\n```\n\nCONCAT 函数用于连接两个或多个文本值并返回连接的字符串。\n\n### RTRIM\n\n```mysql\nSELECT\n\tRTRIM(列名)\nFROM\n\t表名;\n```\n\nRTRIM 函数用于去除所取列的值右边所有的空格。\n\n### LTRIM\n\n```mysql\nSELECT\n\tLTRIM(列名)\nFROM\n\t表名;\n```\n\nRTRIM 函数用于去除所取列的值**左边**所有的空格。\n\n### TRIM\n\n```mysql\nSELECT\n\tTRIM(列名)\nFROM\n\t表名;\n```\n\nRTRIM 函数用于去除所取列的值**左右两边**所有的空格。\n\n### **UPPER**\n\n```mysql\nSELECT\n\tUPPER(列名)\nFROM\n\t表名;\n```\n\nUPPER 函数将指定字符串中的所有字母转换为大写。 \n\n### LOWER\n\n```mysql\nSELECT\n\tLOWER(列名)\nFROM\n\t表名;\n```\n\nLOWER 函数将字符串转换为小写。\n\n> 如果字符串中有不是字母的字符，这个函数对它们不起作用。\n\n### LEFT\n\n```mysql\nSELECT\n\tLEFT(列名, 数字)\nFROM\n\t表名\n```\n\nLEFT 函数将取到该列中值的前 n 个字符。\n\n### RIGHT\n\n```mysql\nSELECT\n\tRIGHT(列名, 数字)\nFROM\n\t表名\n```\n\nRIGHT 函数将取到该列中值的后 n 个字符。\n\n### SUBSTRING\n\n```mysql\nSELECT\n\tSUBSTRING(列名 FROM 数字1 FOR 数字2)\nFROM\n\t表名\n```\n\n从 `数字1` 开始（字符串下标从 1 开始而不是 0），取 `数字2` 个数字。\n\n### SOUNDEX\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\tSOUNDEX(列名) = SOUNDEX(字符串)\n```\n\n返回与字符串发音相同的列名里的值。\n\n## 数值处理函数\n\n### SQRT\n\n```mysql\nSELECT\n\tSQRT(列名)\nFROM\n\t表名;\n```\n\nSQRT 函数返回该列中给定值的平方根。\n\n### ABS\n\n```mysql\nSELECT\n\tABS(列名)\nFROM\n\t表名;\n```\n\nABS 函数返回该列中给定值的绝对值。\n\n### SIN、COS、TAN、PI、EXP\n\n| 函数 | 说明                       |\n| ---- | -------------------------- |\n| SIN  | 返回一个角度的正弦         |\n| COS  | 返回一个角度的余弦         |\n| TAN  | 返回一个角度的正切         |\n| PI   | 返回圆周率 $\\pi$ 的值      |\n| EXP  | 返回一个数的指数值 $e^{x}$ |\n\n## 聚集函数\n\n**这种函数只会返回一个值，此所谓聚集的意思。**\n\n### AVG\n\n```mysql\nSELECT\n\tAVG(列名)\nFROM\n\t表名;\n```\n\nAVG 函数返回该列的平均值。\n\n> AVG 函数忽略列值为 NULL 的行。\n\n### COUNT\n\n```mysql\nSELECT\n\tCOUNT(列名)\nFROM\n\t表名;\n```\n\nCOUNT 函数返回该列的行数。\n\n> 如果指定列名，则 COUNT 函数会忽略指定列的值为 NULL 的行，但 如果 COUNT 函数中用的是星号 `*` ，则不忽略。DISTINCT 不能用于 COUNT(*) 。\n\n### MAX\n\n```mysql\nSELECT\n\tMAX(列名)\nFROM\n\t表名;\n```\n\nMAX 函数返回该列的最大值。\n\n> MAX 函数忽略列值为 NULL 的行。\n\n### MIN\n\n```mysql\nSELECT\n\tMIN(列名)\nFROM\n\t表名;\n```\n\nMIN 函数返回该列的最小值。\n\n> MIN 函数忽略列值为 NULL 的行。\n\n### SUM\n\n```mysql\nSELECT\n\tSUM(列名)\nFROM\n\t表名;\n```\n\nSUM 函数返回该列的和。\n\n> SUM 函数忽略列值为 NULL 的行。\n\n# 分组数据\n\n使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。\n\n## GROUP BY\n\n```mysql\nSELECT\n\t列名, 聚集函数(*)\nFROM\n\t表名\nGROUP BY\n\t列名;\n```\n\nGROUP BY 子句指示 DBMS分组数据，然后对每个组而不是整 个结果集进行聚集。\n\n## HAVING\n\n# 子查询\n\n子查询是另一个查询中的查询。它的末尾没有分号。\n\n> 作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回 错误。\n\n```mysql\nSELECT\n\t(子查询)\nFROM\n\t表名;\n```\n\n子查询作为查询结果。\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 in (子查询);\n```\n\n子查询作为筛选条件。\n\n# 连接\n\n**在引用的列可能出现歧义时，必须使用完全限定列名（用一个句点分隔表名和列名， `表名.列名` 的形式）。如果引用一个没有用表名限制的具有歧义的列名，数据库会报错。**\n\n> DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害。\n\n## 等值连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t表名1, 表名2\nWHERE\n\t表名1.列名1 = 表名2.列名2;\n```\n\n这样会返回两个表的笛卡尔积，使用 WHERE 语句。\n\n## 内连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t表名1\n\tINNER JOIN 表名2 ON 表名1.列名1=表名2.列名2;\n```\n\n![](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081810684.png)\n\n## 自连接\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名 AS 别名1, 表名 AS 别名2\nWHERE\n\t别名1.列名 = 别名2.列名;\n```\n\n或\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名 AS 别名1\n\tINNER JOIN 表名 AS 别名2 ON 别名1.列名=别名2.列名;\n```\n\n> 自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。\n>\n> 虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。\n>\n> 应该试一下两种方法，以确定哪一种的性能更好。\n\n## 自然连接\n\n```mysql\nSELECT\n\t列名\nFROM\n\t表名1\n\tNATURAL JOIN 表名2;\n```\n\n自然连接是一种特殊的内连接，它不需要指定连接条件，重复的列会被去掉。\n\n## 外连接\n\n许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行。\n\n### 左连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tLEFT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;\n```\n\n![](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081845615.png)\n\n### 右连接\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tRIGHT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;\n```\n\n![](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081847770.png)\n\n# 组合查询\n\n> 多数 SQL查询只包含从一个或多个表中返回数据的单条 SELECT 语句。但是，SQL也允许执行多个查询（多条  SELECT 语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（ union ）或复合查询（ compound query ）。\n\n```mysql\n查询1\nUNION\n查询2;\n```\n\nUNION 返回的结果已经是去重了的，如果不需要去重，用 UNION ALL ，并且 UNION ALL 也更快\n\n```mysql\n查询1\nUNION ALL\n查询2;\n```\n\n- 在用 UNION 组合查询时，只能使用一条 **ORDER BY** 子句，它必须位于最后一条 SELECT 语句之后。\n\n- 如果列在所有查询中不完全匹配，可以使用 NULL（或任何其他）值（**说明组合查询要求列的数量完全匹配，最终列名会按第一个查询的列名来展示结果**），例如：\n\n```mysql\nSELECT\n\t列名1, 列名2\nFROM\n\t表名1\nUNION\nSELECT\n\t列名1, NULL\nFROM\n\t表名2;\n```\n\n# 插入数据\n\n## 插入完整的行\n\n```mysql\nINSERT INTO\n\t表名\nVALUES\n\t(值1, 值2);\n```\n\n这种写法能够实现插入功能，但是依赖列的顺序，很不安全，不推荐使用。\n\n推荐使用下面的写法：\n\n```mysql\nINSERT INTO\n\t表名(列名1, 列名2)\nVALUES\n\t(值1, 值2);\n```\n\n## 插入部分行\n\n其实就是使用写列名加值的写法。但是省略的列必须满足以下两个条件之一：\n\n- 该列定义允许 NULL 值。\n- 该列在表定义种给出默认值。\n\n## 插入检索出的数据\n\n```mysql\nINSERT INTO\n\t表名1(列名)\nSELECT\n\t列名\nFROM\n\t表名2;\n```\n\n一般用于表的迁移或合并。**并不要求插入的列名和查询的列名一致，DBMS 使用列的位置来插入。**\n\n## 复制表\n\n当然对于迁移到全新的表，也可以选择复制表。\n\n```mysql\nCREATE TABLE\n\t新表名 AS\nSELECT\n\t*\nFROM\n\t旧表名;\n```\n\n# 修改数据\n\n```mysql\nUPDATE\n\t表名\nSET\n\t列名1=值名1, 列名2=值名2\nWHERE\n\t条件;\n```\n\n**如果不加 WHERE 条件的话，就会更新所有行。**\n\n# 删除数据\n\n```mysql\nDELETE FROM\n\t表名\nWHERE\n\t条件;\n```\n\n与更新数据一样，**如果不加 WHERE 条件的话，就会删除所有行。**\n\n# 创建表\n\n```mysql\nCREATE TABLE\n\t表名\n(\n\t列名1 数据类型 NOT NULL DEFAULT 默认值,\n\t列名2 数据类型 NULL,\n    列名3 INT NOT NULL AUTO_INCREMENT,\n    PRIMARY KET(列名)\n);\n```\n\n## 数据类型\n\n常用数据类型如下：\n\n| 列种类     | 数据类型     | 说明                                                         |\n| ---------- | ------------ | ------------------------------------------------------------ |\n| 数值型     | INT          | 有符号或无符号的正常大小的整数。                             |\n|            | FLOAT(M, D)  | 有符号的浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。    |\n|            | DOUBLE(M, D) | 有符号的双精度浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。 |\n| 日期与时间 | DATE         | YYYY-MM-DD 格式的日期。                                      |\n|            | DATETIME     | YYYY-MM-DD HH:MM:SS 格式的日期和时间组合。                   |\n|            | TIMESTAMP    | 时间戳，从 1970 年 1 月 1 日午夜开始计算。                   |\n|            | TIME         | 以 HH:MM:SS 格式存储时间。                                   |\n| 字符型     | CHAR(M)      | 定长字符串。大小在括号中指定。最大 255 字节。                |\n|            | VARCHAR(M)   | 变长字符串。最大尺寸在括号中指定。                           |\n|            | BLOB         | “二进制大对象”，用于存储大量二进制数据，例如图像或其他类型的文件。 |\n|            | TEXT         | 大量的文本数据。                                             |\n\n## 约束\n\n常用约束如下：\n\n| 约束               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| NOT NULL           | 指示列不能包含任何 NULL 值。                                 |\n| UNIQUE             | 不允许在列中插入重复值。 UNIQUE 约束保持表中列的唯一性。一个表中可以使用多个 UNIQUE 列。 |\n| PRIMARY KEY        | 强制表接受特定列的唯一数据，并且此约束创建唯一索引以更快地访问表。 |\n| CHECK              | 根据逻辑表达式确定值是否有效。                               |\n| DEFAULT            | 在向表中插入数据时，如果没有为列提供值，则该列将获取设置为 DEFAULT 的值。 |\n| **AUTO_INCREMENT** | 自增。                                                       |\n\n# 更新表\n\n## 增加列\n\n```mysql\nALTER TABLE\n\t表名\nADD COLUMN\n\t列名 数据类型;\n```\n\n## 删除列\n\n```mysql\nALTER TABLE\n\t表名\nDROP COLUMN\n\t列名;\n```\n\n## 重命名\n\n```mysql\nALTER TABLE\n\t表名\nRENAME\n\t旧列名\nTO\n\t新列名;\n```\n\n重命名列。\n\n```mysql\nRENAME TABLE\n\t旧表名\nTO\n\t新表名;\n```\n\n重命名表。\n\n# 删除表\n\n```mysql\nDROP TABLE\n\t表名;\n```\n\n# 视图\n\n在 SQL 中，视图是一个基于 SQL 语句结果集的虚拟表。每次访问视图都会重新查询，因此视图其实可能会导致性能下降得特别厉害。它的优点在于封装了底层查询，同时也可用作权限的管理。\n\n## 创建视图\n\n```mysql\nCREATE VIEW\n\t视图名 AS\n查询;\n```\n\n## 更新视图\n\n```mysql\nCREATE OR REPLACE VIEW\n\t视图名 AS\n查询;\n```\n\n不太推荐，直接删掉重新创建就行了。\n\n## 删除视图\n\n```mysql\nDROP VIEW\n\t视图名;\n```\n\n","slug":"MySQL基础","published":1,"updated":"2022-08-11T15:43:07.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1f70001142p0a3f54zh","content":"<blockquote>\n<p>参考资料：</p>\n<p><a href=\"https://www.sololearn.com/learning/1060\">Learn SQL |\nSololearn</a></p>\n<p>《SQL 必知必会》（第 5 版）</p>\n</blockquote>\n<h1 id=\"基础概念\">基础概念</h1>\n<h2 id=\"数据库介绍\">数据库介绍</h2>\n<p>数据库是一个以便于访问、高效管理与更新的方式组织起来的数据集合。</p>\n<p>数据库由存储相关信息的表组成。</p>\n<p>表以行和列的格式存储并展示信息，就像 Excel 表格一样。</p>\n<p>数据库通常包含多个表，每个表都因特定的目的而设计。</p>\n<p><strong>表可拥有任意数量的行，但只能拥有一定数量的列。</strong></p>\n<blockquote>\n<p>MySQL Server 最多只允许 4096 个字段</p>\n<p>InnoDB 最多只能有 1017 个字段</p>\n<p><a\nhref=\"https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html\">MySQL\n:: MySQL 8.0 Reference Manual :: 8.4.7 Limits on Table Column Count and\nRow Size</a></p>\n</blockquote>\n<h2 id=\"主键---primary-keys\">主键 - Primary Keys</h2>\n<p>主键是表中唯一标识表记录的字段。它关键的两个特点：</p>\n<ul>\n<li>每行值唯一。</li>\n<li>非空。</li>\n</ul>\n<p>每张表最多只能有一个主键（也可以没有）。</p>\n<h2 id=\"sql---structured-query-language\">SQL - Structured Query\nLanguage</h2>\n<p>SQL 中文叫结构化查询语言。</p>\n<p>它用于访问和操作数据库。</p>\n<blockquote>\n<p>SQL 是 ANSI（美国国家标准协会）标准，但 SQL 语言有不同的版本。</p>\n<p>除了 SQL 标准之外，大多数 SQL\n数据库程序都有自己的专有扩展，但它们都支持主要命令。</p>\n<p>MySQL 是其中的一种。</p>\n</blockquote>\n<p>最主要的 4 大功能：<strong>增删查改</strong>。</p>\n<h2 id=\"基础-sql-命令\">基础 SQL 命令</h2>\n<h3 id=\"show-databases\">SHOW DATABASES</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SHOW DATABASES</code></pre></div>\n<p>列出了服务器管理的数据库。</p>\n<h3 id=\"show-tables\">SHOW TABLES</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SHOW TABLES</code></pre></div>\n<p>列出当前数据库里所有表。</p>\n<h3 id=\"show-columns-from\">SHOW COLUMNS FROM</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SHOW COLUMNS FROM 表名</code></pre></div>\n<p>列出表里的所有字段的详细信息。</p>\n<p>如结果可能是</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Field</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Default</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>NULL</td>\n<td>auto_increment</td>\n</tr>\n<tr class=\"even\">\n<td>name</td>\n<td>varchar(30)</td>\n<td>YES</td>\n<td></td>\n<td>NULL</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Field - 列名，字段名。</li>\n<li>Type - 列数据类型。</li>\n<li>Null - 字段可否是空值。</li>\n<li>Key - 指示列是否被索引。</li>\n<li>Default - 分配给该列的默认值。</li>\n<li>Extra - 可能包含有关给定列的任何其他可用信息。</li>\n</ul>\n<h1 id=\"查询\">查询</h1>\n<h3 id=\"select\">SELECT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT 列名 FROM 表名;</code></pre></div>\n<p>从一个表中查询指定的列。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT 列名1, 列名2 FROM 表名;</code></pre></div>\n<p>从一个表里查询多列的数据，列名之间用 <code>,</code> 分隔。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT * FROM 表名;</code></pre></div>\n<p>如果要查询所有列的数据，可以用 <code>*</code> 。</p>\n<ul>\n<li>对于多条 SQL ，每条后需要添加 <code>;</code> 。</li>\n<li>SQL 语言不区分大小写。</li>\n<li>SQL 中忽略空格和多行。\n<ul>\n<li>结合适当的间距和缩进，将命令分成逻辑行将使 SQL\n语句更易于阅读和维护。</li>\n</ul></li>\n</ul>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT 表名.列名 FROM 表名;</code></pre></div>\n<p>同样也可以指定查询某张表的某一列，在表名和列名之间加上 <code>.</code>\n，当处理可能共享相同列名的多个表时，这种书写形式特别有用。</p>\n<h3 id=\"distinct\">DISTINCT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT DISTINCT\n\t列名\nFROM\n\t表名;</code></pre></div>\n<p>DISTINCT 关键字可以达到去重的效果。</p>\n<h3 id=\"limit\">LIMIT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nLIMIT 数量;</code></pre></div>\n<p>LIMIT 关键字可以指定返回结果的数量。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nOFFSET 数量\nLIMIT 数量;</code></pre></div>\n<p>可以使用 OFFSET 关键字对所取结果中作筛选偏移，可以理解为 OFFSET\n几条就是前几条不要。</p>\n<h3 id=\"order-by\">ORDER BY</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nORDER BY\n\t列名;</code></pre></div>\n<p>ORDER BY 关键字可以将结果排序后再返回。</p>\n<p>如果是数值型列，默认返回从小到大；如果是字符型列，默认返回字母顺序升序。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t*\nFROM\n\t表名\nORDER BY\n\t列名1, 列名2;</code></pre></div>\n<p>ORDER BY 后可以跟两列，像这句一样。这样首先满足 <code>列名1</code>\n的顺序，再满足 <code>列名2</code> 的顺序。</p>\n<ul>\n<li><p>ASC - 升序。</p></li>\n<li><p>DESC - 降序。</p></li>\n</ul>\n<h1 id=\"筛选\">筛选</h1>\n<h3 id=\"where\">WHERE</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t表名\nFROM\n\t列名\nWHERE\n\t条件;</code></pre></div>\n<p>WHERE 语句可用于按条件筛选返回结果。</p>\n<p>使用文本列时，用单引号 <code>'</code>\n将语句中出现的任何文本括起来。</p>\n<p>并且如果字符串内部有单引号，可以使用单引号来转义。例如：</p>\n<p>我有一个查询条件 <code>值 = I'm</code> ，写成：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">WHERE\n\t列名 = &#x27;I&#x27;&#x27;m&#x27;</code></pre></div>\n<p>使用比较运算符和逻辑运算符来过滤要选择的数据。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>比较运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr class=\"even\">\n<td>!=</td>\n<td>不等于</td>\n</tr>\n<tr class=\"odd\">\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr class=\"odd\">\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr class=\"odd\">\n<td>BETWEEN</td>\n<td>和 AND 一起筛选一个范围</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"between\">BETWEEN</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 BETWEEN 值1 AND 值2;</code></pre></div>\n<p>BETWEEN\n运算符选择范围内的值。第一个值必须是下限，第二个值必须是上限。<strong>这两个值都会被包括进去。</strong></p>\n<h3 id=\"逻辑运算符\">逻辑运算符</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>逻辑运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>AND</td>\n<td>返回左右两个条件的交集</td>\n</tr>\n<tr class=\"even\">\n<td>OR</td>\n<td>返回左右两个条件的并集</td>\n</tr>\n<tr class=\"odd\">\n<td>IN</td>\n<td>返回值在后面跟的括号里的结果</td>\n</tr>\n<tr class=\"even\">\n<td>NOT</td>\n<td>对条件取反</td>\n</tr>\n</tbody>\n</table>\n<p>在上述逻辑运算符中，<code>AND</code> 优先级是要比 <code>OR</code>\n高的。</p>\n<p>所以 如果要同时用 <code>AND</code> 和 <code>OR</code> ，最好用括号\n<code>()</code> 把 <code>OR</code> 的括起来以免出错。</p>\n<h3 id=\"in\">IN</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 IN (值1， 值2);</code></pre></div>\n<p>比较一个列与多个值时，使用 IN 运算符。其效果等同于：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名=值1 OR 列名=值2;</code></pre></div>\n<h3 id=\"as\">AS</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名 AS 新列名\nFROM\n\t表名;</code></pre></div>\n<p>用 AS 关键字能够将列名的结果以新列名的标题返回。</p>\n<h3 id=\"算术运算符\">算术运算符</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名+值 AS 列名\nFROM\n\t表名;</code></pre></div>\n<p>可以使用算术运算符将每列的值都做运算。</p>\n<p>包括四则运算 <code>+-*/</code>\n和括号，括号可用于强制操作优先于任何其他运算符，还用于提高代码的可读性。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>+</td>\n<td>加</td>\n</tr>\n<tr class=\"even\">\n<td>-</td>\n<td>减</td>\n</tr>\n<tr class=\"odd\">\n<td>*</td>\n<td>乘</td>\n</tr>\n<tr class=\"even\">\n<td>/</td>\n<td>除</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"like\">LIKE</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 LIKE 搜索条件;</code></pre></div>\n<p>使用 <code>_</code> 匹配任何单个字符，使用 <code>%</code>\n匹配任意数量的字符（包括零个字符）。</p>\n<ul>\n<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>\n<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>\n<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>\n</ul>\n<h1 id=\"函数\">函数</h1>\n<blockquote>\n<p>SELECT 语句为测试、检验函数和计算提供了很好的方法。</p>\n<p>虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM\n子句后就是简单地访问和 处理表达式，例如 ：</p>\n<p>SELECT 3 * 2;将返回 6，</p>\n<p>SELECT Trim(' abc '); 将返回 abc，</p>\n<p>SELECT Curdate();使用 Curdate()函数返回当前日期和时间。</p>\n<p>可以根据需要使用 SELECT 语句进行检验。</p>\n</blockquote>\n<h2 id=\"文本处理函数\">文本处理函数</h2>\n<h3 id=\"concat\">CONCAT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tCONCAT(列名1, &#x27;,&#x27;, 列名2)\nFROM\n\t表名;</code></pre></div>\n<p>CONCAT 函数用于连接两个或多个文本值并返回连接的字符串。</p>\n<h3 id=\"rtrim\">RTRIM</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tRTRIM(列名)\nFROM\n\t表名;</code></pre></div>\n<p>RTRIM 函数用于去除所取列的值右边所有的空格。</p>\n<h3 id=\"ltrim\">LTRIM</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tLTRIM(列名)\nFROM\n\t表名;</code></pre></div>\n<p>RTRIM 函数用于去除所取列的值<strong>左边</strong>所有的空格。</p>\n<h3 id=\"trim\">TRIM</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tTRIM(列名)\nFROM\n\t表名;</code></pre></div>\n<p>RTRIM 函数用于去除所取列的值<strong>左右两边</strong>所有的空格。</p>\n<h3 id=\"upper\"><strong>UPPER</strong></h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tUPPER(列名)\nFROM\n\t表名;</code></pre></div>\n<p>UPPER 函数将指定字符串中的所有字母转换为大写。</p>\n<h3 id=\"lower\">LOWER</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tLOWER(列名)\nFROM\n\t表名;</code></pre></div>\n<p>LOWER 函数将字符串转换为小写。</p>\n<blockquote>\n<p>如果字符串中有不是字母的字符，这个函数对它们不起作用。</p>\n</blockquote>\n<h3 id=\"left\">LEFT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tLEFT(列名, 数字)\nFROM\n\t表名</code></pre></div>\n<p>LEFT 函数将取到该列中值的前 n 个字符。</p>\n<h3 id=\"right\">RIGHT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tRIGHT(列名, 数字)\nFROM\n\t表名</code></pre></div>\n<p>RIGHT 函数将取到该列中值的后 n 个字符。</p>\n<h3 id=\"substring\">SUBSTRING</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tSUBSTRING(列名 FROM 数字1 FOR 数字2)\nFROM\n\t表名</code></pre></div>\n<p>从 <code>数字1</code> 开始（字符串下标从 1 开始而不是 0），取\n<code>数字2</code> 个数字。</p>\n<h3 id=\"soundex\">SOUNDEX</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\tSOUNDEX(列名) = SOUNDEX(字符串)</code></pre></div>\n<p>返回与字符串发音相同的列名里的值。</p>\n<h2 id=\"数值处理函数\">数值处理函数</h2>\n<h3 id=\"sqrt\">SQRT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tSQRT(列名)\nFROM\n\t表名;</code></pre></div>\n<p>SQRT 函数返回该列中给定值的平方根。</p>\n<h3 id=\"abs\">ABS</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tABS(列名)\nFROM\n\t表名;</code></pre></div>\n<p>ABS 函数返回该列中给定值的绝对值。</p>\n<h3 id=\"sincostanpiexp\">SIN、COS、TAN、PI、EXP</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>SIN</td>\n<td>返回一个角度的正弦</td>\n</tr>\n<tr class=\"even\">\n<td>COS</td>\n<td>返回一个角度的余弦</td>\n</tr>\n<tr class=\"odd\">\n<td>TAN</td>\n<td>返回一个角度的正切</td>\n</tr>\n<tr class=\"even\">\n<td>PI</td>\n<td>返回圆周率 <span class=\"math inline\">\\(\\pi\\)</span> 的值</td>\n</tr>\n<tr class=\"odd\">\n<td>EXP</td>\n<td>返回一个数的指数值 <span class=\"math inline\">\\(e^{x}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"聚集函数\">聚集函数</h2>\n<p><strong>这种函数只会返回一个值，此所谓聚集的意思。</strong></p>\n<h3 id=\"avg\">AVG</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tAVG(列名)\nFROM\n\t表名;</code></pre></div>\n<p>AVG 函数返回该列的平均值。</p>\n<blockquote>\n<p>AVG 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h3 id=\"count\">COUNT</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tCOUNT(列名)\nFROM\n\t表名;</code></pre></div>\n<p>COUNT 函数返回该列的行数。</p>\n<blockquote>\n<p>如果指定列名，则 COUNT 函数会忽略指定列的值为 NULL 的行，但 如果\nCOUNT 函数中用的是星号 <code>*</code> ，则不忽略。DISTINCT 不能用于\nCOUNT(*) 。</p>\n</blockquote>\n<h3 id=\"max\">MAX</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tMAX(列名)\nFROM\n\t表名;</code></pre></div>\n<p>MAX 函数返回该列的最大值。</p>\n<blockquote>\n<p>MAX 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h3 id=\"min\">MIN</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tMIN(列名)\nFROM\n\t表名;</code></pre></div>\n<p>MIN 函数返回该列的最小值。</p>\n<blockquote>\n<p>MIN 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h3 id=\"sum\">SUM</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tSUM(列名)\nFROM\n\t表名;</code></pre></div>\n<p>SUM 函数返回该列的和。</p>\n<blockquote>\n<p>SUM 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h1 id=\"分组数据\">分组数据</h1>\n<p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p>\n<h2 id=\"group-by\">GROUP BY</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名, 聚集函数(*)\nFROM\n\t表名\nGROUP BY\n\t列名;</code></pre></div>\n<p>GROUP BY 子句指示 DBMS分组数据，然后对每个组而不是整\n个结果集进行聚集。</p>\n<h2 id=\"having\">HAVING</h2>\n<h1 id=\"子查询\">子查询</h1>\n<p>子查询是另一个查询中的查询。它的末尾没有分号。</p>\n<blockquote>\n<p>作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回\n错误。</p>\n</blockquote>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t(子查询)\nFROM\n\t表名;</code></pre></div>\n<p>子查询作为查询结果。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 in (子查询);</code></pre></div>\n<p>子查询作为筛选条件。</p>\n<h1 id=\"连接\">连接</h1>\n<p><strong>在引用的列可能出现歧义时，必须使用完全限定列名（用一个句点分隔表名和列名，\n<code>表名.列名</code>\n的形式）。如果引用一个没有用表名限制的具有歧义的列名，数据库会报错。</strong></p>\n<blockquote>\n<p>DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>\n</blockquote>\n<h2 id=\"等值连接\">等值连接</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t表名1, 表名2\nWHERE\n\t表名1.列名1 = 表名2.列名2;</code></pre></div>\n<p>这样会返回两个表的笛卡尔积，使用 WHERE 语句。</p>\n<h2 id=\"内连接\">内连接</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t表名1\n\tINNER JOIN 表名2 ON 表名1.列名1=表名2.列名2;</code></pre></div>\n<p><img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081810684.png\" /></p>\n<h2 id=\"自连接\">自连接</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名 AS 别名1, 表名 AS 别名2\nWHERE\n\t别名1.列名 = 别名2.列名;</code></pre></div>\n<p>或</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名 AS 别名1\n\tINNER JOIN 表名 AS 别名2 ON 别名1.列名=别名2.列名;</code></pre></div>\n<blockquote>\n<p>自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。</p>\n<p>虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。</p>\n<p>应该试一下两种方法，以确定哪一种的性能更好。</p>\n</blockquote>\n<h2 id=\"自然连接\">自然连接</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名1\n\tNATURAL JOIN 表名2;</code></pre></div>\n<p>自然连接是一种特殊的内连接，它不需要指定连接条件，重复的列会被去掉。</p>\n<h2 id=\"外连接\">外连接</h2>\n<p>许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行。</p>\n<h3 id=\"左连接\">左连接</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tLEFT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;</code></pre></div>\n<p><img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081845615.png\" /></p>\n<h3 id=\"右连接\">右连接</h3>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tRIGHT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;</code></pre></div>\n<p><img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081847770.png\" /></p>\n<h1 id=\"组合查询\">组合查询</h1>\n<blockquote>\n<p>多数 SQL查询只包含从一个或多个表中返回数据的单条 SELECT\n语句。但是，SQL也允许执行多个查询（多条 SELECT\n语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（ union\n）或复合查询（ compound query ）。</p>\n</blockquote>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">查询1\nUNION\n查询2;</code></pre></div>\n<p>UNION 返回的结果已经是去重了的，如果不需要去重，用 UNION ALL ，并且\nUNION ALL 也更快</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">查询1\nUNION ALL\n查询2;</code></pre></div>\n<ul>\n<li><p>在用 UNION 组合查询时，只能使用一条 <strong>ORDER BY</strong>\n子句，它必须位于最后一条 SELECT 语句之后。</p></li>\n<li><p>如果列在所有查询中不完全匹配，可以使用\nNULL（或任何其他）值（<strong>说明组合查询要求列的数量完全匹配，最终列名会按第一个查询的列名来展示结果</strong>），例如：</p></li>\n</ul>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t表名1\nUNION\nSELECT\n\t列名1, NULL\nFROM\n\t表名2;</code></pre></div>\n<h1 id=\"插入数据\">插入数据</h1>\n<h2 id=\"插入完整的行\">插入完整的行</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">INSERT INTO\n\t表名\nVALUES\n\t(值1, 值2);</code></pre></div>\n<p>这种写法能够实现插入功能，但是依赖列的顺序，很不安全，不推荐使用。</p>\n<p>推荐使用下面的写法：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">INSERT INTO\n\t表名(列名1, 列名2)\nVALUES\n\t(值1, 值2);</code></pre></div>\n<h2 id=\"插入部分行\">插入部分行</h2>\n<p>其实就是使用写列名加值的写法。但是省略的列必须满足以下两个条件之一：</p>\n<ul>\n<li>该列定义允许 NULL 值。</li>\n<li>该列在表定义种给出默认值。</li>\n</ul>\n<h2 id=\"插入检索出的数据\">插入检索出的数据</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">INSERT INTO\n\t表名1(列名)\nSELECT\n\t列名\nFROM\n\t表名2;</code></pre></div>\n<p>一般用于表的迁移或合并。<strong>并不要求插入的列名和查询的列名一致，DBMS\n使用列的位置来插入。</strong></p>\n<h2 id=\"复制表\">复制表</h2>\n<p>当然对于迁移到全新的表，也可以选择复制表。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">CREATE TABLE\n\t新表名 AS\nSELECT\n\t*\nFROM\n\t旧表名;</code></pre></div>\n<h1 id=\"修改数据\">修改数据</h1>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">UPDATE\n\t表名\nSET\n\t列名1=值名1, 列名2=值名2\nWHERE\n\t条件;</code></pre></div>\n<p><strong>如果不加 WHERE 条件的话，就会更新所有行。</strong></p>\n<h1 id=\"删除数据\">删除数据</h1>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">DELETE FROM\n\t表名\nWHERE\n\t条件;</code></pre></div>\n<p>与更新数据一样，<strong>如果不加 WHERE\n条件的话，就会删除所有行。</strong></p>\n<h1 id=\"创建表\">创建表</h1>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">CREATE TABLE\n\t表名\n(\n\t列名1 数据类型 NOT NULL DEFAULT 默认值,\n\t列名2 数据类型 NULL,\n    列名3 INT NOT NULL AUTO_INCREMENT,\n    PRIMARY KET(列名)\n);</code></pre></div>\n<h2 id=\"数据类型\">数据类型</h2>\n<p>常用数据类型如下：</p>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>列种类</th>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>数值型</td>\n<td>INT</td>\n<td>有符号或无符号的正常大小的整数。</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>FLOAT(M, D)</td>\n<td>有符号的浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>DOUBLE(M, D)</td>\n<td>有符号的双精度浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。</td>\n</tr>\n<tr class=\"even\">\n<td>日期与时间</td>\n<td>DATE</td>\n<td>YYYY-MM-DD 格式的日期。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>DATETIME</td>\n<td>YYYY-MM-DD HH:MM:SS 格式的日期和时间组合。</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>TIMESTAMP</td>\n<td>时间戳，从 1970 年 1 月 1 日午夜开始计算。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>TIME</td>\n<td>以 HH:MM:SS 格式存储时间。</td>\n</tr>\n<tr class=\"even\">\n<td>字符型</td>\n<td>CHAR(M)</td>\n<td>定长字符串。大小在括号中指定。最大 255 字节。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>VARCHAR(M)</td>\n<td>变长字符串。最大尺寸在括号中指定。</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>BLOB</td>\n<td>“二进制大对象”，用于存储大量二进制数据，例如图像或其他类型的文件。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>TEXT</td>\n<td>大量的文本数据。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"约束\">约束</h2>\n<p>常用约束如下：</p>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>约束</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>NOT NULL</td>\n<td>指示列不能包含任何 NULL 值。</td>\n</tr>\n<tr class=\"even\">\n<td>UNIQUE</td>\n<td>不允许在列中插入重复值。 UNIQUE\n约束保持表中列的唯一性。一个表中可以使用多个 UNIQUE 列。</td>\n</tr>\n<tr class=\"odd\">\n<td>PRIMARY KEY</td>\n<td>强制表接受特定列的唯一数据，并且此约束创建唯一索引以更快地访问表。</td>\n</tr>\n<tr class=\"even\">\n<td>CHECK</td>\n<td>根据逻辑表达式确定值是否有效。</td>\n</tr>\n<tr class=\"odd\">\n<td>DEFAULT</td>\n<td>在向表中插入数据时，如果没有为列提供值，则该列将获取设置为 DEFAULT\n的值。</td>\n</tr>\n<tr class=\"even\">\n<td><strong>AUTO_INCREMENT</strong></td>\n<td>自增。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"更新表\">更新表</h1>\n<h2 id=\"增加列\">增加列</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">ALTER TABLE\n\t表名\nADD COLUMN\n\t列名 数据类型;</code></pre></div>\n<h2 id=\"删除列\">删除列</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">ALTER TABLE\n\t表名\nDROP COLUMN\n\t列名;</code></pre></div>\n<h2 id=\"重命名\">重命名</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">ALTER TABLE\n\t表名\nRENAME\n\t旧列名\nTO\n\t新列名;</code></pre></div>\n<p>重命名列。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">RENAME TABLE\n\t旧表名\nTO\n\t新表名;</code></pre></div>\n<p>重命名表。</p>\n<h1 id=\"删除表\">删除表</h1>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">DROP TABLE\n\t表名;</code></pre></div>\n<h1 id=\"视图\">视图</h1>\n<p>在 SQL 中，视图是一个基于 SQL\n语句结果集的虚拟表。每次访问视图都会重新查询，因此视图其实可能会导致性能下降得特别厉害。它的优点在于封装了底层查询，同时也可用作权限的管理。</p>\n<h2 id=\"创建视图\">创建视图</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">CREATE VIEW\n\t视图名 AS\n查询;</code></pre></div>\n<h2 id=\"更新视图\">更新视图</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">CREATE OR REPLACE VIEW\n\t视图名 AS\n查询;</code></pre></div>\n<p>不太推荐，直接删掉重新创建就行了。</p>\n<h2 id=\"删除视图\">删除视图</h2>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">DROP VIEW\n\t视图名;</code></pre></div>\n","site":{"data":{}},"wordcount":6327,"excerpt":"","more":"<blockquote>\n<p>参考资料：</p>\n<p><a href=\"https://www.sololearn.com/learning/1060\">Learn SQL |\nSololearn</a></p>\n<p>《SQL 必知必会》（第 5 版）</p>\n</blockquote>\n<h1 id=\"基础概念\">基础概念</h1>\n<h2 id=\"数据库介绍\">数据库介绍</h2>\n<p>数据库是一个以便于访问、高效管理与更新的方式组织起来的数据集合。</p>\n<p>数据库由存储相关信息的表组成。</p>\n<p>表以行和列的格式存储并展示信息，就像 Excel 表格一样。</p>\n<p>数据库通常包含多个表，每个表都因特定的目的而设计。</p>\n<p><strong>表可拥有任意数量的行，但只能拥有一定数量的列。</strong></p>\n<blockquote>\n<p>MySQL Server 最多只允许 4096 个字段</p>\n<p>InnoDB 最多只能有 1017 个字段</p>\n<p><a\nhref=\"https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html\">MySQL\n:: MySQL 8.0 Reference Manual :: 8.4.7 Limits on Table Column Count and\nRow Size</a></p>\n</blockquote>\n<h2 id=\"主键---primary-keys\">主键 - Primary Keys</h2>\n<p>主键是表中唯一标识表记录的字段。它关键的两个特点：</p>\n<ul>\n<li>每行值唯一。</li>\n<li>非空。</li>\n</ul>\n<p>每张表最多只能有一个主键（也可以没有）。</p>\n<h2 id=\"sql---structured-query-language\">SQL - Structured Query\nLanguage</h2>\n<p>SQL 中文叫结构化查询语言。</p>\n<p>它用于访问和操作数据库。</p>\n<blockquote>\n<p>SQL 是 ANSI（美国国家标准协会）标准，但 SQL 语言有不同的版本。</p>\n<p>除了 SQL 标准之外，大多数 SQL\n数据库程序都有自己的专有扩展，但它们都支持主要命令。</p>\n<p>MySQL 是其中的一种。</p>\n</blockquote>\n<p>最主要的 4 大功能：<strong>增删查改</strong>。</p>\n<h2 id=\"基础-sql-命令\">基础 SQL 命令</h2>\n<h3 id=\"show-databases\">SHOW DATABASES</h3>\n<pre><code class=\"hljs mysql\">SHOW DATABASES</code></pre>\n<p>列出了服务器管理的数据库。</p>\n<h3 id=\"show-tables\">SHOW TABLES</h3>\n<pre><code class=\"hljs mysql\">SHOW TABLES</code></pre>\n<p>列出当前数据库里所有表。</p>\n<h3 id=\"show-columns-from\">SHOW COLUMNS FROM</h3>\n<pre><code class=\"hljs mysql\">SHOW COLUMNS FROM 表名</code></pre>\n<p>列出表里的所有字段的详细信息。</p>\n<p>如结果可能是</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Field</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Default</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>NULL</td>\n<td>auto_increment</td>\n</tr>\n<tr class=\"even\">\n<td>name</td>\n<td>varchar(30)</td>\n<td>YES</td>\n<td></td>\n<td>NULL</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Field - 列名，字段名。</li>\n<li>Type - 列数据类型。</li>\n<li>Null - 字段可否是空值。</li>\n<li>Key - 指示列是否被索引。</li>\n<li>Default - 分配给该列的默认值。</li>\n<li>Extra - 可能包含有关给定列的任何其他可用信息。</li>\n</ul>\n<h1 id=\"查询\">查询</h1>\n<h3 id=\"select\">SELECT</h3>\n<pre><code class=\"hljs mysql\">SELECT 列名 FROM 表名;</code></pre>\n<p>从一个表中查询指定的列。</p>\n<pre><code class=\"hljs mysql\">SELECT 列名1, 列名2 FROM 表名;</code></pre>\n<p>从一个表里查询多列的数据，列名之间用 <code>,</code> 分隔。</p>\n<pre><code class=\"hljs mysql\">SELECT * FROM 表名;</code></pre>\n<p>如果要查询所有列的数据，可以用 <code>*</code> 。</p>\n<ul>\n<li>对于多条 SQL ，每条后需要添加 <code>;</code> 。</li>\n<li>SQL 语言不区分大小写。</li>\n<li>SQL 中忽略空格和多行。\n<ul>\n<li>结合适当的间距和缩进，将命令分成逻辑行将使 SQL\n语句更易于阅读和维护。</li>\n</ul></li>\n</ul>\n<pre><code class=\"hljs mysql\">SELECT 表名.列名 FROM 表名;</code></pre>\n<p>同样也可以指定查询某张表的某一列，在表名和列名之间加上 <code>.</code>\n，当处理可能共享相同列名的多个表时，这种书写形式特别有用。</p>\n<h3 id=\"distinct\">DISTINCT</h3>\n<pre><code class=\"hljs mysql\">SELECT DISTINCT\n\t列名\nFROM\n\t表名;</code></pre>\n<p>DISTINCT 关键字可以达到去重的效果。</p>\n<h3 id=\"limit\">LIMIT</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nLIMIT 数量;</code></pre>\n<p>LIMIT 关键字可以指定返回结果的数量。</p>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nOFFSET 数量\nLIMIT 数量;</code></pre>\n<p>可以使用 OFFSET 关键字对所取结果中作筛选偏移，可以理解为 OFFSET\n几条就是前几条不要。</p>\n<h3 id=\"order-by\">ORDER BY</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nORDER BY\n\t列名;</code></pre>\n<p>ORDER BY 关键字可以将结果排序后再返回。</p>\n<p>如果是数值型列，默认返回从小到大；如果是字符型列，默认返回字母顺序升序。</p>\n<pre><code class=\"hljs mysql\">SELECT\n\t*\nFROM\n\t表名\nORDER BY\n\t列名1, 列名2;</code></pre>\n<p>ORDER BY 后可以跟两列，像这句一样。这样首先满足 <code>列名1</code>\n的顺序，再满足 <code>列名2</code> 的顺序。</p>\n<ul>\n<li><p>ASC - 升序。</p></li>\n<li><p>DESC - 降序。</p></li>\n</ul>\n<h1 id=\"筛选\">筛选</h1>\n<h3 id=\"where\">WHERE</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t表名\nFROM\n\t列名\nWHERE\n\t条件;</code></pre>\n<p>WHERE 语句可用于按条件筛选返回结果。</p>\n<p>使用文本列时，用单引号 <code>'</code>\n将语句中出现的任何文本括起来。</p>\n<p>并且如果字符串内部有单引号，可以使用单引号来转义。例如：</p>\n<p>我有一个查询条件 <code>值 = I'm</code> ，写成：</p>\n<pre><code class=\"hljs mysql\">WHERE\n\t列名 = &#x27;I&#x27;&#x27;m&#x27;</code></pre>\n<p>使用比较运算符和逻辑运算符来过滤要选择的数据。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>比较运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr class=\"even\">\n<td>!=</td>\n<td>不等于</td>\n</tr>\n<tr class=\"odd\">\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr class=\"odd\">\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr class=\"odd\">\n<td>BETWEEN</td>\n<td>和 AND 一起筛选一个范围</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"between\">BETWEEN</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 BETWEEN 值1 AND 值2;</code></pre>\n<p>BETWEEN\n运算符选择范围内的值。第一个值必须是下限，第二个值必须是上限。<strong>这两个值都会被包括进去。</strong></p>\n<h3 id=\"逻辑运算符\">逻辑运算符</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>逻辑运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>AND</td>\n<td>返回左右两个条件的交集</td>\n</tr>\n<tr class=\"even\">\n<td>OR</td>\n<td>返回左右两个条件的并集</td>\n</tr>\n<tr class=\"odd\">\n<td>IN</td>\n<td>返回值在后面跟的括号里的结果</td>\n</tr>\n<tr class=\"even\">\n<td>NOT</td>\n<td>对条件取反</td>\n</tr>\n</tbody>\n</table>\n<p>在上述逻辑运算符中，<code>AND</code> 优先级是要比 <code>OR</code>\n高的。</p>\n<p>所以 如果要同时用 <code>AND</code> 和 <code>OR</code> ，最好用括号\n<code>()</code> 把 <code>OR</code> 的括起来以免出错。</p>\n<h3 id=\"in\">IN</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 IN (值1， 值2);</code></pre>\n<p>比较一个列与多个值时，使用 IN 运算符。其效果等同于：</p>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名=值1 OR 列名=值2;</code></pre>\n<h3 id=\"as\">AS</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名 AS 新列名\nFROM\n\t表名;</code></pre>\n<p>用 AS 关键字能够将列名的结果以新列名的标题返回。</p>\n<h3 id=\"算术运算符\">算术运算符</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名+值 AS 列名\nFROM\n\t表名;</code></pre>\n<p>可以使用算术运算符将每列的值都做运算。</p>\n<p>包括四则运算 <code>+-*/</code>\n和括号，括号可用于强制操作优先于任何其他运算符，还用于提高代码的可读性。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>+</td>\n<td>加</td>\n</tr>\n<tr class=\"even\">\n<td>-</td>\n<td>减</td>\n</tr>\n<tr class=\"odd\">\n<td>*</td>\n<td>乘</td>\n</tr>\n<tr class=\"even\">\n<td>/</td>\n<td>除</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"like\">LIKE</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 LIKE 搜索条件;</code></pre>\n<p>使用 <code>_</code> 匹配任何单个字符，使用 <code>%</code>\n匹配任意数量的字符（包括零个字符）。</p>\n<ul>\n<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>\n<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>\n<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>\n</ul>\n<h1 id=\"函数\">函数</h1>\n<blockquote>\n<p>SELECT 语句为测试、检验函数和计算提供了很好的方法。</p>\n<p>虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM\n子句后就是简单地访问和 处理表达式，例如 ：</p>\n<p>SELECT 3 * 2;将返回 6，</p>\n<p>SELECT Trim(' abc '); 将返回 abc，</p>\n<p>SELECT Curdate();使用 Curdate()函数返回当前日期和时间。</p>\n<p>可以根据需要使用 SELECT 语句进行检验。</p>\n</blockquote>\n<h2 id=\"文本处理函数\">文本处理函数</h2>\n<h3 id=\"concat\">CONCAT</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tCONCAT(列名1, &#x27;,&#x27;, 列名2)\nFROM\n\t表名;</code></pre>\n<p>CONCAT 函数用于连接两个或多个文本值并返回连接的字符串。</p>\n<h3 id=\"rtrim\">RTRIM</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tRTRIM(列名)\nFROM\n\t表名;</code></pre>\n<p>RTRIM 函数用于去除所取列的值右边所有的空格。</p>\n<h3 id=\"ltrim\">LTRIM</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tLTRIM(列名)\nFROM\n\t表名;</code></pre>\n<p>RTRIM 函数用于去除所取列的值<strong>左边</strong>所有的空格。</p>\n<h3 id=\"trim\">TRIM</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tTRIM(列名)\nFROM\n\t表名;</code></pre>\n<p>RTRIM 函数用于去除所取列的值<strong>左右两边</strong>所有的空格。</p>\n<h3 id=\"upper\"><strong>UPPER</strong></h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tUPPER(列名)\nFROM\n\t表名;</code></pre>\n<p>UPPER 函数将指定字符串中的所有字母转换为大写。</p>\n<h3 id=\"lower\">LOWER</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tLOWER(列名)\nFROM\n\t表名;</code></pre>\n<p>LOWER 函数将字符串转换为小写。</p>\n<blockquote>\n<p>如果字符串中有不是字母的字符，这个函数对它们不起作用。</p>\n</blockquote>\n<h3 id=\"left\">LEFT</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tLEFT(列名, 数字)\nFROM\n\t表名</code></pre>\n<p>LEFT 函数将取到该列中值的前 n 个字符。</p>\n<h3 id=\"right\">RIGHT</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tRIGHT(列名, 数字)\nFROM\n\t表名</code></pre>\n<p>RIGHT 函数将取到该列中值的后 n 个字符。</p>\n<h3 id=\"substring\">SUBSTRING</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tSUBSTRING(列名 FROM 数字1 FOR 数字2)\nFROM\n\t表名</code></pre>\n<p>从 <code>数字1</code> 开始（字符串下标从 1 开始而不是 0），取\n<code>数字2</code> 个数字。</p>\n<h3 id=\"soundex\">SOUNDEX</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\tSOUNDEX(列名) = SOUNDEX(字符串)</code></pre>\n<p>返回与字符串发音相同的列名里的值。</p>\n<h2 id=\"数值处理函数\">数值处理函数</h2>\n<h3 id=\"sqrt\">SQRT</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tSQRT(列名)\nFROM\n\t表名;</code></pre>\n<p>SQRT 函数返回该列中给定值的平方根。</p>\n<h3 id=\"abs\">ABS</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tABS(列名)\nFROM\n\t表名;</code></pre>\n<p>ABS 函数返回该列中给定值的绝对值。</p>\n<h3 id=\"sincostanpiexp\">SIN、COS、TAN、PI、EXP</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>SIN</td>\n<td>返回一个角度的正弦</td>\n</tr>\n<tr class=\"even\">\n<td>COS</td>\n<td>返回一个角度的余弦</td>\n</tr>\n<tr class=\"odd\">\n<td>TAN</td>\n<td>返回一个角度的正切</td>\n</tr>\n<tr class=\"even\">\n<td>PI</td>\n<td>返回圆周率 <span class=\"math inline\">\\(\\pi\\)</span> 的值</td>\n</tr>\n<tr class=\"odd\">\n<td>EXP</td>\n<td>返回一个数的指数值 <span class=\"math inline\">\\(e^{x}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"聚集函数\">聚集函数</h2>\n<p><strong>这种函数只会返回一个值，此所谓聚集的意思。</strong></p>\n<h3 id=\"avg\">AVG</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tAVG(列名)\nFROM\n\t表名;</code></pre>\n<p>AVG 函数返回该列的平均值。</p>\n<blockquote>\n<p>AVG 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h3 id=\"count\">COUNT</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tCOUNT(列名)\nFROM\n\t表名;</code></pre>\n<p>COUNT 函数返回该列的行数。</p>\n<blockquote>\n<p>如果指定列名，则 COUNT 函数会忽略指定列的值为 NULL 的行，但 如果\nCOUNT 函数中用的是星号 <code>*</code> ，则不忽略。DISTINCT 不能用于\nCOUNT(*) 。</p>\n</blockquote>\n<h3 id=\"max\">MAX</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tMAX(列名)\nFROM\n\t表名;</code></pre>\n<p>MAX 函数返回该列的最大值。</p>\n<blockquote>\n<p>MAX 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h3 id=\"min\">MIN</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tMIN(列名)\nFROM\n\t表名;</code></pre>\n<p>MIN 函数返回该列的最小值。</p>\n<blockquote>\n<p>MIN 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h3 id=\"sum\">SUM</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\tSUM(列名)\nFROM\n\t表名;</code></pre>\n<p>SUM 函数返回该列的和。</p>\n<blockquote>\n<p>SUM 函数忽略列值为 NULL 的行。</p>\n</blockquote>\n<h1 id=\"分组数据\">分组数据</h1>\n<p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p>\n<h2 id=\"group-by\">GROUP BY</h2>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名, 聚集函数(*)\nFROM\n\t表名\nGROUP BY\n\t列名;</code></pre>\n<p>GROUP BY 子句指示 DBMS分组数据，然后对每个组而不是整\n个结果集进行聚集。</p>\n<h2 id=\"having\">HAVING</h2>\n<h1 id=\"子查询\">子查询</h1>\n<p>子查询是另一个查询中的查询。它的末尾没有分号。</p>\n<blockquote>\n<p>作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回\n错误。</p>\n</blockquote>\n<pre><code class=\"hljs mysql\">SELECT\n\t(子查询)\nFROM\n\t表名;</code></pre>\n<p>子查询作为查询结果。</p>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名\nWHERE\n\t列名 in (子查询);</code></pre>\n<p>子查询作为筛选条件。</p>\n<h1 id=\"连接\">连接</h1>\n<p><strong>在引用的列可能出现歧义时，必须使用完全限定列名（用一个句点分隔表名和列名，\n<code>表名.列名</code>\n的形式）。如果引用一个没有用表名限制的具有歧义的列名，数据库会报错。</strong></p>\n<blockquote>\n<p>DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>\n</blockquote>\n<h2 id=\"等值连接\">等值连接</h2>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t表名1, 表名2\nWHERE\n\t表名1.列名1 = 表名2.列名2;</code></pre>\n<p>这样会返回两个表的笛卡尔积，使用 WHERE 语句。</p>\n<h2 id=\"内连接\">内连接</h2>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t表名1\n\tINNER JOIN 表名2 ON 表名1.列名1=表名2.列名2;</code></pre>\n<p><img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081810684.png\" /></p>\n<h2 id=\"自连接\">自连接</h2>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名 AS 别名1, 表名 AS 别名2\nWHERE\n\t别名1.列名 = 别名2.列名;</code></pre>\n<p>或</p>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名 AS 别名1\n\tINNER JOIN 表名 AS 别名2 ON 别名1.列名=别名2.列名;</code></pre>\n<blockquote>\n<p>自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。</p>\n<p>虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。</p>\n<p>应该试一下两种方法，以确定哪一种的性能更好。</p>\n</blockquote>\n<h2 id=\"自然连接\">自然连接</h2>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名\nFROM\n\t表名1\n\tNATURAL JOIN 表名2;</code></pre>\n<p>自然连接是一种特殊的内连接，它不需要指定连接条件，重复的列会被去掉。</p>\n<h2 id=\"外连接\">外连接</h2>\n<p>许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行。</p>\n<h3 id=\"左连接\">左连接</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tLEFT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;</code></pre>\n<p><img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081845615.png\" /></p>\n<h3 id=\"右连接\">右连接</h3>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t左表名\n\tRIGHT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;</code></pre>\n<p><img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081847770.png\" /></p>\n<h1 id=\"组合查询\">组合查询</h1>\n<blockquote>\n<p>多数 SQL查询只包含从一个或多个表中返回数据的单条 SELECT\n语句。但是，SQL也允许执行多个查询（多条 SELECT\n语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（ union\n）或复合查询（ compound query ）。</p>\n</blockquote>\n<pre><code class=\"hljs mysql\">查询1\nUNION\n查询2;</code></pre>\n<p>UNION 返回的结果已经是去重了的，如果不需要去重，用 UNION ALL ，并且\nUNION ALL 也更快</p>\n<pre><code class=\"hljs mysql\">查询1\nUNION ALL\n查询2;</code></pre>\n<ul>\n<li><p>在用 UNION 组合查询时，只能使用一条 <strong>ORDER BY</strong>\n子句，它必须位于最后一条 SELECT 语句之后。</p></li>\n<li><p>如果列在所有查询中不完全匹配，可以使用\nNULL（或任何其他）值（<strong>说明组合查询要求列的数量完全匹配，最终列名会按第一个查询的列名来展示结果</strong>），例如：</p></li>\n</ul>\n<pre><code class=\"hljs mysql\">SELECT\n\t列名1, 列名2\nFROM\n\t表名1\nUNION\nSELECT\n\t列名1, NULL\nFROM\n\t表名2;</code></pre>\n<h1 id=\"插入数据\">插入数据</h1>\n<h2 id=\"插入完整的行\">插入完整的行</h2>\n<pre><code class=\"hljs mysql\">INSERT INTO\n\t表名\nVALUES\n\t(值1, 值2);</code></pre>\n<p>这种写法能够实现插入功能，但是依赖列的顺序，很不安全，不推荐使用。</p>\n<p>推荐使用下面的写法：</p>\n<pre><code class=\"hljs mysql\">INSERT INTO\n\t表名(列名1, 列名2)\nVALUES\n\t(值1, 值2);</code></pre>\n<h2 id=\"插入部分行\">插入部分行</h2>\n<p>其实就是使用写列名加值的写法。但是省略的列必须满足以下两个条件之一：</p>\n<ul>\n<li>该列定义允许 NULL 值。</li>\n<li>该列在表定义种给出默认值。</li>\n</ul>\n<h2 id=\"插入检索出的数据\">插入检索出的数据</h2>\n<pre><code class=\"hljs mysql\">INSERT INTO\n\t表名1(列名)\nSELECT\n\t列名\nFROM\n\t表名2;</code></pre>\n<p>一般用于表的迁移或合并。<strong>并不要求插入的列名和查询的列名一致，DBMS\n使用列的位置来插入。</strong></p>\n<h2 id=\"复制表\">复制表</h2>\n<p>当然对于迁移到全新的表，也可以选择复制表。</p>\n<pre><code class=\"hljs mysql\">CREATE TABLE\n\t新表名 AS\nSELECT\n\t*\nFROM\n\t旧表名;</code></pre>\n<h1 id=\"修改数据\">修改数据</h1>\n<pre><code class=\"hljs mysql\">UPDATE\n\t表名\nSET\n\t列名1=值名1, 列名2=值名2\nWHERE\n\t条件;</code></pre>\n<p><strong>如果不加 WHERE 条件的话，就会更新所有行。</strong></p>\n<h1 id=\"删除数据\">删除数据</h1>\n<pre><code class=\"hljs mysql\">DELETE FROM\n\t表名\nWHERE\n\t条件;</code></pre>\n<p>与更新数据一样，<strong>如果不加 WHERE\n条件的话，就会删除所有行。</strong></p>\n<h1 id=\"创建表\">创建表</h1>\n<pre><code class=\"hljs mysql\">CREATE TABLE\n\t表名\n(\n\t列名1 数据类型 NOT NULL DEFAULT 默认值,\n\t列名2 数据类型 NULL,\n    列名3 INT NOT NULL AUTO_INCREMENT,\n    PRIMARY KET(列名)\n);</code></pre>\n<h2 id=\"数据类型\">数据类型</h2>\n<p>常用数据类型如下：</p>\n<table>\n<colgroup>\n<col style=\"width: 12%\" />\n<col style=\"width: 14%\" />\n<col style=\"width: 73%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>列种类</th>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>数值型</td>\n<td>INT</td>\n<td>有符号或无符号的正常大小的整数。</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>FLOAT(M, D)</td>\n<td>有符号的浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>DOUBLE(M, D)</td>\n<td>有符号的双精度浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。</td>\n</tr>\n<tr class=\"even\">\n<td>日期与时间</td>\n<td>DATE</td>\n<td>YYYY-MM-DD 格式的日期。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>DATETIME</td>\n<td>YYYY-MM-DD HH:MM:SS 格式的日期和时间组合。</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>TIMESTAMP</td>\n<td>时间戳，从 1970 年 1 月 1 日午夜开始计算。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>TIME</td>\n<td>以 HH:MM:SS 格式存储时间。</td>\n</tr>\n<tr class=\"even\">\n<td>字符型</td>\n<td>CHAR(M)</td>\n<td>定长字符串。大小在括号中指定。最大 255 字节。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>VARCHAR(M)</td>\n<td>变长字符串。最大尺寸在括号中指定。</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>BLOB</td>\n<td>“二进制大对象”，用于存储大量二进制数据，例如图像或其他类型的文件。</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>TEXT</td>\n<td>大量的文本数据。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"约束\">约束</h2>\n<p>常用约束如下：</p>\n<table>\n<colgroup>\n<col style=\"width: 23%\" />\n<col style=\"width: 76%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>约束</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>NOT NULL</td>\n<td>指示列不能包含任何 NULL 值。</td>\n</tr>\n<tr class=\"even\">\n<td>UNIQUE</td>\n<td>不允许在列中插入重复值。 UNIQUE\n约束保持表中列的唯一性。一个表中可以使用多个 UNIQUE 列。</td>\n</tr>\n<tr class=\"odd\">\n<td>PRIMARY KEY</td>\n<td>强制表接受特定列的唯一数据，并且此约束创建唯一索引以更快地访问表。</td>\n</tr>\n<tr class=\"even\">\n<td>CHECK</td>\n<td>根据逻辑表达式确定值是否有效。</td>\n</tr>\n<tr class=\"odd\">\n<td>DEFAULT</td>\n<td>在向表中插入数据时，如果没有为列提供值，则该列将获取设置为 DEFAULT\n的值。</td>\n</tr>\n<tr class=\"even\">\n<td><strong>AUTO_INCREMENT</strong></td>\n<td>自增。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"更新表\">更新表</h1>\n<h2 id=\"增加列\">增加列</h2>\n<pre><code class=\"hljs mysql\">ALTER TABLE\n\t表名\nADD COLUMN\n\t列名 数据类型;</code></pre>\n<h2 id=\"删除列\">删除列</h2>\n<pre><code class=\"hljs mysql\">ALTER TABLE\n\t表名\nDROP COLUMN\n\t列名;</code></pre>\n<h2 id=\"重命名\">重命名</h2>\n<pre><code class=\"hljs mysql\">ALTER TABLE\n\t表名\nRENAME\n\t旧列名\nTO\n\t新列名;</code></pre>\n<p>重命名列。</p>\n<pre><code class=\"hljs mysql\">RENAME TABLE\n\t旧表名\nTO\n\t新表名;</code></pre>\n<p>重命名表。</p>\n<h1 id=\"删除表\">删除表</h1>\n<pre><code class=\"hljs mysql\">DROP TABLE\n\t表名;</code></pre>\n<h1 id=\"视图\">视图</h1>\n<p>在 SQL 中，视图是一个基于 SQL\n语句结果集的虚拟表。每次访问视图都会重新查询，因此视图其实可能会导致性能下降得特别厉害。它的优点在于封装了底层查询，同时也可用作权限的管理。</p>\n<h2 id=\"创建视图\">创建视图</h2>\n<pre><code class=\"hljs mysql\">CREATE VIEW\n\t视图名 AS\n查询;</code></pre>\n<h2 id=\"更新视图\">更新视图</h2>\n<pre><code class=\"hljs mysql\">CREATE OR REPLACE VIEW\n\t视图名 AS\n查询;</code></pre>\n<p>不太推荐，直接删掉重新创建就行了。</p>\n<h2 id=\"删除视图\">删除视图</h2>\n<pre><code class=\"hljs mysql\">DROP VIEW\n\t视图名;</code></pre>\n"},{"title":"LeetCode 1 9","date":"2022-05-03T04:00:00.000Z","_content":"\n# 1. 两数之和\n\n建立一个`dict`(map)，遍历一次数组，判断`目标值-当前值`是否在`dict`的`key`里，在就输出对应的`value`(index)与当前的`index`。\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i in range(len(nums)):\n            temp_target = target - nums[i]\n            if temp_target in hashmap:\n                return [hashmap[temp_target], i]\n            else:\n                hashmap[nums[i]] = i\n\n        return None\n```\n\n# 9. 回文数\n\n转字符串判断正序和逆序是否相等。\n\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        return str(x)[::-1]==str(x)\n```\n\n 左右指针逐步向中间移动判断每一步是否相等。\n\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        string = str(x)\n        left = 0\n        right = len(string)-1\n        while left<right:\n            if string[left] != string[right]:\n                return False\n            else:\n                left += 1\n                right -= 1\n        \n        return True\n```\n\n","source":"_posts/leetcode20220503.md","raw":"---\ntitle: LeetCode 1 9\ndate: 2022-05-03 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash, point]\n---\n\n# 1. 两数之和\n\n建立一个`dict`(map)，遍历一次数组，判断`目标值-当前值`是否在`dict`的`key`里，在就输出对应的`value`(index)与当前的`index`。\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i in range(len(nums)):\n            temp_target = target - nums[i]\n            if temp_target in hashmap:\n                return [hashmap[temp_target], i]\n            else:\n                hashmap[nums[i]] = i\n\n        return None\n```\n\n# 9. 回文数\n\n转字符串判断正序和逆序是否相等。\n\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        return str(x)[::-1]==str(x)\n```\n\n 左右指针逐步向中间移动判断每一步是否相等。\n\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        string = str(x)\n        left = 0\n        right = len(string)-1\n        while left<right:\n            if string[left] != string[right]:\n                return False\n            else:\n                left += 1\n                right -= 1\n        \n        return True\n```\n\n","slug":"leetcode20220503","published":1,"updated":"2022-08-11T15:43:07.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1f90002142p1k2iedks","content":"<h1 id=\"两数之和\">1. 两数之和</h1>\n<p>建立一个<code>dict</code>(map)，遍历一次数组，判断<code>目标值-当前值</code>是否在<code>dict</code>的<code>key</code>里，在就输出对应的<code>value</code>(index)与当前的<code>index</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">twoSum</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)):\n            temp_target = target - nums[i]\n            <span class=\"hljs-keyword\">if</span> temp_target <span class=\"hljs-keyword\">in</span> hashmap:\n                <span class=\"hljs-keyword\">return</span> [hashmap[temp_target], i]\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[nums[i]] = i\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre></div>\n<h1 id=\"回文数\">9. 回文数</h1>\n<p>转字符串判断正序和逆序是否相等。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPalindrome</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(x)[::-<span class=\"hljs-number\">1</span>]==<span class=\"hljs-built_in\">str</span>(x)</code></pre></div>\n<p> 左右指针逐步向中间移动判断每一步是否相等。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPalindrome</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        string = <span class=\"hljs-built_in\">str</span>(x)\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-built_in\">len</span>(string)-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left&lt;right:\n            <span class=\"hljs-keyword\">if</span> string[left] != string[right]:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                left += <span class=\"hljs-number\">1</span>\n                right -= <span class=\"hljs-number\">1</span>\n        \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n","site":{"data":{}},"wordcount":601,"excerpt":"","more":"<h1 id=\"两数之和\">1. 两数之和</h1>\n<p>建立一个<code>dict</code>(map)，遍历一次数组，判断<code>目标值-当前值</code>是否在<code>dict</code>的<code>key</code>里，在就输出对应的<code>value</code>(index)与当前的<code>index</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">twoSum</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)):\n            temp_target = target - nums[i]\n            <span class=\"hljs-keyword\">if</span> temp_target <span class=\"hljs-keyword\">in</span> hashmap:\n                <span class=\"hljs-keyword\">return</span> [hashmap[temp_target], i]\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[nums[i]] = i\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre>\n<h1 id=\"回文数\">9. 回文数</h1>\n<p>转字符串判断正序和逆序是否相等。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPalindrome</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(x)[::-<span class=\"hljs-number\">1</span>]==<span class=\"hljs-built_in\">str</span>(x)</code></pre>\n<p> 左右指针逐步向中间移动判断每一步是否相等。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPalindrome</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        string = <span class=\"hljs-built_in\">str</span>(x)\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-built_in\">len</span>(string)-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left&lt;right:\n            <span class=\"hljs-keyword\">if</span> string[left] != string[right]:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                left += <span class=\"hljs-number\">1</span>\n                right -= <span class=\"hljs-number\">1</span>\n        \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n"},{"title":"LeetCode 14 20 21","date":"2022-05-04T04:00:00.000Z","_content":"\n# 14. 最长公共前缀\n\n首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。\n\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        res = \"\"\n        min_len = 1<<31\n        for i in strs:\n            min_len = min(min_len, len(i))\n        for i in range(min_len):\n            tmp_target = strs[0][i]\n            for s in strs:\n                if s[i] != tmp_target:\n                    return res\n            res += tmp_target\n        \n        return res\n```\n\n# 20. 有效的括号\n\n有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回`False`，二是后括号是否对应出栈的前括号，不对应也返回`False`。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回`False`。\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if not stack:\n                    return False\n                if i == ')' and stack.pop() != '(':\n                    return False\n                elif i == '}' and stack.pop() != '{':\n                    return False\n                elif i == ']' and stack.pop() != '[':\n                    return False\n        if stack:\n            return False\n        else:\n            return True\n```\n\n# 21. 合并两个有序链表\n\n迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。\n\n```python\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        res = ListNode(0)\n        tmp = res\n        while list1 and list2:\n            if list1.val <= list2.val:\n                tmp.next = list1\n                tmp = tmp.next\n                list1 = list1.next\n            else:\n                tmp.next = list2\n                tmp = tmp.next\n                list2 = list2.next\n        if list1:\n            tmp.next = list1\n        elif list2:\n            tmp.next = list2\n        return res.next\n```\n\n","source":"_posts/leetcode20220504.md","raw":"---\ntitle: LeetCode 14 20 21\ndate: 2022-05-04 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, stack, linked list]\n---\n\n# 14. 最长公共前缀\n\n首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。\n\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        res = \"\"\n        min_len = 1<<31\n        for i in strs:\n            min_len = min(min_len, len(i))\n        for i in range(min_len):\n            tmp_target = strs[0][i]\n            for s in strs:\n                if s[i] != tmp_target:\n                    return res\n            res += tmp_target\n        \n        return res\n```\n\n# 20. 有效的括号\n\n有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回`False`，二是后括号是否对应出栈的前括号，不对应也返回`False`。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回`False`。\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if not stack:\n                    return False\n                if i == ')' and stack.pop() != '(':\n                    return False\n                elif i == '}' and stack.pop() != '{':\n                    return False\n                elif i == ']' and stack.pop() != '[':\n                    return False\n        if stack:\n            return False\n        else:\n            return True\n```\n\n# 21. 合并两个有序链表\n\n迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。\n\n```python\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        res = ListNode(0)\n        tmp = res\n        while list1 and list2:\n            if list1.val <= list2.val:\n                tmp.next = list1\n                tmp = tmp.next\n                list1 = list1.next\n            else:\n                tmp.next = list2\n                tmp = tmp.next\n                list2 = list2.next\n        if list1:\n            tmp.next = list1\n        elif list2:\n            tmp.next = list2\n        return res.next\n```\n\n","slug":"leetcode20220504","published":1,"updated":"2022-08-11T15:43:07.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fc0005142pfknr6b2u","content":"<h1 id=\"最长公共前缀\">14. 最长公共前缀</h1>\n<p>首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">longestCommonPrefix</span>(<span class=\"hljs-params\">self, strs: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        res = <span class=\"hljs-string\">&quot;&quot;</span>\n        min_len = <span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">31</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> strs:\n            min_len = <span class=\"hljs-built_in\">min</span>(min_len, <span class=\"hljs-built_in\">len</span>(i))\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(min_len):\n            tmp_target = strs[<span class=\"hljs-number\">0</span>][i]\n            <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> strs:\n                <span class=\"hljs-keyword\">if</span> s[i] != tmp_target:\n                    <span class=\"hljs-keyword\">return</span> res\n            res += tmp_target\n        \n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"有效的括号\">20. 有效的括号</h1>\n<p>有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回<code>False</code>，二是后括号是否对应出栈的前括号，不对应也返回<code>False</code>。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回<code>False</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isValid</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        stack = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-string\">&#x27;(&#x27;</span> <span class=\"hljs-keyword\">or</span> i == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span> <span class=\"hljs-keyword\">or</span> i == <span class=\"hljs-string\">&#x27;[&#x27;</span>:\n                stack.append(i)\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> stack:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n                <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-string\">&#x27;)&#x27;</span> <span class=\"hljs-keyword\">and</span> stack.pop() != <span class=\"hljs-string\">&#x27;(&#x27;</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n                <span class=\"hljs-keyword\">elif</span> i == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span> <span class=\"hljs-keyword\">and</span> stack.pop() != <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n                <span class=\"hljs-keyword\">elif</span> i == <span class=\"hljs-string\">&#x27;]&#x27;</span> <span class=\"hljs-keyword\">and</span> stack.pop() != <span class=\"hljs-string\">&#x27;[&#x27;</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> stack:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n<h1 id=\"合并两个有序链表\">21. 合并两个有序链表</h1>\n<p>迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mergeTwoLists</span>(<span class=\"hljs-params\">self, list1: <span class=\"hljs-type\">Optional</span>[ListNode], list2: <span class=\"hljs-type\">Optional</span>[ListNode]</span>) -&gt; <span class=\"hljs-type\">Optional</span>[ListNode]:\n        res = ListNode(<span class=\"hljs-number\">0</span>)\n        tmp = res\n        <span class=\"hljs-keyword\">while</span> list1 <span class=\"hljs-keyword\">and</span> list2:\n            <span class=\"hljs-keyword\">if</span> list1.val &lt;= list2.val:\n                tmp.<span class=\"hljs-built_in\">next</span> = list1\n                tmp = tmp.<span class=\"hljs-built_in\">next</span>\n                list1 = list1.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                tmp.<span class=\"hljs-built_in\">next</span> = list2\n                tmp = tmp.<span class=\"hljs-built_in\">next</span>\n                list2 = list2.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">if</span> list1:\n            tmp.<span class=\"hljs-built_in\">next</span> = list1\n        <span class=\"hljs-keyword\">elif</span> list2:\n            tmp.<span class=\"hljs-built_in\">next</span> = list2\n        <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">next</span></code></pre></div>\n","site":{"data":{}},"wordcount":1288,"excerpt":"","more":"<h1 id=\"最长公共前缀\">14. 最长公共前缀</h1>\n<p>首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">longestCommonPrefix</span>(<span class=\"hljs-params\">self, strs: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        res = <span class=\"hljs-string\">&quot;&quot;</span>\n        min_len = <span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">31</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> strs:\n            min_len = <span class=\"hljs-built_in\">min</span>(min_len, <span class=\"hljs-built_in\">len</span>(i))\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(min_len):\n            tmp_target = strs[<span class=\"hljs-number\">0</span>][i]\n            <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> strs:\n                <span class=\"hljs-keyword\">if</span> s[i] != tmp_target:\n                    <span class=\"hljs-keyword\">return</span> res\n            res += tmp_target\n        \n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"有效的括号\">20. 有效的括号</h1>\n<p>有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回<code>False</code>，二是后括号是否对应出栈的前括号，不对应也返回<code>False</code>。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回<code>False</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isValid</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        stack = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-string\">&#x27;(&#x27;</span> <span class=\"hljs-keyword\">or</span> i == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span> <span class=\"hljs-keyword\">or</span> i == <span class=\"hljs-string\">&#x27;[&#x27;</span>:\n                stack.append(i)\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> stack:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n                <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-string\">&#x27;)&#x27;</span> <span class=\"hljs-keyword\">and</span> stack.pop() != <span class=\"hljs-string\">&#x27;(&#x27;</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n                <span class=\"hljs-keyword\">elif</span> i == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span> <span class=\"hljs-keyword\">and</span> stack.pop() != <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n                <span class=\"hljs-keyword\">elif</span> i == <span class=\"hljs-string\">&#x27;]&#x27;</span> <span class=\"hljs-keyword\">and</span> stack.pop() != <span class=\"hljs-string\">&#x27;[&#x27;</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> stack:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n<h1 id=\"合并两个有序链表\">21. 合并两个有序链表</h1>\n<p>迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mergeTwoLists</span>(<span class=\"hljs-params\">self, list1: <span class=\"hljs-type\">Optional</span>[ListNode], list2: <span class=\"hljs-type\">Optional</span>[ListNode]</span>) -&gt; <span class=\"hljs-type\">Optional</span>[ListNode]:\n        res = ListNode(<span class=\"hljs-number\">0</span>)\n        tmp = res\n        <span class=\"hljs-keyword\">while</span> list1 <span class=\"hljs-keyword\">and</span> list2:\n            <span class=\"hljs-keyword\">if</span> list1.val &lt;= list2.val:\n                tmp.<span class=\"hljs-built_in\">next</span> = list1\n                tmp = tmp.<span class=\"hljs-built_in\">next</span>\n                list1 = list1.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                tmp.<span class=\"hljs-built_in\">next</span> = list2\n                tmp = tmp.<span class=\"hljs-built_in\">next</span>\n                list2 = list2.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">if</span> list1:\n            tmp.<span class=\"hljs-built_in\">next</span> = list1\n        <span class=\"hljs-keyword\">elif</span> list2:\n            tmp.<span class=\"hljs-built_in\">next</span> = list2\n        <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">next</span></code></pre>\n"},{"title":"LeetCode 13","date":"2022-05-05T04:00:00.000Z","_content":"\n# 13. 罗马数字转整数\n\n比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。\n\n```python\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        res = 0\n        s_len = len(s)\n        index = 0\n        while index<s_len:\n            if s[index] == 'I':\n                next_index = index+1\n                if next_index < s_len:\n                    if s[next_index] == 'V':\n                        res += 4\n                        index += 2\n                    elif s[next_index] == 'X':\n                        res += 9\n                        index += 2\n                    else:\n                        res += 1\n                        index += 1\n                else:\n                    res += 1\n                    index += 1\n            elif s[index] == 'X':\n                next_index = index+1\n                if next_index < s_len:\n                    if s[next_index] == 'L':\n                        res += 40\n                        index += 2\n                    elif s[next_index] == 'C':\n                        res += 90\n                        index += 2\n                    else:\n                        res += 10\n                        index += 1\n                else:\n                    res += 10\n                    index += 1\n            elif s[index] == 'C':\n                next_index = index+1\n                if next_index < s_len:\n                    if s[next_index] == 'D':\n                        res += 400\n                        index += 2\n                    elif s[next_index] == 'M':\n                        res += 900\n                        index += 2\n                    else:\n                        res += 100\n                        index += 1\n                else:\n                    res += 100\n                    index += 1\n            elif s[index] == 'V':\n                res += 5\n                index += 1\n            elif s[index] == 'L':\n                res += 50\n                index += 1\n            elif s[index] == 'D':\n                res += 500\n                index += 1\n            elif s[index] == 'M':\n                res += 1000\n                index += 1\n\n        return res\n```\n\n","source":"_posts/leetcode20220505.md","raw":"---\ntitle: LeetCode 13\ndate: 2022-05-05 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, point, string]\n---\n\n# 13. 罗马数字转整数\n\n比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。\n\n```python\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        res = 0\n        s_len = len(s)\n        index = 0\n        while index<s_len:\n            if s[index] == 'I':\n                next_index = index+1\n                if next_index < s_len:\n                    if s[next_index] == 'V':\n                        res += 4\n                        index += 2\n                    elif s[next_index] == 'X':\n                        res += 9\n                        index += 2\n                    else:\n                        res += 1\n                        index += 1\n                else:\n                    res += 1\n                    index += 1\n            elif s[index] == 'X':\n                next_index = index+1\n                if next_index < s_len:\n                    if s[next_index] == 'L':\n                        res += 40\n                        index += 2\n                    elif s[next_index] == 'C':\n                        res += 90\n                        index += 2\n                    else:\n                        res += 10\n                        index += 1\n                else:\n                    res += 10\n                    index += 1\n            elif s[index] == 'C':\n                next_index = index+1\n                if next_index < s_len:\n                    if s[next_index] == 'D':\n                        res += 400\n                        index += 2\n                    elif s[next_index] == 'M':\n                        res += 900\n                        index += 2\n                    else:\n                        res += 100\n                        index += 1\n                else:\n                    res += 100\n                    index += 1\n            elif s[index] == 'V':\n                res += 5\n                index += 1\n            elif s[index] == 'L':\n                res += 50\n                index += 1\n            elif s[index] == 'D':\n                res += 500\n                index += 1\n            elif s[index] == 'M':\n                res += 1000\n                index += 1\n\n        return res\n```\n\n","slug":"leetcode20220505","published":1,"updated":"2022-08-11T15:43:07.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fd0006142pfo9l39uz","content":"<h1 id=\"罗马数字转整数\">13. 罗马数字转整数</h1>\n<p>比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">romanToInt</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        s_len = <span class=\"hljs-built_in\">len</span>(s)\n        index = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> index&lt;s_len:\n            <span class=\"hljs-keyword\">if</span> s[index] == <span class=\"hljs-string\">&#x27;I&#x27;</span>:\n                next_index = index+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">if</span> next_index &lt; s_len:\n                    <span class=\"hljs-keyword\">if</span> s[next_index] == <span class=\"hljs-string\">&#x27;V&#x27;</span>:\n                        res += <span class=\"hljs-number\">4</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">elif</span> s[next_index] == <span class=\"hljs-string\">&#x27;X&#x27;</span>:\n                        res += <span class=\"hljs-number\">9</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">else</span>:\n                        res += <span class=\"hljs-number\">1</span>\n                        index += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    res += <span class=\"hljs-number\">1</span>\n                    index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;X&#x27;</span>:\n                next_index = index+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">if</span> next_index &lt; s_len:\n                    <span class=\"hljs-keyword\">if</span> s[next_index] == <span class=\"hljs-string\">&#x27;L&#x27;</span>:\n                        res += <span class=\"hljs-number\">40</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">elif</span> s[next_index] == <span class=\"hljs-string\">&#x27;C&#x27;</span>:\n                        res += <span class=\"hljs-number\">90</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">else</span>:\n                        res += <span class=\"hljs-number\">10</span>\n                        index += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    res += <span class=\"hljs-number\">10</span>\n                    index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;C&#x27;</span>:\n                next_index = index+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">if</span> next_index &lt; s_len:\n                    <span class=\"hljs-keyword\">if</span> s[next_index] == <span class=\"hljs-string\">&#x27;D&#x27;</span>:\n                        res += <span class=\"hljs-number\">400</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">elif</span> s[next_index] == <span class=\"hljs-string\">&#x27;M&#x27;</span>:\n                        res += <span class=\"hljs-number\">900</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">else</span>:\n                        res += <span class=\"hljs-number\">100</span>\n                        index += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    res += <span class=\"hljs-number\">100</span>\n                    index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;V&#x27;</span>:\n                res += <span class=\"hljs-number\">5</span>\n                index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;L&#x27;</span>:\n                res += <span class=\"hljs-number\">50</span>\n                index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;D&#x27;</span>:\n                res += <span class=\"hljs-number\">500</span>\n                index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;M&#x27;</span>:\n                res += <span class=\"hljs-number\">1000</span>\n                index += <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":998,"excerpt":"","more":"<h1 id=\"罗马数字转整数\">13. 罗马数字转整数</h1>\n<p>比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">romanToInt</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        s_len = <span class=\"hljs-built_in\">len</span>(s)\n        index = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> index&lt;s_len:\n            <span class=\"hljs-keyword\">if</span> s[index] == <span class=\"hljs-string\">&#x27;I&#x27;</span>:\n                next_index = index+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">if</span> next_index &lt; s_len:\n                    <span class=\"hljs-keyword\">if</span> s[next_index] == <span class=\"hljs-string\">&#x27;V&#x27;</span>:\n                        res += <span class=\"hljs-number\">4</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">elif</span> s[next_index] == <span class=\"hljs-string\">&#x27;X&#x27;</span>:\n                        res += <span class=\"hljs-number\">9</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">else</span>:\n                        res += <span class=\"hljs-number\">1</span>\n                        index += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    res += <span class=\"hljs-number\">1</span>\n                    index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;X&#x27;</span>:\n                next_index = index+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">if</span> next_index &lt; s_len:\n                    <span class=\"hljs-keyword\">if</span> s[next_index] == <span class=\"hljs-string\">&#x27;L&#x27;</span>:\n                        res += <span class=\"hljs-number\">40</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">elif</span> s[next_index] == <span class=\"hljs-string\">&#x27;C&#x27;</span>:\n                        res += <span class=\"hljs-number\">90</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">else</span>:\n                        res += <span class=\"hljs-number\">10</span>\n                        index += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    res += <span class=\"hljs-number\">10</span>\n                    index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;C&#x27;</span>:\n                next_index = index+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">if</span> next_index &lt; s_len:\n                    <span class=\"hljs-keyword\">if</span> s[next_index] == <span class=\"hljs-string\">&#x27;D&#x27;</span>:\n                        res += <span class=\"hljs-number\">400</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">elif</span> s[next_index] == <span class=\"hljs-string\">&#x27;M&#x27;</span>:\n                        res += <span class=\"hljs-number\">900</span>\n                        index += <span class=\"hljs-number\">2</span>\n                    <span class=\"hljs-keyword\">else</span>:\n                        res += <span class=\"hljs-number\">100</span>\n                        index += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    res += <span class=\"hljs-number\">100</span>\n                    index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;V&#x27;</span>:\n                res += <span class=\"hljs-number\">5</span>\n                index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;L&#x27;</span>:\n                res += <span class=\"hljs-number\">50</span>\n                index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;D&#x27;</span>:\n                res += <span class=\"hljs-number\">500</span>\n                index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> s[index] == <span class=\"hljs-string\">&#x27;M&#x27;</span>:\n                res += <span class=\"hljs-number\">1000</span>\n                index += <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 26","date":"2022-05-06T04:00:00.000Z","_content":"\n# 26. 删除有序数组中的重复项\n\n暴力解法，创建`set`用于记录出现过的唯一元素，创建`drop_lst`用于记录要删的位置，删元素的时候注意下`python`的`del`会更改后续元素的下标，所以建立一个`k`辅助找到真正的下标再删。\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        hashset = set('')\n        drop_lst = []\n        for i in range(len(nums)):\n            if nums[i] not in hashset:\n                hashset.add(nums[i])\n            else:\n                drop_lst.append(i)\n        k = 0\n        for i in drop_lst:\n            del nums[i-k]\n            k += 1\n        return len(hashset)\n```\n\n> 1068 ms\n\n核心在于前探指针，每次循环时生成一个前探指针`next_index`找寻下一个不重复的元素的`index`，用指针`k`代表下一个不重复元素（假如有）正确的位置，所以在找到正确的`next_index`后，将其赋值给`k`就行了，同时将`index`变为`next_index`，最后返回`k-1`因为多算了一次`k`。\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        index = 0\n        length = len(nums)\n        k = 1\n        while index < length:\n            next_index = index+1\n            while next_index<length:\n                if nums[next_index] != nums[index]:\n                    break\n                next_index += 1\n            if next_index != length:\n                nums[k] = nums[next_index]\n            k += 1\n            index = next_index\n        return k-1\n```\n\n> 28 ms\n","source":"_posts/leetcode20220506.md","raw":"---\ntitle: LeetCode 26\ndate: 2022-05-06 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, point]\n---\n\n# 26. 删除有序数组中的重复项\n\n暴力解法，创建`set`用于记录出现过的唯一元素，创建`drop_lst`用于记录要删的位置，删元素的时候注意下`python`的`del`会更改后续元素的下标，所以建立一个`k`辅助找到真正的下标再删。\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        hashset = set('')\n        drop_lst = []\n        for i in range(len(nums)):\n            if nums[i] not in hashset:\n                hashset.add(nums[i])\n            else:\n                drop_lst.append(i)\n        k = 0\n        for i in drop_lst:\n            del nums[i-k]\n            k += 1\n        return len(hashset)\n```\n\n> 1068 ms\n\n核心在于前探指针，每次循环时生成一个前探指针`next_index`找寻下一个不重复的元素的`index`，用指针`k`代表下一个不重复元素（假如有）正确的位置，所以在找到正确的`next_index`后，将其赋值给`k`就行了，同时将`index`变为`next_index`，最后返回`k-1`因为多算了一次`k`。\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        index = 0\n        length = len(nums)\n        k = 1\n        while index < length:\n            next_index = index+1\n            while next_index<length:\n                if nums[next_index] != nums[index]:\n                    break\n                next_index += 1\n            if next_index != length:\n                nums[k] = nums[next_index]\n            k += 1\n            index = next_index\n        return k-1\n```\n\n> 28 ms\n","slug":"leetcode20220506","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fe0007142pclulf23e","content":"<h1 id=\"删除有序数组中的重复项\">26. 删除有序数组中的重复项</h1>\n<p>暴力解法，创建<code>set</code>用于记录出现过的唯一元素，创建<code>drop_lst</code>用于记录要删的位置，删元素的时候注意下<code>python</code>的<code>del</code>会更改后续元素的下标，所以建立一个<code>k</code>辅助找到真正的下标再删。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeDuplicates</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        drop_lst = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)):\n            <span class=\"hljs-keyword\">if</span> nums[i] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset:\n                hashset.add(nums[i])\n            <span class=\"hljs-keyword\">else</span>:\n                drop_lst.append(i)\n        k = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> drop_lst:\n            <span class=\"hljs-keyword\">del</span> nums[i-k]\n            k += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(hashset)</code></pre></div>\n<blockquote>\n<p>1068 ms</p>\n</blockquote>\n<p>核心在于前探指针，每次循环时生成一个前探指针<code>next_index</code>找寻下一个不重复的元素的<code>index</code>，用指针<code>k</code>代表下一个不重复元素（假如有）正确的位置，所以在找到正确的<code>next_index</code>后，将其赋值给<code>k</code>就行了，同时将<code>index</code>变为<code>next_index</code>，最后返回<code>k-1</code>因为多算了一次<code>k</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeDuplicates</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        index = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        k = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> index &lt; length:\n            next_index = index+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">while</span> next_index&lt;length:\n                <span class=\"hljs-keyword\">if</span> nums[next_index] != nums[index]:\n                    <span class=\"hljs-keyword\">break</span>\n                next_index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> next_index != length:\n                nums[k] = nums[next_index]\n            k += <span class=\"hljs-number\">1</span>\n            index = next_index\n        <span class=\"hljs-keyword\">return</span> k-<span class=\"hljs-number\">1</span></code></pre></div>\n<blockquote>\n<p>28 ms</p>\n</blockquote>\n","site":{"data":{}},"wordcount":775,"excerpt":"","more":"<h1 id=\"删除有序数组中的重复项\">26. 删除有序数组中的重复项</h1>\n<p>暴力解法，创建<code>set</code>用于记录出现过的唯一元素，创建<code>drop_lst</code>用于记录要删的位置，删元素的时候注意下<code>python</code>的<code>del</code>会更改后续元素的下标，所以建立一个<code>k</code>辅助找到真正的下标再删。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeDuplicates</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        drop_lst = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)):\n            <span class=\"hljs-keyword\">if</span> nums[i] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset:\n                hashset.add(nums[i])\n            <span class=\"hljs-keyword\">else</span>:\n                drop_lst.append(i)\n        k = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> drop_lst:\n            <span class=\"hljs-keyword\">del</span> nums[i-k]\n            k += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(hashset)</code></pre>\n<blockquote>\n<p>1068 ms</p>\n</blockquote>\n<p>核心在于前探指针，每次循环时生成一个前探指针<code>next_index</code>找寻下一个不重复的元素的<code>index</code>，用指针<code>k</code>代表下一个不重复元素（假如有）正确的位置，所以在找到正确的<code>next_index</code>后，将其赋值给<code>k</code>就行了，同时将<code>index</code>变为<code>next_index</code>，最后返回<code>k-1</code>因为多算了一次<code>k</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeDuplicates</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        index = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        k = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> index &lt; length:\n            next_index = index+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">while</span> next_index&lt;length:\n                <span class=\"hljs-keyword\">if</span> nums[next_index] != nums[index]:\n                    <span class=\"hljs-keyword\">break</span>\n                next_index += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> next_index != length:\n                nums[k] = nums[next_index]\n            k += <span class=\"hljs-number\">1</span>\n            index = next_index\n        <span class=\"hljs-keyword\">return</span> k-<span class=\"hljs-number\">1</span></code></pre>\n<blockquote>\n<p>28 ms</p>\n</blockquote>\n"},{"title":"LeetCode 27 28 35 53","date":"2022-05-07T04:00:00.000Z","_content":"\n# 27. 移除元素\n\n双指针，一个指针`index`控制循环遍历，另一个指针`k`控制将正确的数填到正确的位置。\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        index = 0\n        k = 0\n        length = len(nums)\n        while index<length:\n            if nums[index] != val:\n                nums[k] = nums[index]\n                k+=1\n            index += 1\n        return k\n```\n\n# 28. 实现strStr()\n\n只是用的话，调用python字符串的find函数就行了。\n\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)\n```\n\n思路就是逐位比较。\n\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        length = len(needle)\n        for i in range(len(haystack)-length+1):\n            j = i\n            k = 0\n            while k<length and haystack[j] == needle[k]:\n                j += 1\n                k += 1\n            if j-i == length:\n                return i\n        \n        return -1\n```\n\n# 35. 搜索插入位置\n\n时间复杂度`O(log n)`，经典二分查找。但是这题如果没找到要返回插入的位置，当 $left<x<right$ 时，很明显该插入的位置是`right_index`，然后看一下经典二分查找代码，因为没找到的话`left`还是会加1，所以其实没找到的话`left`就是`right_index`，所以没找到返回`left`。\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums)-1\n        while left<=right:\n            mid = (right+left)//2\n            if nums[mid] < target:\n                left = mid+1\n            elif nums[mid] > target:\n                right = mid-1\n            else:\n                return mid\n        \n        return left\n```\n\n# 53. 最大子数组和\n\n动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于`nums[0]`，然后从左往右遍历，创建一个变量`temp_sum`用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个`temp_sum`了。每找出一段`temp_sum`都与`result`比较取大的作为新的`result`。遍历完成后，就可以得到最大的`result`。\n\n```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = nums[0]\n        temp_sum = 0\n        for i in nums:\n            temp_sum += i\n            if temp_sum > res:\n                res = temp_sum\n            if temp_sum < 0:\n                temp_sum = 0\n        \n        return res\n```\n\n> 时间复杂度 O(n)\n\n","source":"_posts/leetcode20220507.md","raw":"---\ntitle: LeetCode 27 28 35 53\ndate: 2022-05-07 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, point, binary search, dp]\n---\n\n# 27. 移除元素\n\n双指针，一个指针`index`控制循环遍历，另一个指针`k`控制将正确的数填到正确的位置。\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        index = 0\n        k = 0\n        length = len(nums)\n        while index<length:\n            if nums[index] != val:\n                nums[k] = nums[index]\n                k+=1\n            index += 1\n        return k\n```\n\n# 28. 实现strStr()\n\n只是用的话，调用python字符串的find函数就行了。\n\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)\n```\n\n思路就是逐位比较。\n\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        length = len(needle)\n        for i in range(len(haystack)-length+1):\n            j = i\n            k = 0\n            while k<length and haystack[j] == needle[k]:\n                j += 1\n                k += 1\n            if j-i == length:\n                return i\n        \n        return -1\n```\n\n# 35. 搜索插入位置\n\n时间复杂度`O(log n)`，经典二分查找。但是这题如果没找到要返回插入的位置，当 $left<x<right$ 时，很明显该插入的位置是`right_index`，然后看一下经典二分查找代码，因为没找到的话`left`还是会加1，所以其实没找到的话`left`就是`right_index`，所以没找到返回`left`。\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums)-1\n        while left<=right:\n            mid = (right+left)//2\n            if nums[mid] < target:\n                left = mid+1\n            elif nums[mid] > target:\n                right = mid-1\n            else:\n                return mid\n        \n        return left\n```\n\n# 53. 最大子数组和\n\n动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于`nums[0]`，然后从左往右遍历，创建一个变量`temp_sum`用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个`temp_sum`了。每找出一段`temp_sum`都与`result`比较取大的作为新的`result`。遍历完成后，就可以得到最大的`result`。\n\n```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = nums[0]\n        temp_sum = 0\n        for i in nums:\n            temp_sum += i\n            if temp_sum > res:\n                res = temp_sum\n            if temp_sum < 0:\n                temp_sum = 0\n        \n        return res\n```\n\n> 时间复杂度 O(n)\n\n","slug":"leetcode20220507","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1ff000a142pb1sb83qm","content":"<h1 id=\"移除元素\">27. 移除元素</h1>\n<p>双指针，一个指针<code>index</code>控制循环遍历，另一个指针<code>k</code>控制将正确的数填到正确的位置。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeElement</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], val: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        index = <span class=\"hljs-number\">0</span>\n        k = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> index&lt;length:\n            <span class=\"hljs-keyword\">if</span> nums[index] != val:\n                nums[k] = nums[index]\n                k+=<span class=\"hljs-number\">1</span>\n            index += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> k</code></pre></div>\n<h1 id=\"实现strstr\">28. 实现strStr()</h1>\n<p>只是用的话，调用python字符串的find函数就行了。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">strStr</span>(<span class=\"hljs-params\">self, haystack: <span class=\"hljs-built_in\">str</span>, needle: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> haystack.find(needle)</code></pre></div>\n<p>思路就是逐位比较。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">strStr</span>(<span class=\"hljs-params\">self, haystack: <span class=\"hljs-built_in\">str</span>, needle: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        length = <span class=\"hljs-built_in\">len</span>(needle)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(haystack)-length+<span class=\"hljs-number\">1</span>):\n            j = i\n            k = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">while</span> k&lt;length <span class=\"hljs-keyword\">and</span> haystack[j] == needle[k]:\n                j += <span class=\"hljs-number\">1</span>\n                k += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> j-i == length:\n                <span class=\"hljs-keyword\">return</span> i\n        \n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span></code></pre></div>\n<h1 id=\"搜索插入位置\">35. 搜索插入位置</h1>\n<p>时间复杂度<code>O(log n)</code>，经典二分查找。但是这题如果没找到要返回插入的位置，当\n<span class=\"math inline\">\\(left&lt;x&lt;right\\)</span>\n时，很明显该插入的位置是<code>right_index</code>，然后看一下经典二分查找代码，因为没找到的话<code>left</code>还是会加1，所以其实没找到的话<code>left</code>就是<code>right_index</code>，所以没找到返回<code>left</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">searchInsert</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-built_in\">len</span>(nums)-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            mid = (right+left)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid] &lt; target:\n                left = mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> nums[mid] &gt; target:\n                right = mid-<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> mid\n        \n        <span class=\"hljs-keyword\">return</span> left</code></pre></div>\n<h1 id=\"最大子数组和\">53. 最大子数组和</h1>\n<p>动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于<code>nums[0]</code>，然后从左往右遍历，创建一个变量<code>temp_sum</code>用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个<code>temp_sum</code>了。每找出一段<code>temp_sum</code>都与<code>result</code>比较取大的作为新的<code>result</code>。遍历完成后，就可以得到最大的<code>result</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxSubArray</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = nums[<span class=\"hljs-number\">0</span>]\n        temp_sum = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            temp_sum += i\n            <span class=\"hljs-keyword\">if</span> temp_sum &gt; res:\n                res = temp_sum\n            <span class=\"hljs-keyword\">if</span> temp_sum &lt; <span class=\"hljs-number\">0</span>:\n                temp_sum = <span class=\"hljs-number\">0</span>\n        \n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<blockquote>\n<p>时间复杂度 O(n)</p>\n</blockquote>\n","site":{"data":{}},"wordcount":1330,"excerpt":"","more":"<h1 id=\"移除元素\">27. 移除元素</h1>\n<p>双指针，一个指针<code>index</code>控制循环遍历，另一个指针<code>k</code>控制将正确的数填到正确的位置。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeElement</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], val: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        index = <span class=\"hljs-number\">0</span>\n        k = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> index&lt;length:\n            <span class=\"hljs-keyword\">if</span> nums[index] != val:\n                nums[k] = nums[index]\n                k+=<span class=\"hljs-number\">1</span>\n            index += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> k</code></pre>\n<h1 id=\"实现strstr\">28. 实现strStr()</h1>\n<p>只是用的话，调用python字符串的find函数就行了。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">strStr</span>(<span class=\"hljs-params\">self, haystack: <span class=\"hljs-built_in\">str</span>, needle: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> haystack.find(needle)</code></pre>\n<p>思路就是逐位比较。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">strStr</span>(<span class=\"hljs-params\">self, haystack: <span class=\"hljs-built_in\">str</span>, needle: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        length = <span class=\"hljs-built_in\">len</span>(needle)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(haystack)-length+<span class=\"hljs-number\">1</span>):\n            j = i\n            k = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">while</span> k&lt;length <span class=\"hljs-keyword\">and</span> haystack[j] == needle[k]:\n                j += <span class=\"hljs-number\">1</span>\n                k += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> j-i == length:\n                <span class=\"hljs-keyword\">return</span> i\n        \n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span></code></pre>\n<h1 id=\"搜索插入位置\">35. 搜索插入位置</h1>\n<p>时间复杂度<code>O(log n)</code>，经典二分查找。但是这题如果没找到要返回插入的位置，当\n<span class=\"math inline\">\\(left&lt;x&lt;right\\)</span>\n时，很明显该插入的位置是<code>right_index</code>，然后看一下经典二分查找代码，因为没找到的话<code>left</code>还是会加1，所以其实没找到的话<code>left</code>就是<code>right_index</code>，所以没找到返回<code>left</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">searchInsert</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-built_in\">len</span>(nums)-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            mid = (right+left)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid] &lt; target:\n                left = mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> nums[mid] &gt; target:\n                right = mid-<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> mid\n        \n        <span class=\"hljs-keyword\">return</span> left</code></pre>\n<h1 id=\"最大子数组和\">53. 最大子数组和</h1>\n<p>动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于<code>nums[0]</code>，然后从左往右遍历，创建一个变量<code>temp_sum</code>用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个<code>temp_sum</code>了。每找出一段<code>temp_sum</code>都与<code>result</code>比较取大的作为新的<code>result</code>。遍历完成后，就可以得到最大的<code>result</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxSubArray</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = nums[<span class=\"hljs-number\">0</span>]\n        temp_sum = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            temp_sum += i\n            <span class=\"hljs-keyword\">if</span> temp_sum &gt; res:\n                res = temp_sum\n            <span class=\"hljs-keyword\">if</span> temp_sum &lt; <span class=\"hljs-number\">0</span>:\n                temp_sum = <span class=\"hljs-number\">0</span>\n        \n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<blockquote>\n<p>时间复杂度 O(n)</p>\n</blockquote>\n"},{"title":"LeetCode 58","date":"2022-05-09T04:00:00.000Z","_content":"\n# 58. 最后一个单词的长度\n\n反向遍历，用一个`flag`稍微控制下流程就行了，注意几个`if`的顺序。\n\n```python\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        res = 0\n        start = False\n        for i in range(len(s)-1, -1, -1):\n            if s[i] != ' ' and not start:\n                start = True\n            if s[i] == ' ' and start:\n                break\n            if start:\n                res += 1\n        return res\n```\n\n","source":"_posts/leetcode20220509.md","raw":"---\ntitle: LeetCode 58\ndate: 2022-05-09 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, string]\n---\n\n# 58. 最后一个单词的长度\n\n反向遍历，用一个`flag`稍微控制下流程就行了，注意几个`if`的顺序。\n\n```python\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        res = 0\n        start = False\n        for i in range(len(s)-1, -1, -1):\n            if s[i] != ' ' and not start:\n                start = True\n            if s[i] == ' ' and start:\n                break\n            if start:\n                res += 1\n        return res\n```\n\n","slug":"leetcode20220509","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fg000b142p5lnucq4n","content":"<h1 id=\"最后一个单词的长度\">58. 最后一个单词的长度</h1>\n<p>反向遍历，用一个<code>flag</code>稍微控制下流程就行了，注意几个<code>if</code>的顺序。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lengthOfLastWord</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        start = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> s[i] != <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> start:\n                start = <span class=\"hljs-literal\">True</span>\n            <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> start:\n                <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> start:\n                res += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":242,"excerpt":"","more":"<h1 id=\"最后一个单词的长度\">58. 最后一个单词的长度</h1>\n<p>反向遍历，用一个<code>flag</code>稍微控制下流程就行了，注意几个<code>if</code>的顺序。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lengthOfLastWord</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        start = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> s[i] != <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> start:\n                start = <span class=\"hljs-literal\">True</span>\n            <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> start:\n                <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> start:\n                res += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 66 67 69","date":"2022-05-10T04:00:00.000Z","_content":"\n# 66. 加一\n\n从后往前加就行了，需要用一个`carry flag`控制是否进位，加一对末位来说就是进位的，所以当`carry flag`变为`False`时，跳出循环。如果循环走完还需进位，则需要在`list`第0个位置增添个元素1。但是实际上因为`return`的位置可以放得巧妙点，所以可以省略`flag`。\n\n```python\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += 1\n            if digits[i] >= 10:\n                digits[i] -= 10\n            else:\n                return digits\n        return [1] + digits\n```\n\n# 67.二进制求和\n\n直接用内置函数就行了。\n\n```python\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return str(bin(int(a,2)+int(b,2)))[2:]\n```\n\n# 69. x 的平方根 \n\n牛顿迭代法：\n\n为了方便区别问题写为求n的平方根，即\n$$\nx^2=n\\\\\nf(x)=x^2-n\n$$\n相当于求函数$f(x)$的根，关于牛顿迭代的原理参照\n\n> [如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？](https://www.zhihu.com/question/20690553/answer/146104283)\n\n对$x_0$点的切线为：\n$$\ny = f(x_0)-2x_0(x-x0)\n$$\n令$y=0$，迭代后的$x_1$点值可算得：\n$$\nx_1=x_0-\\frac{x_0}{2}+\\frac{n}{2x_0}\n$$\n每次迭代的误差为：\n$$\n\\varepsilon = |x0-x1|\n$$\n当误差小于0.1时跳出就行了。\n\n**初值不能为0。**\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        res = 1\n        while True:\n            last = res\n            res = res - res/2 + x/2/res\n            if abs(last-res) < 1:\n                break\n        return int(res)\n```\n\n二分查找：\n\n$x$的平方根整数部分是满足$k^2\\leq x$的最大$k$值，所以只要保证这个条件可以进行赋值。经典二分查找代码。\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        left, right, res = 0, x, -1\n        while left <= right:\n            mid = (left+right)//2\n            if mid*mid <= x:\n                res = mid\n                left = mid+1\n            else:\n                right = mid-1\n        return res\n```\n\n","source":"_posts/leetcode20220510.md","raw":"---\ntitle: LeetCode 66 67 69\ndate: 2022-05-10 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, loop, binary search, Newton's method]\n---\n\n# 66. 加一\n\n从后往前加就行了，需要用一个`carry flag`控制是否进位，加一对末位来说就是进位的，所以当`carry flag`变为`False`时，跳出循环。如果循环走完还需进位，则需要在`list`第0个位置增添个元素1。但是实际上因为`return`的位置可以放得巧妙点，所以可以省略`flag`。\n\n```python\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += 1\n            if digits[i] >= 10:\n                digits[i] -= 10\n            else:\n                return digits\n        return [1] + digits\n```\n\n# 67.二进制求和\n\n直接用内置函数就行了。\n\n```python\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return str(bin(int(a,2)+int(b,2)))[2:]\n```\n\n# 69. x 的平方根 \n\n牛顿迭代法：\n\n为了方便区别问题写为求n的平方根，即\n$$\nx^2=n\\\\\nf(x)=x^2-n\n$$\n相当于求函数$f(x)$的根，关于牛顿迭代的原理参照\n\n> [如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？](https://www.zhihu.com/question/20690553/answer/146104283)\n\n对$x_0$点的切线为：\n$$\ny = f(x_0)-2x_0(x-x0)\n$$\n令$y=0$，迭代后的$x_1$点值可算得：\n$$\nx_1=x_0-\\frac{x_0}{2}+\\frac{n}{2x_0}\n$$\n每次迭代的误差为：\n$$\n\\varepsilon = |x0-x1|\n$$\n当误差小于0.1时跳出就行了。\n\n**初值不能为0。**\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        res = 1\n        while True:\n            last = res\n            res = res - res/2 + x/2/res\n            if abs(last-res) < 1:\n                break\n        return int(res)\n```\n\n二分查找：\n\n$x$的平方根整数部分是满足$k^2\\leq x$的最大$k$值，所以只要保证这个条件可以进行赋值。经典二分查找代码。\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        left, right, res = 0, x, -1\n        while left <= right:\n            mid = (left+right)//2\n            if mid*mid <= x:\n                res = mid\n                left = mid+1\n            else:\n                right = mid-1\n        return res\n```\n\n","slug":"leetcode20220510","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fi000e142p4ucf0v1h","content":"<h1 id=\"加一\">66. 加一</h1>\n<p>从后往前加就行了，需要用一个<code>carry flag</code>控制是否进位，加一对末位来说就是进位的，所以当<code>carry flag</code>变为<code>False</code>时，跳出循环。如果循环走完还需进位，则需要在<code>list</code>第0个位置增添个元素1。但是实际上因为<code>return</code>的位置可以放得巧妙点，所以可以省略<code>flag</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plusOne</span>(<span class=\"hljs-params\">self, digits: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(digits)-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            digits[i] += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> digits[i] &gt;= <span class=\"hljs-number\">10</span>:\n                digits[i] -= <span class=\"hljs-number\">10</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> digits\n        <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>] + digits</code></pre></div>\n<h1 id=\"二进制求和\">67.二进制求和</h1>\n<p>直接用内置函数就行了。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addBinary</span>(<span class=\"hljs-params\">self, a: <span class=\"hljs-built_in\">str</span>, b: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(<span class=\"hljs-built_in\">int</span>(a,<span class=\"hljs-number\">2</span>)+<span class=\"hljs-built_in\">int</span>(b,<span class=\"hljs-number\">2</span>)))[<span class=\"hljs-number\">2</span>:]</code></pre></div>\n<h1 id=\"x-的平方根\">69. x 的平方根</h1>\n<p>牛顿迭代法：</p>\n<p>为了方便区别问题写为求n的平方根，即 <span class=\"math display\">\\[\nx^2=n\\\\\nf(x)=x^2-n\n\\]</span> 相当于求函数<span\nclass=\"math inline\">\\(f(x)\\)</span>的根，关于牛顿迭代的原理参照</p>\n<blockquote>\n<p><a\nhref=\"https://www.zhihu.com/question/20690553/answer/146104283\">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p>\n</blockquote>\n<p>对<span class=\"math inline\">\\(x_0\\)</span>点的切线为： <span\nclass=\"math display\">\\[\ny = f(x_0)-2x_0(x-x0)\n\\]</span> 令<span class=\"math inline\">\\(y=0\\)</span>，迭代后的<span\nclass=\"math inline\">\\(x_1\\)</span>点值可算得： <span\nclass=\"math display\">\\[\nx_1=x_0-\\frac{x_0}{2}+\\frac{n}{2x_0}\n\\]</span> 每次迭代的误差为： <span class=\"math display\">\\[\n\\varepsilon = |x0-x1|\n\\]</span> 当误差小于0.1时跳出就行了。</p>\n<p><strong>初值不能为0。</strong></p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mySqrt</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n            last = res\n            res = res - res/<span class=\"hljs-number\">2</span> + x/<span class=\"hljs-number\">2</span>/res\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">abs</span>(last-res) &lt; <span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">break</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(res)</code></pre></div>\n<p>二分查找：</p>\n<p><span class=\"math inline\">\\(x\\)</span>的平方根整数部分是满足<span\nclass=\"math inline\">\\(k^2\\leq x\\)</span>的最大<span\nclass=\"math inline\">\\(k\\)</span>值，所以只要保证这个条件可以进行赋值。经典二分查找代码。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mySqrt</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        left, right, res = <span class=\"hljs-number\">0</span>, x, -<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left &lt;= right:\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> mid*mid &lt;= x:\n                res = mid\n                left = mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right = mid-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":1042,"excerpt":"","more":"<h1 id=\"加一\">66. 加一</h1>\n<p>从后往前加就行了，需要用一个<code>carry flag</code>控制是否进位，加一对末位来说就是进位的，所以当<code>carry flag</code>变为<code>False</code>时，跳出循环。如果循环走完还需进位，则需要在<code>list</code>第0个位置增添个元素1。但是实际上因为<code>return</code>的位置可以放得巧妙点，所以可以省略<code>flag</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plusOne</span>(<span class=\"hljs-params\">self, digits: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(digits)-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            digits[i] += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> digits[i] &gt;= <span class=\"hljs-number\">10</span>:\n                digits[i] -= <span class=\"hljs-number\">10</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> digits\n        <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>] + digits</code></pre>\n<h1 id=\"二进制求和\">67.二进制求和</h1>\n<p>直接用内置函数就行了。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addBinary</span>(<span class=\"hljs-params\">self, a: <span class=\"hljs-built_in\">str</span>, b: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(<span class=\"hljs-built_in\">int</span>(a,<span class=\"hljs-number\">2</span>)+<span class=\"hljs-built_in\">int</span>(b,<span class=\"hljs-number\">2</span>)))[<span class=\"hljs-number\">2</span>:]</code></pre>\n<h1 id=\"x-的平方根\">69. x 的平方根</h1>\n<p>牛顿迭代法：</p>\n<p>为了方便区别问题写为求n的平方根，即 <span class=\"math display\">\\[\nx^2=n\\\\\nf(x)=x^2-n\n\\]</span> 相当于求函数<span\nclass=\"math inline\">\\(f(x)\\)</span>的根，关于牛顿迭代的原理参照</p>\n<blockquote>\n<p><a\nhref=\"https://www.zhihu.com/question/20690553/answer/146104283\">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p>\n</blockquote>\n<p>对<span class=\"math inline\">\\(x_0\\)</span>点的切线为： <span\nclass=\"math display\">\\[\ny = f(x_0)-2x_0(x-x0)\n\\]</span> 令<span class=\"math inline\">\\(y=0\\)</span>，迭代后的<span\nclass=\"math inline\">\\(x_1\\)</span>点值可算得： <span\nclass=\"math display\">\\[\nx_1=x_0-\\frac{x_0}{2}+\\frac{n}{2x_0}\n\\]</span> 每次迭代的误差为： <span class=\"math display\">\\[\n\\varepsilon = |x0-x1|\n\\]</span> 当误差小于0.1时跳出就行了。</p>\n<p><strong>初值不能为0。</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mySqrt</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n            last = res\n            res = res - res/<span class=\"hljs-number\">2</span> + x/<span class=\"hljs-number\">2</span>/res\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">abs</span>(last-res) &lt; <span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">break</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(res)</code></pre>\n<p>二分查找：</p>\n<p><span class=\"math inline\">\\(x\\)</span>的平方根整数部分是满足<span\nclass=\"math inline\">\\(k^2\\leq x\\)</span>的最大<span\nclass=\"math inline\">\\(k\\)</span>值，所以只要保证这个条件可以进行赋值。经典二分查找代码。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mySqrt</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        left, right, res = <span class=\"hljs-number\">0</span>, x, -<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left &lt;= right:\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> mid*mid &lt;= x:\n                res = mid\n                left = mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right = mid-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 70","date":"2022-05-11T04:00:00.000Z","_content":"\n# 70. 爬楼梯\n\n斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        lst = [1, 1]\n        for i in range(0, n-1):\n            lst.append(lst[i]+lst[i+1])\n        return lst[n]\n```\n","source":"_posts/leetcode20220511.md","raw":"---\ntitle: LeetCode 70\ndate: 2022-05-11 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, stack, recursion]\n---\n\n# 70. 爬楼梯\n\n斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        lst = [1, 1]\n        for i in range(0, n-1):\n            lst.append(lst[i]+lst[i+1])\n        return lst[n]\n```\n","slug":"leetcode20220511","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fj000g142p4gvo5k9v","content":"<h1 id=\"爬楼梯\">70. 爬楼梯</h1>\n<p>斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        lst = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>):\n            lst.append(lst[i]+lst[i+<span class=\"hljs-number\">1</span>])\n        <span class=\"hljs-keyword\">return</span> lst[n]</code></pre></div>\n","site":{"data":{}},"wordcount":176,"excerpt":"","more":"<h1 id=\"爬楼梯\">70. 爬楼梯</h1>\n<p>斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        lst = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>):\n            lst.append(lst[i]+lst[i+<span class=\"hljs-number\">1</span>])\n        <span class=\"hljs-keyword\">return</span> lst[n]</code></pre>\n"},{"title":"LeetCode 83 88 94 118 119","date":"2022-05-13T04:00:00.000Z","_content":"\n# 83. 删除排序链表中的重复元素\n\n基本链表操作。\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        node = head\n        while node.next:\n            if node.val == node.next.val:\n                node.next = node.next.next\n            else:\n                node = node.next\n        return head\n```\n\n# 88. 合并两个有序数组\n\n本题要求`inplace`，但是我们仍然可以用`不inplace`的思想做`inplace`的事情。\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        left = 0\n        right = 0\n        res = []\n        while (left+right)<(m+n):\n            if left>=m:\n                res.append(nums2[right])\n                right += 1\n                continue\n            if right>=n:\n                res.append(nums1[left])\n                left += 1\n                continue\n            if nums1[left] <= nums2[right]:\n                res.append(nums1[left])\n                left += 1\n            else:\n                res.append(nums2[right])\n                right += 1\n        nums1[:]=res\n```\n\n当然我们也可以逆向开始放数，空间复杂度会更低。\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        tail = m+n-1\n        while m>=1 or n>=1:\n            if m<1:\n                nums1[tail] = nums2[n-1]\n                tail -= 1\n                n -= 1\n                continue\n            if n<1:\n                break\n            if nums1[m-1] >= nums2[n-1]:\n                nums1[tail] = nums1[m-1]\n                m -= 1\n                tail -= 1\n            else:\n                nums1[tail] = nums2[n-1]\n                n -= 1\n                tail -= 1\n```\n\n# 94. 二叉树的中序遍历\n\n递归：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        if root:\n            res.extend(self.inorderTraversal(root.left))\n            res.append(root.val)\n            res.extend(self.inorderTraversal(root.right))\n        return res\n```\n\n非递归：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        if not root:\n            return res\n        node = root\n        stack = []\n        while node or stack:\n            if node:\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack.pop()\n                res.append(node.val)\n                node = node.right\n        return res\n```\n\n# 118. 杨辉三角\n\n就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。\n\n```python\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        res = [[1],[1,1]]\n        curRow = 2\n        while curRow<numRows:\n            temp = [1]\n            for i in range(len(res[curRow-1])-1):\n                temp.append(res[curRow-1][i]+res[curRow-1][i+1])\n            temp.append(1)\n            res.append(temp)\n            curRow += 1\n        return res\n```\n\n# 119. 杨辉三角 II\n\n```python\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        res = [1]\n        cal_num = (rowIndex)//2\n        for i in range(1, cal_num+1, 1):\n            res.append(int(res[i-1]*(rowIndex-i+1)/i))\n        if rowIndex%2 != 0:\n            for i in range(cal_num,-1,-1):\n                res.append(res[i])\n        else:\n            for i in range(cal_num-1,-1,-1):\n                res.append(res[i])\n        return res\n```\n\n","source":"_posts/leetcode20220513.md","raw":"---\ntitle: LeetCode 83 88 94 118 119\ndate: 2022-05-13 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, linked list, array, binary tree]\n---\n\n# 83. 删除排序链表中的重复元素\n\n基本链表操作。\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        node = head\n        while node.next:\n            if node.val == node.next.val:\n                node.next = node.next.next\n            else:\n                node = node.next\n        return head\n```\n\n# 88. 合并两个有序数组\n\n本题要求`inplace`，但是我们仍然可以用`不inplace`的思想做`inplace`的事情。\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        left = 0\n        right = 0\n        res = []\n        while (left+right)<(m+n):\n            if left>=m:\n                res.append(nums2[right])\n                right += 1\n                continue\n            if right>=n:\n                res.append(nums1[left])\n                left += 1\n                continue\n            if nums1[left] <= nums2[right]:\n                res.append(nums1[left])\n                left += 1\n            else:\n                res.append(nums2[right])\n                right += 1\n        nums1[:]=res\n```\n\n当然我们也可以逆向开始放数，空间复杂度会更低。\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        tail = m+n-1\n        while m>=1 or n>=1:\n            if m<1:\n                nums1[tail] = nums2[n-1]\n                tail -= 1\n                n -= 1\n                continue\n            if n<1:\n                break\n            if nums1[m-1] >= nums2[n-1]:\n                nums1[tail] = nums1[m-1]\n                m -= 1\n                tail -= 1\n            else:\n                nums1[tail] = nums2[n-1]\n                n -= 1\n                tail -= 1\n```\n\n# 94. 二叉树的中序遍历\n\n递归：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        if root:\n            res.extend(self.inorderTraversal(root.left))\n            res.append(root.val)\n            res.extend(self.inorderTraversal(root.right))\n        return res\n```\n\n非递归：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        if not root:\n            return res\n        node = root\n        stack = []\n        while node or stack:\n            if node:\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack.pop()\n                res.append(node.val)\n                node = node.right\n        return res\n```\n\n# 118. 杨辉三角\n\n就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。\n\n```python\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        res = [[1],[1,1]]\n        curRow = 2\n        while curRow<numRows:\n            temp = [1]\n            for i in range(len(res[curRow-1])-1):\n                temp.append(res[curRow-1][i]+res[curRow-1][i+1])\n            temp.append(1)\n            res.append(temp)\n            curRow += 1\n        return res\n```\n\n# 119. 杨辉三角 II\n\n```python\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        res = [1]\n        cal_num = (rowIndex)//2\n        for i in range(1, cal_num+1, 1):\n            res.append(int(res[i-1]*(rowIndex-i+1)/i))\n        if rowIndex%2 != 0:\n            for i in range(cal_num,-1,-1):\n                res.append(res[i])\n        else:\n            for i in range(cal_num-1,-1,-1):\n                res.append(res[i])\n        return res\n```\n\n","slug":"leetcode20220513","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fl000k142p82ig1fhp","content":"<h1 id=\"删除排序链表中的重复元素\">83. 删除排序链表中的重复元素</h1>\n<p>基本链表操作。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">deleteDuplicates</span>(<span class=\"hljs-params\">self, head: ListNode</span>) -&gt; ListNode:\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> head:\n            <span class=\"hljs-keyword\">return</span> head\n        node = head\n        <span class=\"hljs-keyword\">while</span> node.<span class=\"hljs-built_in\">next</span>:\n            <span class=\"hljs-keyword\">if</span> node.val == node.<span class=\"hljs-built_in\">next</span>.val:\n                node.<span class=\"hljs-built_in\">next</span> = node.<span class=\"hljs-built_in\">next</span>.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> head</code></pre></div>\n<h1 id=\"合并两个有序数组\">88. 合并两个有序数组</h1>\n<p>本题要求<code>inplace</code>，但是我们仍然可以用<code>不inplace</code>的思想做<code>inplace</code>的事情。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], m: <span class=\"hljs-built_in\">int</span>, nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-number\">0</span>\n        res = []\n        <span class=\"hljs-keyword\">while</span> (left+right)&lt;(m+n):\n            <span class=\"hljs-keyword\">if</span> left&gt;=m:\n                res.append(nums2[right])\n                right += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">if</span> right&gt;=n:\n                res.append(nums1[left])\n                left += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">if</span> nums1[left] &lt;= nums2[right]:\n                res.append(nums1[left])\n                left += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                res.append(nums2[right])\n                right += <span class=\"hljs-number\">1</span>\n        nums1[:]=res</code></pre></div>\n<p>当然我们也可以逆向开始放数，空间复杂度会更低。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], m: <span class=\"hljs-built_in\">int</span>, nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        tail = m+n-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> m&gt;=<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> n&gt;=<span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">if</span> m&lt;<span class=\"hljs-number\">1</span>:\n                nums1[tail] = nums2[n-<span class=\"hljs-number\">1</span>]\n                tail -= <span class=\"hljs-number\">1</span>\n                n -= <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">if</span> n&lt;<span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> nums1[m-<span class=\"hljs-number\">1</span>] &gt;= nums2[n-<span class=\"hljs-number\">1</span>]:\n                nums1[tail] = nums1[m-<span class=\"hljs-number\">1</span>]\n                m -= <span class=\"hljs-number\">1</span>\n                tail -= <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                nums1[tail] = nums2[n-<span class=\"hljs-number\">1</span>]\n                n -= <span class=\"hljs-number\">1</span>\n                tail -= <span class=\"hljs-number\">1</span></code></pre></div>\n<h1 id=\"二叉树的中序遍历\">94. 二叉树的中序遍历</h1>\n<p>递归：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">inorderTraversal</span>(<span class=\"hljs-params\">self, root: <span class=\"hljs-type\">Optional</span>[TreeNode]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        <span class=\"hljs-keyword\">if</span> root:\n            res.extend(self.inorderTraversal(root.left))\n            res.append(root.val)\n            res.extend(self.inorderTraversal(root.right))\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<p>非递归：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">inorderTraversal</span>(<span class=\"hljs-params\">self, root: <span class=\"hljs-type\">Optional</span>[TreeNode]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n            <span class=\"hljs-keyword\">return</span> res\n        node = root\n        stack = []\n        <span class=\"hljs-keyword\">while</span> node <span class=\"hljs-keyword\">or</span> stack:\n            <span class=\"hljs-keyword\">if</span> node:\n                stack.append(node)\n                node = node.left\n            <span class=\"hljs-keyword\">else</span>:\n                node = stack.pop()\n                res.append(node.val)\n                node = node.right\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"杨辉三角\">118. 杨辉三角</h1>\n<p>就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate</span>(<span class=\"hljs-params\">self, numRows: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]]:\n        <span class=\"hljs-keyword\">if</span> numRows == <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">return</span> [[<span class=\"hljs-number\">1</span>]]\n        res = [[<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>]]\n        curRow = <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">while</span> curRow&lt;numRows:\n            temp = [<span class=\"hljs-number\">1</span>]\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(res[curRow-<span class=\"hljs-number\">1</span>])-<span class=\"hljs-number\">1</span>):\n                temp.append(res[curRow-<span class=\"hljs-number\">1</span>][i]+res[curRow-<span class=\"hljs-number\">1</span>][i+<span class=\"hljs-number\">1</span>])\n            temp.append(<span class=\"hljs-number\">1</span>)\n            res.append(temp)\n            curRow += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"杨辉三角-ii\">119. 杨辉三角 II</h1>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getRow</span>(<span class=\"hljs-params\">self, rowIndex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = [<span class=\"hljs-number\">1</span>]\n        cal_num = (rowIndex)//<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, cal_num+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>):\n            res.append(<span class=\"hljs-built_in\">int</span>(res[i-<span class=\"hljs-number\">1</span>]*(rowIndex-i+<span class=\"hljs-number\">1</span>)/i))\n        <span class=\"hljs-keyword\">if</span> rowIndex%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(cal_num,-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>):\n                res.append(res[i])\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(cal_num-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>):\n                res.append(res[i])\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":1987,"excerpt":"","more":"<h1 id=\"删除排序链表中的重复元素\">83. 删除排序链表中的重复元素</h1>\n<p>基本链表操作。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">deleteDuplicates</span>(<span class=\"hljs-params\">self, head: ListNode</span>) -&gt; ListNode:\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> head:\n            <span class=\"hljs-keyword\">return</span> head\n        node = head\n        <span class=\"hljs-keyword\">while</span> node.<span class=\"hljs-built_in\">next</span>:\n            <span class=\"hljs-keyword\">if</span> node.val == node.<span class=\"hljs-built_in\">next</span>.val:\n                node.<span class=\"hljs-built_in\">next</span> = node.<span class=\"hljs-built_in\">next</span>.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> head</code></pre>\n<h1 id=\"合并两个有序数组\">88. 合并两个有序数组</h1>\n<p>本题要求<code>inplace</code>，但是我们仍然可以用<code>不inplace</code>的思想做<code>inplace</code>的事情。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], m: <span class=\"hljs-built_in\">int</span>, nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-number\">0</span>\n        res = []\n        <span class=\"hljs-keyword\">while</span> (left+right)&lt;(m+n):\n            <span class=\"hljs-keyword\">if</span> left&gt;=m:\n                res.append(nums2[right])\n                right += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">if</span> right&gt;=n:\n                res.append(nums1[left])\n                left += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">if</span> nums1[left] &lt;= nums2[right]:\n                res.append(nums1[left])\n                left += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                res.append(nums2[right])\n                right += <span class=\"hljs-number\">1</span>\n        nums1[:]=res</code></pre>\n<p>当然我们也可以逆向开始放数，空间复杂度会更低。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], m: <span class=\"hljs-built_in\">int</span>, nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        tail = m+n-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> m&gt;=<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> n&gt;=<span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">if</span> m&lt;<span class=\"hljs-number\">1</span>:\n                nums1[tail] = nums2[n-<span class=\"hljs-number\">1</span>]\n                tail -= <span class=\"hljs-number\">1</span>\n                n -= <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">if</span> n&lt;<span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> nums1[m-<span class=\"hljs-number\">1</span>] &gt;= nums2[n-<span class=\"hljs-number\">1</span>]:\n                nums1[tail] = nums1[m-<span class=\"hljs-number\">1</span>]\n                m -= <span class=\"hljs-number\">1</span>\n                tail -= <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                nums1[tail] = nums2[n-<span class=\"hljs-number\">1</span>]\n                n -= <span class=\"hljs-number\">1</span>\n                tail -= <span class=\"hljs-number\">1</span></code></pre>\n<h1 id=\"二叉树的中序遍历\">94. 二叉树的中序遍历</h1>\n<p>递归：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">inorderTraversal</span>(<span class=\"hljs-params\">self, root: <span class=\"hljs-type\">Optional</span>[TreeNode]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        <span class=\"hljs-keyword\">if</span> root:\n            res.extend(self.inorderTraversal(root.left))\n            res.append(root.val)\n            res.extend(self.inorderTraversal(root.right))\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<p>非递归：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">inorderTraversal</span>(<span class=\"hljs-params\">self, root: <span class=\"hljs-type\">Optional</span>[TreeNode]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n            <span class=\"hljs-keyword\">return</span> res\n        node = root\n        stack = []\n        <span class=\"hljs-keyword\">while</span> node <span class=\"hljs-keyword\">or</span> stack:\n            <span class=\"hljs-keyword\">if</span> node:\n                stack.append(node)\n                node = node.left\n            <span class=\"hljs-keyword\">else</span>:\n                node = stack.pop()\n                res.append(node.val)\n                node = node.right\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"杨辉三角\">118. 杨辉三角</h1>\n<p>就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate</span>(<span class=\"hljs-params\">self, numRows: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]]:\n        <span class=\"hljs-keyword\">if</span> numRows == <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">return</span> [[<span class=\"hljs-number\">1</span>]]\n        res = [[<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>]]\n        curRow = <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">while</span> curRow&lt;numRows:\n            temp = [<span class=\"hljs-number\">1</span>]\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(res[curRow-<span class=\"hljs-number\">1</span>])-<span class=\"hljs-number\">1</span>):\n                temp.append(res[curRow-<span class=\"hljs-number\">1</span>][i]+res[curRow-<span class=\"hljs-number\">1</span>][i+<span class=\"hljs-number\">1</span>])\n            temp.append(<span class=\"hljs-number\">1</span>)\n            res.append(temp)\n            curRow += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"杨辉三角-ii\">119. 杨辉三角 II</h1>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getRow</span>(<span class=\"hljs-params\">self, rowIndex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = [<span class=\"hljs-number\">1</span>]\n        cal_num = (rowIndex)//<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, cal_num+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>):\n            res.append(<span class=\"hljs-built_in\">int</span>(res[i-<span class=\"hljs-number\">1</span>]*(rowIndex-i+<span class=\"hljs-number\">1</span>)/i))\n        <span class=\"hljs-keyword\">if</span> rowIndex%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(cal_num,-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>):\n                res.append(res[i])\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(cal_num-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>):\n                res.append(res[i])\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 121 125 136 169","date":"2022-05-15T04:00:00.000Z","_content":"\n# 121. 买卖股票的最佳时机\n遍历一次数组，更新数组的最小值`min_pcp`与当前值与数组最小值差的最大值`max_pft`。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。\n````python\nclass Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    max_pft = 0\n    min_pcp = prices[0]\n    for i in prices:\n      if i < min_pcp:\n        min_pcp = i\n        continue\n      if (i-min_pcp)>max_pft:\n        max_pft = i-min_pcp\n    return max_pft\n````\n\n# 125. 验证回文串\n先进行数据清洗再比较。\n```python\nclass Solution:\n  def isPalindrome(self, s: str) -> bool:\n    washed = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return washed == washed[::-1]\n```\n\n# 136. 只出现一次的数字\n蠢蠢hashset。\n```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        hashset = set('')\n        res = []\n        for i in nums:\n            if i not in hashset:\n                res.append(i)\n                hashset.add(i)\n            else:\n                res.remove(i)\n        return res[0]\n```\n题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。\n```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return reduce(lambda x,y: x^y, nums)\n```\n\n# 169. 多数元素\n简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        hashmap = {}\n        feq = len(nums)/2\n        for i in nums:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for k,v in hashmap.items():\n            if v > feq:\n                return k\n```\n\n","source":"_posts/leetcode20220515.md","raw":"---\ntitle: LeetCode 121 125 136 169\ndate: 2022-05-15 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, dp, string, hash]\n---\n\n# 121. 买卖股票的最佳时机\n遍历一次数组，更新数组的最小值`min_pcp`与当前值与数组最小值差的最大值`max_pft`。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。\n````python\nclass Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    max_pft = 0\n    min_pcp = prices[0]\n    for i in prices:\n      if i < min_pcp:\n        min_pcp = i\n        continue\n      if (i-min_pcp)>max_pft:\n        max_pft = i-min_pcp\n    return max_pft\n````\n\n# 125. 验证回文串\n先进行数据清洗再比较。\n```python\nclass Solution:\n  def isPalindrome(self, s: str) -> bool:\n    washed = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return washed == washed[::-1]\n```\n\n# 136. 只出现一次的数字\n蠢蠢hashset。\n```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        hashset = set('')\n        res = []\n        for i in nums:\n            if i not in hashset:\n                res.append(i)\n                hashset.add(i)\n            else:\n                res.remove(i)\n        return res[0]\n```\n题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。\n```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return reduce(lambda x,y: x^y, nums)\n```\n\n# 169. 多数元素\n简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        hashmap = {}\n        feq = len(nums)/2\n        for i in nums:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for k,v in hashmap.items():\n            if v > feq:\n                return k\n```\n\n","slug":"leetcode20220515","published":1,"updated":"2022-08-11T15:43:07.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fm000l142p3box2n1d","content":"<h1 id=\"买卖股票的最佳时机\">121. 买卖股票的最佳时机</h1>\n<p>遍历一次数组，更新数组的最小值<code>min_pcp</code>与当前值与数组最小值差的最大值<code>max_pft</code>。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxProfit</span>(<span class=\"hljs-params\">self, prices: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    max_pft = <span class=\"hljs-number\">0</span>\n    min_pcp = prices[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> prices:\n      <span class=\"hljs-keyword\">if</span> i &lt; min_pcp:\n        min_pcp = i\n        <span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span> (i-min_pcp)&gt;max_pft:\n        max_pft = i-min_pcp\n    <span class=\"hljs-keyword\">return</span> max_pft</code></pre></div></p>\n<h1 id=\"验证回文串\">125. 验证回文串</h1>\n<p>先进行数据清洗再比较。 <div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPalindrome</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n    washed = <span class=\"hljs-string\">&#x27;&#x27;</span>.join(ch.lower() <span class=\"hljs-keyword\">for</span> ch <span class=\"hljs-keyword\">in</span> s <span class=\"hljs-keyword\">if</span> ch.isalnum())\n    <span class=\"hljs-keyword\">return</span> washed == washed[::-<span class=\"hljs-number\">1</span>]</code></pre></div></p>\n<h1 id=\"只出现一次的数字\">136. 只出现一次的数字</h1>\n<p>蠢蠢hashset。 <div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">singleNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset:\n                res.append(i)\n                hashset.add(i)\n            <span class=\"hljs-keyword\">else</span>:\n                res.remove(i)\n        <span class=\"hljs-keyword\">return</span> res[<span class=\"hljs-number\">0</span>]</code></pre></div>\n题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">singleNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> reduce(<span class=\"hljs-keyword\">lambda</span> x,y: x^y, nums)</code></pre></div></p>\n<h1 id=\"多数元素\">169. 多数元素</h1>\n<p>简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">majorityElement</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashmap = &#123;&#125;\n        feq = <span class=\"hljs-built_in\">len</span>(nums)/<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> hashmap.items():\n            <span class=\"hljs-keyword\">if</span> v &gt; feq:\n                <span class=\"hljs-keyword\">return</span> k</code></pre></div></p>\n","site":{"data":{}},"wordcount":1042,"excerpt":"","more":"<h1 id=\"买卖股票的最佳时机\">121. 买卖股票的最佳时机</h1>\n<p>遍历一次数组，更新数组的最小值<code>min_pcp</code>与当前值与数组最小值差的最大值<code>max_pft</code>。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxProfit</span>(<span class=\"hljs-params\">self, prices: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    max_pft = <span class=\"hljs-number\">0</span>\n    min_pcp = prices[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> prices:\n      <span class=\"hljs-keyword\">if</span> i &lt; min_pcp:\n        min_pcp = i\n        <span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span> (i-min_pcp)&gt;max_pft:\n        max_pft = i-min_pcp\n    <span class=\"hljs-keyword\">return</span> max_pft</code></pre></p>\n<h1 id=\"验证回文串\">125. 验证回文串</h1>\n<p>先进行数据清洗再比较。 <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPalindrome</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n    washed = <span class=\"hljs-string\">&#x27;&#x27;</span>.join(ch.lower() <span class=\"hljs-keyword\">for</span> ch <span class=\"hljs-keyword\">in</span> s <span class=\"hljs-keyword\">if</span> ch.isalnum())\n    <span class=\"hljs-keyword\">return</span> washed == washed[::-<span class=\"hljs-number\">1</span>]</code></pre></p>\n<h1 id=\"只出现一次的数字\">136. 只出现一次的数字</h1>\n<p>蠢蠢hashset。 <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">singleNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset:\n                res.append(i)\n                hashset.add(i)\n            <span class=\"hljs-keyword\">else</span>:\n                res.remove(i)\n        <span class=\"hljs-keyword\">return</span> res[<span class=\"hljs-number\">0</span>]</code></pre>\n题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">singleNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> reduce(<span class=\"hljs-keyword\">lambda</span> x,y: x^y, nums)</code></pre></p>\n<h1 id=\"多数元素\">169. 多数元素</h1>\n<p>简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">majorityElement</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashmap = &#123;&#125;\n        feq = <span class=\"hljs-built_in\">len</span>(nums)/<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> hashmap.items():\n            <span class=\"hljs-keyword\">if</span> v &gt; feq:\n                <span class=\"hljs-keyword\">return</span> k</code></pre></p>\n"},{"title":"LeetCode 190","date":"2022-05-18T04:00:00.000Z","_content":"\n# 190. 颠倒二进制位\n\n注意下题目中的32位无符号整数。暴力解：\n\n```python\nclass Solution:\n    def reverseBits(self, n: int) -> int:\n        return int(str('0'*(32-len(str(bin(n))[2:]))+str(bin(n))[2:])[::-1], 2)\n```\n\n","source":"_posts/leetcode20220518.md","raw":"---\ntitle: LeetCode 190\ndate: 2022-05-18 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, string]\n---\n\n# 190. 颠倒二进制位\n\n注意下题目中的32位无符号整数。暴力解：\n\n```python\nclass Solution:\n    def reverseBits(self, n: int) -> int:\n        return int(str('0'*(32-len(str(bin(n))[2:]))+str(bin(n))[2:])[::-1], 2)\n```\n\n","slug":"leetcode20220518","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fn000o142p7ce4035g","content":"<h1 id=\"颠倒二进制位\">190. 颠倒二进制位</h1>\n<p>注意下题目中的32位无符号整数。暴力解：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseBits</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-string\">&#x27;0&#x27;</span>*(<span class=\"hljs-number\">32</span>-<span class=\"hljs-built_in\">len</span>(<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(n))[<span class=\"hljs-number\">2</span>:]))+<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(n))[<span class=\"hljs-number\">2</span>:])[::-<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">2</span>)</code></pre></div>\n","site":{"data":{}},"wordcount":158,"excerpt":"","more":"<h1 id=\"颠倒二进制位\">190. 颠倒二进制位</h1>\n<p>注意下题目中的32位无符号整数。暴力解：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseBits</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-string\">&#x27;0&#x27;</span>*(<span class=\"hljs-number\">32</span>-<span class=\"hljs-built_in\">len</span>(<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(n))[<span class=\"hljs-number\">2</span>:]))+<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(n))[<span class=\"hljs-number\">2</span>:])[::-<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">2</span>)</code></pre>\n"},{"title":"LeetCode 168 171 175 181 182 183","date":"2022-05-16T04:00:00.000Z","_content":"\n# 168. Excel表列名称\n\n此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面`temp = (columnNumber-1)%26+1`这行代码。\n\n```python\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = ''\n        while columnNumber != 0:\n            temp = (columnNumber-1)%26+1\n            res += chr(temp+64)\n            columnNumber = (columnNumber-temp)//26\n        return res[::-1]\n```\n\n# 171. Excel 表列序号\n\n与上题差不多，上题的逆向。本质上还是个进制转换。\n\n```python\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        res = 0\n        n = 1\n        for i in columnTitle[::-1]:\n            res += (ord(i)-64)*n\n            n *= 26\n        return res\n```\n\n# 175. 组合两个表\n\n依题意做一个简单左链接就行了。\n\n```mysql\nSELECT\n\tt1.firstName,\n\tt1.lastName,\n\tt2.city,\n\tt2.state \nFROM\n\tPerson t1\n\tLEFT JOIN Address t2 ON t1.personId = t2.personId\n```\n\n# 181. 超过经理收入的员工\n\n表自链接就行了。\n\n```mysql\nSELECT\n\tl.NAME AS Employee \nFROM\n\tEmployee l\n\tINNER JOIN Employee r ON l.managerId = r.id \nWHERE\n\tl.salary > r.salary\n```\n\n\n\n# 182. 查找重复的电子邮箱\n\n自链接\n\n```mysql\nSELECT DISTINCT\n\tt1.Email \nFROM\n\tPerson t1\n\tJOIN Person t2 ON t1.Email = t2.Email \n\tAND t1.Id != t2.Id\n```\n\n子表查询\n\n```mysql\nSELECT\n\tEmail \nFROM\n\t( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec \nWHERE\n\ttec.ec > 1\n```\n\n# 183. 从不订购的客户\n\n子表查询\n\n```mysql\nSELECT\n\tn.NAME AS Customers \nFROM\n\t( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n \nWHERE\n\tn.id IS NULL\n```\n\n子表查询和`NOT IN`语句\n\n```mysql\nSELECT\n\tCustomers.Name AS Customers \nFROM\n\tCustomers \nWHERE\n\tCustomers.Id NOT IN ( SELECT CustomerId FROM Orders )\n```\n\n右链接\n\n```mysql\nSELECT\n\ta.NAME AS Customers \nFROM\n\tCustomers a\n\tLEFT JOIN Orders b ON a.Id = b.CustomerId \nWHERE\n\tb.CustomerId IS NULL\n```\n\n","source":"_posts/leetcode20220516.md","raw":"---\ntitle: LeetCode 168 171 175 181 182 183\ndate: 2022-05-16 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, sql, ascii]\n---\n\n# 168. Excel表列名称\n\n此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面`temp = (columnNumber-1)%26+1`这行代码。\n\n```python\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = ''\n        while columnNumber != 0:\n            temp = (columnNumber-1)%26+1\n            res += chr(temp+64)\n            columnNumber = (columnNumber-temp)//26\n        return res[::-1]\n```\n\n# 171. Excel 表列序号\n\n与上题差不多，上题的逆向。本质上还是个进制转换。\n\n```python\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        res = 0\n        n = 1\n        for i in columnTitle[::-1]:\n            res += (ord(i)-64)*n\n            n *= 26\n        return res\n```\n\n# 175. 组合两个表\n\n依题意做一个简单左链接就行了。\n\n```mysql\nSELECT\n\tt1.firstName,\n\tt1.lastName,\n\tt2.city,\n\tt2.state \nFROM\n\tPerson t1\n\tLEFT JOIN Address t2 ON t1.personId = t2.personId\n```\n\n# 181. 超过经理收入的员工\n\n表自链接就行了。\n\n```mysql\nSELECT\n\tl.NAME AS Employee \nFROM\n\tEmployee l\n\tINNER JOIN Employee r ON l.managerId = r.id \nWHERE\n\tl.salary > r.salary\n```\n\n\n\n# 182. 查找重复的电子邮箱\n\n自链接\n\n```mysql\nSELECT DISTINCT\n\tt1.Email \nFROM\n\tPerson t1\n\tJOIN Person t2 ON t1.Email = t2.Email \n\tAND t1.Id != t2.Id\n```\n\n子表查询\n\n```mysql\nSELECT\n\tEmail \nFROM\n\t( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec \nWHERE\n\ttec.ec > 1\n```\n\n# 183. 从不订购的客户\n\n子表查询\n\n```mysql\nSELECT\n\tn.NAME AS Customers \nFROM\n\t( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n \nWHERE\n\tn.id IS NULL\n```\n\n子表查询和`NOT IN`语句\n\n```mysql\nSELECT\n\tCustomers.Name AS Customers \nFROM\n\tCustomers \nWHERE\n\tCustomers.Id NOT IN ( SELECT CustomerId FROM Orders )\n```\n\n右链接\n\n```mysql\nSELECT\n\ta.NAME AS Customers \nFROM\n\tCustomers a\n\tLEFT JOIN Orders b ON a.Id = b.CustomerId \nWHERE\n\tb.CustomerId IS NULL\n```\n\n","slug":"leetcode20220516","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fn000p142p3nhzc2c9","content":"<h1 id=\"excel表列名称\">168. Excel表列名称</h1>\n<p>此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面<code>temp = (columnNumber-1)%26+1</code>这行代码。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convertToTitle</span>(<span class=\"hljs-params\">self, columnNumber: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">while</span> columnNumber != <span class=\"hljs-number\">0</span>:\n            temp = (columnNumber-<span class=\"hljs-number\">1</span>)%<span class=\"hljs-number\">26</span>+<span class=\"hljs-number\">1</span>\n            res += <span class=\"hljs-built_in\">chr</span>(temp+<span class=\"hljs-number\">64</span>)\n            columnNumber = (columnNumber-temp)//<span class=\"hljs-number\">26</span>\n        <span class=\"hljs-keyword\">return</span> res[::-<span class=\"hljs-number\">1</span>]</code></pre></div>\n<h1 id=\"excel-表列序号\">171. Excel 表列序号</h1>\n<p>与上题差不多，上题的逆向。本质上还是个进制转换。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">titleToNumber</span>(<span class=\"hljs-params\">self, columnTitle: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        n = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> columnTitle[::-<span class=\"hljs-number\">1</span>]:\n            res += (<span class=\"hljs-built_in\">ord</span>(i)-<span class=\"hljs-number\">64</span>)*n\n            n *= <span class=\"hljs-number\">26</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"组合两个表\">175. 组合两个表</h1>\n<p>依题意做一个简单左链接就行了。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tt1.firstName,\n\tt1.lastName,\n\tt2.city,\n\tt2.state \nFROM\n\tPerson t1\n\tLEFT JOIN Address t2 ON t1.personId = t2.personId</code></pre></div>\n<h1 id=\"超过经理收入的员工\">181. 超过经理收入的员工</h1>\n<p>表自链接就行了。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tl.NAME AS Employee \nFROM\n\tEmployee l\n\tINNER JOIN Employee r ON l.managerId = r.id \nWHERE\n\tl.salary &gt; r.salary</code></pre></div>\n<h1 id=\"查找重复的电子邮箱\">182. 查找重复的电子邮箱</h1>\n<p>自链接</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT DISTINCT\n\tt1.Email \nFROM\n\tPerson t1\n\tJOIN Person t2 ON t1.Email = t2.Email \n\tAND t1.Id != t2.Id</code></pre></div>\n<p>子表查询</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tEmail \nFROM\n\t( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec \nWHERE\n\ttec.ec &gt; 1</code></pre></div>\n<h1 id=\"从不订购的客户\">183. 从不订购的客户</h1>\n<p>子表查询</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tn.NAME AS Customers \nFROM\n\t( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n \nWHERE\n\tn.id IS NULL</code></pre></div>\n<p>子表查询和<code>NOT IN</code>语句</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\tCustomers.Name AS Customers \nFROM\n\tCustomers \nWHERE\n\tCustomers.Id NOT IN ( SELECT CustomerId FROM Orders )</code></pre></div>\n<p>右链接</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs mysql\">SELECT\n\ta.NAME AS Customers \nFROM\n\tCustomers a\n\tLEFT JOIN Orders b ON a.Id = b.CustomerId \nWHERE\n\tb.CustomerId IS NULL</code></pre></div>\n","site":{"data":{}},"wordcount":1240,"excerpt":"","more":"<h1 id=\"excel表列名称\">168. Excel表列名称</h1>\n<p>此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面<code>temp = (columnNumber-1)%26+1</code>这行代码。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convertToTitle</span>(<span class=\"hljs-params\">self, columnNumber: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">while</span> columnNumber != <span class=\"hljs-number\">0</span>:\n            temp = (columnNumber-<span class=\"hljs-number\">1</span>)%<span class=\"hljs-number\">26</span>+<span class=\"hljs-number\">1</span>\n            res += <span class=\"hljs-built_in\">chr</span>(temp+<span class=\"hljs-number\">64</span>)\n            columnNumber = (columnNumber-temp)//<span class=\"hljs-number\">26</span>\n        <span class=\"hljs-keyword\">return</span> res[::-<span class=\"hljs-number\">1</span>]</code></pre>\n<h1 id=\"excel-表列序号\">171. Excel 表列序号</h1>\n<p>与上题差不多，上题的逆向。本质上还是个进制转换。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">titleToNumber</span>(<span class=\"hljs-params\">self, columnTitle: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        n = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> columnTitle[::-<span class=\"hljs-number\">1</span>]:\n            res += (<span class=\"hljs-built_in\">ord</span>(i)-<span class=\"hljs-number\">64</span>)*n\n            n *= <span class=\"hljs-number\">26</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"组合两个表\">175. 组合两个表</h1>\n<p>依题意做一个简单左链接就行了。</p>\n<pre><code class=\"hljs mysql\">SELECT\n\tt1.firstName,\n\tt1.lastName,\n\tt2.city,\n\tt2.state \nFROM\n\tPerson t1\n\tLEFT JOIN Address t2 ON t1.personId = t2.personId</code></pre>\n<h1 id=\"超过经理收入的员工\">181. 超过经理收入的员工</h1>\n<p>表自链接就行了。</p>\n<pre><code class=\"hljs mysql\">SELECT\n\tl.NAME AS Employee \nFROM\n\tEmployee l\n\tINNER JOIN Employee r ON l.managerId = r.id \nWHERE\n\tl.salary &gt; r.salary</code></pre>\n<h1 id=\"查找重复的电子邮箱\">182. 查找重复的电子邮箱</h1>\n<p>自链接</p>\n<pre><code class=\"hljs mysql\">SELECT DISTINCT\n\tt1.Email \nFROM\n\tPerson t1\n\tJOIN Person t2 ON t1.Email = t2.Email \n\tAND t1.Id != t2.Id</code></pre>\n<p>子表查询</p>\n<pre><code class=\"hljs mysql\">SELECT\n\tEmail \nFROM\n\t( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec \nWHERE\n\ttec.ec &gt; 1</code></pre>\n<h1 id=\"从不订购的客户\">183. 从不订购的客户</h1>\n<p>子表查询</p>\n<pre><code class=\"hljs mysql\">SELECT\n\tn.NAME AS Customers \nFROM\n\t( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n \nWHERE\n\tn.id IS NULL</code></pre>\n<p>子表查询和<code>NOT IN</code>语句</p>\n<pre><code class=\"hljs mysql\">SELECT\n\tCustomers.Name AS Customers \nFROM\n\tCustomers \nWHERE\n\tCustomers.Id NOT IN ( SELECT CustomerId FROM Orders )</code></pre>\n<p>右链接</p>\n<pre><code class=\"hljs mysql\">SELECT\n\ta.NAME AS Customers \nFROM\n\tCustomers a\n\tLEFT JOIN Orders b ON a.Id = b.CustomerId \nWHERE\n\tb.CustomerId IS NULL</code></pre>\n"},{"title":"LeetCode 191","date":"2022-05-19T04:00:00.000Z","_content":"\n# 191. 位1的个数\n\n首先来个循环检查每一位是否为1。\n\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        bin_str = bin(n)[2:]\n        res = 0\n        for i in bin_str:\n            if i == '1':\n                res += 1\n        return res\n```\n\n当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1， python 的右移运算符`>>`就是高位补0，低位舍去。所以移动32次，就可以得到结果。\n\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            res += 1\n            n >>= 1\n        return res\n```\n\n但是在位运算里，还有个神奇的做法，可以通过`n&(n-1)`把二进制中最后一个1改写成0。\n\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            res += 1\n            n &= n-1\n        return res\n```\n\n参考[【负雪明烛】详解位运算，附本题躲坑指南 - 位1的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/)\n","source":"_posts/leetcode20220519.md","raw":"---\ntitle: LeetCode 191\ndate: 2022-05-19 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, bit]\n---\n\n# 191. 位1的个数\n\n首先来个循环检查每一位是否为1。\n\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        bin_str = bin(n)[2:]\n        res = 0\n        for i in bin_str:\n            if i == '1':\n                res += 1\n        return res\n```\n\n当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1， python 的右移运算符`>>`就是高位补0，低位舍去。所以移动32次，就可以得到结果。\n\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            res += 1\n            n >>= 1\n        return res\n```\n\n但是在位运算里，还有个神奇的做法，可以通过`n&(n-1)`把二进制中最后一个1改写成0。\n\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            res += 1\n            n &= n-1\n        return res\n```\n\n参考[【负雪明烛】详解位运算，附本题躲坑指南 - 位1的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/)\n","slug":"leetcode20220519","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fo000r142p5vzmgi25","content":"<h1 id=\"位1的个数\">191. 位1的个数</h1>\n<p>首先来个循环检查每一位是否为1。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingWeight</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        bin_str = <span class=\"hljs-built_in\">bin</span>(n)[<span class=\"hljs-number\">2</span>:]\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> bin_str:\n            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-string\">&#x27;1&#x27;</span>:\n                res += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<p>当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1，\npython\n的右移运算符<code>&gt;&gt;</code>就是高位补0，低位舍去。所以移动32次，就可以得到结果。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingWeight</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> n:\n            res += <span class=\"hljs-number\">1</span>\n            n &gt;&gt;= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<p>但是在位运算里，还有个神奇的做法，可以通过<code>n&amp;(n-1)</code>把二进制中最后一个1改写成0。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingWeight</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> n:\n            res += <span class=\"hljs-number\">1</span>\n            n &amp;= n-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<p>参考<a\nhref=\"https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/\">【负雪明烛】详解位运算，附本题躲坑指南\n- 位1的个数 - 力扣（LeetCode）</a></p>\n","site":{"data":{}},"wordcount":504,"excerpt":"","more":"<h1 id=\"位1的个数\">191. 位1的个数</h1>\n<p>首先来个循环检查每一位是否为1。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingWeight</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        bin_str = <span class=\"hljs-built_in\">bin</span>(n)[<span class=\"hljs-number\">2</span>:]\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> bin_str:\n            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-string\">&#x27;1&#x27;</span>:\n                res += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<p>当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1，\npython\n的右移运算符<code>&gt;&gt;</code>就是高位补0，低位舍去。所以移动32次，就可以得到结果。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingWeight</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> n:\n            res += <span class=\"hljs-number\">1</span>\n            n &gt;&gt;= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<p>但是在位运算里，还有个神奇的做法，可以通过<code>n&amp;(n-1)</code>把二进制中最后一个1改写成0。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingWeight</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> n:\n            res += <span class=\"hljs-number\">1</span>\n            n &amp;= n-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<p>参考<a\nhref=\"https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/\">【负雪明烛】详解位运算，附本题躲坑指南\n- 位1的个数 - 力扣（LeetCode）</a></p>\n"},{"title":"LeetCode 202","date":"2022-05-24T04:00:00.000Z","_content":"\n# 202. 快乐数\n\n首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是`False`，否则就是`True`。\n\n```python\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        if n == 1 or n == 7:\n            return True\n        res = n\n        while res>=10:\n            temp = str(res)\n            res = 0\n            for i in temp:\n                res += int(i)**2\n            if res == 1 or res == 7:\n                return True\n        return False\n```\n\n也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了`hashset`，当这次运算结果出现在`set`里时，说明循环已经开始了，否则我们把这次结果加入`set`。\n\n```python\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        hashset = {n}\n        while n!=1:\n            temp = str(n)\n            n = 0\n            for i in temp:\n                n += int(i)**2\n            if n in hashset:\n                return False\n            else:\n                hashset.add(n)\n        return True\n```\n\n","source":"_posts/leetcode20220524.md","raw":"---\ntitle: LeetCode 202\ndate: 2022-05-24 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 202. 快乐数\n\n首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是`False`，否则就是`True`。\n\n```python\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        if n == 1 or n == 7:\n            return True\n        res = n\n        while res>=10:\n            temp = str(res)\n            res = 0\n            for i in temp:\n                res += int(i)**2\n            if res == 1 or res == 7:\n                return True\n        return False\n```\n\n也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了`hashset`，当这次运算结果出现在`set`里时，说明循环已经开始了，否则我们把这次结果加入`set`。\n\n```python\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        hashset = {n}\n        while n!=1:\n            temp = str(n)\n            n = 0\n            for i in temp:\n                n += int(i)**2\n            if n in hashset:\n                return False\n            else:\n                hashset.add(n)\n        return True\n```\n\n","slug":"leetcode20220524","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fp000u142p7lh357qm","content":"<h1 id=\"快乐数\">202. 快乐数</h1>\n<p>首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是<code>False</code>，否则就是<code>True</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isHappy</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> n == <span class=\"hljs-number\">7</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        res = n\n        <span class=\"hljs-keyword\">while</span> res&gt;=<span class=\"hljs-number\">10</span>:\n            temp = <span class=\"hljs-built_in\">str</span>(res)\n            res = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> temp:\n                res += <span class=\"hljs-built_in\">int</span>(i)**<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> res == <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> res == <span class=\"hljs-number\">7</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n<p>也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了<code>hashset</code>，当这次运算结果出现在<code>set</code>里时，说明循环已经开始了，否则我们把这次结果加入<code>set</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isHappy</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashset = &#123;n&#125;\n        <span class=\"hljs-keyword\">while</span> n!=<span class=\"hljs-number\">1</span>:\n            temp = <span class=\"hljs-built_in\">str</span>(n)\n            n = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> temp:\n                n += <span class=\"hljs-built_in\">int</span>(i)**<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> n <span class=\"hljs-keyword\">in</span> hashset:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashset.add(n)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n","site":{"data":{}},"wordcount":519,"excerpt":"","more":"<h1 id=\"快乐数\">202. 快乐数</h1>\n<p>首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是<code>False</code>，否则就是<code>True</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isHappy</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> n == <span class=\"hljs-number\">7</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        res = n\n        <span class=\"hljs-keyword\">while</span> res&gt;=<span class=\"hljs-number\">10</span>:\n            temp = <span class=\"hljs-built_in\">str</span>(res)\n            res = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> temp:\n                res += <span class=\"hljs-built_in\">int</span>(i)**<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> res == <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> res == <span class=\"hljs-number\">7</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre>\n<p>也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了<code>hashset</code>，当这次运算结果出现在<code>set</code>里时，说明循环已经开始了，否则我们把这次结果加入<code>set</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isHappy</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashset = &#123;n&#125;\n        <span class=\"hljs-keyword\">while</span> n!=<span class=\"hljs-number\">1</span>:\n            temp = <span class=\"hljs-built_in\">str</span>(n)\n            n = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> temp:\n                n += <span class=\"hljs-built_in\">int</span>(i)**<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> n <span class=\"hljs-keyword\">in</span> hashset:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashset.add(n)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n"},{"title":"LeetCode 203 205","date":"2022-05-25T04:00:00.000Z","_content":"\n# 203. 移除链表元素\n\n一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        res = ListNode()\n        res.next = head\n        node = res\n        while node.next:\n            if node.next.val == val:\n                node.next = node.next.next\n            else:\n                node = node.next\n        return res.next\n```\n\n也可以先对头节点进行处理，先保证头节点不是要删除的节点。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        while head and head.val == val:\n            head = head.next\n        node = head\n        if not node:\n            return None\n        while node.next:\n            if node.next.val == val:\n                node.next = node.next.next\n            else:\n                node = node.next\n        return head\n```\n\n# 205. 同构字符串\n\n分别建立正向映射关系`dict_forward`和逆向映射关系`dict_backward`，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：\n\n> \"bbbaaaba\" \n>\n> \"aaabbbba\"\n\n这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。\n\n```python\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        dict_forward = {}\n        dict_backward = {}\n        for i in range(len(s)):\n            if s[i] not in dict_forward:\n                dict_forward[s[i]] = t[i]\n            dict_backward[t[i]] = s[i]\n        if len(dict_forward) != len(dict_backward):\n            return False\n        for k,v in dict_forward.items():\n            if dict_backward[v] != k:\n                return False\n        return True\n```\n\n","source":"_posts/leetcode20220525.md","raw":"---\ntitle: LeetCode 203 205\ndate: 2022-05-25 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, linked list, hash]\n---\n\n# 203. 移除链表元素\n\n一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        res = ListNode()\n        res.next = head\n        node = res\n        while node.next:\n            if node.next.val == val:\n                node.next = node.next.next\n            else:\n                node = node.next\n        return res.next\n```\n\n也可以先对头节点进行处理，先保证头节点不是要删除的节点。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        while head and head.val == val:\n            head = head.next\n        node = head\n        if not node:\n            return None\n        while node.next:\n            if node.next.val == val:\n                node.next = node.next.next\n            else:\n                node = node.next\n        return head\n```\n\n# 205. 同构字符串\n\n分别建立正向映射关系`dict_forward`和逆向映射关系`dict_backward`，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：\n\n> \"bbbaaaba\" \n>\n> \"aaabbbba\"\n\n这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。\n\n```python\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        dict_forward = {}\n        dict_backward = {}\n        for i in range(len(s)):\n            if s[i] not in dict_forward:\n                dict_forward[s[i]] = t[i]\n            dict_backward[t[i]] = s[i]\n        if len(dict_forward) != len(dict_backward):\n            return False\n        for k,v in dict_forward.items():\n            if dict_backward[v] != k:\n                return False\n        return True\n```\n\n","slug":"leetcode20220525","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fq000y142pg2oibxzm","content":"<h1 id=\"移除链表元素\">203. 移除链表元素</h1>\n<p>一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># Definition for singly-linked list.</span>\n<span class=\"hljs-comment\"># class ListNode:</span>\n<span class=\"hljs-comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"hljs-comment\">#         self.val = val</span>\n<span class=\"hljs-comment\">#         self.next = next</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeElements</span>(<span class=\"hljs-params\">self, head: ListNode, val: <span class=\"hljs-built_in\">int</span></span>) -&gt; ListNode:\n        res = ListNode()\n        res.<span class=\"hljs-built_in\">next</span> = head\n        node = res\n        <span class=\"hljs-keyword\">while</span> node.<span class=\"hljs-built_in\">next</span>:\n            <span class=\"hljs-keyword\">if</span> node.<span class=\"hljs-built_in\">next</span>.val == val:\n                node.<span class=\"hljs-built_in\">next</span> = node.<span class=\"hljs-built_in\">next</span>.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">next</span></code></pre></div>\n<p>也可以先对头节点进行处理，先保证头节点不是要删除的节点。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># Definition for singly-linked list.</span>\n<span class=\"hljs-comment\"># class ListNode:</span>\n<span class=\"hljs-comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"hljs-comment\">#         self.val = val</span>\n<span class=\"hljs-comment\">#         self.next = next</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeElements</span>(<span class=\"hljs-params\">self, head: ListNode, val: <span class=\"hljs-built_in\">int</span></span>) -&gt; ListNode:\n        <span class=\"hljs-keyword\">while</span> head <span class=\"hljs-keyword\">and</span> head.val == val:\n            head = head.<span class=\"hljs-built_in\">next</span>\n        node = head\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> node:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>\n        <span class=\"hljs-keyword\">while</span> node.<span class=\"hljs-built_in\">next</span>:\n            <span class=\"hljs-keyword\">if</span> node.<span class=\"hljs-built_in\">next</span>.val == val:\n                node.<span class=\"hljs-built_in\">next</span> = node.<span class=\"hljs-built_in\">next</span>.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> head</code></pre></div>\n<h1 id=\"同构字符串\">205. 同构字符串</h1>\n<p>分别建立正向映射关系<code>dict_forward</code>和逆向映射关系<code>dict_backward</code>，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：</p>\n<blockquote>\n<p>\"bbbaaaba\"</p>\n<p>\"aaabbbba\"</p>\n</blockquote>\n<p>这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isIsomorphic</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        dict_forward = &#123;&#125;\n        dict_backward = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)):\n            <span class=\"hljs-keyword\">if</span> s[i] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict_forward:\n                dict_forward[s[i]] = t[i]\n            dict_backward[t[i]] = s[i]\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(dict_forward) != <span class=\"hljs-built_in\">len</span>(dict_backward):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> dict_forward.items():\n            <span class=\"hljs-keyword\">if</span> dict_backward[v] != k:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n","site":{"data":{}},"wordcount":1236,"excerpt":"","more":"<h1 id=\"移除链表元素\">203. 移除链表元素</h1>\n<p>一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-comment\"># Definition for singly-linked list.</span>\n<span class=\"hljs-comment\"># class ListNode:</span>\n<span class=\"hljs-comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"hljs-comment\">#         self.val = val</span>\n<span class=\"hljs-comment\">#         self.next = next</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeElements</span>(<span class=\"hljs-params\">self, head: ListNode, val: <span class=\"hljs-built_in\">int</span></span>) -&gt; ListNode:\n        res = ListNode()\n        res.<span class=\"hljs-built_in\">next</span> = head\n        node = res\n        <span class=\"hljs-keyword\">while</span> node.<span class=\"hljs-built_in\">next</span>:\n            <span class=\"hljs-keyword\">if</span> node.<span class=\"hljs-built_in\">next</span>.val == val:\n                node.<span class=\"hljs-built_in\">next</span> = node.<span class=\"hljs-built_in\">next</span>.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">next</span></code></pre>\n<p>也可以先对头节点进行处理，先保证头节点不是要删除的节点。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-comment\"># Definition for singly-linked list.</span>\n<span class=\"hljs-comment\"># class ListNode:</span>\n<span class=\"hljs-comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"hljs-comment\">#         self.val = val</span>\n<span class=\"hljs-comment\">#         self.next = next</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">removeElements</span>(<span class=\"hljs-params\">self, head: ListNode, val: <span class=\"hljs-built_in\">int</span></span>) -&gt; ListNode:\n        <span class=\"hljs-keyword\">while</span> head <span class=\"hljs-keyword\">and</span> head.val == val:\n            head = head.<span class=\"hljs-built_in\">next</span>\n        node = head\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> node:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>\n        <span class=\"hljs-keyword\">while</span> node.<span class=\"hljs-built_in\">next</span>:\n            <span class=\"hljs-keyword\">if</span> node.<span class=\"hljs-built_in\">next</span>.val == val:\n                node.<span class=\"hljs-built_in\">next</span> = node.<span class=\"hljs-built_in\">next</span>.<span class=\"hljs-built_in\">next</span>\n            <span class=\"hljs-keyword\">else</span>:\n                node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> head</code></pre>\n<h1 id=\"同构字符串\">205. 同构字符串</h1>\n<p>分别建立正向映射关系<code>dict_forward</code>和逆向映射关系<code>dict_backward</code>，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：</p>\n<blockquote>\n<p>\"bbbaaaba\"</p>\n<p>\"aaabbbba\"</p>\n</blockquote>\n<p>这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isIsomorphic</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        dict_forward = &#123;&#125;\n        dict_backward = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)):\n            <span class=\"hljs-keyword\">if</span> s[i] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict_forward:\n                dict_forward[s[i]] = t[i]\n            dict_backward[t[i]] = s[i]\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(dict_forward) != <span class=\"hljs-built_in\">len</span>(dict_backward):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> dict_forward.items():\n            <span class=\"hljs-keyword\">if</span> dict_backward[v] != k:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n"},{"title":"LeetCode 206","date":"2022-05-26T04:00:00.000Z","_content":"\n# 206. 反转链表\n\n常见的用栈反转。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        stack = []\n        node = head\n        while node:\n            stack.append(node.val)\n            node = node.next\n        res = ListNode()\n        node = res\n        while stack:\n            node.next = ListNode(stack.pop())\n            node = node.next\n        return res.next\n```\n\n","source":"_posts/leetcode20220526.md","raw":"---\ntitle: LeetCode 206\ndate: 2022-05-26 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, stack]\n---\n\n# 206. 反转链表\n\n常见的用栈反转。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        stack = []\n        node = head\n        while node:\n            stack.append(node.val)\n            node = node.next\n        res = ListNode()\n        node = res\n        while stack:\n            node.next = ListNode(stack.pop())\n            node = node.next\n        return res.next\n```\n\n","slug":"leetcode20220526","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fr0012142pb2f447tz","content":"<h1 id=\"反转链表\">206. 反转链表</h1>\n<p>常见的用栈反转。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># Definition for singly-linked list.</span>\n<span class=\"hljs-comment\"># class ListNode:</span>\n<span class=\"hljs-comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"hljs-comment\">#         self.val = val</span>\n<span class=\"hljs-comment\">#         self.next = next</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseList</span>(<span class=\"hljs-params\">self, head: ListNode</span>) -&gt; ListNode:\n        stack = []\n        node = head\n        <span class=\"hljs-keyword\">while</span> node:\n            stack.append(node.val)\n            node = node.<span class=\"hljs-built_in\">next</span>\n        res = ListNode()\n        node = res\n        <span class=\"hljs-keyword\">while</span> stack:\n            node.<span class=\"hljs-built_in\">next</span> = ListNode(stack.pop())\n            node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">next</span></code></pre></div>\n","site":{"data":{}},"wordcount":343,"excerpt":"","more":"<h1 id=\"反转链表\">206. 反转链表</h1>\n<p>常见的用栈反转。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-comment\"># Definition for singly-linked list.</span>\n<span class=\"hljs-comment\"># class ListNode:</span>\n<span class=\"hljs-comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"hljs-comment\">#         self.val = val</span>\n<span class=\"hljs-comment\">#         self.next = next</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseList</span>(<span class=\"hljs-params\">self, head: ListNode</span>) -&gt; ListNode:\n        stack = []\n        node = head\n        <span class=\"hljs-keyword\">while</span> node:\n            stack.append(node.val)\n            node = node.<span class=\"hljs-built_in\">next</span>\n        res = ListNode()\n        node = res\n        <span class=\"hljs-keyword\">while</span> stack:\n            node.<span class=\"hljs-built_in\">next</span> = ListNode(stack.pop())\n            node = node.<span class=\"hljs-built_in\">next</span>\n        <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">next</span></code></pre>\n"},{"title":"LeetCode 217 219","date":"2022-05-27T04:00:00.000Z","_content":"\n# 217. 存在重复元素\n\n简单`hash`，建立一个`set`，遍历数组，如果元素不在里面就添加，如果在里面就返回`True`。\n\n```python\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        hashset = set('')\n        for i in nums:\n            if i not in hashset:\n                hashset.add(i)\n            else:\n                return True\n        return False\n```\n\n# 219. 存在重复元素 II\n\n这次涉及到元素还有它的下标，也是简单`hash`，不过要建立的是`dict`，`dict`的`key`是元素值，`dict`的`value`是元素下标。\n\n```python\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        hashmap = {}\n        for n,v in enumerate(nums):\n            if v not in hashmap:\n                hashmap[v] = n\n            else:\n                if n-hashmap[v] <= k:\n                    return True\n                else:\n                    hashmap[v] = n\n        return False\n```\n\n","source":"_posts/leetcode20220527.md","raw":"---\ntitle: LeetCode 217 219\ndate: 2022-05-27 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 217. 存在重复元素\n\n简单`hash`，建立一个`set`，遍历数组，如果元素不在里面就添加，如果在里面就返回`True`。\n\n```python\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        hashset = set('')\n        for i in nums:\n            if i not in hashset:\n                hashset.add(i)\n            else:\n                return True\n        return False\n```\n\n# 219. 存在重复元素 II\n\n这次涉及到元素还有它的下标，也是简单`hash`，不过要建立的是`dict`，`dict`的`key`是元素值，`dict`的`value`是元素下标。\n\n```python\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        hashmap = {}\n        for n,v in enumerate(nums):\n            if v not in hashmap:\n                hashmap[v] = n\n            else:\n                if n-hashmap[v] <= k:\n                    return True\n                else:\n                    hashmap[v] = n\n        return False\n```\n\n","slug":"leetcode20220527","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fs0015142pheqmdiox","content":"<h1 id=\"存在重复元素\">217. 存在重复元素</h1>\n<p>简单<code>hash</code>，建立一个<code>set</code>，遍历数组，如果元素不在里面就添加，如果在里面就返回<code>True</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">containsDuplicate</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset:\n                hashset.add(i)\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n<h1 id=\"存在重复元素-ii\">219. 存在重复元素 II</h1>\n<p>这次涉及到元素还有它的下标，也是简单<code>hash</code>，不过要建立的是<code>dict</code>，<code>dict</code>的<code>key</code>是元素值，<code>dict</code>的<code>value</code>是元素下标。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">containsNearbyDuplicate</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> n,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums):\n            <span class=\"hljs-keyword\">if</span> v <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[v] = n\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> n-hashmap[v] &lt;= k:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    hashmap[v] = n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n","site":{"data":{}},"wordcount":501,"excerpt":"","more":"<h1 id=\"存在重复元素\">217. 存在重复元素</h1>\n<p>简单<code>hash</code>，建立一个<code>set</code>，遍历数组，如果元素不在里面就添加，如果在里面就返回<code>True</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">containsDuplicate</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset:\n                hashset.add(i)\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre>\n<h1 id=\"存在重复元素-ii\">219. 存在重复元素 II</h1>\n<p>这次涉及到元素还有它的下标，也是简单<code>hash</code>，不过要建立的是<code>dict</code>，<code>dict</code>的<code>key</code>是元素值，<code>dict</code>的<code>value</code>是元素下标。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">containsNearbyDuplicate</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> n,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums):\n            <span class=\"hljs-keyword\">if</span> v <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[v] = n\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> n-hashmap[v] &lt;= k:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    hashmap[v] = n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre>\n"},{"title":"LeetCode 228 231","date":"2022-05-29T04:00:00.000Z","_content":"\n# 228. 汇总区间\n\n双指针 `start` 和 `end` ，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。\n\n```python\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        res = []\n        start = 0\n        length = len(nums)\n        while start < length:\n            end = start\n            while end < length-1 and (nums[end+1]-nums[end])==1:\n                end += 1\n            if start == end:\n                res.append(str(nums[start]))\n            else:\n                res.append(str(nums[start])+'->'+str(nums[end]))\n            start = end+1\n        return res\n```\n\n# 231. 2 的幂\n\n先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c 的幂的最大值设为 $x$ ，必有 $x\\%c=0$ ，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是  `2<<30` ，就可以写成如下代码。\n\n```python\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return (2<<30)%n == 0 if n > 0 else False\n```\n\n 当然正规军的做法是位运算。首先 2 的幂的二进制表示有个规律就是所有位只有一个 1 ，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2 的幂。这里有个小技巧[LeetCode 191](https://movisli.github.io/posts/2022/05/19/Solution.html) ，`n & (n - 1) ` 可以将最后一个 1 去掉，既然只有一个 1 所以去掉之后就没有了。\n\n```python\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and n & (n - 1) == 0\n```\n\n","source":"_posts/leetcode20220529.md","raw":"---\ntitle: LeetCode 228 231\ndate: 2022-05-29 12:00:00\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, point, bit]\n---\n\n# 228. 汇总区间\n\n双指针 `start` 和 `end` ，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。\n\n```python\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        res = []\n        start = 0\n        length = len(nums)\n        while start < length:\n            end = start\n            while end < length-1 and (nums[end+1]-nums[end])==1:\n                end += 1\n            if start == end:\n                res.append(str(nums[start]))\n            else:\n                res.append(str(nums[start])+'->'+str(nums[end]))\n            start = end+1\n        return res\n```\n\n# 231. 2 的幂\n\n先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c 的幂的最大值设为 $x$ ，必有 $x\\%c=0$ ，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是  `2<<30` ，就可以写成如下代码。\n\n```python\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return (2<<30)%n == 0 if n > 0 else False\n```\n\n 当然正规军的做法是位运算。首先 2 的幂的二进制表示有个规律就是所有位只有一个 1 ，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2 的幂。这里有个小技巧[LeetCode 191](https://movisli.github.io/posts/2022/05/19/Solution.html) ，`n & (n - 1) ` 可以将最后一个 1 去掉，既然只有一个 1 所以去掉之后就没有了。\n\n```python\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and n & (n - 1) == 0\n```\n\n","slug":"leetcode20220529","published":1,"updated":"2022-08-11T15:43:07.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fu0018142p3643fh9y","content":"<h1 id=\"汇总区间\">228. 汇总区间</h1>\n<p>双指针 <code>start</code> 和 <code>end</code>\n，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">summaryRanges</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        start = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> start &lt; length:\n            end = start\n            <span class=\"hljs-keyword\">while</span> end &lt; length-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> (nums[end+<span class=\"hljs-number\">1</span>]-nums[end])==<span class=\"hljs-number\">1</span>:\n                end += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> start == end:\n                res.append(<span class=\"hljs-built_in\">str</span>(nums[start]))\n            <span class=\"hljs-keyword\">else</span>:\n                res.append(<span class=\"hljs-built_in\">str</span>(nums[start])+<span class=\"hljs-string\">&#x27;-&gt;&#x27;</span>+<span class=\"hljs-built_in\">str</span>(nums[end]))\n            start = end+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"的幂\">231. 2 的幂</h1>\n<p>先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c\n的幂的最大值设为 <span class=\"math inline\">\\(x\\)</span> ，必有 <span\nclass=\"math inline\">\\(x\\%c=0\\)</span>\n，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是\n<code>2&lt;&lt;30</code> ，就可以写成如下代码。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfTwo</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">2</span>&lt;&lt;<span class=\"hljs-number\">30</span>)%n == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n<p>当然正规军的做法是位运算。首先 2\n的幂的二进制表示有个规律就是所有位只有一个 1\n，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2\n的幂。这里有个小技巧<a\nhref=\"https://movisli.github.io/posts/2022/05/19/Solution.html\">LeetCode\n191</a> ，<code>n &amp; (n - 1)</code> 可以将最后一个 1\n去掉，既然只有一个 1 所以去掉之后就没有了。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfTwo</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> n &amp; (n - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">0</span></code></pre></div>\n","site":{"data":{}},"wordcount":783,"excerpt":"","more":"<h1 id=\"汇总区间\">228. 汇总区间</h1>\n<p>双指针 <code>start</code> 和 <code>end</code>\n，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">summaryRanges</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        start = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> start &lt; length:\n            end = start\n            <span class=\"hljs-keyword\">while</span> end &lt; length-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> (nums[end+<span class=\"hljs-number\">1</span>]-nums[end])==<span class=\"hljs-number\">1</span>:\n                end += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> start == end:\n                res.append(<span class=\"hljs-built_in\">str</span>(nums[start]))\n            <span class=\"hljs-keyword\">else</span>:\n                res.append(<span class=\"hljs-built_in\">str</span>(nums[start])+<span class=\"hljs-string\">&#x27;-&gt;&#x27;</span>+<span class=\"hljs-built_in\">str</span>(nums[end]))\n            start = end+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"的幂\">231. 2 的幂</h1>\n<p>先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c\n的幂的最大值设为 <span class=\"math inline\">\\(x\\)</span> ，必有 <span\nclass=\"math inline\">\\(x\\%c=0\\)</span>\n，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是\n<code>2&lt;&lt;30</code> ，就可以写成如下代码。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfTwo</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">2</span>&lt;&lt;<span class=\"hljs-number\">30</span>)%n == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-literal\">False</span></code></pre>\n<p>当然正规军的做法是位运算。首先 2\n的幂的二进制表示有个规律就是所有位只有一个 1\n，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2\n的幂。这里有个小技巧<a\nhref=\"https://movisli.github.io/posts/2022/05/19/Solution.html\">LeetCode\n191</a> ，<code>n &amp; (n - 1)</code> 可以将最后一个 1\n去掉，既然只有一个 1 所以去掉之后就没有了。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfTwo</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> n &amp; (n - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">0</span></code></pre>\n"},{"title":"LeetCode 242","date":"2022-06-01T14:41:34.000Z","_content":"\n# 242. 有效的字母异位词\n\n排序，比较两个字符串排序后是否相同。\n\n```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        import operator\n        return operator.eq(sorted(list(s)), sorted(list(t)))\n```\n\n哈希，用`dict`进行计数。比上一种快。\n\n```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        hashmap = {}\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for i in t:\n            if i not in hashmap:\n                return False\n            else:\n                hashmap[i] -= 1\n        for v in hashmap.values():\n            if v != 0:\n                return False\n        return True\n```\n\n","source":"_posts/leetcode20220601.md","raw":"---\ntitle: LeetCode 242\ndate: 2022-06-01 22:41:34\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 242. 有效的字母异位词\n\n排序，比较两个字符串排序后是否相同。\n\n```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        import operator\n        return operator.eq(sorted(list(s)), sorted(list(t)))\n```\n\n哈希，用`dict`进行计数。比上一种快。\n\n```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        hashmap = {}\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for i in t:\n            if i not in hashmap:\n                return False\n            else:\n                hashmap[i] -= 1\n        for v in hashmap.values():\n            if v != 0:\n                return False\n        return True\n```\n\n","slug":"leetcode20220601","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fv001b142p7vvjc83p","content":"<h1 id=\"有效的字母异位词\">242. 有效的字母异位词</h1>\n<p>排序，比较两个字符串排序后是否相同。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isAnagram</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">import</span> operator\n        <span class=\"hljs-keyword\">return</span> operator.eq(<span class=\"hljs-built_in\">sorted</span>(<span class=\"hljs-built_in\">list</span>(s)), <span class=\"hljs-built_in\">sorted</span>(<span class=\"hljs-built_in\">list</span>(t)))</code></pre></div>\n<p>哈希，用<code>dict</code>进行计数。比上一种快。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isAnagram</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> t:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> hashmap.values():\n            <span class=\"hljs-keyword\">if</span> v != <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n","site":{"data":{}},"wordcount":399,"excerpt":"","more":"<h1 id=\"有效的字母异位词\">242. 有效的字母异位词</h1>\n<p>排序，比较两个字符串排序后是否相同。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isAnagram</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">import</span> operator\n        <span class=\"hljs-keyword\">return</span> operator.eq(<span class=\"hljs-built_in\">sorted</span>(<span class=\"hljs-built_in\">list</span>(s)), <span class=\"hljs-built_in\">sorted</span>(<span class=\"hljs-built_in\">list</span>(t)))</code></pre>\n<p>哈希，用<code>dict</code>进行计数。比上一种快。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isAnagram</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> t:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> hashmap.values():\n            <span class=\"hljs-keyword\">if</span> v != <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n"},{"title":"LeetCode 258","date":"2022-06-03T17:28:10.000Z","_content":"\n# 258. 各位相加\n\n简单循环，模拟题目中描述的过程逐位相加直到`num`小于10。\n\n```python\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        while num >= 10:\n            num_str = str(num)\n            num = sum([int(i) for i in num_str])\n        return num\n```\n\n但是题目中提到了有`O(1)`时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：\n\n```text\n9->9\n99->18->9\n999->27->9\n...\n假设\n9...9(n位)->9\n那么\n9...9(n+1位)->9(n+1)=9*n+9=18->9\n所以假设成立\n```\n\n通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：\n$$\n\\begin{cases}\n\tresult=0,\\ when\\ n=0 \\\\\n\tresult=9,\\ when\\ n\\%9=0\\ and\\ n\\neq 0 \\\\\n\tresult=n\\%9,\\ when\\ n\\%9\\neq0\\\\\n\\end{cases}\n$$\n\n```python\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        return 0 if num==0 else 9 if num%9==0 else num%9\n```\n\n","source":"_posts/leetcode20220603.md","raw":"---\ntitle: LeetCode 258\ndate: 2022-06-04 01:28:10\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, recursion, math]\n---\n\n# 258. 各位相加\n\n简单循环，模拟题目中描述的过程逐位相加直到`num`小于10。\n\n```python\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        while num >= 10:\n            num_str = str(num)\n            num = sum([int(i) for i in num_str])\n        return num\n```\n\n但是题目中提到了有`O(1)`时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：\n\n```text\n9->9\n99->18->9\n999->27->9\n...\n假设\n9...9(n位)->9\n那么\n9...9(n+1位)->9(n+1)=9*n+9=18->9\n所以假设成立\n```\n\n通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：\n$$\n\\begin{cases}\n\tresult=0,\\ when\\ n=0 \\\\\n\tresult=9,\\ when\\ n\\%9=0\\ and\\ n\\neq 0 \\\\\n\tresult=n\\%9,\\ when\\ n\\%9\\neq0\\\\\n\\end{cases}\n$$\n\n```python\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        return 0 if num==0 else 9 if num%9==0 else num%9\n```\n\n","slug":"leetcode20220603","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fw001e142peby5at6x","content":"<h1 id=\"各位相加\">258. 各位相加</h1>\n<p>简单循环，模拟题目中描述的过程逐位相加直到<code>num</code>小于10。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addDigits</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">while</span> num &gt;= <span class=\"hljs-number\">10</span>:\n            num_str = <span class=\"hljs-built_in\">str</span>(num)\n            num = <span class=\"hljs-built_in\">sum</span>([<span class=\"hljs-built_in\">int</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> num_str])\n        <span class=\"hljs-keyword\">return</span> num</code></pre></div>\n<p>但是题目中提到了有<code>O(1)</code>时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs text\">9-&gt;9\n99-&gt;18-&gt;9\n999-&gt;27-&gt;9\n...\n假设\n9...9(n位)-&gt;9\n那么\n9...9(n+1位)-&gt;9(n+1)=9*n+9=18-&gt;9\n所以假设成立</code></pre></div>\n<p>通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：\n<span class=\"math display\">\\[\n\\begin{cases}\n    result=0,\\ when\\ n=0 \\\\\n    result=9,\\ when\\ n\\%9=0\\ and\\ n\\neq 0 \\\\\n    result=n\\%9,\\ when\\ n\\%9\\neq0\\\\\n\\end{cases}\n\\]</span></p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addDigits</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> num==<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-keyword\">if</span> num%<span class=\"hljs-number\">9</span>==<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> num%<span class=\"hljs-number\">9</span></code></pre></div>\n","site":{"data":{}},"wordcount":589,"excerpt":"","more":"<h1 id=\"各位相加\">258. 各位相加</h1>\n<p>简单循环，模拟题目中描述的过程逐位相加直到<code>num</code>小于10。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addDigits</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">while</span> num &gt;= <span class=\"hljs-number\">10</span>:\n            num_str = <span class=\"hljs-built_in\">str</span>(num)\n            num = <span class=\"hljs-built_in\">sum</span>([<span class=\"hljs-built_in\">int</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> num_str])\n        <span class=\"hljs-keyword\">return</span> num</code></pre>\n<p>但是题目中提到了有<code>O(1)</code>时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：</p>\n<pre><code class=\"hljs text\">9-&gt;9\n99-&gt;18-&gt;9\n999-&gt;27-&gt;9\n...\n假设\n9...9(n位)-&gt;9\n那么\n9...9(n+1位)-&gt;9(n+1)=9*n+9=18-&gt;9\n所以假设成立</code></pre>\n<p>通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：\n<span class=\"math display\">\\[\n\\begin{cases}\n    result=0,\\ when\\ n=0 \\\\\n    result=9,\\ when\\ n\\%9=0\\ and\\ n\\neq 0 \\\\\n    result=n\\%9,\\ when\\ n\\%9\\neq0\\\\\n\\end{cases}\n\\]</span></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addDigits</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> num==<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-keyword\">if</span> num%<span class=\"hljs-number\">9</span>==<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> num%<span class=\"hljs-number\">9</span></code></pre>\n"},{"title":"LeetCode 263 268","date":"2022-06-05T07:20:12.000Z","_content":"\n# 263. 丑数\n\n根据丑数的定义，1是第一个丑数，而且质因数只有2、3、5，就有如下代码。优化的地方就是除2可以用位运算。\n\n```python\nclass Solution:\n    def isUgly(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n%2 == 0:\n            n >>= 1\n        while n%3 == 0:\n            n /= 3\n        while n%5 == 0:\n            n /= 5\n        return n == 1\n```\n\n# 268. 丢失的数字\n\n读题可以知道要找的那个数是在`[0, len(nums)]`里的，所以可以用`range`生成器生成一个未丢失的数组来遍历查找是否在`nums`里面确定那个丢失的数。然后发现很慢，很容易可以想到用`set`替代查找范围`list`会快一点。\n\n```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        for i in range(len(nums)+1):\n            if i not in nums_set:\n                return i\n```\n\n当然像这种对应关系很容易想到`enumerate`这个`python`内置的函数，也就是用排序的方法解决。值得注意的就是，如果恰好是`n`是丢失的数字，需要最后返回一下`n`。\n\n```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        for i,v in enumerate(nums):\n            if i != v:\n                return i\n        return len(nums)\n```\n\n","source":"_posts/leetcode20220605.md","raw":"---\ntitle: LeetCode 263 268\ndate: 2022-06-05 15:20:12\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, math, hash, sort]\n---\n\n# 263. 丑数\n\n根据丑数的定义，1是第一个丑数，而且质因数只有2、3、5，就有如下代码。优化的地方就是除2可以用位运算。\n\n```python\nclass Solution:\n    def isUgly(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n%2 == 0:\n            n >>= 1\n        while n%3 == 0:\n            n /= 3\n        while n%5 == 0:\n            n /= 5\n        return n == 1\n```\n\n# 268. 丢失的数字\n\n读题可以知道要找的那个数是在`[0, len(nums)]`里的，所以可以用`range`生成器生成一个未丢失的数组来遍历查找是否在`nums`里面确定那个丢失的数。然后发现很慢，很容易可以想到用`set`替代查找范围`list`会快一点。\n\n```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        for i in range(len(nums)+1):\n            if i not in nums_set:\n                return i\n```\n\n当然像这种对应关系很容易想到`enumerate`这个`python`内置的函数，也就是用排序的方法解决。值得注意的就是，如果恰好是`n`是丢失的数字，需要最后返回一下`n`。\n\n```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        for i,v in enumerate(nums):\n            if i != v:\n                return i\n        return len(nums)\n```\n\n","slug":"leetcode20220605","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fx001h142p6la62cyr","content":"<h1 id=\"丑数\">263. 丑数</h1>\n<p>根据丑数的定义，1是第一个丑数，而且质因数只有2、3、5，就有如下代码。优化的地方就是除2可以用位运算。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isUgly</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">if</span> n &lt;= <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">while</span> n%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n            n &gt;&gt;= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> n%<span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>:\n            n /= <span class=\"hljs-number\">3</span>\n        <span class=\"hljs-keyword\">while</span> n%<span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span>:\n            n /= <span class=\"hljs-number\">5</span>\n        <span class=\"hljs-keyword\">return</span> n == <span class=\"hljs-number\">1</span></code></pre></div>\n<h1 id=\"丢失的数字\">268. 丢失的数字</h1>\n<p>读题可以知道要找的那个数是在<code>[0, len(nums)]</code>里的，所以可以用<code>range</code>生成器生成一个未丢失的数组来遍历查找是否在<code>nums</code>里面确定那个丢失的数。然后发现很慢，很容易可以想到用<code>set</code>替代查找范围<code>list</code>会快一点。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">missingNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        nums_set = <span class=\"hljs-built_in\">set</span>(nums)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)+<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> nums_set:\n                <span class=\"hljs-keyword\">return</span> i</code></pre></div>\n<p>当然像这种对应关系很容易想到<code>enumerate</code>这个<code>python</code>内置的函数，也就是用排序的方法解决。值得注意的就是，如果恰好是<code>n</code>是丢失的数字，需要最后返回一下<code>n</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">missingNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        nums.sort()\n        <span class=\"hljs-keyword\">for</span> i,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums):\n            <span class=\"hljs-keyword\">if</span> i != v:\n                <span class=\"hljs-keyword\">return</span> i\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(nums)</code></pre></div>\n","site":{"data":{}},"wordcount":638,"excerpt":"","more":"<h1 id=\"丑数\">263. 丑数</h1>\n<p>根据丑数的定义，1是第一个丑数，而且质因数只有2、3、5，就有如下代码。优化的地方就是除2可以用位运算。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isUgly</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">if</span> n &lt;= <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">while</span> n%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n            n &gt;&gt;= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> n%<span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>:\n            n /= <span class=\"hljs-number\">3</span>\n        <span class=\"hljs-keyword\">while</span> n%<span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span>:\n            n /= <span class=\"hljs-number\">5</span>\n        <span class=\"hljs-keyword\">return</span> n == <span class=\"hljs-number\">1</span></code></pre>\n<h1 id=\"丢失的数字\">268. 丢失的数字</h1>\n<p>读题可以知道要找的那个数是在<code>[0, len(nums)]</code>里的，所以可以用<code>range</code>生成器生成一个未丢失的数组来遍历查找是否在<code>nums</code>里面确定那个丢失的数。然后发现很慢，很容易可以想到用<code>set</code>替代查找范围<code>list</code>会快一点。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">missingNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        nums_set = <span class=\"hljs-built_in\">set</span>(nums)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)+<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> nums_set:\n                <span class=\"hljs-keyword\">return</span> i</code></pre>\n<p>当然像这种对应关系很容易想到<code>enumerate</code>这个<code>python</code>内置的函数，也就是用排序的方法解决。值得注意的就是，如果恰好是<code>n</code>是丢失的数字，需要最后返回一下<code>n</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">missingNumber</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        nums.sort()\n        <span class=\"hljs-keyword\">for</span> i,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums):\n            <span class=\"hljs-keyword\">if</span> i != v:\n                <span class=\"hljs-keyword\">return</span> i\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(nums)</code></pre>\n"},{"title":"LeetCode 278","date":"2022-06-06T05:09:25.000Z","_content":"\n# 278. 第一个错误的版本\n\n二分查找可以解决，左指针`left`记录当前正确的版本，右指针`right`记录当前错误的版本，所以当`right-left=1`时，`right`所指的就是第一个错误的版本，也就是结果。\n\n```python\nclass Solution:\n    def firstBadVersion(self, n):\n        left = 0\n        right = n\n        mid = (1+n)//2\n        while right-left>1:\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid\n            mid = (left+right)//2\n        return right\n```\n\n","source":"_posts/leetcode20220606.md","raw":"---\ntitle: LeetCode 278\ndate: 2022-06-06 13:09:25\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, binary search, point]\n---\n\n# 278. 第一个错误的版本\n\n二分查找可以解决，左指针`left`记录当前正确的版本，右指针`right`记录当前错误的版本，所以当`right-left=1`时，`right`所指的就是第一个错误的版本，也就是结果。\n\n```python\nclass Solution:\n    def firstBadVersion(self, n):\n        left = 0\n        right = n\n        mid = (1+n)//2\n        while right-left>1:\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid\n            mid = (left+right)//2\n        return right\n```\n\n","slug":"leetcode20220606","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fy001k142p53ou14oe","content":"<h1 id=\"第一个错误的版本\">278. 第一个错误的版本</h1>\n<p>二分查找可以解决，左指针<code>left</code>记录当前正确的版本，右指针<code>right</code>记录当前错误的版本，所以当<code>right-left=1</code>时，<code>right</code>所指的就是第一个错误的版本，也就是结果。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">firstBadVersion</span>(<span class=\"hljs-params\">self, n</span>):\n        left = <span class=\"hljs-number\">0</span>\n        right = n\n        mid = (<span class=\"hljs-number\">1</span>+n)//<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">while</span> right-left&gt;<span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">if</span> isBadVersion(mid):\n                right = mid\n            <span class=\"hljs-keyword\">else</span>:\n                left = mid\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">return</span> right</code></pre></div>\n","site":{"data":{}},"wordcount":257,"excerpt":"","more":"<h1 id=\"第一个错误的版本\">278. 第一个错误的版本</h1>\n<p>二分查找可以解决，左指针<code>left</code>记录当前正确的版本，右指针<code>right</code>记录当前错误的版本，所以当<code>right-left=1</code>时，<code>right</code>所指的就是第一个错误的版本，也就是结果。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">firstBadVersion</span>(<span class=\"hljs-params\">self, n</span>):\n        left = <span class=\"hljs-number\">0</span>\n        right = n\n        mid = (<span class=\"hljs-number\">1</span>+n)//<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">while</span> right-left&gt;<span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">if</span> isBadVersion(mid):\n                right = mid\n            <span class=\"hljs-keyword\">else</span>:\n                left = mid\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">return</span> right</code></pre>\n"},{"title":"LeetCode 283 290 292","date":"2022-06-07T04:17:57.000Z","_content":"\n# 283. 移动零\n\n第一种就是想办法绕过测试。其实还是复制数组而非原地算法。\n\n```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        array = []\n        for i in nums:\n            if i != 0:\n                array.append(i)\n        for i in range(len(array)):\n            nums[i] = array[i]\n        for i in range(len(array),len(nums)):\n            nums[i] = 0\n```\n\n第二种，快慢双指针。用快指针遍历整个数组，慢指针记录不为0的元素并更改数组中此位置的值。最后在快指针遍历完后，慢指针到数组末端都是0，再填充。\n\n```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        slow = 0\n        fast = 0\n        length = len(nums)\n        while fast<length:\n            if nums[fast] != 0:\n                nums[slow] = nums[fast]\n                fast += 1\n                slow += 1\n            else:\n                fast += 1\n        while slow<length:\n            nums[slow] = 0\n            slow += 1\n```\n\n# 290. 单词规律\n\n双哈希表，分为正向哈希记录`(pattern, string)`与逆向哈希记录`(string, pattern)`。值得注意的点有两个：一是正向哈希记录第一次看到的键值对，逆向哈希记录最后一次看到的键值对；二是正向哈希与逆向哈希的键值对数量应该是一样的。\n\n```python\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        dict_pos = {}\n        dict_nag = {}\n        lst_ptn = list(pattern)\n        lst_s = s.split()\n        if len(lst_ptn) != len(lst_s):\n            return False\n        for k,v in zip(lst_ptn, lst_s):\n            if k not in dict_pos:\n                dict_pos[k] = v\n            dict_nag[v] = k\n        if len(dict_pos) != len(dict_nag):\n            return False\n        for k,v in dict_pos.items():\n            if k != dict_nag[v]:\n                return False\n        return True\n```\n\n# 292. Nim 游戏\n\n这是一个简单的博弈，在此模拟下博弈的过程。\n\n```text\n1：自己拿走1块，赢。\n2：自己拿走2块，赢。\n3：自己拿走3块，赢。\n4：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是1、2、3中的一种。\n5：自己拿走1块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n6：自己拿走2块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n7：自己拿走3块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n8：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是5、6、7中的一种。\n9：自己拿走1块，赢。构建对方8的局面，因为8时拿无论怎么都会输所以只要构造出来就赢。\n```\n\n所以可以发现，当桌上还剩4的倍数的石头数目时，拿的那一方一定会输。所以一开始的时候，我先手的话只要桌上石头是4的倍数就一定会输。\n\n```python\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n%4 != 0\n```\n\n","source":"_posts/leetcode20220607.md","raw":"---\ntitle: LeetCode 283 290 292\ndate: 2022-06-07 12:17:57\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, point, hash, math]\n---\n\n# 283. 移动零\n\n第一种就是想办法绕过测试。其实还是复制数组而非原地算法。\n\n```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        array = []\n        for i in nums:\n            if i != 0:\n                array.append(i)\n        for i in range(len(array)):\n            nums[i] = array[i]\n        for i in range(len(array),len(nums)):\n            nums[i] = 0\n```\n\n第二种，快慢双指针。用快指针遍历整个数组，慢指针记录不为0的元素并更改数组中此位置的值。最后在快指针遍历完后，慢指针到数组末端都是0，再填充。\n\n```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        slow = 0\n        fast = 0\n        length = len(nums)\n        while fast<length:\n            if nums[fast] != 0:\n                nums[slow] = nums[fast]\n                fast += 1\n                slow += 1\n            else:\n                fast += 1\n        while slow<length:\n            nums[slow] = 0\n            slow += 1\n```\n\n# 290. 单词规律\n\n双哈希表，分为正向哈希记录`(pattern, string)`与逆向哈希记录`(string, pattern)`。值得注意的点有两个：一是正向哈希记录第一次看到的键值对，逆向哈希记录最后一次看到的键值对；二是正向哈希与逆向哈希的键值对数量应该是一样的。\n\n```python\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        dict_pos = {}\n        dict_nag = {}\n        lst_ptn = list(pattern)\n        lst_s = s.split()\n        if len(lst_ptn) != len(lst_s):\n            return False\n        for k,v in zip(lst_ptn, lst_s):\n            if k not in dict_pos:\n                dict_pos[k] = v\n            dict_nag[v] = k\n        if len(dict_pos) != len(dict_nag):\n            return False\n        for k,v in dict_pos.items():\n            if k != dict_nag[v]:\n                return False\n        return True\n```\n\n# 292. Nim 游戏\n\n这是一个简单的博弈，在此模拟下博弈的过程。\n\n```text\n1：自己拿走1块，赢。\n2：自己拿走2块，赢。\n3：自己拿走3块，赢。\n4：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是1、2、3中的一种。\n5：自己拿走1块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n6：自己拿走2块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n7：自己拿走3块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n8：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是5、6、7中的一种。\n9：自己拿走1块，赢。构建对方8的局面，因为8时拿无论怎么都会输所以只要构造出来就赢。\n```\n\n所以可以发现，当桌上还剩4的倍数的石头数目时，拿的那一方一定会输。所以一开始的时候，我先手的话只要桌上石头是4的倍数就一定会输。\n\n```python\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n%4 != 0\n```\n\n","slug":"leetcode20220607","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fy001n142p8ozc8f73","content":"<h1 id=\"移动零\">283. 移动零</h1>\n<p>第一种就是想办法绕过测试。其实还是复制数组而非原地算法。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">moveZeroes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        array = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i != <span class=\"hljs-number\">0</span>:\n                array.append(i)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(array)):\n            nums[i] = array[i]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(array),<span class=\"hljs-built_in\">len</span>(nums)):\n            nums[i] = <span class=\"hljs-number\">0</span></code></pre></div>\n<p>第二种，快慢双指针。用快指针遍历整个数组，慢指针记录不为0的元素并更改数组中此位置的值。最后在快指针遍历完后，慢指针到数组末端都是0，再填充。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">moveZeroes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        slow = <span class=\"hljs-number\">0</span>\n        fast = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> fast&lt;length:\n            <span class=\"hljs-keyword\">if</span> nums[fast] != <span class=\"hljs-number\">0</span>:\n                nums[slow] = nums[fast]\n                fast += <span class=\"hljs-number\">1</span>\n                slow += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                fast += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> slow&lt;length:\n            nums[slow] = <span class=\"hljs-number\">0</span>\n            slow += <span class=\"hljs-number\">1</span></code></pre></div>\n<h1 id=\"单词规律\">290. 单词规律</h1>\n<p>双哈希表，分为正向哈希记录<code>(pattern, string)</code>与逆向哈希记录<code>(string, pattern)</code>。值得注意的点有两个：一是正向哈希记录第一次看到的键值对，逆向哈希记录最后一次看到的键值对；二是正向哈希与逆向哈希的键值对数量应该是一样的。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wordPattern</span>(<span class=\"hljs-params\">self, pattern: <span class=\"hljs-built_in\">str</span>, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        dict_pos = &#123;&#125;\n        dict_nag = &#123;&#125;\n        lst_ptn = <span class=\"hljs-built_in\">list</span>(pattern)\n        lst_s = s.split()\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(lst_ptn) != <span class=\"hljs-built_in\">len</span>(lst_s):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">zip</span>(lst_ptn, lst_s):\n            <span class=\"hljs-keyword\">if</span> k <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict_pos:\n                dict_pos[k] = v\n            dict_nag[v] = k\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(dict_pos) != <span class=\"hljs-built_in\">len</span>(dict_nag):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> dict_pos.items():\n            <span class=\"hljs-keyword\">if</span> k != dict_nag[v]:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n<h1 id=\"nim-游戏\">292. Nim 游戏</h1>\n<p>这是一个简单的博弈，在此模拟下博弈的过程。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs text\">1：自己拿走1块，赢。\n2：自己拿走2块，赢。\n3：自己拿走3块，赢。\n4：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是1、2、3中的一种。\n5：自己拿走1块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n6：自己拿走2块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n7：自己拿走3块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n8：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是5、6、7中的一种。\n9：自己拿走1块，赢。构建对方8的局面，因为8时拿无论怎么都会输所以只要构造出来就赢。</code></pre></div>\n<p>所以可以发现，当桌上还剩4的倍数的石头数目时，拿的那一方一定会输。所以一开始的时候，我先手的话只要桌上石头是4的倍数就一定会输。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">canWinNim</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> n%<span class=\"hljs-number\">4</span> != <span class=\"hljs-number\">0</span></code></pre></div>\n","site":{"data":{}},"wordcount":1430,"excerpt":"","more":"<h1 id=\"移动零\">283. 移动零</h1>\n<p>第一种就是想办法绕过测试。其实还是复制数组而非原地算法。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">moveZeroes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        array = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i != <span class=\"hljs-number\">0</span>:\n                array.append(i)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(array)):\n            nums[i] = array[i]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(array),<span class=\"hljs-built_in\">len</span>(nums)):\n            nums[i] = <span class=\"hljs-number\">0</span></code></pre>\n<p>第二种，快慢双指针。用快指针遍历整个数组，慢指针记录不为0的元素并更改数组中此位置的值。最后在快指针遍历完后，慢指针到数组末端都是0，再填充。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">moveZeroes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        slow = <span class=\"hljs-number\">0</span>\n        fast = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> fast&lt;length:\n            <span class=\"hljs-keyword\">if</span> nums[fast] != <span class=\"hljs-number\">0</span>:\n                nums[slow] = nums[fast]\n                fast += <span class=\"hljs-number\">1</span>\n                slow += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                fast += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> slow&lt;length:\n            nums[slow] = <span class=\"hljs-number\">0</span>\n            slow += <span class=\"hljs-number\">1</span></code></pre>\n<h1 id=\"单词规律\">290. 单词规律</h1>\n<p>双哈希表，分为正向哈希记录<code>(pattern, string)</code>与逆向哈希记录<code>(string, pattern)</code>。值得注意的点有两个：一是正向哈希记录第一次看到的键值对，逆向哈希记录最后一次看到的键值对；二是正向哈希与逆向哈希的键值对数量应该是一样的。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wordPattern</span>(<span class=\"hljs-params\">self, pattern: <span class=\"hljs-built_in\">str</span>, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        dict_pos = &#123;&#125;\n        dict_nag = &#123;&#125;\n        lst_ptn = <span class=\"hljs-built_in\">list</span>(pattern)\n        lst_s = s.split()\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(lst_ptn) != <span class=\"hljs-built_in\">len</span>(lst_s):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">zip</span>(lst_ptn, lst_s):\n            <span class=\"hljs-keyword\">if</span> k <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict_pos:\n                dict_pos[k] = v\n            dict_nag[v] = k\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(dict_pos) != <span class=\"hljs-built_in\">len</span>(dict_nag):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> dict_pos.items():\n            <span class=\"hljs-keyword\">if</span> k != dict_nag[v]:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n<h1 id=\"nim-游戏\">292. Nim 游戏</h1>\n<p>这是一个简单的博弈，在此模拟下博弈的过程。</p>\n<pre><code class=\"hljs text\">1：自己拿走1块，赢。\n2：自己拿走2块，赢。\n3：自己拿走3块，赢。\n4：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是1、2、3中的一种。\n5：自己拿走1块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n6：自己拿走2块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n7：自己拿走3块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。\n8：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是5、6、7中的一种。\n9：自己拿走1块，赢。构建对方8的局面，因为8时拿无论怎么都会输所以只要构造出来就赢。</code></pre>\n<p>所以可以发现，当桌上还剩4的倍数的石头数目时，拿的那一方一定会输。所以一开始的时候，我先手的话只要桌上石头是4的倍数就一定会输。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">canWinNim</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> n%<span class=\"hljs-number\">4</span> != <span class=\"hljs-number\">0</span></code></pre>\n"},{"title":"LeetCode 344 345","date":"2022-06-17T14:13:57.000Z","_content":"\n# 344. 反转字符串\n\n简单交换。\n\n```python\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        length = len(s)\n        for i in range(int(length/2)):\n            temp = s[i]\n            s[i] = s[length-i-1]\n            s[length-i-1] = temp\n```\n\n# 345. 反转字符串中的元音字母\n\n首先我们需要用`set`存储元音字母表（这里有个坑就是大写小写都要写进去），然后通过双指针，首尾指针一起往中间遍历。如果同时遇到或者同时没有遇到元音就交换并且都移动，否则只移动没有遇到元音的指针。\n\n```python\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        vovel = {'a','e','i','o','u','A','E','I','O','U'}\n        res = list(s)\n        left = 0\n        right = len(res) - 1\n        while left <= right:\n            if res[left] not in vovel and res[right] not in vovel:\n                left += 1\n                right -= 1\n            elif res[left] in vovel and res[right] not in vovel:\n                right -= 1\n            elif res[left] not in vovel and res[right] in vovel:\n                left += 1\n            else:\n                temp = res[left]\n                res[left] = res[right]\n                res[right] = temp\n                left += 1\n                right -= 1\n        return ''.join(res)\n```\n\n","source":"_posts/leetcode20220617.md","raw":"---\ntitle: LeetCode 344 345\ndate: 2022-06-17 22:13:57\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, bubble, hash, point]\n---\n\n# 344. 反转字符串\n\n简单交换。\n\n```python\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        length = len(s)\n        for i in range(int(length/2)):\n            temp = s[i]\n            s[i] = s[length-i-1]\n            s[length-i-1] = temp\n```\n\n# 345. 反转字符串中的元音字母\n\n首先我们需要用`set`存储元音字母表（这里有个坑就是大写小写都要写进去），然后通过双指针，首尾指针一起往中间遍历。如果同时遇到或者同时没有遇到元音就交换并且都移动，否则只移动没有遇到元音的指针。\n\n```python\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        vovel = {'a','e','i','o','u','A','E','I','O','U'}\n        res = list(s)\n        left = 0\n        right = len(res) - 1\n        while left <= right:\n            if res[left] not in vovel and res[right] not in vovel:\n                left += 1\n                right -= 1\n            elif res[left] in vovel and res[right] not in vovel:\n                right -= 1\n            elif res[left] not in vovel and res[right] in vovel:\n                left += 1\n            else:\n                temp = res[left]\n                res[left] = res[right]\n                res[right] = temp\n                left += 1\n                right -= 1\n        return ''.join(res)\n```\n\n","slug":"leetcode20220617","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1fz001q142pgx965qz2","content":"<h1 id=\"反转字符串\">344. 反转字符串</h1>\n<p>简单交换。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseString</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        length = <span class=\"hljs-built_in\">len</span>(s)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">int</span>(length/<span class=\"hljs-number\">2</span>)):\n            temp = s[i]\n            s[i] = s[length-i-<span class=\"hljs-number\">1</span>]\n            s[length-i-<span class=\"hljs-number\">1</span>] = temp</code></pre></div>\n<h1 id=\"反转字符串中的元音字母\">345. 反转字符串中的元音字母</h1>\n<p>首先我们需要用<code>set</code>存储元音字母表（这里有个坑就是大写小写都要写进去），然后通过双指针，首尾指针一起往中间遍历。如果同时遇到或者同时没有遇到元音就交换并且都移动，否则只移动没有遇到元音的指针。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseVowels</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        vovel = &#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>,<span class=\"hljs-string\">&#x27;i&#x27;</span>,<span class=\"hljs-string\">&#x27;o&#x27;</span>,<span class=\"hljs-string\">&#x27;u&#x27;</span>,<span class=\"hljs-string\">&#x27;A&#x27;</span>,<span class=\"hljs-string\">&#x27;E&#x27;</span>,<span class=\"hljs-string\">&#x27;I&#x27;</span>,<span class=\"hljs-string\">&#x27;O&#x27;</span>,<span class=\"hljs-string\">&#x27;U&#x27;</span>&#125;\n        res = <span class=\"hljs-built_in\">list</span>(s)\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-built_in\">len</span>(res) - <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left &lt;= right:\n            <span class=\"hljs-keyword\">if</span> res[left] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel <span class=\"hljs-keyword\">and</span> res[right] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel:\n                left += <span class=\"hljs-number\">1</span>\n                right -= <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> res[left] <span class=\"hljs-keyword\">in</span> vovel <span class=\"hljs-keyword\">and</span> res[right] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel:\n                right -= <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> res[left] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel <span class=\"hljs-keyword\">and</span> res[right] <span class=\"hljs-keyword\">in</span> vovel:\n                left += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                temp = res[left]\n                res[left] = res[right]\n                res[right] = temp\n                left += <span class=\"hljs-number\">1</span>\n                right -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&#x27;</span>.join(res)</code></pre></div>\n","site":{"data":{}},"wordcount":789,"excerpt":"","more":"<h1 id=\"反转字符串\">344. 反转字符串</h1>\n<p>简单交换。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseString</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        length = <span class=\"hljs-built_in\">len</span>(s)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">int</span>(length/<span class=\"hljs-number\">2</span>)):\n            temp = s[i]\n            s[i] = s[length-i-<span class=\"hljs-number\">1</span>]\n            s[length-i-<span class=\"hljs-number\">1</span>] = temp</code></pre>\n<h1 id=\"反转字符串中的元音字母\">345. 反转字符串中的元音字母</h1>\n<p>首先我们需要用<code>set</code>存储元音字母表（这里有个坑就是大写小写都要写进去），然后通过双指针，首尾指针一起往中间遍历。如果同时遇到或者同时没有遇到元音就交换并且都移动，否则只移动没有遇到元音的指针。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">reverseVowels</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        vovel = &#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>,<span class=\"hljs-string\">&#x27;i&#x27;</span>,<span class=\"hljs-string\">&#x27;o&#x27;</span>,<span class=\"hljs-string\">&#x27;u&#x27;</span>,<span class=\"hljs-string\">&#x27;A&#x27;</span>,<span class=\"hljs-string\">&#x27;E&#x27;</span>,<span class=\"hljs-string\">&#x27;I&#x27;</span>,<span class=\"hljs-string\">&#x27;O&#x27;</span>,<span class=\"hljs-string\">&#x27;U&#x27;</span>&#125;\n        res = <span class=\"hljs-built_in\">list</span>(s)\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-built_in\">len</span>(res) - <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left &lt;= right:\n            <span class=\"hljs-keyword\">if</span> res[left] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel <span class=\"hljs-keyword\">and</span> res[right] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel:\n                left += <span class=\"hljs-number\">1</span>\n                right -= <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> res[left] <span class=\"hljs-keyword\">in</span> vovel <span class=\"hljs-keyword\">and</span> res[right] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel:\n                right -= <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> res[left] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vovel <span class=\"hljs-keyword\">and</span> res[right] <span class=\"hljs-keyword\">in</span> vovel:\n                left += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                temp = res[left]\n                res[left] = res[right]\n                res[right] = temp\n                left += <span class=\"hljs-number\">1</span>\n                right -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&#x27;</span>.join(res)</code></pre>\n"},{"title":"LeetCode 326 344 349","date":"2022-06-25T15:30:12.000Z","_content":"\n# 326. 3 的幂\n\n还是经典的是否是最大值的约数。\n\n```python\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        return (3**20)%n == 0 if n > 0 else False\n```\n\n# 342. 4 的幂\n\n这题不同于 2 和 3 的幂，因为 4 = 2$\\times$2，所以如果按 2 的幂和 3 的幂的解法会识别不了是 2 的幂但是不是 4 的幂的数这种情况，不过可以转换为求解 2 的幂，如果一个数是 4 的幂，那它的算术平方根肯定是 2 的幂就可解得正确答案。\n\n```python\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return (2**30)%(n**0.5) == 0 if n > 0 else False\n```\n\n# 349. 两个数组的交集\n\n其实就是两个 `list`  转 `set` 后求交集再返回 `list` 。\n\n```python\nclass Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        return list(set(nums1)&set(nums2))\n```\n\n# 350. 两个数组的交集 II\n\n比上个题要难一点，需要对字符出现次数进行一个统计，所以用了 `dict` 而不是 `set` ，在往结果列表里添加值时取最小的次数就可以。\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        dict1 = {}\n        dict2 = {}\n        res = []\n        for i in nums1:\n            if i not in dict1:\n                dict1[i] = 1\n            else:\n                dict1[i] += 1\n        for i in nums2:\n            if i not in dict2:\n                dict2[i] = 1\n            else:\n                dict2[i] += 1\n        for key,value in dict1.items():\n            if key in dict2:\n                for i in range(min(value,dict2[key])):\n                    res.append(key)\n        return res\n```\n\n","source":"_posts/leetcode20220625.md","raw":"---\ntitle: LeetCode 326 344 349\ndate: 2022-06-25 23:30:12\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 326. 3 的幂\n\n还是经典的是否是最大值的约数。\n\n```python\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        return (3**20)%n == 0 if n > 0 else False\n```\n\n# 342. 4 的幂\n\n这题不同于 2 和 3 的幂，因为 4 = 2$\\times$2，所以如果按 2 的幂和 3 的幂的解法会识别不了是 2 的幂但是不是 4 的幂的数这种情况，不过可以转换为求解 2 的幂，如果一个数是 4 的幂，那它的算术平方根肯定是 2 的幂就可解得正确答案。\n\n```python\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return (2**30)%(n**0.5) == 0 if n > 0 else False\n```\n\n# 349. 两个数组的交集\n\n其实就是两个 `list`  转 `set` 后求交集再返回 `list` 。\n\n```python\nclass Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        return list(set(nums1)&set(nums2))\n```\n\n# 350. 两个数组的交集 II\n\n比上个题要难一点，需要对字符出现次数进行一个统计，所以用了 `dict` 而不是 `set` ，在往结果列表里添加值时取最小的次数就可以。\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        dict1 = {}\n        dict2 = {}\n        res = []\n        for i in nums1:\n            if i not in dict1:\n                dict1[i] = 1\n            else:\n                dict1[i] += 1\n        for i in nums2:\n            if i not in dict2:\n                dict2[i] = 1\n            else:\n                dict2[i] += 1\n        for key,value in dict1.items():\n            if key in dict2:\n                for i in range(min(value,dict2[key])):\n                    res.append(key)\n        return res\n```\n\n","slug":"leetcode20220625","published":1,"updated":"2022-08-11T15:43:07.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g0001t142p4jo1ar80","content":"<h1 id=\"的幂\">326. 3 的幂</h1>\n<p>还是经典的是否是最大值的约数。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfThree</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">3</span>**<span class=\"hljs-number\">20</span>)%n == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n<h1 id=\"的幂-1\">342. 4 的幂</h1>\n<p>这题不同于 2 和 3 的幂，因为 4 = 2$$2，所以如果按 2 的幂和 3\n的幂的解法会识别不了是 2 的幂但是不是 4\n的幂的数这种情况，不过可以转换为求解 2 的幂，如果一个数是 4\n的幂，那它的算术平方根肯定是 2 的幂就可解得正确答案。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfFour</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">2</span>**<span class=\"hljs-number\">30</span>)%(n**<span class=\"hljs-number\">0.5</span>) == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n<h1 id=\"两个数组的交集\">349. 两个数组的交集</h1>\n<p>其实就是两个 <code>list</code> 转 <code>set</code> 后求交集再返回\n<code>list</code> 。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">intersection</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">set</span>(nums1)&amp;<span class=\"hljs-built_in\">set</span>(nums2))</code></pre></div>\n<h1 id=\"两个数组的交集-ii\">350. 两个数组的交集 II</h1>\n<p>比上个题要难一点，需要对字符出现次数进行一个统计，所以用了\n<code>dict</code> 而不是 <code>set</code>\n，在往结果列表里添加值时取最小的次数就可以。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">intersect</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        dict1 = &#123;&#125;\n        dict2 = &#123;&#125;\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums1:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict1:\n                dict1[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                dict1[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums2:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict2:\n                dict2[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                dict2[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> key,value <span class=\"hljs-keyword\">in</span> dict1.items():\n            <span class=\"hljs-keyword\">if</span> key <span class=\"hljs-keyword\">in</span> dict2:\n                <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">min</span>(value,dict2[key])):\n                    res.append(key)\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":870,"excerpt":"","more":"<h1 id=\"的幂\">326. 3 的幂</h1>\n<p>还是经典的是否是最大值的约数。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfThree</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">3</span>**<span class=\"hljs-number\">20</span>)%n == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-literal\">False</span></code></pre>\n<h1 id=\"的幂-1\">342. 4 的幂</h1>\n<p>这题不同于 2 和 3 的幂，因为 4 = 2$$2，所以如果按 2 的幂和 3\n的幂的解法会识别不了是 2 的幂但是不是 4\n的幂的数这种情况，不过可以转换为求解 2 的幂，如果一个数是 4\n的幂，那它的算术平方根肯定是 2 的幂就可解得正确答案。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPowerOfFour</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">2</span>**<span class=\"hljs-number\">30</span>)%(n**<span class=\"hljs-number\">0.5</span>) == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-literal\">False</span></code></pre>\n<h1 id=\"两个数组的交集\">349. 两个数组的交集</h1>\n<p>其实就是两个 <code>list</code> 转 <code>set</code> 后求交集再返回\n<code>list</code> 。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">intersection</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">set</span>(nums1)&amp;<span class=\"hljs-built_in\">set</span>(nums2))</code></pre>\n<h1 id=\"两个数组的交集-ii\">350. 两个数组的交集 II</h1>\n<p>比上个题要难一点，需要对字符出现次数进行一个统计，所以用了\n<code>dict</code> 而不是 <code>set</code>\n，在往结果列表里添加值时取最小的次数就可以。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">intersect</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        dict1 = &#123;&#125;\n        dict2 = &#123;&#125;\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums1:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict1:\n                dict1[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                dict1[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums2:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict2:\n                dict2[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                dict2[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> key,value <span class=\"hljs-keyword\">in</span> dict1.items():\n            <span class=\"hljs-keyword\">if</span> key <span class=\"hljs-keyword\">in</span> dict2:\n                <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">min</span>(value,dict2[key])):\n                    res.append(key)\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 326 344 349","date":"2022-06-27T04:43:19.000Z","_content":"\n# 367. 有效的完全平方数\n\n> [完全平方数 - 百度百科](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)\n\n这道题不禁让我想到了之前求算术平方根的题，看起来好像要更简单一点，那么直接用二分搜索。\n\n```python\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        left = 1\n        right = num\n        while left<=right:\n            mid = (left+right)//2\n            if mid*mid == num:\n                return True\n            elif mid*mid < num:\n                left = mid+1\n            else:\n                right = mid-1\n        return False\n```\n\n# 374. 猜数字大小\n\n这道题和上道题几乎完全一样的思路，不同之处在于这道题更直白地说明了二分法的可行性。\n\n```python\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        left = 1\n        right = n\n        while left<=right:\n            mid = (left+right)//2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res == -1:\n                right = mid-1\n            else:\n                left = mid+1\n        return None\n```\n\n","source":"_posts/leetcode20220627.md","raw":"---\ntitle: LeetCode 326 344 349\ndate: 2022-06-27 12:43:19\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, binary search]\n---\n\n# 367. 有效的完全平方数\n\n> [完全平方数 - 百度百科](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)\n\n这道题不禁让我想到了之前求算术平方根的题，看起来好像要更简单一点，那么直接用二分搜索。\n\n```python\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        left = 1\n        right = num\n        while left<=right:\n            mid = (left+right)//2\n            if mid*mid == num:\n                return True\n            elif mid*mid < num:\n                left = mid+1\n            else:\n                right = mid-1\n        return False\n```\n\n# 374. 猜数字大小\n\n这道题和上道题几乎完全一样的思路，不同之处在于这道题更直白地说明了二分法的可行性。\n\n```python\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        left = 1\n        right = n\n        while left<=right:\n            mid = (left+right)//2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res == -1:\n                right = mid-1\n            else:\n                left = mid+1\n        return None\n```\n\n","slug":"leetcode20220627","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g1001w142pb9jicoy4","content":"<h1 id=\"有效的完全平方数\">367. 有效的完全平方数</h1>\n<blockquote>\n<p><a\nhref=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0\">完全平方数\n- 百度百科</a></p>\n</blockquote>\n<p>这道题不禁让我想到了之前求算术平方根的题，看起来好像要更简单一点，那么直接用二分搜索。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPerfectSquare</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        left = <span class=\"hljs-number\">1</span>\n        right = num\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> mid*mid == num:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n            <span class=\"hljs-keyword\">elif</span> mid*mid &lt; num:\n                left = mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right = mid-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n<h1 id=\"猜数字大小\">374. 猜数字大小</h1>\n<p>这道题和上道题几乎完全一样的思路，不同之处在于这道题更直白地说明了二分法的可行性。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">guessNumber</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        left = <span class=\"hljs-number\">1</span>\n        right = n\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n            res = guess(mid)\n            <span class=\"hljs-keyword\">if</span> res == <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> mid\n            <span class=\"hljs-keyword\">elif</span> res == -<span class=\"hljs-number\">1</span>:\n                right = mid-<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                left = mid+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre></div>\n","site":{"data":{}},"wordcount":487,"excerpt":"","more":"<h1 id=\"有效的完全平方数\">367. 有效的完全平方数</h1>\n<blockquote>\n<p><a\nhref=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0\">完全平方数\n- 百度百科</a></p>\n</blockquote>\n<p>这道题不禁让我想到了之前求算术平方根的题，看起来好像要更简单一点，那么直接用二分搜索。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isPerfectSquare</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        left = <span class=\"hljs-number\">1</span>\n        right = num\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> mid*mid == num:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n            <span class=\"hljs-keyword\">elif</span> mid*mid &lt; num:\n                left = mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right = mid-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre>\n<h1 id=\"猜数字大小\">374. 猜数字大小</h1>\n<p>这道题和上道题几乎完全一样的思路，不同之处在于这道题更直白地说明了二分法的可行性。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">guessNumber</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        left = <span class=\"hljs-number\">1</span>\n        right = n\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            mid = (left+right)//<span class=\"hljs-number\">2</span>\n            res = guess(mid)\n            <span class=\"hljs-keyword\">if</span> res == <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> mid\n            <span class=\"hljs-keyword\">elif</span> res == -<span class=\"hljs-number\">1</span>:\n                right = mid-<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                left = mid+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre>\n"},{"title":"LeetCode 383","date":"2022-06-28T15:58:30.000Z","_content":"\n# 383. 赎金信\n\n采用字典方式对两个字符串计数，一旦`ransomNote`里的字符没有出现在`magazine`里或是比`magazine`里出现的次数多时，返回`False`，否则返回`True`。\n\n```python\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        magazine_dict = {}\n        ransomNote_dict = {}\n        for i in magazine:\n            if i not in magazine_dict:\n                magazine_dict[i] = 1\n            else:\n                magazine_dict[i] += 1\n        for i in ransomNote:\n            if i not in ransomNote_dict:\n                ransomNote_dict[i] = 1\n            else:\n                ransomNote_dict[i] += 1\n        for k,v in ransomNote_dict.items():\n            if k not in magazine_dict:\n                return False\n            else:\n                if v > magazine_dict[k]:\n                    return False\n        return True\n```\n\n","source":"_posts/leetcode20220628.md","raw":"---\ntitle: LeetCode 383\ndate: 2022-06-28 23:58:30\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 383. 赎金信\n\n采用字典方式对两个字符串计数，一旦`ransomNote`里的字符没有出现在`magazine`里或是比`magazine`里出现的次数多时，返回`False`，否则返回`True`。\n\n```python\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        magazine_dict = {}\n        ransomNote_dict = {}\n        for i in magazine:\n            if i not in magazine_dict:\n                magazine_dict[i] = 1\n            else:\n                magazine_dict[i] += 1\n        for i in ransomNote:\n            if i not in ransomNote_dict:\n                ransomNote_dict[i] = 1\n            else:\n                ransomNote_dict[i] += 1\n        for k,v in ransomNote_dict.items():\n            if k not in magazine_dict:\n                return False\n            else:\n                if v > magazine_dict[k]:\n                    return False\n        return True\n```\n\n","slug":"leetcode20220628","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g2001z142p27yi5spo","content":"<h1 id=\"赎金信\">383. 赎金信</h1>\n<p>采用字典方式对两个字符串计数，一旦<code>ransomNote</code>里的字符没有出现在<code>magazine</code>里或是比<code>magazine</code>里出现的次数多时，返回<code>False</code>，否则返回<code>True</code>。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">canConstruct</span>(<span class=\"hljs-params\">self, ransomNote: <span class=\"hljs-built_in\">str</span>, magazine: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        magazine_dict = &#123;&#125;\n        ransomNote_dict = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> magazine:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> magazine_dict:\n                magazine_dict[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                magazine_dict[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> ransomNote:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> ransomNote_dict:\n                ransomNote_dict[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                ransomNote_dict[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> ransomNote_dict.items():\n            <span class=\"hljs-keyword\">if</span> k <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> magazine_dict:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> v &gt; magazine_dict[k]:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre></div>\n","site":{"data":{}},"wordcount":497,"excerpt":"","more":"<h1 id=\"赎金信\">383. 赎金信</h1>\n<p>采用字典方式对两个字符串计数，一旦<code>ransomNote</code>里的字符没有出现在<code>magazine</code>里或是比<code>magazine</code>里出现的次数多时，返回<code>False</code>，否则返回<code>True</code>。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">canConstruct</span>(<span class=\"hljs-params\">self, ransomNote: <span class=\"hljs-built_in\">str</span>, magazine: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        magazine_dict = &#123;&#125;\n        ransomNote_dict = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> magazine:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> magazine_dict:\n                magazine_dict[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                magazine_dict[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> ransomNote:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> ransomNote_dict:\n                ransomNote_dict[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                ransomNote_dict[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> ransomNote_dict.items():\n            <span class=\"hljs-keyword\">if</span> k <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> magazine_dict:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> v &gt; magazine_dict[k]:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span></code></pre>\n"},{"title":"LeetCode 387","date":"2022-06-29T03:35:51.000Z","_content":"\n# 387. 字符串中的第一个唯一字符\n\n先想到的一种思路就是用双`set`，一个`set`用来存储字符串每个字符，作用时校验是否重复，另一个`set`用来存储重复的字符。\n\n```python\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        hashset1 = set('')\n        hashset2 = set('')\n        for value in s:\n            if value not in hashset1:\n                hashset1.add(value)\n            else:\n                hashset2.add(value)\n        for index,value in enumerate(s):\n            if value not in hashset2:\n                return index\n        return -1\n```\n\n当然用字典也可以。\n\n```python\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        hashmap = {}\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for index,key_char in enumerate(s):\n            if hashmap[key_char] == 1:\n                return index\n        return -1\n```\n\n","source":"_posts/leetcode20220629.md","raw":"---\ntitle: LeetCode 387\ndate: 2022-06-29 11:35:51\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 387. 字符串中的第一个唯一字符\n\n先想到的一种思路就是用双`set`，一个`set`用来存储字符串每个字符，作用时校验是否重复，另一个`set`用来存储重复的字符。\n\n```python\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        hashset1 = set('')\n        hashset2 = set('')\n        for value in s:\n            if value not in hashset1:\n                hashset1.add(value)\n            else:\n                hashset2.add(value)\n        for index,value in enumerate(s):\n            if value not in hashset2:\n                return index\n        return -1\n```\n\n当然用字典也可以。\n\n```python\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        hashmap = {}\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for index,key_char in enumerate(s):\n            if hashmap[key_char] == 1:\n                return index\n        return -1\n```\n\n","slug":"leetcode20220629","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g30022142p44aodmro","content":"<h1 id=\"字符串中的第一个唯一字符\">387. 字符串中的第一个唯一字符</h1>\n<p>先想到的一种思路就是用双<code>set</code>，一个<code>set</code>用来存储字符串每个字符，作用时校验是否重复，另一个<code>set</code>用来存储重复的字符。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">firstUniqChar</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset1 = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        hashset2 = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        <span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset1:\n                hashset1.add(value)\n            <span class=\"hljs-keyword\">else</span>:\n                hashset2.add(value)\n        <span class=\"hljs-keyword\">for</span> index,value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(s):\n            <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset2:\n                <span class=\"hljs-keyword\">return</span> index\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span></code></pre></div>\n<p>当然用字典也可以。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">firstUniqChar</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> index,key_char <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(s):\n            <span class=\"hljs-keyword\">if</span> hashmap[key_char] == <span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">return</span> index\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span></code></pre></div>\n","site":{"data":{}},"wordcount":531,"excerpt":"","more":"<h1 id=\"字符串中的第一个唯一字符\">387. 字符串中的第一个唯一字符</h1>\n<p>先想到的一种思路就是用双<code>set</code>，一个<code>set</code>用来存储字符串每个字符，作用时校验是否重复，另一个<code>set</code>用来存储重复的字符。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">firstUniqChar</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset1 = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        hashset2 = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        <span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset1:\n                hashset1.add(value)\n            <span class=\"hljs-keyword\">else</span>:\n                hashset2.add(value)\n        <span class=\"hljs-keyword\">for</span> index,value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(s):\n            <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashset2:\n                <span class=\"hljs-keyword\">return</span> index\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span></code></pre>\n<p>当然用字典也可以。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">firstUniqChar</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> index,key_char <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(s):\n            <span class=\"hljs-keyword\">if</span> hashmap[key_char] == <span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">return</span> index\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span></code></pre>\n"},{"title":"LeetCode 389","date":"2022-06-30T04:44:16.000Z","_content":"\n# 389. 找不同\n\n用 `dict` 对字符串 `s` 进行计数，然后遍历 `t` 用 `dict` 进行检索。\n\n```python\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        hashmap = {}\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for i in t:\n            if i not in hashmap:\n                return i\n            else:\n                if hashmap[i] == 0:\n                    return i\n                else:\n                    hashmap[i] -= 1\n        return None\n```\n\n当然 `t` 只是在 `s` 打乱顺序的基础上随机添加了一个字母，所以那个随机添加的字母的 ascii 码其实就是两个字符串 ascii 码和的差值。\n\n```python\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        ascii_s = sum([ord(i) for i in s])\n        ascii_t = sum([ord(i) for i in t])\n        return chr(ascii_t-ascii_s)\n```\n\n# 392. 判断子序列\n\n> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。\n\n这个题目不仅要保证 `s` 的字符在 `t` 中有，还要有序。在遍历两个字符串的过程中，指针移动速度不一定一样，所以很容易想到了双指针。\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        left = 0\n        right = 0\n        len_s = len(s)\n        len_t = len(t)\n        while left<len_s and right<len_t:\n            if s[left] == t[right]:\n                left += 1\n                right += 1\n            else:\n                right += 1\n        return left == len_s\n```\n\n","source":"_posts/leetcode20220630.md","raw":"---\ntitle: LeetCode 389\ndate: 2022-06-30 12:44:16\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash, ascii]\n---\n\n# 389. 找不同\n\n用 `dict` 对字符串 `s` 进行计数，然后遍历 `t` 用 `dict` 进行检索。\n\n```python\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        hashmap = {}\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for i in t:\n            if i not in hashmap:\n                return i\n            else:\n                if hashmap[i] == 0:\n                    return i\n                else:\n                    hashmap[i] -= 1\n        return None\n```\n\n当然 `t` 只是在 `s` 打乱顺序的基础上随机添加了一个字母，所以那个随机添加的字母的 ascii 码其实就是两个字符串 ascii 码和的差值。\n\n```python\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        ascii_s = sum([ord(i) for i in s])\n        ascii_t = sum([ord(i) for i in t])\n        return chr(ascii_t-ascii_s)\n```\n\n# 392. 判断子序列\n\n> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。\n\n这个题目不仅要保证 `s` 的字符在 `t` 中有，还要有序。在遍历两个字符串的过程中，指针移动速度不一定一样，所以很容易想到了双指针。\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        left = 0\n        right = 0\n        len_s = len(s)\n        len_t = len(t)\n        while left<len_s and right<len_t:\n            if s[left] == t[right]:\n                left += 1\n                right += 1\n            else:\n                right += 1\n        return left == len_s\n```\n\n","slug":"leetcode20220630","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g30025142p5z4na6d7","content":"<h1 id=\"找不同\">389. 找不同</h1>\n<p>用 <code>dict</code> 对字符串 <code>s</code> 进行计数，然后遍历\n<code>t</code> 用 <code>dict</code> 进行检索。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findTheDifference</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> t:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                <span class=\"hljs-keyword\">return</span> i\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> hashmap[i] == <span class=\"hljs-number\">0</span>:\n                    <span class=\"hljs-keyword\">return</span> i\n                <span class=\"hljs-keyword\">else</span>:\n                    hashmap[i] -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre></div>\n<p>当然 <code>t</code> 只是在 <code>s</code>\n打乱顺序的基础上随机添加了一个字母，所以那个随机添加的字母的 ascii\n码其实就是两个字符串 ascii 码和的差值。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findTheDifference</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        ascii_s = <span class=\"hljs-built_in\">sum</span>([<span class=\"hljs-built_in\">ord</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s])\n        ascii_t = <span class=\"hljs-built_in\">sum</span>([<span class=\"hljs-built_in\">ord</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> t])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">chr</span>(ascii_t-ascii_s)</code></pre></div>\n<h1 id=\"判断子序列\">392. 判断子序列</h1>\n<blockquote>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。</p>\n</blockquote>\n<p>这个题目不仅要保证 <code>s</code> 的字符在 <code>t</code>\n中有，还要有序。在遍历两个字符串的过程中，指针移动速度不一定一样，所以很容易想到了双指针。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isSubsequence</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-number\">0</span>\n        len_s = <span class=\"hljs-built_in\">len</span>(s)\n        len_t = <span class=\"hljs-built_in\">len</span>(t)\n        <span class=\"hljs-keyword\">while</span> left&lt;len_s <span class=\"hljs-keyword\">and</span> right&lt;len_t:\n            <span class=\"hljs-keyword\">if</span> s[left] == t[right]:\n                left += <span class=\"hljs-number\">1</span>\n                right += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> left == len_s</code></pre></div>\n","site":{"data":{}},"wordcount":779,"excerpt":"","more":"<h1 id=\"找不同\">389. 找不同</h1>\n<p>用 <code>dict</code> 对字符串 <code>s</code> 进行计数，然后遍历\n<code>t</code> 用 <code>dict</code> 进行检索。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findTheDifference</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        hashmap = &#123;&#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> t:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                <span class=\"hljs-keyword\">return</span> i\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> hashmap[i] == <span class=\"hljs-number\">0</span>:\n                    <span class=\"hljs-keyword\">return</span> i\n                <span class=\"hljs-keyword\">else</span>:\n                    hashmap[i] -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre>\n<p>当然 <code>t</code> 只是在 <code>s</code>\n打乱顺序的基础上随机添加了一个字母，所以那个随机添加的字母的 ascii\n码其实就是两个字符串 ascii 码和的差值。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findTheDifference</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        ascii_s = <span class=\"hljs-built_in\">sum</span>([<span class=\"hljs-built_in\">ord</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s])\n        ascii_t = <span class=\"hljs-built_in\">sum</span>([<span class=\"hljs-built_in\">ord</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> t])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">chr</span>(ascii_t-ascii_s)</code></pre>\n<h1 id=\"判断子序列\">392. 判断子序列</h1>\n<blockquote>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。</p>\n</blockquote>\n<p>这个题目不仅要保证 <code>s</code> 的字符在 <code>t</code>\n中有，还要有序。在遍历两个字符串的过程中，指针移动速度不一定一样，所以很容易想到了双指针。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isSubsequence</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, t: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-number\">0</span>\n        len_s = <span class=\"hljs-built_in\">len</span>(s)\n        len_t = <span class=\"hljs-built_in\">len</span>(t)\n        <span class=\"hljs-keyword\">while</span> left&lt;len_s <span class=\"hljs-keyword\">and</span> right&lt;len_t:\n            <span class=\"hljs-keyword\">if</span> s[left] == t[right]:\n                left += <span class=\"hljs-number\">1</span>\n                right += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> left == len_s</code></pre>\n"},{"title":"LeetCode 401","date":"2022-07-10T10:45:26.000Z","_content":"\n# 401. 二进制手表\n\n枚举法，枚举时和分，如果满足就添加进列表。\n\n```python\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        res = []\n        for h in range(12):\n            for m in range(60):\n               if bin(h).count('1')+bin(m).count('1') == turnedOn:\n                   res.append('%d:%.2d' % (h,m))\n        return res\n```\n\n","source":"_posts/leetcode20220710.md","raw":"---\ntitle: LeetCode 401\ndate: 2022-07-10 18:45:26\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, enumerate]\n---\n\n# 401. 二进制手表\n\n枚举法，枚举时和分，如果满足就添加进列表。\n\n```python\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        res = []\n        for h in range(12):\n            for m in range(60):\n               if bin(h).count('1')+bin(m).count('1') == turnedOn:\n                   res.append('%d:%.2d' % (h,m))\n        return res\n```\n\n","slug":"leetcode20220710","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g40028142pe5zzaf85","content":"<h1 id=\"二进制手表\">401. 二进制手表</h1>\n<p>枚举法，枚举时和分，如果满足就添加进列表。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">readBinaryWatch</span>(<span class=\"hljs-params\">self, turnedOn: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        <span class=\"hljs-keyword\">for</span> h <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">12</span>):\n            <span class=\"hljs-keyword\">for</span> m <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">60</span>):\n               <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">bin</span>(h).count(<span class=\"hljs-string\">&#x27;1&#x27;</span>)+<span class=\"hljs-built_in\">bin</span>(m).count(<span class=\"hljs-string\">&#x27;1&#x27;</span>) == turnedOn:\n                   res.append(<span class=\"hljs-string\">&#x27;%d:%.2d&#x27;</span> % (h,m))\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":248,"excerpt":"","more":"<h1 id=\"二进制手表\">401. 二进制手表</h1>\n<p>枚举法，枚举时和分，如果满足就添加进列表。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">readBinaryWatch</span>(<span class=\"hljs-params\">self, turnedOn: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        <span class=\"hljs-keyword\">for</span> h <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">12</span>):\n            <span class=\"hljs-keyword\">for</span> m <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">60</span>):\n               <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">bin</span>(h).count(<span class=\"hljs-string\">&#x27;1&#x27;</span>)+<span class=\"hljs-built_in\">bin</span>(m).count(<span class=\"hljs-string\">&#x27;1&#x27;</span>) == turnedOn:\n                   res.append(<span class=\"hljs-string\">&#x27;%d:%.2d&#x27;</span> % (h,m))\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 409 412 414 415 434","date":"2022-07-14T16:33:09.000Z","_content":"\n# 409. 最长回文串\n\n贪心法。回文串要满足的条件就是出现奇数次的字符数量要小于等于1。所以，对于每个字符来讲，如果它出现为奇数次，就可以用`n-1`次；如果它出现为偶数次，就可以用`n`次。如果有出现奇数次的字符，最后结果再加1，没有就不管了。按照这种思路用一个`flag`记录是否有出现过奇数次的字符。\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        res = 0\n        hashmap = {}\n        flag = False\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for value in hashmap.values():\n            if value%2 == 0:\n                res += value\n            else:\n                res += value -1\n                flag = True\n        return res+1 if flag else res\n```\n\n# 412. Fizz Buzz\n\n感觉就是一个穷举。\n\n看了一下讨论，好像这道题背后有故事，就是来筛选不会编程的人。\n\n> [Why Can't Programmers.. Program?](https://blog.codinghorror.com/why-cant-programmers-program/)\n\n```python\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        res = []\n        for i in range(1, n+1):\n            if i%15 == 0:\n                res.append('FizzBuzz')\n            elif i%5 == 0:\n                res.append('Buzz')\n            elif i%3 == 0:\n                res.append('Fizz')\n            else:\n                res.append(str(i))\n        return res\n```\n\n# 414. 第三大的数\n\n先去重再排除两次最大值是可以的。而且也不慢。\n\n```python\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        lst = list(set(nums))\n        if len(lst) < 3:\n            return max(lst)\n        lst.remove(max(lst))\n        lst.remove(max(lst))\n        return max(lst)\n```\n\n排序也试了下，稍微慢点。\n\n```python\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        lst = sorted(nums, reverse = True)\n        count = 1\n        temp = lst[0]\n        for i in lst:\n            if i != temp:\n                count += 1\n                temp = i\n            if count == 3:\n                return i\n        return lst[0]\n```\n\n# 415. 字符串相加\n\n从一个数的后面加到前面。\n\n```python\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        carry = False\n        res = ''\n        len_1 = len(num1)\n        len_2 = len(num2)\n        for i in range(-1, -max(len_1,len_2)-1, -1):\n            if i<-len_1:\n                temp = int(num2[i])\n            elif i<-len_2:\n                temp = int(num1[i])\n            else:\n                temp = int(num1[i])+int(num2[i])\n            if carry:\n                temp += 1\n            if temp >= 10:\n                temp -= 10\n                carry = True\n            else:\n                carry = False\n            res = str(temp)+res\n        return '1'+res if carry else res\n```\n\n# 434. 字符串中的单词数\n\n循环搜索。在没有计数的情况下，遇到非空格开始计数。在计数的情况下，遇到空格停止计数。\n\n```python\nclass Solution:\n    def countSegments(self, s: str) -> int:\n        res = 0\n        counting = False\n        for i in s:\n            if i != ' ' and not counting:\n                counting = True\n                res += 1\n            elif i == ' ' and counting:\n                counting = False\n        return res\n```\n\n","source":"_posts/leetcode20220715.md","raw":"---\ntitle: LeetCode 409 412 414 415 434\ndate: 2022-07-15 00:33:09\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, greedy, hash, enumerate]\n---\n\n# 409. 最长回文串\n\n贪心法。回文串要满足的条件就是出现奇数次的字符数量要小于等于1。所以，对于每个字符来讲，如果它出现为奇数次，就可以用`n-1`次；如果它出现为偶数次，就可以用`n`次。如果有出现奇数次的字符，最后结果再加1，没有就不管了。按照这种思路用一个`flag`记录是否有出现过奇数次的字符。\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        res = 0\n        hashmap = {}\n        flag = False\n        for i in s:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        for value in hashmap.values():\n            if value%2 == 0:\n                res += value\n            else:\n                res += value -1\n                flag = True\n        return res+1 if flag else res\n```\n\n# 412. Fizz Buzz\n\n感觉就是一个穷举。\n\n看了一下讨论，好像这道题背后有故事，就是来筛选不会编程的人。\n\n> [Why Can't Programmers.. Program?](https://blog.codinghorror.com/why-cant-programmers-program/)\n\n```python\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        res = []\n        for i in range(1, n+1):\n            if i%15 == 0:\n                res.append('FizzBuzz')\n            elif i%5 == 0:\n                res.append('Buzz')\n            elif i%3 == 0:\n                res.append('Fizz')\n            else:\n                res.append(str(i))\n        return res\n```\n\n# 414. 第三大的数\n\n先去重再排除两次最大值是可以的。而且也不慢。\n\n```python\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        lst = list(set(nums))\n        if len(lst) < 3:\n            return max(lst)\n        lst.remove(max(lst))\n        lst.remove(max(lst))\n        return max(lst)\n```\n\n排序也试了下，稍微慢点。\n\n```python\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        lst = sorted(nums, reverse = True)\n        count = 1\n        temp = lst[0]\n        for i in lst:\n            if i != temp:\n                count += 1\n                temp = i\n            if count == 3:\n                return i\n        return lst[0]\n```\n\n# 415. 字符串相加\n\n从一个数的后面加到前面。\n\n```python\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        carry = False\n        res = ''\n        len_1 = len(num1)\n        len_2 = len(num2)\n        for i in range(-1, -max(len_1,len_2)-1, -1):\n            if i<-len_1:\n                temp = int(num2[i])\n            elif i<-len_2:\n                temp = int(num1[i])\n            else:\n                temp = int(num1[i])+int(num2[i])\n            if carry:\n                temp += 1\n            if temp >= 10:\n                temp -= 10\n                carry = True\n            else:\n                carry = False\n            res = str(temp)+res\n        return '1'+res if carry else res\n```\n\n# 434. 字符串中的单词数\n\n循环搜索。在没有计数的情况下，遇到非空格开始计数。在计数的情况下，遇到空格停止计数。\n\n```python\nclass Solution:\n    def countSegments(self, s: str) -> int:\n        res = 0\n        counting = False\n        for i in s:\n            if i != ' ' and not counting:\n                counting = True\n                res += 1\n            elif i == ' ' and counting:\n                counting = False\n        return res\n```\n\n","slug":"leetcode20220715","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g5002b142p12p6hauh","content":"<h1 id=\"最长回文串\">409. 最长回文串</h1>\n<p>贪心法。回文串要满足的条件就是出现奇数次的字符数量要小于等于1。所以，对于每个字符来讲，如果它出现为奇数次，就可以用<code>n-1</code>次；如果它出现为偶数次，就可以用<code>n</code>次。如果有出现奇数次的字符，最后结果再加1，没有就不管了。按照这种思路用一个<code>flag</code>记录是否有出现过奇数次的字符。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">longestPalindrome</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        hashmap = &#123;&#125;\n        flag = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> hashmap.values():\n            <span class=\"hljs-keyword\">if</span> value%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n                res += value\n            <span class=\"hljs-keyword\">else</span>:\n                res += value -<span class=\"hljs-number\">1</span>\n                flag = <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">return</span> res+<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">if</span> flag <span class=\"hljs-keyword\">else</span> res</code></pre></div>\n<h1 id=\"fizz-buzz\">412. Fizz Buzz</h1>\n<p>感觉就是一个穷举。</p>\n<p>看了一下讨论，好像这道题背后有故事，就是来筛选不会编程的人。</p>\n<blockquote>\n<p><a\nhref=\"https://blog.codinghorror.com/why-cant-programmers-program/\">Why\nCan't Programmers.. Program?</a></p>\n</blockquote>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fizzBuzz</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, n+<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">15</span> == <span class=\"hljs-number\">0</span>:\n                res.append(<span class=\"hljs-string\">&#x27;FizzBuzz&#x27;</span>)\n            <span class=\"hljs-keyword\">elif</span> i%<span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span>:\n                res.append(<span class=\"hljs-string\">&#x27;Buzz&#x27;</span>)\n            <span class=\"hljs-keyword\">elif</span> i%<span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>:\n                res.append(<span class=\"hljs-string\">&#x27;Fizz&#x27;</span>)\n            <span class=\"hljs-keyword\">else</span>:\n                res.append(<span class=\"hljs-built_in\">str</span>(i))\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"第三大的数\">414. 第三大的数</h1>\n<p>先去重再排除两次最大值是可以的。而且也不慢。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">thirdMax</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        lst = <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">set</span>(nums))\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(lst) &lt; <span class=\"hljs-number\">3</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(lst)\n        lst.remove(<span class=\"hljs-built_in\">max</span>(lst))\n        lst.remove(<span class=\"hljs-built_in\">max</span>(lst))\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(lst)</code></pre></div>\n<p>排序也试了下，稍微慢点。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">thirdMax</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        lst = <span class=\"hljs-built_in\">sorted</span>(nums, reverse = <span class=\"hljs-literal\">True</span>)\n        count = <span class=\"hljs-number\">1</span>\n        temp = lst[<span class=\"hljs-number\">0</span>]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> lst:\n            <span class=\"hljs-keyword\">if</span> i != temp:\n                count += <span class=\"hljs-number\">1</span>\n                temp = i\n            <span class=\"hljs-keyword\">if</span> count == <span class=\"hljs-number\">3</span>:\n                <span class=\"hljs-keyword\">return</span> i\n        <span class=\"hljs-keyword\">return</span> lst[<span class=\"hljs-number\">0</span>]</code></pre></div>\n<h1 id=\"字符串相加\">415. 字符串相加</h1>\n<p>从一个数的后面加到前面。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addStrings</span>(<span class=\"hljs-params\">self, num1: <span class=\"hljs-built_in\">str</span>, num2: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        carry = <span class=\"hljs-literal\">False</span>\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        len_1 = <span class=\"hljs-built_in\">len</span>(num1)\n        len_2 = <span class=\"hljs-built_in\">len</span>(num2)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-built_in\">max</span>(len_1,len_2)-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> i&lt;-len_1:\n                temp = <span class=\"hljs-built_in\">int</span>(num2[i])\n            <span class=\"hljs-keyword\">elif</span> i&lt;-len_2:\n                temp = <span class=\"hljs-built_in\">int</span>(num1[i])\n            <span class=\"hljs-keyword\">else</span>:\n                temp = <span class=\"hljs-built_in\">int</span>(num1[i])+<span class=\"hljs-built_in\">int</span>(num2[i])\n            <span class=\"hljs-keyword\">if</span> carry:\n                temp += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> temp &gt;= <span class=\"hljs-number\">10</span>:\n                temp -= <span class=\"hljs-number\">10</span>\n                carry = <span class=\"hljs-literal\">True</span>\n            <span class=\"hljs-keyword\">else</span>:\n                carry = <span class=\"hljs-literal\">False</span>\n            res = <span class=\"hljs-built_in\">str</span>(temp)+res\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;1&#x27;</span>+res <span class=\"hljs-keyword\">if</span> carry <span class=\"hljs-keyword\">else</span> res</code></pre></div>\n<h1 id=\"字符串中的单词数\">434. 字符串中的单词数</h1>\n<p>循环搜索。在没有计数的情况下，遇到非空格开始计数。在计数的情况下，遇到空格停止计数。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">countSegments</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        counting = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i != <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> counting:\n                counting = <span class=\"hljs-literal\">True</span>\n                res += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> i == <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> counting:\n                counting = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":1694,"excerpt":"","more":"<h1 id=\"最长回文串\">409. 最长回文串</h1>\n<p>贪心法。回文串要满足的条件就是出现奇数次的字符数量要小于等于1。所以，对于每个字符来讲，如果它出现为奇数次，就可以用<code>n-1</code>次；如果它出现为偶数次，就可以用<code>n</code>次。如果有出现奇数次的字符，最后结果再加1，没有就不管了。按照这种思路用一个<code>flag</code>记录是否有出现过奇数次的字符。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">longestPalindrome</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        hashmap = &#123;&#125;\n        flag = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> hashmap:\n                hashmap[i] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                hashmap[i] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> hashmap.values():\n            <span class=\"hljs-keyword\">if</span> value%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n                res += value\n            <span class=\"hljs-keyword\">else</span>:\n                res += value -<span class=\"hljs-number\">1</span>\n                flag = <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">return</span> res+<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">if</span> flag <span class=\"hljs-keyword\">else</span> res</code></pre>\n<h1 id=\"fizz-buzz\">412. Fizz Buzz</h1>\n<p>感觉就是一个穷举。</p>\n<p>看了一下讨论，好像这道题背后有故事，就是来筛选不会编程的人。</p>\n<blockquote>\n<p><a\nhref=\"https://blog.codinghorror.com/why-cant-programmers-program/\">Why\nCan't Programmers.. Program?</a></p>\n</blockquote>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fizzBuzz</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, n+<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">15</span> == <span class=\"hljs-number\">0</span>:\n                res.append(<span class=\"hljs-string\">&#x27;FizzBuzz&#x27;</span>)\n            <span class=\"hljs-keyword\">elif</span> i%<span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span>:\n                res.append(<span class=\"hljs-string\">&#x27;Buzz&#x27;</span>)\n            <span class=\"hljs-keyword\">elif</span> i%<span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>:\n                res.append(<span class=\"hljs-string\">&#x27;Fizz&#x27;</span>)\n            <span class=\"hljs-keyword\">else</span>:\n                res.append(<span class=\"hljs-built_in\">str</span>(i))\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"第三大的数\">414. 第三大的数</h1>\n<p>先去重再排除两次最大值是可以的。而且也不慢。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">thirdMax</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        lst = <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">set</span>(nums))\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(lst) &lt; <span class=\"hljs-number\">3</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(lst)\n        lst.remove(<span class=\"hljs-built_in\">max</span>(lst))\n        lst.remove(<span class=\"hljs-built_in\">max</span>(lst))\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(lst)</code></pre>\n<p>排序也试了下，稍微慢点。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">thirdMax</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        lst = <span class=\"hljs-built_in\">sorted</span>(nums, reverse = <span class=\"hljs-literal\">True</span>)\n        count = <span class=\"hljs-number\">1</span>\n        temp = lst[<span class=\"hljs-number\">0</span>]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> lst:\n            <span class=\"hljs-keyword\">if</span> i != temp:\n                count += <span class=\"hljs-number\">1</span>\n                temp = i\n            <span class=\"hljs-keyword\">if</span> count == <span class=\"hljs-number\">3</span>:\n                <span class=\"hljs-keyword\">return</span> i\n        <span class=\"hljs-keyword\">return</span> lst[<span class=\"hljs-number\">0</span>]</code></pre>\n<h1 id=\"字符串相加\">415. 字符串相加</h1>\n<p>从一个数的后面加到前面。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addStrings</span>(<span class=\"hljs-params\">self, num1: <span class=\"hljs-built_in\">str</span>, num2: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        carry = <span class=\"hljs-literal\">False</span>\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        len_1 = <span class=\"hljs-built_in\">len</span>(num1)\n        len_2 = <span class=\"hljs-built_in\">len</span>(num2)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-built_in\">max</span>(len_1,len_2)-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> i&lt;-len_1:\n                temp = <span class=\"hljs-built_in\">int</span>(num2[i])\n            <span class=\"hljs-keyword\">elif</span> i&lt;-len_2:\n                temp = <span class=\"hljs-built_in\">int</span>(num1[i])\n            <span class=\"hljs-keyword\">else</span>:\n                temp = <span class=\"hljs-built_in\">int</span>(num1[i])+<span class=\"hljs-built_in\">int</span>(num2[i])\n            <span class=\"hljs-keyword\">if</span> carry:\n                temp += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> temp &gt;= <span class=\"hljs-number\">10</span>:\n                temp -= <span class=\"hljs-number\">10</span>\n                carry = <span class=\"hljs-literal\">True</span>\n            <span class=\"hljs-keyword\">else</span>:\n                carry = <span class=\"hljs-literal\">False</span>\n            res = <span class=\"hljs-built_in\">str</span>(temp)+res\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;1&#x27;</span>+res <span class=\"hljs-keyword\">if</span> carry <span class=\"hljs-keyword\">else</span> res</code></pre>\n<h1 id=\"字符串中的单词数\">434. 字符串中的单词数</h1>\n<p>循环搜索。在没有计数的情况下，遇到非空格开始计数。在计数的情况下，遇到空格停止计数。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">countSegments</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-number\">0</span>\n        counting = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> s:\n            <span class=\"hljs-keyword\">if</span> i != <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> counting:\n                counting = <span class=\"hljs-literal\">True</span>\n                res += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> i == <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-keyword\">and</span> counting:\n                counting = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 441 448 453","date":"2022-07-18T17:59:10.000Z","_content":"\n# 441. 排列硬币\n\n首先是基本的累加。\n\n```python\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        x = 0\n        total = 0\n        while total<n:\n            x+=1\n            total +=x   \n        return x-1 if total!=n else x\n```\n\n然后其实可以看出这道题是一道求解不等式的问题，问题为：\n$$\n\\frac{x(x-1)}{2}\\le n\\lt\\frac{x(x+1)}{2}\n$$\n当 `n` 确定时，求解 `x` 的值。而且是顺序的，所以很自然想到了二分法。\n\n```python\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        l = 0\n        r = n\n        while l<=r:\n            mid = (l+r)//2\n            s = mid*(mid-1)//2\n            b = mid*(mid+1)//2\n            if s<=n<b:\n                return mid-1\n            elif n>=b:\n                l=mid+1\n            else:\n                r=mid-1\n        return l-1\n```\n\n# 448. 找到所有数组中消失的数字\n\n集合的差集运算。\n\n```python\nclass Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        set_all = set(range(1, len(nums)+1))\n        set_nums = set(nums)\n        return list(set_all-set_nums)\n```\n\n# 453. 最小操作次数使数组元素相等\n\n说句实话感觉这题应该不算简单题。\n\n这题最核心的是 `n-1` 个数都加一等价于`1` 个数减1。所以最后结果应该是\n$$\nresult=\\sum^{len(nums)-1}_{i=0}(nums[i]-min(nums))\n$$\n把`min(nums)`提出来就是\n$$\nresult = \\sum nums-n\\times min(nums)\n$$\n\n\n```python\nclass Solution:\n    def minMoves(self, nums: List[int]) -> int:\n        return sum(nums)-len(nums)*min(nums)\n```\n\n","source":"_posts/leetcode20220719.md","raw":"---\ntitle: LeetCode 441 448 453\ndate: 2022-07-19 01:59:10\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, greedy, hash, enumerate]\n---\n\n# 441. 排列硬币\n\n首先是基本的累加。\n\n```python\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        x = 0\n        total = 0\n        while total<n:\n            x+=1\n            total +=x   \n        return x-1 if total!=n else x\n```\n\n然后其实可以看出这道题是一道求解不等式的问题，问题为：\n$$\n\\frac{x(x-1)}{2}\\le n\\lt\\frac{x(x+1)}{2}\n$$\n当 `n` 确定时，求解 `x` 的值。而且是顺序的，所以很自然想到了二分法。\n\n```python\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        l = 0\n        r = n\n        while l<=r:\n            mid = (l+r)//2\n            s = mid*(mid-1)//2\n            b = mid*(mid+1)//2\n            if s<=n<b:\n                return mid-1\n            elif n>=b:\n                l=mid+1\n            else:\n                r=mid-1\n        return l-1\n```\n\n# 448. 找到所有数组中消失的数字\n\n集合的差集运算。\n\n```python\nclass Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        set_all = set(range(1, len(nums)+1))\n        set_nums = set(nums)\n        return list(set_all-set_nums)\n```\n\n# 453. 最小操作次数使数组元素相等\n\n说句实话感觉这题应该不算简单题。\n\n这题最核心的是 `n-1` 个数都加一等价于`1` 个数减1。所以最后结果应该是\n$$\nresult=\\sum^{len(nums)-1}_{i=0}(nums[i]-min(nums))\n$$\n把`min(nums)`提出来就是\n$$\nresult = \\sum nums-n\\times min(nums)\n$$\n\n\n```python\nclass Solution:\n    def minMoves(self, nums: List[int]) -> int:\n        return sum(nums)-len(nums)*min(nums)\n```\n\n","slug":"leetcode20220719","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g6002e142p4tdr3zb8","content":"<h1 id=\"排列硬币\">441. 排列硬币</h1>\n<p>首先是基本的累加。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">arrangeCoins</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        x = <span class=\"hljs-number\">0</span>\n        total = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> total&lt;n:\n            x+=<span class=\"hljs-number\">1</span>\n            total +=x   \n        <span class=\"hljs-keyword\">return</span> x-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">if</span> total!=n <span class=\"hljs-keyword\">else</span> x</code></pre></div>\n<p>然后其实可以看出这道题是一道求解不等式的问题，问题为： <span\nclass=\"math display\">\\[\n\\frac{x(x-1)}{2}\\le n\\lt\\frac{x(x+1)}{2}\n\\]</span> 当 <code>n</code> 确定时，求解 <code>x</code>\n的值。而且是顺序的，所以很自然想到了二分法。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">arrangeCoins</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        l = <span class=\"hljs-number\">0</span>\n        r = n\n        <span class=\"hljs-keyword\">while</span> l&lt;=r:\n            mid = (l+r)//<span class=\"hljs-number\">2</span>\n            s = mid*(mid-<span class=\"hljs-number\">1</span>)//<span class=\"hljs-number\">2</span>\n            b = mid*(mid+<span class=\"hljs-number\">1</span>)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> s&lt;=n&lt;b:\n                <span class=\"hljs-keyword\">return</span> mid-<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> n&gt;=b:\n                l=mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                r=mid-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> l-<span class=\"hljs-number\">1</span></code></pre></div>\n<h1 id=\"找到所有数组中消失的数字\">448. 找到所有数组中消失的数字</h1>\n<p>集合的差集运算。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findDisappearedNumbers</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        set_all = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(nums)+<span class=\"hljs-number\">1</span>))\n        set_nums = <span class=\"hljs-built_in\">set</span>(nums)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>(set_all-set_nums)</code></pre></div>\n<h1 id=\"最小操作次数使数组元素相等\">453. 最小操作次数使数组元素相等</h1>\n<p>说句实话感觉这题应该不算简单题。</p>\n<p>这题最核心的是 <code>n-1</code> 个数都加一等价于<code>1</code>\n个数减1。所以最后结果应该是 <span class=\"math display\">\\[\nresult=\\sum^{len(nums)-1}_{i=0}(nums[i]-min(nums))\n\\]</span> 把<code>min(nums)</code>提出来就是 <span\nclass=\"math display\">\\[\nresult = \\sum nums-n\\times min(nums)\n\\]</span></p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">minMoves</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sum</span>(nums)-<span class=\"hljs-built_in\">len</span>(nums)*<span class=\"hljs-built_in\">min</span>(nums)</code></pre></div>\n","site":{"data":{}},"wordcount":848,"excerpt":"","more":"<h1 id=\"排列硬币\">441. 排列硬币</h1>\n<p>首先是基本的累加。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">arrangeCoins</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        x = <span class=\"hljs-number\">0</span>\n        total = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> total&lt;n:\n            x+=<span class=\"hljs-number\">1</span>\n            total +=x   \n        <span class=\"hljs-keyword\">return</span> x-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">if</span> total!=n <span class=\"hljs-keyword\">else</span> x</code></pre>\n<p>然后其实可以看出这道题是一道求解不等式的问题，问题为： <span\nclass=\"math display\">\\[\n\\frac{x(x-1)}{2}\\le n\\lt\\frac{x(x+1)}{2}\n\\]</span> 当 <code>n</code> 确定时，求解 <code>x</code>\n的值。而且是顺序的，所以很自然想到了二分法。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">arrangeCoins</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        l = <span class=\"hljs-number\">0</span>\n        r = n\n        <span class=\"hljs-keyword\">while</span> l&lt;=r:\n            mid = (l+r)//<span class=\"hljs-number\">2</span>\n            s = mid*(mid-<span class=\"hljs-number\">1</span>)//<span class=\"hljs-number\">2</span>\n            b = mid*(mid+<span class=\"hljs-number\">1</span>)//<span class=\"hljs-number\">2</span>\n            <span class=\"hljs-keyword\">if</span> s&lt;=n&lt;b:\n                <span class=\"hljs-keyword\">return</span> mid-<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">elif</span> n&gt;=b:\n                l=mid+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                r=mid-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> l-<span class=\"hljs-number\">1</span></code></pre>\n<h1 id=\"找到所有数组中消失的数字\">448. 找到所有数组中消失的数字</h1>\n<p>集合的差集运算。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findDisappearedNumbers</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        set_all = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(nums)+<span class=\"hljs-number\">1</span>))\n        set_nums = <span class=\"hljs-built_in\">set</span>(nums)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>(set_all-set_nums)</code></pre>\n<h1 id=\"最小操作次数使数组元素相等\">453. 最小操作次数使数组元素相等</h1>\n<p>说句实话感觉这题应该不算简单题。</p>\n<p>这题最核心的是 <code>n-1</code> 个数都加一等价于<code>1</code>\n个数减1。所以最后结果应该是 <span class=\"math display\">\\[\nresult=\\sum^{len(nums)-1}_{i=0}(nums[i]-min(nums))\n\\]</span> 把<code>min(nums)</code>提出来就是 <span\nclass=\"math display\">\\[\nresult = \\sum nums-n\\times min(nums)\n\\]</span></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">minMoves</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sum</span>(nums)-<span class=\"hljs-built_in\">len</span>(nums)*<span class=\"hljs-built_in\">min</span>(nums)</code></pre>\n"},{"title":"LeetCode 455 459","date":"2022-07-25T08:13:46.000Z","_content":"\n# 455. 分发饼干\n\n首先可以排序之后贪心算法解决。\n\n```python\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        left = 0\n        right = 0\n        res = 0\n        len_g = len(g)\n        len_s = len(s)\n        while left<len_g and right<len_s:\n            if g[left] <= s[right]:\n                left += 1\n                res += 1\n            right += 1\n        return res\n```\n\n# 459. 重复的子字符串\n\n双指针。思路是如果字符串有子字符串长度为m 重复 n 次构成，那么它前 m 个字符与后 m 个字符是一样的，并且 m 重复 n 次与它本身也是一样的。\n\n```python\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        length = len(s)\n        if length == 1:\n            return False\n        left = 1\n        right = length-1\n        while left<=right:\n            if length%left == 0 and s[:left] == s[right:]:\n                if s[:left]*(length//left) == s:\n                    return True\n            left += 1\n            right -= 1\n        return False\n```\n\n","source":"_posts/leetcode20220725.md","raw":"---\ntitle: LeetCode 455 459\ndate: 2022-07-25 16:13:46\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, greedy, point]\n---\n\n# 455. 分发饼干\n\n首先可以排序之后贪心算法解决。\n\n```python\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        left = 0\n        right = 0\n        res = 0\n        len_g = len(g)\n        len_s = len(s)\n        while left<len_g and right<len_s:\n            if g[left] <= s[right]:\n                left += 1\n                res += 1\n            right += 1\n        return res\n```\n\n# 459. 重复的子字符串\n\n双指针。思路是如果字符串有子字符串长度为m 重复 n 次构成，那么它前 m 个字符与后 m 个字符是一样的，并且 m 重复 n 次与它本身也是一样的。\n\n```python\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        length = len(s)\n        if length == 1:\n            return False\n        left = 1\n        right = length-1\n        while left<=right:\n            if length%left == 0 and s[:left] == s[right:]:\n                if s[:left]*(length//left) == s:\n                    return True\n            left += 1\n            right -= 1\n        return False\n```\n\n","slug":"leetcode20220725","published":1,"updated":"2022-08-11T15:43:07.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g6002h142p3h33bvl1","content":"<h1 id=\"分发饼干\">455. 分发饼干</h1>\n<p>首先可以排序之后贪心算法解决。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findContentChildren</span>(<span class=\"hljs-params\">self, g: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], s: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        g.sort()\n        s.sort()\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-number\">0</span>\n        res = <span class=\"hljs-number\">0</span>\n        len_g = <span class=\"hljs-built_in\">len</span>(g)\n        len_s = <span class=\"hljs-built_in\">len</span>(s)\n        <span class=\"hljs-keyword\">while</span> left&lt;len_g <span class=\"hljs-keyword\">and</span> right&lt;len_s:\n            <span class=\"hljs-keyword\">if</span> g[left] &lt;= s[right]:\n                left += <span class=\"hljs-number\">1</span>\n                res += <span class=\"hljs-number\">1</span>\n            right += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"重复的子字符串\">459. 重复的子字符串</h1>\n<p>双指针。思路是如果字符串有子字符串长度为m 重复 n 次构成，那么它前 m\n个字符与后 m 个字符是一样的，并且 m 重复 n 次与它本身也是一样的。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">repeatedSubstringPattern</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        length = <span class=\"hljs-built_in\">len</span>(s)\n        <span class=\"hljs-keyword\">if</span> length == <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        left = <span class=\"hljs-number\">1</span>\n        right = length-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            <span class=\"hljs-keyword\">if</span> length%left == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> s[:left] == s[right:]:\n                <span class=\"hljs-keyword\">if</span> s[:left]*(length//left) == s:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n            left += <span class=\"hljs-number\">1</span>\n            right -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre></div>\n","site":{"data":{}},"wordcount":563,"excerpt":"","more":"<h1 id=\"分发饼干\">455. 分发饼干</h1>\n<p>首先可以排序之后贪心算法解决。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findContentChildren</span>(<span class=\"hljs-params\">self, g: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], s: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        g.sort()\n        s.sort()\n        left = <span class=\"hljs-number\">0</span>\n        right = <span class=\"hljs-number\">0</span>\n        res = <span class=\"hljs-number\">0</span>\n        len_g = <span class=\"hljs-built_in\">len</span>(g)\n        len_s = <span class=\"hljs-built_in\">len</span>(s)\n        <span class=\"hljs-keyword\">while</span> left&lt;len_g <span class=\"hljs-keyword\">and</span> right&lt;len_s:\n            <span class=\"hljs-keyword\">if</span> g[left] &lt;= s[right]:\n                left += <span class=\"hljs-number\">1</span>\n                res += <span class=\"hljs-number\">1</span>\n            right += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"重复的子字符串\">459. 重复的子字符串</h1>\n<p>双指针。思路是如果字符串有子字符串长度为m 重复 n 次构成，那么它前 m\n个字符与后 m 个字符是一样的，并且 m 重复 n 次与它本身也是一样的。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">repeatedSubstringPattern</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n        length = <span class=\"hljs-built_in\">len</span>(s)\n        <span class=\"hljs-keyword\">if</span> length == <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n        left = <span class=\"hljs-number\">1</span>\n        right = length-<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">while</span> left&lt;=right:\n            <span class=\"hljs-keyword\">if</span> length%left == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> s[:left] == s[right:]:\n                <span class=\"hljs-keyword\">if</span> s[:left]*(length//left) == s:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n            left += <span class=\"hljs-number\">1</span>\n            right -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span></code></pre>\n"},{"title":"LeetCode 492 495","date":"2022-08-02T04:08:28.000Z","_content":"\n# 492. 构造矩形\n\n先获取面积的算术平方根的整数部分 `square_root` ，宽一定在 [1, square_root] 里，所以开始递减找长就行了，当面积能够整除宽的时候，就找到了长，直接返回。\n\n```python\nclass Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        s_root = round(area**0.5)\n        for i in range(s_root, 0, -1):\n            if area%i == 0:\n                return (area//i, i)\n        return None\n```\n\n# 495. 提莫攻击\n\n前探指针，遍历整个数组，做一下条件判断。\n\n```python\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        length = len(timeSeries)\n        res = 0\n        cur = 0\n        while cur<length:\n            pre = cur+1\n            if pre<length:\n                temp = timeSeries[cur]+duration-timeSeries[pre]\n                if temp <= 0:\n                    res += duration\n                else:\n                    res += duration-temp\n            else:\n                res += duration\n            cur = pre\n        return res\n```\n\n","source":"_posts/leetcode20220802-2.md","raw":"---\ntitle: LeetCode 492 495\ndate: 2022-08-02 12:08:28\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, point]\n---\n\n# 492. 构造矩形\n\n先获取面积的算术平方根的整数部分 `square_root` ，宽一定在 [1, square_root] 里，所以开始递减找长就行了，当面积能够整除宽的时候，就找到了长，直接返回。\n\n```python\nclass Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        s_root = round(area**0.5)\n        for i in range(s_root, 0, -1):\n            if area%i == 0:\n                return (area//i, i)\n        return None\n```\n\n# 495. 提莫攻击\n\n前探指针，遍历整个数组，做一下条件判断。\n\n```python\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        length = len(timeSeries)\n        res = 0\n        cur = 0\n        while cur<length:\n            pre = cur+1\n            if pre<length:\n                temp = timeSeries[cur]+duration-timeSeries[pre]\n                if temp <= 0:\n                    res += duration\n                else:\n                    res += duration-temp\n            else:\n                res += duration\n            cur = pre\n        return res\n```\n\n","slug":"leetcode20220802-2","published":1,"updated":"2022-08-11T15:43:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g7002k142phd9ibjp1","content":"<h1 id=\"构造矩形\">492. 构造矩形</h1>\n<p>先获取面积的算术平方根的整数部分 <code>square_root</code> ，宽一定在\n[1, square_root]\n里，所以开始递减找长就行了，当面积能够整除宽的时候，就找到了长，直接返回。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">constructRectangle</span>(<span class=\"hljs-params\">self, area: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        s_root = <span class=\"hljs-built_in\">round</span>(area**<span class=\"hljs-number\">0.5</span>)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(s_root, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> area%i == <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> (area//i, i)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre></div>\n<h1 id=\"提莫攻击\">495. 提莫攻击</h1>\n<p>前探指针，遍历整个数组，做一下条件判断。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findPoisonedDuration</span>(<span class=\"hljs-params\">self, timeSeries: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], duration: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        length = <span class=\"hljs-built_in\">len</span>(timeSeries)\n        res = <span class=\"hljs-number\">0</span>\n        cur = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> cur&lt;length:\n            pre = cur+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> pre&lt;length:\n                temp = timeSeries[cur]+duration-timeSeries[pre]\n                <span class=\"hljs-keyword\">if</span> temp &lt;= <span class=\"hljs-number\">0</span>:\n                    res += duration\n                <span class=\"hljs-keyword\">else</span>:\n                    res += duration-temp\n            <span class=\"hljs-keyword\">else</span>:\n                res += duration\n            cur = pre\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":562,"excerpt":"","more":"<h1 id=\"构造矩形\">492. 构造矩形</h1>\n<p>先获取面积的算术平方根的整数部分 <code>square_root</code> ，宽一定在\n[1, square_root]\n里，所以开始递减找长就行了，当面积能够整除宽的时候，就找到了长，直接返回。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">constructRectangle</span>(<span class=\"hljs-params\">self, area: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        s_root = <span class=\"hljs-built_in\">round</span>(area**<span class=\"hljs-number\">0.5</span>)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(s_root, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">if</span> area%i == <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> (area//i, i)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span></code></pre>\n<h1 id=\"提莫攻击\">495. 提莫攻击</h1>\n<p>前探指针，遍历整个数组，做一下条件判断。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findPoisonedDuration</span>(<span class=\"hljs-params\">self, timeSeries: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], duration: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        length = <span class=\"hljs-built_in\">len</span>(timeSeries)\n        res = <span class=\"hljs-number\">0</span>\n        cur = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> cur&lt;length:\n            pre = cur+<span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> pre&lt;length:\n                temp = timeSeries[cur]+duration-timeSeries[pre]\n                <span class=\"hljs-keyword\">if</span> temp &lt;= <span class=\"hljs-number\">0</span>:\n                    res += duration\n                <span class=\"hljs-keyword\">else</span>:\n                    res += duration-temp\n            <span class=\"hljs-keyword\">else</span>:\n                res += duration\n            cur = pre\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 461 463 476 482 485","date":"2022-08-01T16:11:22.000Z","_content":"\n# 461. 汉明距离\n\n那这道题，很明显需要一个异或 `^` 的运算，那异或完了之后所有二进制不同的位会变成 1， 之前的题里学到了 `n&(n-1)` 可以消除最后一个 1， 那么我们做一个循环消除的操作，直到这个异或结果为 0 就可以，用一个计数器来统计循环的次数。\n\n```python\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        res = x^y\n        count = 0\n        while res:\n            res &= res-1\n            count += 1\n        return count\n```\n\n# 463. 岛屿的周长\n\n把格子的点看作一个坐标，那么我们从左上建立坐标系。用一个元组 `(x1, y1, x2, y2)` 来表示一条边。用一个 `set` 来记录存放的边。然后遍历整个数组，当一个新的 `1` 被找到时，看一下它四条边是否在 `set` 里，在就删除，不在就添加。最后集合的长度就是周长。\n\n```python\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        hashset = set('')\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == 1:\n                    if (i, j, i+1, j) in hashset:\n                        hashset.remove((i, j, i+1, j))\n                    else:\n                        hashset.add((i, j, i+1, j))\n                    if (i, j, i, j+1) in hashset:\n                        hashset.remove((i, j, i, j+1))\n                    else:\n                        hashset.add((i, j, i, j+1))\n                    if (i, j+1, i+1, j+1) in hashset:\n                        hashset.remove((i, j+1, i+1, j+1))\n                    else:\n                        hashset.add((i, j+1, i+1, j+1))\n                    if (i+1, j, i+1, j+1) in hashset:\n                        hashset.remove((i+1, j, i+1, j+1))\n                    else:\n                        hashset.add((i+1, j, i+1, j+1))\n        return len(hashset)\n```\n\n# 476. 数字的补数\n\n转成字符串取反了之后再转回来。\n\n```python\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        str_num = str(bin(num)).replace('0b','')\n        res = ''\n        for i in str_num:\n            if i=='1':\n                res+='0'\n            else:\n                res+='1'\n        return int(res,2)\n```\n\n# 482. 密钥格式化\n\n从后往前添加格式化结果，注意异常情况的处理就行。\n\n```python\nclass Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        s = s.replace('-','').upper()\n        count = len(s)//k\n        other = len(s)%k\n        res = ''\n        for i in range(0, -count*k, -k):\n            if i == 0:\n                res = s[i-k:]\n            else:\n                res = s[i-k:i]+'-'+res\n        if other == 0:\n            return res\n        else:\n            if count != 0:\n                return s[:other]+'-'+res\n            else:\n                return s[:other]\n```\n\n# 485. 最大连续 1 的个数\n\n前探指针探寻 `1` 的位置，计数器计数。\n\n```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        count = 0\n        cur = 0\n        length = len(nums)\n        while cur<length:\n            if not nums[cur]:\n                cur += 1\n            else:\n                pre = cur+1\n                while pre<length and nums[pre]:\n                    pre += 1\n                count = max(count, pre-cur)\n                cur = pre+1\n        return count\n```\n\n或者设置一个 `flag` 来判断是否开始计数了，并用一个结果计数器和中间计数器控制整个遍历：\n\n```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        flag = False\n        res = 0\n        count = 0\n        for i in nums:\n            if i==1:\n                if flag:\n                    count+=1\n                else:\n                    flag = True\n                    count += 1\n            else:\n                if flag:\n                    flag = False\n                    res = max(res, count)\n                    count = 0\n        res = max(res, count)\n        return res\n```\n\n","source":"_posts/leetcode20220802.md","raw":"---\ntitle: LeetCode 461 463 476 482 485\ndate: 2022-08-02 00:11:22\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash, point, bit, string]\n---\n\n# 461. 汉明距离\n\n那这道题，很明显需要一个异或 `^` 的运算，那异或完了之后所有二进制不同的位会变成 1， 之前的题里学到了 `n&(n-1)` 可以消除最后一个 1， 那么我们做一个循环消除的操作，直到这个异或结果为 0 就可以，用一个计数器来统计循环的次数。\n\n```python\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        res = x^y\n        count = 0\n        while res:\n            res &= res-1\n            count += 1\n        return count\n```\n\n# 463. 岛屿的周长\n\n把格子的点看作一个坐标，那么我们从左上建立坐标系。用一个元组 `(x1, y1, x2, y2)` 来表示一条边。用一个 `set` 来记录存放的边。然后遍历整个数组，当一个新的 `1` 被找到时，看一下它四条边是否在 `set` 里，在就删除，不在就添加。最后集合的长度就是周长。\n\n```python\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        hashset = set('')\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == 1:\n                    if (i, j, i+1, j) in hashset:\n                        hashset.remove((i, j, i+1, j))\n                    else:\n                        hashset.add((i, j, i+1, j))\n                    if (i, j, i, j+1) in hashset:\n                        hashset.remove((i, j, i, j+1))\n                    else:\n                        hashset.add((i, j, i, j+1))\n                    if (i, j+1, i+1, j+1) in hashset:\n                        hashset.remove((i, j+1, i+1, j+1))\n                    else:\n                        hashset.add((i, j+1, i+1, j+1))\n                    if (i+1, j, i+1, j+1) in hashset:\n                        hashset.remove((i+1, j, i+1, j+1))\n                    else:\n                        hashset.add((i+1, j, i+1, j+1))\n        return len(hashset)\n```\n\n# 476. 数字的补数\n\n转成字符串取反了之后再转回来。\n\n```python\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        str_num = str(bin(num)).replace('0b','')\n        res = ''\n        for i in str_num:\n            if i=='1':\n                res+='0'\n            else:\n                res+='1'\n        return int(res,2)\n```\n\n# 482. 密钥格式化\n\n从后往前添加格式化结果，注意异常情况的处理就行。\n\n```python\nclass Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        s = s.replace('-','').upper()\n        count = len(s)//k\n        other = len(s)%k\n        res = ''\n        for i in range(0, -count*k, -k):\n            if i == 0:\n                res = s[i-k:]\n            else:\n                res = s[i-k:i]+'-'+res\n        if other == 0:\n            return res\n        else:\n            if count != 0:\n                return s[:other]+'-'+res\n            else:\n                return s[:other]\n```\n\n# 485. 最大连续 1 的个数\n\n前探指针探寻 `1` 的位置，计数器计数。\n\n```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        count = 0\n        cur = 0\n        length = len(nums)\n        while cur<length:\n            if not nums[cur]:\n                cur += 1\n            else:\n                pre = cur+1\n                while pre<length and nums[pre]:\n                    pre += 1\n                count = max(count, pre-cur)\n                cur = pre+1\n        return count\n```\n\n或者设置一个 `flag` 来判断是否开始计数了，并用一个结果计数器和中间计数器控制整个遍历：\n\n```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        flag = False\n        res = 0\n        count = 0\n        for i in nums:\n            if i==1:\n                if flag:\n                    count+=1\n                else:\n                    flag = True\n                    count += 1\n            else:\n                if flag:\n                    flag = False\n                    res = max(res, count)\n                    count = 0\n        res = max(res, count)\n        return res\n```\n\n","slug":"leetcode20220802","published":1,"updated":"2022-08-11T15:43:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g8002n142p4l8k3g03","content":"<h1 id=\"汉明距离\">461. 汉明距离</h1>\n<p>那这道题，很明显需要一个异或 <code>^</code>\n的运算，那异或完了之后所有二进制不同的位会变成 1， 之前的题里学到了\n<code>n&amp;(n-1)</code> 可以消除最后一个 1，\n那么我们做一个循环消除的操作，直到这个异或结果为 0\n就可以，用一个计数器来统计循环的次数。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingDistance</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span>, y: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = x^y\n        count = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> res:\n            res &amp;= res-<span class=\"hljs-number\">1</span>\n            count += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> count</code></pre></div>\n<h1 id=\"岛屿的周长\">463. 岛屿的周长</h1>\n<p>把格子的点看作一个坐标，那么我们从左上建立坐标系。用一个元组\n<code>(x1, y1, x2, y2)</code> 来表示一条边。用一个 <code>set</code>\n来记录存放的边。然后遍历整个数组，当一个新的 <code>1</code>\n被找到时，看一下它四条边是否在 <code>set</code>\n里，在就删除，不在就添加。最后集合的长度就是周长。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">islandPerimeter</span>(<span class=\"hljs-params\">self, grid: <span class=\"hljs-type\">List</span>[<span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(grid)):\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(grid[i])):\n                <span class=\"hljs-keyword\">if</span> grid[i][j] == <span class=\"hljs-number\">1</span>:\n                    <span class=\"hljs-keyword\">if</span> (i, j, i+<span class=\"hljs-number\">1</span>, j) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i, j, i+<span class=\"hljs-number\">1</span>, j))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i, j, i+<span class=\"hljs-number\">1</span>, j))\n                    <span class=\"hljs-keyword\">if</span> (i, j, i, j+<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i, j, i, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i, j, i, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">if</span> (i, j+<span class=\"hljs-number\">1</span>, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i, j+<span class=\"hljs-number\">1</span>, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i, j+<span class=\"hljs-number\">1</span>, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">if</span> (i+<span class=\"hljs-number\">1</span>, j, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i+<span class=\"hljs-number\">1</span>, j, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i+<span class=\"hljs-number\">1</span>, j, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(hashset)</code></pre></div>\n<h1 id=\"数字的补数\">476. 数字的补数</h1>\n<p>转成字符串取反了之后再转回来。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findComplement</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        str_num = <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(num)).replace(<span class=\"hljs-string\">&#x27;0b&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> str_num:\n            <span class=\"hljs-keyword\">if</span> i==<span class=\"hljs-string\">&#x27;1&#x27;</span>:\n                res+=<span class=\"hljs-string\">&#x27;0&#x27;</span>\n            <span class=\"hljs-keyword\">else</span>:\n                res+=<span class=\"hljs-string\">&#x27;1&#x27;</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(res,<span class=\"hljs-number\">2</span>)</code></pre></div>\n<h1 id=\"密钥格式化\">482. 密钥格式化</h1>\n<p>从后往前添加格式化结果，注意异常情况的处理就行。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">licenseKeyFormatting</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        s = s.replace(<span class=\"hljs-string\">&#x27;-&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>).upper()\n        count = <span class=\"hljs-built_in\">len</span>(s)//k\n        other = <span class=\"hljs-built_in\">len</span>(s)%k\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, -count*k, -k):\n            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span>:\n                res = s[i-k:]\n            <span class=\"hljs-keyword\">else</span>:\n                res = s[i-k:i]+<span class=\"hljs-string\">&#x27;-&#x27;</span>+res\n        <span class=\"hljs-keyword\">if</span> other == <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">return</span> res\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">if</span> count != <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> s[:other]+<span class=\"hljs-string\">&#x27;-&#x27;</span>+res\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> s[:other]</code></pre></div>\n<h1 id=\"最大连续-1-的个数\">485. 最大连续 1 的个数</h1>\n<p>前探指针探寻 <code>1</code> 的位置，计数器计数。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findMaxConsecutiveOnes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        count = <span class=\"hljs-number\">0</span>\n        cur = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> cur&lt;length:\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> nums[cur]:\n                cur += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                pre = cur+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">while</span> pre&lt;length <span class=\"hljs-keyword\">and</span> nums[pre]:\n                    pre += <span class=\"hljs-number\">1</span>\n                count = <span class=\"hljs-built_in\">max</span>(count, pre-cur)\n                cur = pre+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> count</code></pre></div>\n<p>或者设置一个 <code>flag</code>\n来判断是否开始计数了，并用一个结果计数器和中间计数器控制整个遍历：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findMaxConsecutiveOnes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        flag = <span class=\"hljs-literal\">False</span>\n        res = <span class=\"hljs-number\">0</span>\n        count = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i==<span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">if</span> flag:\n                    count+=<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    flag = <span class=\"hljs-literal\">True</span>\n                    count += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> flag:\n                    flag = <span class=\"hljs-literal\">False</span>\n                    res = <span class=\"hljs-built_in\">max</span>(res, count)\n                    count = <span class=\"hljs-number\">0</span>\n        res = <span class=\"hljs-built_in\">max</span>(res, count)\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":2007,"excerpt":"","more":"<h1 id=\"汉明距离\">461. 汉明距离</h1>\n<p>那这道题，很明显需要一个异或 <code>^</code>\n的运算，那异或完了之后所有二进制不同的位会变成 1， 之前的题里学到了\n<code>n&amp;(n-1)</code> 可以消除最后一个 1，\n那么我们做一个循环消除的操作，直到这个异或结果为 0\n就可以，用一个计数器来统计循环的次数。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hammingDistance</span>(<span class=\"hljs-params\">self, x: <span class=\"hljs-built_in\">int</span>, y: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        res = x^y\n        count = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> res:\n            res &amp;= res-<span class=\"hljs-number\">1</span>\n            count += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> count</code></pre>\n<h1 id=\"岛屿的周长\">463. 岛屿的周长</h1>\n<p>把格子的点看作一个坐标，那么我们从左上建立坐标系。用一个元组\n<code>(x1, y1, x2, y2)</code> 来表示一条边。用一个 <code>set</code>\n来记录存放的边。然后遍历整个数组，当一个新的 <code>1</code>\n被找到时，看一下它四条边是否在 <code>set</code>\n里，在就删除，不在就添加。最后集合的长度就是周长。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">islandPerimeter</span>(<span class=\"hljs-params\">self, grid: <span class=\"hljs-type\">List</span>[<span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        hashset = <span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(grid)):\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(grid[i])):\n                <span class=\"hljs-keyword\">if</span> grid[i][j] == <span class=\"hljs-number\">1</span>:\n                    <span class=\"hljs-keyword\">if</span> (i, j, i+<span class=\"hljs-number\">1</span>, j) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i, j, i+<span class=\"hljs-number\">1</span>, j))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i, j, i+<span class=\"hljs-number\">1</span>, j))\n                    <span class=\"hljs-keyword\">if</span> (i, j, i, j+<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i, j, i, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i, j, i, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">if</span> (i, j+<span class=\"hljs-number\">1</span>, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i, j+<span class=\"hljs-number\">1</span>, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i, j+<span class=\"hljs-number\">1</span>, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">if</span> (i+<span class=\"hljs-number\">1</span>, j, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">in</span> hashset:\n                        hashset.remove((i+<span class=\"hljs-number\">1</span>, j, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n                    <span class=\"hljs-keyword\">else</span>:\n                        hashset.add((i+<span class=\"hljs-number\">1</span>, j, i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span>))\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(hashset)</code></pre>\n<h1 id=\"数字的补数\">476. 数字的补数</h1>\n<p>转成字符串取反了之后再转回来。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findComplement</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        str_num = <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">bin</span>(num)).replace(<span class=\"hljs-string\">&#x27;0b&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>)\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> str_num:\n            <span class=\"hljs-keyword\">if</span> i==<span class=\"hljs-string\">&#x27;1&#x27;</span>:\n                res+=<span class=\"hljs-string\">&#x27;0&#x27;</span>\n            <span class=\"hljs-keyword\">else</span>:\n                res+=<span class=\"hljs-string\">&#x27;1&#x27;</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(res,<span class=\"hljs-number\">2</span>)</code></pre>\n<h1 id=\"密钥格式化\">482. 密钥格式化</h1>\n<p>从后往前添加格式化结果，注意异常情况的处理就行。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">licenseKeyFormatting</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        s = s.replace(<span class=\"hljs-string\">&#x27;-&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>).upper()\n        count = <span class=\"hljs-built_in\">len</span>(s)//k\n        other = <span class=\"hljs-built_in\">len</span>(s)%k\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, -count*k, -k):\n            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span>:\n                res = s[i-k:]\n            <span class=\"hljs-keyword\">else</span>:\n                res = s[i-k:i]+<span class=\"hljs-string\">&#x27;-&#x27;</span>+res\n        <span class=\"hljs-keyword\">if</span> other == <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">return</span> res\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">if</span> count != <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">return</span> s[:other]+<span class=\"hljs-string\">&#x27;-&#x27;</span>+res\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> s[:other]</code></pre>\n<h1 id=\"最大连续-1-的个数\">485. 最大连续 1 的个数</h1>\n<p>前探指针探寻 <code>1</code> 的位置，计数器计数。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findMaxConsecutiveOnes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        count = <span class=\"hljs-number\">0</span>\n        cur = <span class=\"hljs-number\">0</span>\n        length = <span class=\"hljs-built_in\">len</span>(nums)\n        <span class=\"hljs-keyword\">while</span> cur&lt;length:\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> nums[cur]:\n                cur += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                pre = cur+<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">while</span> pre&lt;length <span class=\"hljs-keyword\">and</span> nums[pre]:\n                    pre += <span class=\"hljs-number\">1</span>\n                count = <span class=\"hljs-built_in\">max</span>(count, pre-cur)\n                cur = pre+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> count</code></pre>\n<p>或者设置一个 <code>flag</code>\n来判断是否开始计数了，并用一个结果计数器和中间计数器控制整个遍历：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findMaxConsecutiveOnes</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        flag = <span class=\"hljs-literal\">False</span>\n        res = <span class=\"hljs-number\">0</span>\n        count = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> i==<span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-keyword\">if</span> flag:\n                    count+=<span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    flag = <span class=\"hljs-literal\">True</span>\n                    count += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">if</span> flag:\n                    flag = <span class=\"hljs-literal\">False</span>\n                    res = <span class=\"hljs-built_in\">max</span>(res, count)\n                    count = <span class=\"hljs-number\">0</span>\n        res = <span class=\"hljs-built_in\">max</span>(res, count)\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode 496 500","date":"2022-08-08T17:20:13.000Z","_content":"\n# 496. 下一个更大元素 I\n\n首先很容易想到暴力法：\n\n```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        res = []\n        nums2_len = len(nums2)\n        for i in nums1:\n            j = nums2.index(i)+1\n            flag = False\n            for v in range(j, nums2_len):\n                if nums2[v] > i:\n                    res.append(nums2[v])\n                    flag = True\n                    break\n            if not flag:\n                res.append(-1)\n        return res\n```\n\n不过很慢。很明显，从慢的时间上来讲，肯定是算法不够好而不是没有优化。然后观察上面的算法可以发现，其实慢就慢在 `j = nums2.index(i)+1` 这里。每次都得重新去寻找元素的下标，这个时候就会想到空间换时间这种方法，就会想到 `dict` ，也就是哈希：\n\n```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        res = []\n        hashmap = {}\n        nums2_len = len(nums2)\n        for i,v in enumerate(nums2):\n            hashmap[v] = i\n        for i in nums1:\n            j = hashmap[i]+1\n            flag = False\n            while j<nums2_len:\n                if nums2[j] > i:\n                    res.append(nums2[j])\n                    flag = True\n                    break\n                j += 1\n            if not flag:\n                res.append(-1)\n        return res\n```\n\n# 500. 键盘行\n\n用 `dict` 记录字母所在行，然后暴力解法。\n\n```python\nclass Solution:\n    def findWords(self, words: List[str]) -> List[str]:\n        res = []\n        hashmap = {\n            'q':1,'w':1,'e':1,'r':1,'t':1,'y':1,'u':1,'i':1,'o':1,'p':1,\n            'a':2,'s':2,'d':2,'f':2,\"g\":2,'h':2,'j':2,'k':2,'l':2,\n            'z':3,'x':3,'c':3,'v':3,'b':3,'n':3,'m':3\n        }\n        for i in range(len(words)):\n            flag = 0\n            for v in words[i].lower():\n                if flag == 0:\n                    flag = hashmap[v]\n                elif flag != hashmap[v]:\n                    flag = -1\n                    break\n            if flag != -1:\n                res.append(words[i])\n        return res\n```\n\n","source":"_posts/leetcode20220809.md","raw":"---\ntitle: LeetCode 496 500\ndate: 2022-08-09 01:20:13\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python, hash]\n---\n\n# 496. 下一个更大元素 I\n\n首先很容易想到暴力法：\n\n```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        res = []\n        nums2_len = len(nums2)\n        for i in nums1:\n            j = nums2.index(i)+1\n            flag = False\n            for v in range(j, nums2_len):\n                if nums2[v] > i:\n                    res.append(nums2[v])\n                    flag = True\n                    break\n            if not flag:\n                res.append(-1)\n        return res\n```\n\n不过很慢。很明显，从慢的时间上来讲，肯定是算法不够好而不是没有优化。然后观察上面的算法可以发现，其实慢就慢在 `j = nums2.index(i)+1` 这里。每次都得重新去寻找元素的下标，这个时候就会想到空间换时间这种方法，就会想到 `dict` ，也就是哈希：\n\n```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        res = []\n        hashmap = {}\n        nums2_len = len(nums2)\n        for i,v in enumerate(nums2):\n            hashmap[v] = i\n        for i in nums1:\n            j = hashmap[i]+1\n            flag = False\n            while j<nums2_len:\n                if nums2[j] > i:\n                    res.append(nums2[j])\n                    flag = True\n                    break\n                j += 1\n            if not flag:\n                res.append(-1)\n        return res\n```\n\n# 500. 键盘行\n\n用 `dict` 记录字母所在行，然后暴力解法。\n\n```python\nclass Solution:\n    def findWords(self, words: List[str]) -> List[str]:\n        res = []\n        hashmap = {\n            'q':1,'w':1,'e':1,'r':1,'t':1,'y':1,'u':1,'i':1,'o':1,'p':1,\n            'a':2,'s':2,'d':2,'f':2,\"g\":2,'h':2,'j':2,'k':2,'l':2,\n            'z':3,'x':3,'c':3,'v':3,'b':3,'n':3,'m':3\n        }\n        for i in range(len(words)):\n            flag = 0\n            for v in words[i].lower():\n                if flag == 0:\n                    flag = hashmap[v]\n                elif flag != hashmap[v]:\n                    flag = -1\n                    break\n            if flag != -1:\n                res.append(words[i])\n        return res\n```\n\n","slug":"leetcode20220809","published":1,"updated":"2022-08-11T15:43:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g8002p142p4wqc4b3a","content":"<h1 id=\"下一个更大元素-i\">496. 下一个更大元素 I</h1>\n<p>首先很容易想到暴力法：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">nextGreaterElement</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        nums2_len = <span class=\"hljs-built_in\">len</span>(nums2)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums1:\n            j = nums2.index(i)+<span class=\"hljs-number\">1</span>\n            flag = <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(j, nums2_len):\n                <span class=\"hljs-keyword\">if</span> nums2[v] &gt; i:\n                    res.append(nums2[v])\n                    flag = <span class=\"hljs-literal\">True</span>\n                    <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> flag:\n                res.append(-<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<p>不过很慢。很明显，从慢的时间上来讲，肯定是算法不够好而不是没有优化。然后观察上面的算法可以发现，其实慢就慢在\n<code>j = nums2.index(i)+1</code>\n这里。每次都得重新去寻找元素的下标，这个时候就会想到空间换时间这种方法，就会想到\n<code>dict</code> ，也就是哈希：</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">nextGreaterElement</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        hashmap = &#123;&#125;\n        nums2_len = <span class=\"hljs-built_in\">len</span>(nums2)\n        <span class=\"hljs-keyword\">for</span> i,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums2):\n            hashmap[v] = i\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums1:\n            j = hashmap[i]+<span class=\"hljs-number\">1</span>\n            flag = <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">while</span> j&lt;nums2_len:\n                <span class=\"hljs-keyword\">if</span> nums2[j] &gt; i:\n                    res.append(nums2[j])\n                    flag = <span class=\"hljs-literal\">True</span>\n                    <span class=\"hljs-keyword\">break</span>\n                j += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> flag:\n                res.append(-<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n<h1 id=\"键盘行\">500. 键盘行</h1>\n<p>用 <code>dict</code> 记录字母所在行，然后暴力解法。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findWords</span>(<span class=\"hljs-params\">self, words: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        hashmap = &#123;\n            <span class=\"hljs-string\">&#x27;q&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;w&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;r&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;t&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;y&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;u&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;i&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;o&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;p&#x27;</span>:<span class=\"hljs-number\">1</span>,\n            <span class=\"hljs-string\">&#x27;a&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;s&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;f&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;g&quot;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;h&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;j&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;k&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;l&#x27;</span>:<span class=\"hljs-number\">2</span>,\n            <span class=\"hljs-string\">&#x27;z&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;x&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;v&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;n&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;m&#x27;</span>:<span class=\"hljs-number\">3</span>\n        &#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(words)):\n            flag = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> words[i].lower():\n                <span class=\"hljs-keyword\">if</span> flag == <span class=\"hljs-number\">0</span>:\n                    flag = hashmap[v]\n                <span class=\"hljs-keyword\">elif</span> flag != hashmap[v]:\n                    flag = -<span class=\"hljs-number\">1</span>\n                    <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> flag != -<span class=\"hljs-number\">1</span>:\n                res.append(words[i])\n        <span class=\"hljs-keyword\">return</span> res</code></pre></div>\n","site":{"data":{}},"wordcount":1404,"excerpt":"","more":"<h1 id=\"下一个更大元素-i\">496. 下一个更大元素 I</h1>\n<p>首先很容易想到暴力法：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">nextGreaterElement</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        nums2_len = <span class=\"hljs-built_in\">len</span>(nums2)\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums1:\n            j = nums2.index(i)+<span class=\"hljs-number\">1</span>\n            flag = <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(j, nums2_len):\n                <span class=\"hljs-keyword\">if</span> nums2[v] &gt; i:\n                    res.append(nums2[v])\n                    flag = <span class=\"hljs-literal\">True</span>\n                    <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> flag:\n                res.append(-<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<p>不过很慢。很明显，从慢的时间上来讲，肯定是算法不够好而不是没有优化。然后观察上面的算法可以发现，其实慢就慢在\n<code>j = nums2.index(i)+1</code>\n这里。每次都得重新去寻找元素的下标，这个时候就会想到空间换时间这种方法，就会想到\n<code>dict</code> ，也就是哈希：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">nextGreaterElement</span>(<span class=\"hljs-params\">self, nums1: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], nums2: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = []\n        hashmap = &#123;&#125;\n        nums2_len = <span class=\"hljs-built_in\">len</span>(nums2)\n        <span class=\"hljs-keyword\">for</span> i,v <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums2):\n            hashmap[v] = i\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> nums1:\n            j = hashmap[i]+<span class=\"hljs-number\">1</span>\n            flag = <span class=\"hljs-literal\">False</span>\n            <span class=\"hljs-keyword\">while</span> j&lt;nums2_len:\n                <span class=\"hljs-keyword\">if</span> nums2[j] &gt; i:\n                    res.append(nums2[j])\n                    flag = <span class=\"hljs-literal\">True</span>\n                    <span class=\"hljs-keyword\">break</span>\n                j += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> flag:\n                res.append(-<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n<h1 id=\"键盘行\">500. 键盘行</h1>\n<p>用 <code>dict</code> 记录字母所在行，然后暴力解法。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findWords</span>(<span class=\"hljs-params\">self, words: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]:\n        res = []\n        hashmap = &#123;\n            <span class=\"hljs-string\">&#x27;q&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;w&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;r&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;t&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;y&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;u&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;i&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;o&#x27;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;p&#x27;</span>:<span class=\"hljs-number\">1</span>,\n            <span class=\"hljs-string\">&#x27;a&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;s&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;f&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;g&quot;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;h&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;j&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;k&#x27;</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;l&#x27;</span>:<span class=\"hljs-number\">2</span>,\n            <span class=\"hljs-string\">&#x27;z&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;x&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;v&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;n&#x27;</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;m&#x27;</span>:<span class=\"hljs-number\">3</span>\n        &#125;\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(words)):\n            flag = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> words[i].lower():\n                <span class=\"hljs-keyword\">if</span> flag == <span class=\"hljs-number\">0</span>:\n                    flag = hashmap[v]\n                <span class=\"hljs-keyword\">elif</span> flag != hashmap[v]:\n                    flag = -<span class=\"hljs-number\">1</span>\n                    <span class=\"hljs-keyword\">break</span>\n            <span class=\"hljs-keyword\">if</span> flag != -<span class=\"hljs-number\">1</span>:\n                res.append(words[i])\n        <span class=\"hljs-keyword\">return</span> res</code></pre>\n"},{"title":"LeetCode","date":"2022-08-11T04:41:14.000Z","_content":"\n# 504. 七进制数\n\n暴力法。\n\n```python\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num > 0:\n            neg = False\n        elif num < 0:\n            neg = True\n            num = -num\n        else:\n            return '0'\n        n = 0\n        while 7**n <= num:\n            n += 1\n        n -= 1\n        res = ''\n        while n>=0:\n            i = num//(7**n)\n            res += str(i)\n            num -= (7**n)*i\n            n -= 1\n        return f'-{res}' if neg else res\n```\n\n然而，将返回结果的字符串换成整数之后，速度提升了很多。这里可以看出字符串连接比整数相加效率要低。\n\n```python\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num >= 0:\n            neg = False\n        else:\n            neg = True\n            num = -num\n        n = 0\n        while 7**n <= num:\n            n += 1\n        n -= 1\n        res = 0\n        while n>=0:\n            i = num//(7**n)\n            res += (10**n)*i\n            num -= (7**n)*i\n            n -= 1\n        return '-'+str(res) if neg else str(res)\n```\n\n","source":"_posts/leetcode20220811.md","raw":"---\ntitle: LeetCode \ndate: 2022-08-11 12:41:14\ncategories: [ComputerScience, Algorithm, LeetCode]\ntags: [python]\n---\n\n# 504. 七进制数\n\n暴力法。\n\n```python\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num > 0:\n            neg = False\n        elif num < 0:\n            neg = True\n            num = -num\n        else:\n            return '0'\n        n = 0\n        while 7**n <= num:\n            n += 1\n        n -= 1\n        res = ''\n        while n>=0:\n            i = num//(7**n)\n            res += str(i)\n            num -= (7**n)*i\n            n -= 1\n        return f'-{res}' if neg else res\n```\n\n然而，将返回结果的字符串换成整数之后，速度提升了很多。这里可以看出字符串连接比整数相加效率要低。\n\n```python\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num >= 0:\n            neg = False\n        else:\n            neg = True\n            num = -num\n        n = 0\n        while 7**n <= num:\n            n += 1\n        n -= 1\n        res = 0\n        while n>=0:\n            i = num//(7**n)\n            res += (10**n)*i\n            num -= (7**n)*i\n            n -= 1\n        return '-'+str(res) if neg else str(res)\n```\n\n","slug":"leetcode20220811","published":1,"updated":"2022-08-11T15:43:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1g9002t142phpivdjkm","content":"<h1 id=\"七进制数\">504. 七进制数</h1>\n<p>暴力法。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convertToBase7</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">if</span> num &gt; <span class=\"hljs-number\">0</span>:\n            neg = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">elif</span> num &lt; <span class=\"hljs-number\">0</span>:\n            neg = <span class=\"hljs-literal\">True</span>\n            num = -num\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;0&#x27;</span>\n        n = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-number\">7</span>**n &lt;= num:\n            n += <span class=\"hljs-number\">1</span>\n        n -= <span class=\"hljs-number\">1</span>\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">while</span> n&gt;=<span class=\"hljs-number\">0</span>:\n            i = num//(<span class=\"hljs-number\">7</span>**n)\n            res += <span class=\"hljs-built_in\">str</span>(i)\n            num -= (<span class=\"hljs-number\">7</span>**n)*i\n            n -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f&#x27;-<span class=\"hljs-subst\">&#123;res&#125;</span>&#x27;</span> <span class=\"hljs-keyword\">if</span> neg <span class=\"hljs-keyword\">else</span> res</code></pre></div>\n<p>然而，将返回结果的字符串换成整数之后，速度提升了很多。这里可以看出字符串连接比整数相加效率要低。</p>\n<div class=\"code-wrapper\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convertToBase7</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">if</span> num &gt;= <span class=\"hljs-number\">0</span>:\n            neg = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">else</span>:\n            neg = <span class=\"hljs-literal\">True</span>\n            num = -num\n        n = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-number\">7</span>**n &lt;= num:\n            n += <span class=\"hljs-number\">1</span>\n        n -= <span class=\"hljs-number\">1</span>\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> n&gt;=<span class=\"hljs-number\">0</span>:\n            i = num//(<span class=\"hljs-number\">7</span>**n)\n            res += (<span class=\"hljs-number\">10</span>**n)*i\n            num -= (<span class=\"hljs-number\">7</span>**n)*i\n            n -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;-&#x27;</span>+<span class=\"hljs-built_in\">str</span>(res) <span class=\"hljs-keyword\">if</span> neg <span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">str</span>(res)</code></pre></div>\n","site":{"data":{}},"wordcount":565,"excerpt":"","more":"<h1 id=\"七进制数\">504. 七进制数</h1>\n<p>暴力法。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convertToBase7</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">if</span> num &gt; <span class=\"hljs-number\">0</span>:\n            neg = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">elif</span> num &lt; <span class=\"hljs-number\">0</span>:\n            neg = <span class=\"hljs-literal\">True</span>\n            num = -num\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;0&#x27;</span>\n        n = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-number\">7</span>**n &lt;= num:\n            n += <span class=\"hljs-number\">1</span>\n        n -= <span class=\"hljs-number\">1</span>\n        res = <span class=\"hljs-string\">&#x27;&#x27;</span>\n        <span class=\"hljs-keyword\">while</span> n&gt;=<span class=\"hljs-number\">0</span>:\n            i = num//(<span class=\"hljs-number\">7</span>**n)\n            res += <span class=\"hljs-built_in\">str</span>(i)\n            num -= (<span class=\"hljs-number\">7</span>**n)*i\n            n -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f&#x27;-<span class=\"hljs-subst\">&#123;res&#125;</span>&#x27;</span> <span class=\"hljs-keyword\">if</span> neg <span class=\"hljs-keyword\">else</span> res</code></pre>\n<p>然而，将返回结果的字符串换成整数之后，速度提升了很多。这里可以看出字符串连接比整数相加效率要低。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convertToBase7</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">if</span> num &gt;= <span class=\"hljs-number\">0</span>:\n            neg = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">else</span>:\n            neg = <span class=\"hljs-literal\">True</span>\n            num = -num\n        n = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-number\">7</span>**n &lt;= num:\n            n += <span class=\"hljs-number\">1</span>\n        n -= <span class=\"hljs-number\">1</span>\n        res = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> n&gt;=<span class=\"hljs-number\">0</span>:\n            i = num//(<span class=\"hljs-number\">7</span>**n)\n            res += (<span class=\"hljs-number\">10</span>**n)*i\n            num -= (<span class=\"hljs-number\">7</span>**n)*i\n            n -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;-&#x27;</span>+<span class=\"hljs-built_in\">str</span>(res) <span class=\"hljs-keyword\">if</span> neg <span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">str</span>(res)</code></pre>\n"},{"title":"SSH Tunnel 实现 BI 工具连接数据库","date":"2022-06-19T09:57:38.000Z","_content":"\n# 背景\n\n最近项目需要 BI 工具看板做一个数据可视化的模块，服务器和数据库都是在云端的，每次访问数据库通过 Navicat 、Python 等工具去访问，但是很可惜，power BI 和 tableau 并没有 ssh 访问的入口（ Navicat 是有的）。关于如何通过这种方式访问数据库在网上没有符合预期的解答，后来经过研究，发现了答案。\n\n# 原理\n\nSSH 的理论在此不多赘述。整个连接过程分为两部分：\n\n- 服务器/远程主机某端口与本机某端口通过 ssh tunnel 连接，连接建立后我去访问本机某端口时，相当于访问服务器/远程主机对应端口。\n- 在 BI 工具（其实 Navicat 也可以，稍有不同）上访问本机的这个端口，而不是访问之前的 3306（ Mysql 默认的）端口。\n\n# 实操过程\n\n## 隧道搭建\n\n我的系统时 Windows 11，系统本身没有命令直接搭建 ssh 隧道。所以需要选择一款 ssh 客户端软件，我用的是 PuTTY （ 0.77 release 64-bit x86 ），下载地址如下：\n\n[https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)\n\n下载完了之后，我们打开 PuTTY，首先是主页面，也就是左侧 `Session` 的页面，这里有个 Host Name (or IP address) 和 Port。\n\n![配置 Session](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192238821.png)\n\n这里的 **Host Name 与 Port 是指的 ssh 服务器的 IP 地址与端口**，对应着 Navicat 如下位置：\n\n![对应的 ssh 服务器](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192244406.png)\n\n接着在左侧`Connection -> SSH -> Tunnels`这个界面，输入 Source port 与 Destination，输入完之后，点击 Add 添加。\n\n![配置单向隧道的源端口和目的端口](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192255705.png)\n\n这里的 **Source port 是指本机要用来建立隧道通信的端口**，我的建议是不要选太怪的数字，最好 10000 以上，65535 以下，也没有太大讲究，最好别和其它服务重合了。**Destination 则是远程主机/服务器的 IP 和端口**，我在 Google 里其实搜索到过搭隧道 tableau 连接远程主机的，它在演示的时候，自己跟自己建立的隧道，稍微不太方便理解这里的意思。Destination 对应着 Navicat 如下位置：\n\n![对应的目的端口](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192305530.png)\n\n然后在 PuTTY 里还需要配置一个地方，它位于 `Connection -> SSH -> Auth`，这个地方是添加私钥的地方，如下：\n\n![配置私钥](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192309718.png)\n\n它对应着 Navicat 里的：\n\n![对应私钥位置](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192310985.png)\n\n**但是其实并不能直接添加 `pem` 文件**，这个时候我们需要打开 PuTTYgen，点击 load，弹出文件选择页面时选择你的 pem 文件，然后点击 Save private key 保存一个 `ppk` 格式的文件。\n\n![私钥格式转换](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192315126.png)\n\n![image-20220619231701159](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192317180.png)\n\n这个时候就可以在 PuTTY 的页面添加这个 `ppk` 格式文件了，如图：\n\n![成功配置私钥](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192318792.png)\n\n回到 `Session ` 点击 `Save` 保存一下以免之后重新配（只用一次当我没说），配置方面就完成了。点击 `Open` 测试一波：\n\n![建立连接，登录账户](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192321988.png)\n\n输入用户名，这个用户名是 ssh 的用户名，对应着 Navicat 如下位置：\n\n![对应的 ssh 账户名](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192322747.png)\n\n然后其实就连上了。注意连上了之后不要关闭 PuTTY ，关了隧道就断开了。\n\n有时可能会突然挂掉，我采用了每隔一段时间发送空包的方式维持隧道。在 `Connection` 里，我把如下位置的值改成了 10：\n\n![保持隧道连接](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192328488.png)\n\n至此，ssh 客户端（ PuTTY ）这边的工作就结束了，下一步就是测试。\n\n## 连接测试\n\n因为我用 Navicat 是可以连接上的，所以我的选择是先用 Navicat 测试。有过 Navicat 通过 ssh 连接数据库经验的同学应该都知道，用这种方式连接数据库时，需要在 `常规` 和 `SSH` 两个页面分别配置，搭建隧道之后，只用配置 `常规` 页面就可以了。\n\n![Navicat 测试](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349956.png)\n\n这里：\n\n- 主机填写 `localhost` 或是 `127.0.0.1`  都可以。\n- 端口填写之前**在 PuTTY 里填写的 Source port**。\n- 用户名填写目的主机/服务器的用户名。\n- 密码填写目的主机/服务器的密码。\n\n![连接成功](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349512.png)\n\n接着在 power BI 上也测试一下。选择 MySQL 数据库。\n\n![power BI 选择数据库](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192355774.png)\n\n**服务器填写 `127.0.0.1:xxxx`，就是本机的 IP 地址加用于搭隧道的端口，也就是 PuTTY 里配置的 Source port 。**数据库填写你要连接的库名。\n\n![power BI 连接数据库](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192357463.png)\n\n高级选项下可以写 SQL 查询语句。然后在下一步选择 `数据库`，用户名填写目的主机/服务器的用户名，密码填写目的主机/服务器的密码，如下：\n\n![power BI 登录数据库账户](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206200000501.png)\n\n\n\n点击连接就可以了。\n\n","source":"_posts/ssh隧道实现bi连接数据库.md","raw":"---\ntitle: SSH Tunnel 实现 BI 工具连接数据库\ndate: 2022-06-19 17:57:38\ncategories: [DataScience, Database]\ntags: [ssh tunnel, mysql, powerbi, tableau]\n---\n\n# 背景\n\n最近项目需要 BI 工具看板做一个数据可视化的模块，服务器和数据库都是在云端的，每次访问数据库通过 Navicat 、Python 等工具去访问，但是很可惜，power BI 和 tableau 并没有 ssh 访问的入口（ Navicat 是有的）。关于如何通过这种方式访问数据库在网上没有符合预期的解答，后来经过研究，发现了答案。\n\n# 原理\n\nSSH 的理论在此不多赘述。整个连接过程分为两部分：\n\n- 服务器/远程主机某端口与本机某端口通过 ssh tunnel 连接，连接建立后我去访问本机某端口时，相当于访问服务器/远程主机对应端口。\n- 在 BI 工具（其实 Navicat 也可以，稍有不同）上访问本机的这个端口，而不是访问之前的 3306（ Mysql 默认的）端口。\n\n# 实操过程\n\n## 隧道搭建\n\n我的系统时 Windows 11，系统本身没有命令直接搭建 ssh 隧道。所以需要选择一款 ssh 客户端软件，我用的是 PuTTY （ 0.77 release 64-bit x86 ），下载地址如下：\n\n[https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)\n\n下载完了之后，我们打开 PuTTY，首先是主页面，也就是左侧 `Session` 的页面，这里有个 Host Name (or IP address) 和 Port。\n\n![配置 Session](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192238821.png)\n\n这里的 **Host Name 与 Port 是指的 ssh 服务器的 IP 地址与端口**，对应着 Navicat 如下位置：\n\n![对应的 ssh 服务器](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192244406.png)\n\n接着在左侧`Connection -> SSH -> Tunnels`这个界面，输入 Source port 与 Destination，输入完之后，点击 Add 添加。\n\n![配置单向隧道的源端口和目的端口](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192255705.png)\n\n这里的 **Source port 是指本机要用来建立隧道通信的端口**，我的建议是不要选太怪的数字，最好 10000 以上，65535 以下，也没有太大讲究，最好别和其它服务重合了。**Destination 则是远程主机/服务器的 IP 和端口**，我在 Google 里其实搜索到过搭隧道 tableau 连接远程主机的，它在演示的时候，自己跟自己建立的隧道，稍微不太方便理解这里的意思。Destination 对应着 Navicat 如下位置：\n\n![对应的目的端口](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192305530.png)\n\n然后在 PuTTY 里还需要配置一个地方，它位于 `Connection -> SSH -> Auth`，这个地方是添加私钥的地方，如下：\n\n![配置私钥](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192309718.png)\n\n它对应着 Navicat 里的：\n\n![对应私钥位置](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192310985.png)\n\n**但是其实并不能直接添加 `pem` 文件**，这个时候我们需要打开 PuTTYgen，点击 load，弹出文件选择页面时选择你的 pem 文件，然后点击 Save private key 保存一个 `ppk` 格式的文件。\n\n![私钥格式转换](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192315126.png)\n\n![image-20220619231701159](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192317180.png)\n\n这个时候就可以在 PuTTY 的页面添加这个 `ppk` 格式文件了，如图：\n\n![成功配置私钥](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192318792.png)\n\n回到 `Session ` 点击 `Save` 保存一下以免之后重新配（只用一次当我没说），配置方面就完成了。点击 `Open` 测试一波：\n\n![建立连接，登录账户](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192321988.png)\n\n输入用户名，这个用户名是 ssh 的用户名，对应着 Navicat 如下位置：\n\n![对应的 ssh 账户名](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192322747.png)\n\n然后其实就连上了。注意连上了之后不要关闭 PuTTY ，关了隧道就断开了。\n\n有时可能会突然挂掉，我采用了每隔一段时间发送空包的方式维持隧道。在 `Connection` 里，我把如下位置的值改成了 10：\n\n![保持隧道连接](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192328488.png)\n\n至此，ssh 客户端（ PuTTY ）这边的工作就结束了，下一步就是测试。\n\n## 连接测试\n\n因为我用 Navicat 是可以连接上的，所以我的选择是先用 Navicat 测试。有过 Navicat 通过 ssh 连接数据库经验的同学应该都知道，用这种方式连接数据库时，需要在 `常规` 和 `SSH` 两个页面分别配置，搭建隧道之后，只用配置 `常规` 页面就可以了。\n\n![Navicat 测试](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349956.png)\n\n这里：\n\n- 主机填写 `localhost` 或是 `127.0.0.1`  都可以。\n- 端口填写之前**在 PuTTY 里填写的 Source port**。\n- 用户名填写目的主机/服务器的用户名。\n- 密码填写目的主机/服务器的密码。\n\n![连接成功](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349512.png)\n\n接着在 power BI 上也测试一下。选择 MySQL 数据库。\n\n![power BI 选择数据库](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192355774.png)\n\n**服务器填写 `127.0.0.1:xxxx`，就是本机的 IP 地址加用于搭隧道的端口，也就是 PuTTY 里配置的 Source port 。**数据库填写你要连接的库名。\n\n![power BI 连接数据库](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192357463.png)\n\n高级选项下可以写 SQL 查询语句。然后在下一步选择 `数据库`，用户名填写目的主机/服务器的用户名，密码填写目的主机/服务器的密码，如下：\n\n![power BI 登录数据库账户](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206200000501.png)\n\n\n\n点击连接就可以了。\n\n","slug":"ssh隧道实现bi连接数据库","published":1,"updated":"2022-08-11T15:43:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1ga002v142p6sorc1og","content":"<h1 id=\"背景\">背景</h1>\n<p>最近项目需要 BI\n工具看板做一个数据可视化的模块，服务器和数据库都是在云端的，每次访问数据库通过\nNavicat 、Python 等工具去访问，但是很可惜，power BI 和 tableau 并没有\nssh 访问的入口（ Navicat\n是有的）。关于如何通过这种方式访问数据库在网上没有符合预期的解答，后来经过研究，发现了答案。</p>\n<h1 id=\"原理\">原理</h1>\n<p>SSH 的理论在此不多赘述。整个连接过程分为两部分：</p>\n<ul>\n<li>服务器/远程主机某端口与本机某端口通过 ssh tunnel\n连接，连接建立后我去访问本机某端口时，相当于访问服务器/远程主机对应端口。</li>\n<li>在 BI 工具（其实 Navicat\n也可以，稍有不同）上访问本机的这个端口，而不是访问之前的 3306（ Mysql\n默认的）端口。</li>\n</ul>\n<h1 id=\"实操过程\">实操过程</h1>\n<h2 id=\"隧道搭建\">隧道搭建</h2>\n<p>我的系统时 Windows 11，系统本身没有命令直接搭建 ssh\n隧道。所以需要选择一款 ssh 客户端软件，我用的是 PuTTY （ 0.77 release\n64-bit x86 ），下载地址如下：</p>\n<p><a\nhref=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p>\n<p>下载完了之后，我们打开 PuTTY，首先是主页面，也就是左侧\n<code>Session</code> 的页面，这里有个 Host Name (or IP address) 和\nPort。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192238821.png\"\nalt=\"配置 Session\" />\n<figcaption aria-hidden=\"true\">配置 Session</figcaption>\n</figure>\n<p>这里的 <strong>Host Name 与 Port 是指的 ssh 服务器的 IP\n地址与端口</strong>，对应着 Navicat 如下位置：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192244406.png\"\nalt=\"对应的 ssh 服务器\" />\n<figcaption aria-hidden=\"true\">对应的 ssh 服务器</figcaption>\n</figure>\n<p>接着在左侧<code>Connection -&gt; SSH -&gt; Tunnels</code>这个界面，输入\nSource port 与 Destination，输入完之后，点击 Add 添加。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192255705.png\"\nalt=\"配置单向隧道的源端口和目的端口\" />\n<figcaption\naria-hidden=\"true\">配置单向隧道的源端口和目的端口</figcaption>\n</figure>\n<p>这里的 <strong>Source port\n是指本机要用来建立隧道通信的端口</strong>，我的建议是不要选太怪的数字，最好\n10000 以上，65535\n以下，也没有太大讲究，最好别和其它服务重合了。<strong>Destination\n则是远程主机/服务器的 IP 和端口</strong>，我在 Google\n里其实搜索到过搭隧道 tableau\n连接远程主机的，它在演示的时候，自己跟自己建立的隧道，稍微不太方便理解这里的意思。Destination\n对应着 Navicat 如下位置：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192305530.png\"\nalt=\"对应的目的端口\" />\n<figcaption aria-hidden=\"true\">对应的目的端口</figcaption>\n</figure>\n<p>然后在 PuTTY 里还需要配置一个地方，它位于\n<code>Connection -&gt; SSH -&gt; Auth</code>，这个地方是添加私钥的地方，如下：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192309718.png\"\nalt=\"配置私钥\" />\n<figcaption aria-hidden=\"true\">配置私钥</figcaption>\n</figure>\n<p>它对应着 Navicat 里的：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192310985.png\"\nalt=\"对应私钥位置\" />\n<figcaption aria-hidden=\"true\">对应私钥位置</figcaption>\n</figure>\n<p><strong>但是其实并不能直接添加 <code>pem</code>\n文件</strong>，这个时候我们需要打开 PuTTYgen，点击\nload，弹出文件选择页面时选择你的 pem 文件，然后点击 Save private key\n保存一个 <code>ppk</code> 格式的文件。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192315126.png\"\nalt=\"私钥格式转换\" />\n<figcaption aria-hidden=\"true\">私钥格式转换</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192317180.png\"\nalt=\"image-20220619231701159\" />\n<figcaption aria-hidden=\"true\">image-20220619231701159</figcaption>\n</figure>\n<p>这个时候就可以在 PuTTY 的页面添加这个 <code>ppk</code>\n格式文件了，如图：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192318792.png\"\nalt=\"成功配置私钥\" />\n<figcaption aria-hidden=\"true\">成功配置私钥</figcaption>\n</figure>\n<p>回到 <code>Session</code> 点击 <code>Save</code>\n保存一下以免之后重新配（只用一次当我没说），配置方面就完成了。点击\n<code>Open</code> 测试一波：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192321988.png\"\nalt=\"建立连接，登录账户\" />\n<figcaption aria-hidden=\"true\">建立连接，登录账户</figcaption>\n</figure>\n<p>输入用户名，这个用户名是 ssh 的用户名，对应着 Navicat 如下位置：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192322747.png\"\nalt=\"对应的 ssh 账户名\" />\n<figcaption aria-hidden=\"true\">对应的 ssh 账户名</figcaption>\n</figure>\n<p>然后其实就连上了。注意连上了之后不要关闭 PuTTY\n，关了隧道就断开了。</p>\n<p>有时可能会突然挂掉，我采用了每隔一段时间发送空包的方式维持隧道。在\n<code>Connection</code> 里，我把如下位置的值改成了 10：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192328488.png\"\nalt=\"保持隧道连接\" />\n<figcaption aria-hidden=\"true\">保持隧道连接</figcaption>\n</figure>\n<p>至此，ssh 客户端（ PuTTY ）这边的工作就结束了，下一步就是测试。</p>\n<h2 id=\"连接测试\">连接测试</h2>\n<p>因为我用 Navicat 是可以连接上的，所以我的选择是先用 Navicat\n测试。有过 Navicat 通过 ssh\n连接数据库经验的同学应该都知道，用这种方式连接数据库时，需要在\n<code>常规</code> 和 <code>SSH</code>\n两个页面分别配置，搭建隧道之后，只用配置 <code>常规</code>\n页面就可以了。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349956.png\"\nalt=\"Navicat 测试\" />\n<figcaption aria-hidden=\"true\">Navicat 测试</figcaption>\n</figure>\n<p>这里：</p>\n<ul>\n<li>主机填写 <code>localhost</code> 或是 <code>127.0.0.1</code>\n都可以。</li>\n<li>端口填写之前<strong>在 PuTTY 里填写的 Source port</strong>。</li>\n<li>用户名填写目的主机/服务器的用户名。</li>\n<li>密码填写目的主机/服务器的密码。</li>\n</ul>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349512.png\"\nalt=\"连接成功\" />\n<figcaption aria-hidden=\"true\">连接成功</figcaption>\n</figure>\n<p>接着在 power BI 上也测试一下。选择 MySQL 数据库。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192355774.png\"\nalt=\"power BI 选择数据库\" />\n<figcaption aria-hidden=\"true\">power BI 选择数据库</figcaption>\n</figure>\n<p><strong>服务器填写 <code>127.0.0.1:xxxx</code>，就是本机的 IP\n地址加用于搭隧道的端口，也就是 PuTTY 里配置的 Source port\n。</strong>数据库填写你要连接的库名。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192357463.png\"\nalt=\"power BI 连接数据库\" />\n<figcaption aria-hidden=\"true\">power BI 连接数据库</figcaption>\n</figure>\n<p>高级选项下可以写 SQL 查询语句。然后在下一步选择\n<code>数据库</code>，用户名填写目的主机/服务器的用户名，密码填写目的主机/服务器的密码，如下：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206200000501.png\"\nalt=\"power BI 登录数据库账户\" />\n<figcaption aria-hidden=\"true\">power BI 登录数据库账户</figcaption>\n</figure>\n<p>点击连接就可以了。</p>\n","site":{"data":{}},"wordcount":1844,"excerpt":"","more":"<h1 id=\"背景\">背景</h1>\n<p>最近项目需要 BI\n工具看板做一个数据可视化的模块，服务器和数据库都是在云端的，每次访问数据库通过\nNavicat 、Python 等工具去访问，但是很可惜，power BI 和 tableau 并没有\nssh 访问的入口（ Navicat\n是有的）。关于如何通过这种方式访问数据库在网上没有符合预期的解答，后来经过研究，发现了答案。</p>\n<h1 id=\"原理\">原理</h1>\n<p>SSH 的理论在此不多赘述。整个连接过程分为两部分：</p>\n<ul>\n<li>服务器/远程主机某端口与本机某端口通过 ssh tunnel\n连接，连接建立后我去访问本机某端口时，相当于访问服务器/远程主机对应端口。</li>\n<li>在 BI 工具（其实 Navicat\n也可以，稍有不同）上访问本机的这个端口，而不是访问之前的 3306（ Mysql\n默认的）端口。</li>\n</ul>\n<h1 id=\"实操过程\">实操过程</h1>\n<h2 id=\"隧道搭建\">隧道搭建</h2>\n<p>我的系统时 Windows 11，系统本身没有命令直接搭建 ssh\n隧道。所以需要选择一款 ssh 客户端软件，我用的是 PuTTY （ 0.77 release\n64-bit x86 ），下载地址如下：</p>\n<p><a\nhref=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p>\n<p>下载完了之后，我们打开 PuTTY，首先是主页面，也就是左侧\n<code>Session</code> 的页面，这里有个 Host Name (or IP address) 和\nPort。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192238821.png\"\nalt=\"配置 Session\" />\n<figcaption aria-hidden=\"true\">配置 Session</figcaption>\n</figure>\n<p>这里的 <strong>Host Name 与 Port 是指的 ssh 服务器的 IP\n地址与端口</strong>，对应着 Navicat 如下位置：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192244406.png\"\nalt=\"对应的 ssh 服务器\" />\n<figcaption aria-hidden=\"true\">对应的 ssh 服务器</figcaption>\n</figure>\n<p>接着在左侧<code>Connection -&gt; SSH -&gt; Tunnels</code>这个界面，输入\nSource port 与 Destination，输入完之后，点击 Add 添加。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192255705.png\"\nalt=\"配置单向隧道的源端口和目的端口\" />\n<figcaption\naria-hidden=\"true\">配置单向隧道的源端口和目的端口</figcaption>\n</figure>\n<p>这里的 <strong>Source port\n是指本机要用来建立隧道通信的端口</strong>，我的建议是不要选太怪的数字，最好\n10000 以上，65535\n以下，也没有太大讲究，最好别和其它服务重合了。<strong>Destination\n则是远程主机/服务器的 IP 和端口</strong>，我在 Google\n里其实搜索到过搭隧道 tableau\n连接远程主机的，它在演示的时候，自己跟自己建立的隧道，稍微不太方便理解这里的意思。Destination\n对应着 Navicat 如下位置：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192305530.png\"\nalt=\"对应的目的端口\" />\n<figcaption aria-hidden=\"true\">对应的目的端口</figcaption>\n</figure>\n<p>然后在 PuTTY 里还需要配置一个地方，它位于\n<code>Connection -&gt; SSH -&gt; Auth</code>，这个地方是添加私钥的地方，如下：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192309718.png\"\nalt=\"配置私钥\" />\n<figcaption aria-hidden=\"true\">配置私钥</figcaption>\n</figure>\n<p>它对应着 Navicat 里的：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192310985.png\"\nalt=\"对应私钥位置\" />\n<figcaption aria-hidden=\"true\">对应私钥位置</figcaption>\n</figure>\n<p><strong>但是其实并不能直接添加 <code>pem</code>\n文件</strong>，这个时候我们需要打开 PuTTYgen，点击\nload，弹出文件选择页面时选择你的 pem 文件，然后点击 Save private key\n保存一个 <code>ppk</code> 格式的文件。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192315126.png\"\nalt=\"私钥格式转换\" />\n<figcaption aria-hidden=\"true\">私钥格式转换</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192317180.png\"\nalt=\"image-20220619231701159\" />\n<figcaption aria-hidden=\"true\">image-20220619231701159</figcaption>\n</figure>\n<p>这个时候就可以在 PuTTY 的页面添加这个 <code>ppk</code>\n格式文件了，如图：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192318792.png\"\nalt=\"成功配置私钥\" />\n<figcaption aria-hidden=\"true\">成功配置私钥</figcaption>\n</figure>\n<p>回到 <code>Session</code> 点击 <code>Save</code>\n保存一下以免之后重新配（只用一次当我没说），配置方面就完成了。点击\n<code>Open</code> 测试一波：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192321988.png\"\nalt=\"建立连接，登录账户\" />\n<figcaption aria-hidden=\"true\">建立连接，登录账户</figcaption>\n</figure>\n<p>输入用户名，这个用户名是 ssh 的用户名，对应着 Navicat 如下位置：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192322747.png\"\nalt=\"对应的 ssh 账户名\" />\n<figcaption aria-hidden=\"true\">对应的 ssh 账户名</figcaption>\n</figure>\n<p>然后其实就连上了。注意连上了之后不要关闭 PuTTY\n，关了隧道就断开了。</p>\n<p>有时可能会突然挂掉，我采用了每隔一段时间发送空包的方式维持隧道。在\n<code>Connection</code> 里，我把如下位置的值改成了 10：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192328488.png\"\nalt=\"保持隧道连接\" />\n<figcaption aria-hidden=\"true\">保持隧道连接</figcaption>\n</figure>\n<p>至此，ssh 客户端（ PuTTY ）这边的工作就结束了，下一步就是测试。</p>\n<h2 id=\"连接测试\">连接测试</h2>\n<p>因为我用 Navicat 是可以连接上的，所以我的选择是先用 Navicat\n测试。有过 Navicat 通过 ssh\n连接数据库经验的同学应该都知道，用这种方式连接数据库时，需要在\n<code>常规</code> 和 <code>SSH</code>\n两个页面分别配置，搭建隧道之后，只用配置 <code>常规</code>\n页面就可以了。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349956.png\"\nalt=\"Navicat 测试\" />\n<figcaption aria-hidden=\"true\">Navicat 测试</figcaption>\n</figure>\n<p>这里：</p>\n<ul>\n<li>主机填写 <code>localhost</code> 或是 <code>127.0.0.1</code>\n都可以。</li>\n<li>端口填写之前<strong>在 PuTTY 里填写的 Source port</strong>。</li>\n<li>用户名填写目的主机/服务器的用户名。</li>\n<li>密码填写目的主机/服务器的密码。</li>\n</ul>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349512.png\"\nalt=\"连接成功\" />\n<figcaption aria-hidden=\"true\">连接成功</figcaption>\n</figure>\n<p>接着在 power BI 上也测试一下。选择 MySQL 数据库。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192355774.png\"\nalt=\"power BI 选择数据库\" />\n<figcaption aria-hidden=\"true\">power BI 选择数据库</figcaption>\n</figure>\n<p><strong>服务器填写 <code>127.0.0.1:xxxx</code>，就是本机的 IP\n地址加用于搭隧道的端口，也就是 PuTTY 里配置的 Source port\n。</strong>数据库填写你要连接的库名。</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192357463.png\"\nalt=\"power BI 连接数据库\" />\n<figcaption aria-hidden=\"true\">power BI 连接数据库</figcaption>\n</figure>\n<p>高级选项下可以写 SQL 查询语句。然后在下一步选择\n<code>数据库</code>，用户名填写目的主机/服务器的用户名，密码填写目的主机/服务器的密码，如下：</p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206200000501.png\"\nalt=\"power BI 登录数据库账户\" />\n<figcaption aria-hidden=\"true\">power BI 登录数据库账户</figcaption>\n</figure>\n<p>点击连接就可以了。</p>\n"},{"title":"test","date":"2022-08-11T13:42:06.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2022-08-11 21:42:06\ntags:\n---\n","slug":"test","published":1,"updated":"2022-08-11T15:43:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1gb002z142p1gvy3wtq","content":"\n","site":{"data":{}},"wordcount":0,"excerpt":"","more":"\n"},{"title":"《消费信用模型：定价、利润与组合》 - 读书笔记","date":"2022-06-10T13:35:12.000Z","_content":"\n# 前言\n\n本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（ pricing ）、利润（ profit ）与组合（ portfolio ）出发，进行了详细的探讨和论述。\n\n这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：\n\n- 贷款机构如何根据违约风险差异化定价。\n\n- 贷款机构如何把违约评分变成利润评分。\n- 如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。\n\n# 1 消费信用和信用评分简介\n\n## 1.1 引言：消费信用的重要性和影响力\n\n讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。\n\n## 1.2 违约信用评分的历史背景\n\n- 申请评分 - A卡\n\n  信用评分技术诞生于 20 世纪 50 年代，当时的学者认识到用来分类的**统计学方法**可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分 - 申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。\n\n  这里也提到了最常见的风险是申请者在获得贷款后12个月内出现90天及以上的逾期，**这个只是坏客户定义的一种**。\n\n  根据这样的坏客户定义得到的模型分数，讲究**排序正确**。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。\n\n- 行为评分 - B卡\n\n  行为评分技术诞生于20世纪80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分 - 贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。\n\n## 1.3 贷款机构的目标\n\n### 1.3.1 银行的目标\n\n主要目标之一是让贷款带来最多的利润，也就是需要利润率最优。\n$$\nprofit\\% = \\frac{profit}{principal}\n$$\n另一个目标是将贷款组合（可以理解为多笔贷款的总额）的风险回报控制在可接受的范围内。\n\n第三个目标是扩大贷款组合的规模。\n\n### 1.3.2贷款过程\n\n- 获得资金\n\n  通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。\n\n- 建立消费贷款组合\n\n  找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。\n\n> 这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。**这里定价指的是定利率而不是额度。**\n>\n> 这里也提到了利润评分重点在于**估计从借款人（ borrower ）那里可能获得的现金流**，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。\n\n## 1.4 贷款决策的建模工具\n\n银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，**本质上都是决策问题**。这里主要介绍了**影响图（ influence diagram ）**和**决策树（ decision tree ）**两种工具。\n\n### 1.4.1 影响图\n\n> [Influence diagram - Wikipedia](https://en.wikipedia.org/wiki/Influence_diagram)\n\n一张影响图由三类节点（ node ）组成，之间由线（ arc ）连接。三类节点是：\n\n- 决策（ 用矩形表示 ）\n- 随机事件（ 用圆圈表示 ）\n- 结果（ 用菱形表示 ）\n\n如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y 会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y 的节点不同时，具有以下三种不同的含义。\n\n-  Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。\n-  Y 是一个随机事件，那么条件概率 $P(Y|X)$ 和非条件概率 $P(Y)$ 并不相同。\n-  Y 是一个结果，那么说明该结果受到了 X 的影响。\n\n### 1.4.2 消费信贷中的申请决策影响图\n\n![消费信贷中的申请决策影响图](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%BE.png)\n\n### 1.4.3 决策树\n\n> [Decision tree - Wikipedia](https://en.wikipedia.org/wiki/Decision_tree)\n\n决策树中同样有三种类型的节点：\n\n- 决策（用矩形表示）\n- 随机事件（用圆圈表示）\n- 回报（ pay off ，用每条路径末端的数值表示）\n\n**值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。**\n\n### 1.4.4 消费信贷决策树\n\n![消费信贷决策树](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91.png)\n\n假设借款人接受贷款概率 $q$ 暂不影响决策。接受申请的条件是申请者的预测风险 $X$ （ $X$ 可能为高也可能为低）满足：\n$$\np(X)g+(1-p(X))(-l)>0\n$$\n如果要考虑接受贷款的概率 $q$ 与每笔贷款的贷前管理费用 $c$ ，那么接受申请的条件变为：\n$$\nq[p(X)g+(1-p(X))(-l)]>c\n$$\n\n### 1.4.5 策略树\n\n## 1.5 概率、比率和分数\n\n### 1.5.1 概率和比率\n\n提到了三种相互关联的方法来描述好借款人的可能性：\n\n- 事件发生的概率（ probability ） $P(good)$ 。\n- 事件发生的比率（ odds ，好坏比） $odds=\\frac{P(good)}{P(bad)}$ 。\n- 包含了估计事件发生比率的所需信息的分数（ score ）或指数（ index ）。\n\n### 1.5.2 总体比率和信息比率\n\n**这里很重要地提到了分离了总体比率和信息比率的概念，当总体样本好坏比发生变化时，信息比率不变，总体比率会变。**我的理解是提到了信息比率可以用来带来排序，而并不会受行情影响。对于贷款来讲，行情变坏时，仅能保持排序不变。\n\n**证据权重 WOE （ weights of evidence）的公式为：**\n$$\nWOE=ln(odds)=ln(\\frac{P(bad)}{P(good)})\n$$\n相较于原始总体比率，证据权重是具有信息 x 或分数 s 的人群的好人比率的对数。WOE 为正表明这个组的好人概率比全部总体要好；若为负，则表明这组比总体要差一些。\n\n### 1.5.3 分数：一个充分统计量\n\n### 1.5.4 对数比率分数\n\n### 1.5.5 对数比率分数的分解\n\n### 1.5.6 朴素 Bayes 评分卡的构建\n\n### 1.5.7 分数分布\n\n## 1.6 分数的变换\n\n### 1.6.1 缩放自然分数\n\n### 1.6.2 缩放正态分布的分数\n\n### 1.6.3 多级评分卡\n\n### 1.6.4 风险率和时变分数\n\n### 1.6.5 离散时间风险概率\n\n## 1.7 贷款的回收和成本\n\n### 1.7.1 单期贷款的回报率模型\n\n### 1.7.2 单期企业债券的回报率模型\n\n### 1.7.3 消费贷款的利润率和回报率\n\n### 1.7.4 两期回报率模型\n\n### 1.7.5 多期贷款\n\n## 1.8 评分卡构建的基本原理\n\n### 1.8.1 建立评分卡的基本方法\n\n### 1.8.2 拒绝推断\n\n### 1.8.3 行为评分\n\n### 1.8.4 数据样本\n\n### 1.8.5 数据检验和整理\n\n### 1.8.6 样本细分\n\n### 1.8.7 训练和检验样本\n\n### 1.8.8 剔除特征变量\n\n### 1.8.9 特征粗分类\n\n### 1.8.10 卡方和信息统计量\n\n### 1.8.11 粗分类生成新变量\n\n### 1.8.12 评分卡最终形成和检验\n\n## 1.9 逻辑回归评分卡\n\n## 1.10 其他建立评分卡的方法\n\n### 1.10.1 线性回归\n\n### 1.10.2 散度最大化\n\n### 1.10.3 线性规划\n\n### 1.10.4 分类树\n\n# 2 评分系统的评估\n\n## 2.1 评分卡质量的评估\n\n### 2.1.1 交叉验证法\n\n### 2.1.2 自展法\n\n## 2.2 判别能力的测量\n\n### 2.2.1 散度与信息量\n\n### 2.2.2 马氏距离\n\n### 2.2.3 KS 统计量\n\n### 2.2.4 D 一致性统计量与 U 统计量\n\n## 2.3 ROC 曲线和 Gini 系数\n\n### 2.3.1 Gini 系数和 AUROC\n\n### 2.3.2 ROC 曲线与 D 统计量、KS统计量的关系\n\n### 2.3.3 Gini 系数的边界\n\n### 2.3.4 ROC 曲线和商业决策\n\n### 2.3.5 CAP 曲线与准确率\n\n## 2.4 评分卡细分对判别能力的影响\n\n### 2.4.1 样本细分对 Gini 系数的影响\n\n### 2.4.2 样本细分对 KS 统计量的影响\n\n### 2.4.3 样本细分对散度的影响\n\n## 2.5 评分卡预测概率的校准\n\n### 2.5.1 二项检验\n\n### 2.5.2 二项检验的正态近似\n\n### 2.5.3 卡方检验\n\n## 2.6 分类预测正确程度的衡量\n\n### 2.6.1 混淆矩阵\n\n### 2.6.2 第一类错误和第二类错误，敏感度和特异度\n\n### 2.6.3 交换集合\n\n### 2.6.4 最小错误成本\n\n# 3 基于风险定价\n\n## 3.1 消费信贷中的可变定价\n\n### 3.1.1 可变定价\n\n### 3.1.2 差异化定价\n\n### 3.1.3 响应率和接受率\n\n## 3.2 无风险利率响应函数和最优定价\n\n### 3.2.1 无风险响应率\n\n### 3.2.2 弹性\n\n### 3.2.3 最大支付意愿\n\n### 3.2.4 常见的响应函数\n\n### 3.2.5 最优定价\n\n## 3.3 风险响应关系，逆向选择和负担能力\n\n### 3.3.1 风险响应关系\n\n### 3.3.2 逆向选择\n\n### 3.3.3 风险响应关系和逆向选择的区别\n\n### 3.3.4 负担能力\n\n## 3.4 基于风险的响应函数和定价\n\n### 3.4.1 基于风险的好人概率\n\n### 3.4.2 基于风险的最优利率\n\n### 3.4.3 无逆向选择的最优利率\n\n### 3.4.4 有逆向选择的最优利率\n\n## 3.5 多种优惠条件下的接受概率\n\n### 3.5.1 贷款的多种优惠条件\n\n### 3.5.2 逻辑接受概率函数\n\n### 3.5.3 线性规划估计最大支付意愿\n\n### 3.5.4 加速生命模型估计最大支付意愿\n\n## 3.6 借贷博弈定价模型\n\n# 4 利润评分和动态模型\n\n## 4.1 行为评分和账户动态管理\n\n### 4.1.1 账户管理和利润率\n\n### 4.1.2 行为分数\n\n## 4.2 利润评分和风险回报矩阵\n\n### 4.2.1 客户层面和产品层面的评分\n\n### 4.2.2 风险回报矩阵\n\n### 4.2.3 风险回报矩阵里的最优策略\n\n### 4.2.4 消费行为的动态估计\n\n## 4.3 账户行为的 Markov 链模型\n\n### 4.3.1 Markov 链的定义\n\n### 4.3.2 消费信用中的 Markov 链模型\n\n### 4.3.3 Markov 链的参数估计和假设检验\n\n### 4.3.4 Markov 链模型的延伸\n\n## 4.4 Markov 的利润率决策模型\n\n## 4.5 生存分析的违约评分系统\n\n### 4.5.1 何时违约\n\n### 4.5.2 生存分析\n\n### 4.5.3 比例风险模型\n\n### 4.5.4 Cox 比例风险模型\n\n### 4.5.5 建立比例风险模型\n\n### 4.5.6 比例风险行为分数\n\n## 4.6 生存分析利润模型\n\n### 4.6.1 生存分析计算利润率\n\n### 4.6.2 风险竞争\n\n# 5 组合信用风险和巴塞尔协议\n\n## 5.1 组合信用风险\n\n### 5.1.1 组合层面的度量\n\n### 5.1.2 组合层面的违约概率\n\n### 5.1.3 违约损失率和组合层面的损失\n\n##  5.2 经济和监管资本\n\n### 5.2.1 资产和负债\n\n### 5.2.2 贷款中的风险\n\n### 5.2.3 监管和经济资本\n\n## 5.3 巴塞尔资本协议概述\n\n### 5.3.1 历史\n\n### 5.3.2 期望损失、意外损失、监管资本和在险价值\n\n### 5.3.3 组合不变性\n\n### 5.3.4 巴塞尔模型中的监管资本\n\n### 5.3.5 消费信用的巴塞尔方程\n\n### 5.3.6 小结\n\n## 5.4 巴塞尔新资本协议对信用评分的影响\n\n### 5.4.1 三角关系\n\n### 5.4.2 违约的定义\n\n### 5.4.3 时点和周期违约概率\n\n### 5.4.4 校准\n\n### 5.4.5 消费贷款中的企业信用模型\n\n### 5.4.6 违约暴露\n\n### 5.4.7 违约损失率\n\n## 5.5 监管资本和最优临界分数\n\n### 5.5.1 个人贷款接受决策的建模\n\n### 5.5.2 给定股权资本的组合最优临界分数\n\n### 5.5.3 可变股权资本的组合最优临界分数\n\n### 5.5.4 巴塞尔协议对 ROC 曲线的影响\n\n## 5.6 消费和企业贷款组合的信用风险建模\n\n### 5.6.1 企业信用模型的发展\n\n### 5.6.2 基于信誉的消费结构模型\n\n### 5.6.3 基于负担能力的消费结构模型\n\n### 5.6.4 基于风险函数的消费简约模型\n\n### 5.6.5 基于 Markov 链的消费简约模型\n\n## 5.7 消费信贷组合的压力测试\n\n### 5.7.1 巴塞尔协议中的压力测试\n\n### 5.7.2 敏感分析和情景分析\n\n### 5.7.3 违约概率的静态压力测试方法\n\n### 5.7.4 动态相关模型\n\n### 5.7.5 基于模型的动态方法\n\n### 5.7.6 LGD 和 EAD 的压力测试\n\n","source":"_posts/《消费信用模型：定价、利润与组合》.md","raw":"---\ntitle: 《消费信用模型：定价、利润与组合》 - 读书笔记\ndate: 2022-06-10 21:35:12\ncategories: [Economics&Finance, RiskControl]\ntags: [credit, decision, economics]\n---\n\n# 前言\n\n本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（ pricing ）、利润（ profit ）与组合（ portfolio ）出发，进行了详细的探讨和论述。\n\n这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：\n\n- 贷款机构如何根据违约风险差异化定价。\n\n- 贷款机构如何把违约评分变成利润评分。\n- 如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。\n\n# 1 消费信用和信用评分简介\n\n## 1.1 引言：消费信用的重要性和影响力\n\n讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。\n\n## 1.2 违约信用评分的历史背景\n\n- 申请评分 - A卡\n\n  信用评分技术诞生于 20 世纪 50 年代，当时的学者认识到用来分类的**统计学方法**可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分 - 申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。\n\n  这里也提到了最常见的风险是申请者在获得贷款后12个月内出现90天及以上的逾期，**这个只是坏客户定义的一种**。\n\n  根据这样的坏客户定义得到的模型分数，讲究**排序正确**。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。\n\n- 行为评分 - B卡\n\n  行为评分技术诞生于20世纪80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分 - 贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。\n\n## 1.3 贷款机构的目标\n\n### 1.3.1 银行的目标\n\n主要目标之一是让贷款带来最多的利润，也就是需要利润率最优。\n$$\nprofit\\% = \\frac{profit}{principal}\n$$\n另一个目标是将贷款组合（可以理解为多笔贷款的总额）的风险回报控制在可接受的范围内。\n\n第三个目标是扩大贷款组合的规模。\n\n### 1.3.2贷款过程\n\n- 获得资金\n\n  通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。\n\n- 建立消费贷款组合\n\n  找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。\n\n> 这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。**这里定价指的是定利率而不是额度。**\n>\n> 这里也提到了利润评分重点在于**估计从借款人（ borrower ）那里可能获得的现金流**，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。\n\n## 1.4 贷款决策的建模工具\n\n银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，**本质上都是决策问题**。这里主要介绍了**影响图（ influence diagram ）**和**决策树（ decision tree ）**两种工具。\n\n### 1.4.1 影响图\n\n> [Influence diagram - Wikipedia](https://en.wikipedia.org/wiki/Influence_diagram)\n\n一张影响图由三类节点（ node ）组成，之间由线（ arc ）连接。三类节点是：\n\n- 决策（ 用矩形表示 ）\n- 随机事件（ 用圆圈表示 ）\n- 结果（ 用菱形表示 ）\n\n如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y 会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y 的节点不同时，具有以下三种不同的含义。\n\n-  Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。\n-  Y 是一个随机事件，那么条件概率 $P(Y|X)$ 和非条件概率 $P(Y)$ 并不相同。\n-  Y 是一个结果，那么说明该结果受到了 X 的影响。\n\n### 1.4.2 消费信贷中的申请决策影响图\n\n![消费信贷中的申请决策影响图](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%BE.png)\n\n### 1.4.3 决策树\n\n> [Decision tree - Wikipedia](https://en.wikipedia.org/wiki/Decision_tree)\n\n决策树中同样有三种类型的节点：\n\n- 决策（用矩形表示）\n- 随机事件（用圆圈表示）\n- 回报（ pay off ，用每条路径末端的数值表示）\n\n**值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。**\n\n### 1.4.4 消费信贷决策树\n\n![消费信贷决策树](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91.png)\n\n假设借款人接受贷款概率 $q$ 暂不影响决策。接受申请的条件是申请者的预测风险 $X$ （ $X$ 可能为高也可能为低）满足：\n$$\np(X)g+(1-p(X))(-l)>0\n$$\n如果要考虑接受贷款的概率 $q$ 与每笔贷款的贷前管理费用 $c$ ，那么接受申请的条件变为：\n$$\nq[p(X)g+(1-p(X))(-l)]>c\n$$\n\n### 1.4.5 策略树\n\n## 1.5 概率、比率和分数\n\n### 1.5.1 概率和比率\n\n提到了三种相互关联的方法来描述好借款人的可能性：\n\n- 事件发生的概率（ probability ） $P(good)$ 。\n- 事件发生的比率（ odds ，好坏比） $odds=\\frac{P(good)}{P(bad)}$ 。\n- 包含了估计事件发生比率的所需信息的分数（ score ）或指数（ index ）。\n\n### 1.5.2 总体比率和信息比率\n\n**这里很重要地提到了分离了总体比率和信息比率的概念，当总体样本好坏比发生变化时，信息比率不变，总体比率会变。**我的理解是提到了信息比率可以用来带来排序，而并不会受行情影响。对于贷款来讲，行情变坏时，仅能保持排序不变。\n\n**证据权重 WOE （ weights of evidence）的公式为：**\n$$\nWOE=ln(odds)=ln(\\frac{P(bad)}{P(good)})\n$$\n相较于原始总体比率，证据权重是具有信息 x 或分数 s 的人群的好人比率的对数。WOE 为正表明这个组的好人概率比全部总体要好；若为负，则表明这组比总体要差一些。\n\n### 1.5.3 分数：一个充分统计量\n\n### 1.5.4 对数比率分数\n\n### 1.5.5 对数比率分数的分解\n\n### 1.5.6 朴素 Bayes 评分卡的构建\n\n### 1.5.7 分数分布\n\n## 1.6 分数的变换\n\n### 1.6.1 缩放自然分数\n\n### 1.6.2 缩放正态分布的分数\n\n### 1.6.3 多级评分卡\n\n### 1.6.4 风险率和时变分数\n\n### 1.6.5 离散时间风险概率\n\n## 1.7 贷款的回收和成本\n\n### 1.7.1 单期贷款的回报率模型\n\n### 1.7.2 单期企业债券的回报率模型\n\n### 1.7.3 消费贷款的利润率和回报率\n\n### 1.7.4 两期回报率模型\n\n### 1.7.5 多期贷款\n\n## 1.8 评分卡构建的基本原理\n\n### 1.8.1 建立评分卡的基本方法\n\n### 1.8.2 拒绝推断\n\n### 1.8.3 行为评分\n\n### 1.8.4 数据样本\n\n### 1.8.5 数据检验和整理\n\n### 1.8.6 样本细分\n\n### 1.8.7 训练和检验样本\n\n### 1.8.8 剔除特征变量\n\n### 1.8.9 特征粗分类\n\n### 1.8.10 卡方和信息统计量\n\n### 1.8.11 粗分类生成新变量\n\n### 1.8.12 评分卡最终形成和检验\n\n## 1.9 逻辑回归评分卡\n\n## 1.10 其他建立评分卡的方法\n\n### 1.10.1 线性回归\n\n### 1.10.2 散度最大化\n\n### 1.10.3 线性规划\n\n### 1.10.4 分类树\n\n# 2 评分系统的评估\n\n## 2.1 评分卡质量的评估\n\n### 2.1.1 交叉验证法\n\n### 2.1.2 自展法\n\n## 2.2 判别能力的测量\n\n### 2.2.1 散度与信息量\n\n### 2.2.2 马氏距离\n\n### 2.2.3 KS 统计量\n\n### 2.2.4 D 一致性统计量与 U 统计量\n\n## 2.3 ROC 曲线和 Gini 系数\n\n### 2.3.1 Gini 系数和 AUROC\n\n### 2.3.2 ROC 曲线与 D 统计量、KS统计量的关系\n\n### 2.3.3 Gini 系数的边界\n\n### 2.3.4 ROC 曲线和商业决策\n\n### 2.3.5 CAP 曲线与准确率\n\n## 2.4 评分卡细分对判别能力的影响\n\n### 2.4.1 样本细分对 Gini 系数的影响\n\n### 2.4.2 样本细分对 KS 统计量的影响\n\n### 2.4.3 样本细分对散度的影响\n\n## 2.5 评分卡预测概率的校准\n\n### 2.5.1 二项检验\n\n### 2.5.2 二项检验的正态近似\n\n### 2.5.3 卡方检验\n\n## 2.6 分类预测正确程度的衡量\n\n### 2.6.1 混淆矩阵\n\n### 2.6.2 第一类错误和第二类错误，敏感度和特异度\n\n### 2.6.3 交换集合\n\n### 2.6.4 最小错误成本\n\n# 3 基于风险定价\n\n## 3.1 消费信贷中的可变定价\n\n### 3.1.1 可变定价\n\n### 3.1.2 差异化定价\n\n### 3.1.3 响应率和接受率\n\n## 3.2 无风险利率响应函数和最优定价\n\n### 3.2.1 无风险响应率\n\n### 3.2.2 弹性\n\n### 3.2.3 最大支付意愿\n\n### 3.2.4 常见的响应函数\n\n### 3.2.5 最优定价\n\n## 3.3 风险响应关系，逆向选择和负担能力\n\n### 3.3.1 风险响应关系\n\n### 3.3.2 逆向选择\n\n### 3.3.3 风险响应关系和逆向选择的区别\n\n### 3.3.4 负担能力\n\n## 3.4 基于风险的响应函数和定价\n\n### 3.4.1 基于风险的好人概率\n\n### 3.4.2 基于风险的最优利率\n\n### 3.4.3 无逆向选择的最优利率\n\n### 3.4.4 有逆向选择的最优利率\n\n## 3.5 多种优惠条件下的接受概率\n\n### 3.5.1 贷款的多种优惠条件\n\n### 3.5.2 逻辑接受概率函数\n\n### 3.5.3 线性规划估计最大支付意愿\n\n### 3.5.4 加速生命模型估计最大支付意愿\n\n## 3.6 借贷博弈定价模型\n\n# 4 利润评分和动态模型\n\n## 4.1 行为评分和账户动态管理\n\n### 4.1.1 账户管理和利润率\n\n### 4.1.2 行为分数\n\n## 4.2 利润评分和风险回报矩阵\n\n### 4.2.1 客户层面和产品层面的评分\n\n### 4.2.2 风险回报矩阵\n\n### 4.2.3 风险回报矩阵里的最优策略\n\n### 4.2.4 消费行为的动态估计\n\n## 4.3 账户行为的 Markov 链模型\n\n### 4.3.1 Markov 链的定义\n\n### 4.3.2 消费信用中的 Markov 链模型\n\n### 4.3.3 Markov 链的参数估计和假设检验\n\n### 4.3.4 Markov 链模型的延伸\n\n## 4.4 Markov 的利润率决策模型\n\n## 4.5 生存分析的违约评分系统\n\n### 4.5.1 何时违约\n\n### 4.5.2 生存分析\n\n### 4.5.3 比例风险模型\n\n### 4.5.4 Cox 比例风险模型\n\n### 4.5.5 建立比例风险模型\n\n### 4.5.6 比例风险行为分数\n\n## 4.6 生存分析利润模型\n\n### 4.6.1 生存分析计算利润率\n\n### 4.6.2 风险竞争\n\n# 5 组合信用风险和巴塞尔协议\n\n## 5.1 组合信用风险\n\n### 5.1.1 组合层面的度量\n\n### 5.1.2 组合层面的违约概率\n\n### 5.1.3 违约损失率和组合层面的损失\n\n##  5.2 经济和监管资本\n\n### 5.2.1 资产和负债\n\n### 5.2.2 贷款中的风险\n\n### 5.2.3 监管和经济资本\n\n## 5.3 巴塞尔资本协议概述\n\n### 5.3.1 历史\n\n### 5.3.2 期望损失、意外损失、监管资本和在险价值\n\n### 5.3.3 组合不变性\n\n### 5.3.4 巴塞尔模型中的监管资本\n\n### 5.3.5 消费信用的巴塞尔方程\n\n### 5.3.6 小结\n\n## 5.4 巴塞尔新资本协议对信用评分的影响\n\n### 5.4.1 三角关系\n\n### 5.4.2 违约的定义\n\n### 5.4.3 时点和周期违约概率\n\n### 5.4.4 校准\n\n### 5.4.5 消费贷款中的企业信用模型\n\n### 5.4.6 违约暴露\n\n### 5.4.7 违约损失率\n\n## 5.5 监管资本和最优临界分数\n\n### 5.5.1 个人贷款接受决策的建模\n\n### 5.5.2 给定股权资本的组合最优临界分数\n\n### 5.5.3 可变股权资本的组合最优临界分数\n\n### 5.5.4 巴塞尔协议对 ROC 曲线的影响\n\n## 5.6 消费和企业贷款组合的信用风险建模\n\n### 5.6.1 企业信用模型的发展\n\n### 5.6.2 基于信誉的消费结构模型\n\n### 5.6.3 基于负担能力的消费结构模型\n\n### 5.6.4 基于风险函数的消费简约模型\n\n### 5.6.5 基于 Markov 链的消费简约模型\n\n## 5.7 消费信贷组合的压力测试\n\n### 5.7.1 巴塞尔协议中的压力测试\n\n### 5.7.2 敏感分析和情景分析\n\n### 5.7.3 违约概率的静态压力测试方法\n\n### 5.7.4 动态相关模型\n\n### 5.7.5 基于模型的动态方法\n\n### 5.7.6 LGD 和 EAD 的压力测试\n\n","slug":"《消费信用模型：定价、利润与组合》","published":1,"updated":"2022-08-11T15:43:07.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1ha00ai142pf1yjdths","content":"<h1 id=\"前言\">前言</h1>\n<p>本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（\npricing ）、利润（ profit ）与组合（ portfolio\n）出发，进行了详细的探讨和论述。</p>\n<p>这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：</p>\n<ul>\n<li><p>贷款机构如何根据违约风险差异化定价。</p></li>\n<li><p>贷款机构如何把违约评分变成利润评分。</p></li>\n<li><p>如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。</p></li>\n</ul>\n<h1 id=\"消费信用和信用评分简介\">1 消费信用和信用评分简介</h1>\n<h2 id=\"引言消费信用的重要性和影响力\">1.1\n引言：消费信用的重要性和影响力</h2>\n<p>讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。</p>\n<h2 id=\"违约信用评分的历史背景\">1.2 违约信用评分的历史背景</h2>\n<ul>\n<li><p>申请评分 - A卡</p>\n<p>信用评分技术诞生于 20 世纪 50\n年代，当时的学者认识到用来分类的<strong>统计学方法</strong>可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分\n-\n申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。</p>\n<p>这里也提到了最常见的风险是申请者在获得贷款后12个月内出现90天及以上的逾期，<strong>这个只是坏客户定义的一种</strong>。</p>\n<p>根据这样的坏客户定义得到的模型分数，讲究<strong>排序正确</strong>。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。</p></li>\n<li><p>行为评分 - B卡</p>\n<p>行为评分技术诞生于20世纪80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分\n-\n贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。</p></li>\n</ul>\n<h2 id=\"贷款机构的目标\">1.3 贷款机构的目标</h2>\n<h3 id=\"银行的目标\">1.3.1 银行的目标</h3>\n<p>主要目标之一是让贷款带来最多的利润，也就是需要利润率最优。 <span\nclass=\"math display\">\\[\nprofit\\% = \\frac{profit}{principal}\n\\]</span>\n另一个目标是将贷款组合（可以理解为多笔贷款的总额）的风险回报控制在可接受的范围内。</p>\n<p>第三个目标是扩大贷款组合的规模。</p>\n<h3 id=\"贷款过程\">1.3.2贷款过程</h3>\n<ul>\n<li><p>获得资金</p>\n<p>通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。</p></li>\n<li><p>建立消费贷款组合</p>\n<p>找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。</p></li>\n</ul>\n<blockquote>\n<p>这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。<strong>这里定价指的是定利率而不是额度。</strong></p>\n<p>这里也提到了利润评分重点在于<strong>估计从借款人（ borrower\n）那里可能获得的现金流</strong>，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。</p>\n</blockquote>\n<h2 id=\"贷款决策的建模工具\">1.4 贷款决策的建模工具</h2>\n<p>银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，<strong>本质上都是决策问题</strong>。这里主要介绍了<strong>影响图（\ninfluence diagram ）</strong>和<strong>决策树（ decision tree\n）</strong>两种工具。</p>\n<h3 id=\"影响图\">1.4.1 影响图</h3>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Influence_diagram\">Influence\ndiagram - Wikipedia</a></p>\n</blockquote>\n<p>一张影响图由三类节点（ node ）组成，之间由线（ arc\n）连接。三类节点是：</p>\n<ul>\n<li>决策（ 用矩形表示 ）</li>\n<li>随机事件（ 用圆圈表示 ）</li>\n<li>结果（ 用菱形表示 ）</li>\n</ul>\n<p>如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y\n会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y\n的节点不同时，具有以下三种不同的含义。</p>\n<ul>\n<li>Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。</li>\n<li>Y 是一个随机事件，那么条件概率 <span\nclass=\"math inline\">\\(P(Y|X)\\)</span> 和非条件概率 <span\nclass=\"math inline\">\\(P(Y)\\)</span> 并不相同。</li>\n<li>Y 是一个结果，那么说明该结果受到了 X 的影响。</li>\n</ul>\n<h3 id=\"消费信贷中的申请决策影响图\">1.4.2\n消费信贷中的申请决策影响图</h3>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%BE.png\"\nalt=\"消费信贷中的申请决策影响图\" />\n<figcaption aria-hidden=\"true\">消费信贷中的申请决策影响图</figcaption>\n</figure>\n<h3 id=\"决策树\">1.4.3 决策树</h3>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Decision_tree\">Decision tree -\nWikipedia</a></p>\n</blockquote>\n<p>决策树中同样有三种类型的节点：</p>\n<ul>\n<li>决策（用矩形表示）</li>\n<li>随机事件（用圆圈表示）</li>\n<li>回报（ pay off ，用每条路径末端的数值表示）</li>\n</ul>\n<p><strong>值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。</strong></p>\n<h3 id=\"消费信贷决策树\">1.4.4 消费信贷决策树</h3>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91.png\"\nalt=\"消费信贷决策树\" />\n<figcaption aria-hidden=\"true\">消费信贷决策树</figcaption>\n</figure>\n<p>假设借款人接受贷款概率 <span class=\"math inline\">\\(q\\)</span>\n暂不影响决策。接受申请的条件是申请者的预测风险 <span\nclass=\"math inline\">\\(X\\)</span> （ <span\nclass=\"math inline\">\\(X\\)</span> 可能为高也可能为低）满足： <span\nclass=\"math display\">\\[\np(X)g+(1-p(X))(-l)&gt;0\n\\]</span> 如果要考虑接受贷款的概率 <span\nclass=\"math inline\">\\(q\\)</span> 与每笔贷款的贷前管理费用 <span\nclass=\"math inline\">\\(c\\)</span> ，那么接受申请的条件变为： <span\nclass=\"math display\">\\[\nq[p(X)g+(1-p(X))(-l)]&gt;c\n\\]</span></p>\n<h3 id=\"策略树\">1.4.5 策略树</h3>\n<h2 id=\"概率比率和分数\">1.5 概率、比率和分数</h2>\n<h3 id=\"概率和比率\">1.5.1 概率和比率</h3>\n<p>提到了三种相互关联的方法来描述好借款人的可能性：</p>\n<ul>\n<li>事件发生的概率（ probability ） <span\nclass=\"math inline\">\\(P(good)\\)</span> 。</li>\n<li>事件发生的比率（ odds ，好坏比） <span\nclass=\"math inline\">\\(odds=\\frac{P(good)}{P(bad)}\\)</span> 。</li>\n<li>包含了估计事件发生比率的所需信息的分数（ score ）或指数（ index\n）。</li>\n</ul>\n<h3 id=\"总体比率和信息比率\">1.5.2 总体比率和信息比率</h3>\n<p><strong>这里很重要地提到了分离了总体比率和信息比率的概念，当总体样本好坏比发生变化时，信息比率不变，总体比率会变。</strong>我的理解是提到了信息比率可以用来带来排序，而并不会受行情影响。对于贷款来讲，行情变坏时，仅能保持排序不变。</p>\n<p><strong>证据权重 WOE （ weights of evidence）的公式为：</strong>\n<span class=\"math display\">\\[\nWOE=ln(odds)=ln(\\frac{P(bad)}{P(good)})\n\\]</span> 相较于原始总体比率，证据权重是具有信息 x 或分数 s\n的人群的好人比率的对数。WOE\n为正表明这个组的好人概率比全部总体要好；若为负，则表明这组比总体要差一些。</p>\n<h3 id=\"分数一个充分统计量\">1.5.3 分数：一个充分统计量</h3>\n<h3 id=\"对数比率分数\">1.5.4 对数比率分数</h3>\n<h3 id=\"对数比率分数的分解\">1.5.5 对数比率分数的分解</h3>\n<h3 id=\"朴素-bayes-评分卡的构建\">1.5.6 朴素 Bayes 评分卡的构建</h3>\n<h3 id=\"分数分布\">1.5.7 分数分布</h3>\n<h2 id=\"分数的变换\">1.6 分数的变换</h2>\n<h3 id=\"缩放自然分数\">1.6.1 缩放自然分数</h3>\n<h3 id=\"缩放正态分布的分数\">1.6.2 缩放正态分布的分数</h3>\n<h3 id=\"多级评分卡\">1.6.3 多级评分卡</h3>\n<h3 id=\"风险率和时变分数\">1.6.4 风险率和时变分数</h3>\n<h3 id=\"离散时间风险概率\">1.6.5 离散时间风险概率</h3>\n<h2 id=\"贷款的回收和成本\">1.7 贷款的回收和成本</h2>\n<h3 id=\"单期贷款的回报率模型\">1.7.1 单期贷款的回报率模型</h3>\n<h3 id=\"单期企业债券的回报率模型\">1.7.2 单期企业债券的回报率模型</h3>\n<h3 id=\"消费贷款的利润率和回报率\">1.7.3 消费贷款的利润率和回报率</h3>\n<h3 id=\"两期回报率模型\">1.7.4 两期回报率模型</h3>\n<h3 id=\"多期贷款\">1.7.5 多期贷款</h3>\n<h2 id=\"评分卡构建的基本原理\">1.8 评分卡构建的基本原理</h2>\n<h3 id=\"建立评分卡的基本方法\">1.8.1 建立评分卡的基本方法</h3>\n<h3 id=\"拒绝推断\">1.8.2 拒绝推断</h3>\n<h3 id=\"行为评分\">1.8.3 行为评分</h3>\n<h3 id=\"数据样本\">1.8.4 数据样本</h3>\n<h3 id=\"数据检验和整理\">1.8.5 数据检验和整理</h3>\n<h3 id=\"样本细分\">1.8.6 样本细分</h3>\n<h3 id=\"训练和检验样本\">1.8.7 训练和检验样本</h3>\n<h3 id=\"剔除特征变量\">1.8.8 剔除特征变量</h3>\n<h3 id=\"特征粗分类\">1.8.9 特征粗分类</h3>\n<h3 id=\"卡方和信息统计量\">1.8.10 卡方和信息统计量</h3>\n<h3 id=\"粗分类生成新变量\">1.8.11 粗分类生成新变量</h3>\n<h3 id=\"评分卡最终形成和检验\">1.8.12 评分卡最终形成和检验</h3>\n<h2 id=\"逻辑回归评分卡\">1.9 逻辑回归评分卡</h2>\n<h2 id=\"其他建立评分卡的方法\">1.10 其他建立评分卡的方法</h2>\n<h3 id=\"线性回归\">1.10.1 线性回归</h3>\n<h3 id=\"散度最大化\">1.10.2 散度最大化</h3>\n<h3 id=\"线性规划\">1.10.3 线性规划</h3>\n<h3 id=\"分类树\">1.10.4 分类树</h3>\n<h1 id=\"评分系统的评估\">2 评分系统的评估</h1>\n<h2 id=\"评分卡质量的评估\">2.1 评分卡质量的评估</h2>\n<h3 id=\"交叉验证法\">2.1.1 交叉验证法</h3>\n<h3 id=\"自展法\">2.1.2 自展法</h3>\n<h2 id=\"判别能力的测量\">2.2 判别能力的测量</h2>\n<h3 id=\"散度与信息量\">2.2.1 散度与信息量</h3>\n<h3 id=\"马氏距离\">2.2.2 马氏距离</h3>\n<h3 id=\"ks-统计量\">2.2.3 KS 统计量</h3>\n<h3 id=\"d-一致性统计量与-u-统计量\">2.2.4 D 一致性统计量与 U 统计量</h3>\n<h2 id=\"roc-曲线和-gini-系数\">2.3 ROC 曲线和 Gini 系数</h2>\n<h3 id=\"gini-系数和-auroc\">2.3.1 Gini 系数和 AUROC</h3>\n<h3 id=\"roc-曲线与-d-统计量ks统计量的关系\">2.3.2 ROC 曲线与 D\n统计量、KS统计量的关系</h3>\n<h3 id=\"gini-系数的边界\">2.3.3 Gini 系数的边界</h3>\n<h3 id=\"roc-曲线和商业决策\">2.3.4 ROC 曲线和商业决策</h3>\n<h3 id=\"cap-曲线与准确率\">2.3.5 CAP 曲线与准确率</h3>\n<h2 id=\"评分卡细分对判别能力的影响\">2.4 评分卡细分对判别能力的影响</h2>\n<h3 id=\"样本细分对-gini-系数的影响\">2.4.1 样本细分对 Gini\n系数的影响</h3>\n<h3 id=\"样本细分对-ks-统计量的影响\">2.4.2 样本细分对 KS\n统计量的影响</h3>\n<h3 id=\"样本细分对散度的影响\">2.4.3 样本细分对散度的影响</h3>\n<h2 id=\"评分卡预测概率的校准\">2.5 评分卡预测概率的校准</h2>\n<h3 id=\"二项检验\">2.5.1 二项检验</h3>\n<h3 id=\"二项检验的正态近似\">2.5.2 二项检验的正态近似</h3>\n<h3 id=\"卡方检验\">2.5.3 卡方检验</h3>\n<h2 id=\"分类预测正确程度的衡量\">2.6 分类预测正确程度的衡量</h2>\n<h3 id=\"混淆矩阵\">2.6.1 混淆矩阵</h3>\n<h3 id=\"第一类错误和第二类错误敏感度和特异度\">2.6.2\n第一类错误和第二类错误，敏感度和特异度</h3>\n<h3 id=\"交换集合\">2.6.3 交换集合</h3>\n<h3 id=\"最小错误成本\">2.6.4 最小错误成本</h3>\n<h1 id=\"基于风险定价\">3 基于风险定价</h1>\n<h2 id=\"消费信贷中的可变定价\">3.1 消费信贷中的可变定价</h2>\n<h3 id=\"可变定价\">3.1.1 可变定价</h3>\n<h3 id=\"差异化定价\">3.1.2 差异化定价</h3>\n<h3 id=\"响应率和接受率\">3.1.3 响应率和接受率</h3>\n<h2 id=\"无风险利率响应函数和最优定价\">3.2\n无风险利率响应函数和最优定价</h2>\n<h3 id=\"无风险响应率\">3.2.1 无风险响应率</h3>\n<h3 id=\"弹性\">3.2.2 弹性</h3>\n<h3 id=\"最大支付意愿\">3.2.3 最大支付意愿</h3>\n<h3 id=\"常见的响应函数\">3.2.4 常见的响应函数</h3>\n<h3 id=\"最优定价\">3.2.5 最优定价</h3>\n<h2 id=\"风险响应关系逆向选择和负担能力\">3.3\n风险响应关系，逆向选择和负担能力</h2>\n<h3 id=\"风险响应关系\">3.3.1 风险响应关系</h3>\n<h3 id=\"逆向选择\">3.3.2 逆向选择</h3>\n<h3 id=\"风险响应关系和逆向选择的区别\">3.3.3\n风险响应关系和逆向选择的区别</h3>\n<h3 id=\"负担能力\">3.3.4 负担能力</h3>\n<h2 id=\"基于风险的响应函数和定价\">3.4 基于风险的响应函数和定价</h2>\n<h3 id=\"基于风险的好人概率\">3.4.1 基于风险的好人概率</h3>\n<h3 id=\"基于风险的最优利率\">3.4.2 基于风险的最优利率</h3>\n<h3 id=\"无逆向选择的最优利率\">3.4.3 无逆向选择的最优利率</h3>\n<h3 id=\"有逆向选择的最优利率\">3.4.4 有逆向选择的最优利率</h3>\n<h2 id=\"多种优惠条件下的接受概率\">3.5 多种优惠条件下的接受概率</h2>\n<h3 id=\"贷款的多种优惠条件\">3.5.1 贷款的多种优惠条件</h3>\n<h3 id=\"逻辑接受概率函数\">3.5.2 逻辑接受概率函数</h3>\n<h3 id=\"线性规划估计最大支付意愿\">3.5.3 线性规划估计最大支付意愿</h3>\n<h3 id=\"加速生命模型估计最大支付意愿\">3.5.4\n加速生命模型估计最大支付意愿</h3>\n<h2 id=\"借贷博弈定价模型\">3.6 借贷博弈定价模型</h2>\n<h1 id=\"利润评分和动态模型\">4 利润评分和动态模型</h1>\n<h2 id=\"行为评分和账户动态管理\">4.1 行为评分和账户动态管理</h2>\n<h3 id=\"账户管理和利润率\">4.1.1 账户管理和利润率</h3>\n<h3 id=\"行为分数\">4.1.2 行为分数</h3>\n<h2 id=\"利润评分和风险回报矩阵\">4.2 利润评分和风险回报矩阵</h2>\n<h3 id=\"客户层面和产品层面的评分\">4.2.1 客户层面和产品层面的评分</h3>\n<h3 id=\"风险回报矩阵\">4.2.2 风险回报矩阵</h3>\n<h3 id=\"风险回报矩阵里的最优策略\">4.2.3 风险回报矩阵里的最优策略</h3>\n<h3 id=\"消费行为的动态估计\">4.2.4 消费行为的动态估计</h3>\n<h2 id=\"账户行为的-markov-链模型\">4.3 账户行为的 Markov 链模型</h2>\n<h3 id=\"markov-链的定义\">4.3.1 Markov 链的定义</h3>\n<h3 id=\"消费信用中的-markov-链模型\">4.3.2 消费信用中的 Markov\n链模型</h3>\n<h3 id=\"markov-链的参数估计和假设检验\">4.3.3 Markov\n链的参数估计和假设检验</h3>\n<h3 id=\"markov-链模型的延伸\">4.3.4 Markov 链模型的延伸</h3>\n<h2 id=\"markov-的利润率决策模型\">4.4 Markov 的利润率决策模型</h2>\n<h2 id=\"生存分析的违约评分系统\">4.5 生存分析的违约评分系统</h2>\n<h3 id=\"何时违约\">4.5.1 何时违约</h3>\n<h3 id=\"生存分析\">4.5.2 生存分析</h3>\n<h3 id=\"比例风险模型\">4.5.3 比例风险模型</h3>\n<h3 id=\"cox-比例风险模型\">4.5.4 Cox 比例风险模型</h3>\n<h3 id=\"建立比例风险模型\">4.5.5 建立比例风险模型</h3>\n<h3 id=\"比例风险行为分数\">4.5.6 比例风险行为分数</h3>\n<h2 id=\"生存分析利润模型\">4.6 生存分析利润模型</h2>\n<h3 id=\"生存分析计算利润率\">4.6.1 生存分析计算利润率</h3>\n<h3 id=\"风险竞争\">4.6.2 风险竞争</h3>\n<h1 id=\"组合信用风险和巴塞尔协议\">5 组合信用风险和巴塞尔协议</h1>\n<h2 id=\"组合信用风险\">5.1 组合信用风险</h2>\n<h3 id=\"组合层面的度量\">5.1.1 组合层面的度量</h3>\n<h3 id=\"组合层面的违约概率\">5.1.2 组合层面的违约概率</h3>\n<h3 id=\"违约损失率和组合层面的损失\">5.1.3\n违约损失率和组合层面的损失</h3>\n<h2 id=\"经济和监管资本\">5.2 经济和监管资本</h2>\n<h3 id=\"资产和负债\">5.2.1 资产和负债</h3>\n<h3 id=\"贷款中的风险\">5.2.2 贷款中的风险</h3>\n<h3 id=\"监管和经济资本\">5.2.3 监管和经济资本</h3>\n<h2 id=\"巴塞尔资本协议概述\">5.3 巴塞尔资本协议概述</h2>\n<h3 id=\"历史\">5.3.1 历史</h3>\n<h3 id=\"期望损失意外损失监管资本和在险价值\">5.3.2\n期望损失、意外损失、监管资本和在险价值</h3>\n<h3 id=\"组合不变性\">5.3.3 组合不变性</h3>\n<h3 id=\"巴塞尔模型中的监管资本\">5.3.4 巴塞尔模型中的监管资本</h3>\n<h3 id=\"消费信用的巴塞尔方程\">5.3.5 消费信用的巴塞尔方程</h3>\n<h3 id=\"小结\">5.3.6 小结</h3>\n<h2 id=\"巴塞尔新资本协议对信用评分的影响\">5.4\n巴塞尔新资本协议对信用评分的影响</h2>\n<h3 id=\"三角关系\">5.4.1 三角关系</h3>\n<h3 id=\"违约的定义\">5.4.2 违约的定义</h3>\n<h3 id=\"时点和周期违约概率\">5.4.3 时点和周期违约概率</h3>\n<h3 id=\"校准\">5.4.4 校准</h3>\n<h3 id=\"消费贷款中的企业信用模型\">5.4.5 消费贷款中的企业信用模型</h3>\n<h3 id=\"违约暴露\">5.4.6 违约暴露</h3>\n<h3 id=\"违约损失率\">5.4.7 违约损失率</h3>\n<h2 id=\"监管资本和最优临界分数\">5.5 监管资本和最优临界分数</h2>\n<h3 id=\"个人贷款接受决策的建模\">5.5.1 个人贷款接受决策的建模</h3>\n<h3 id=\"给定股权资本的组合最优临界分数\">5.5.2\n给定股权资本的组合最优临界分数</h3>\n<h3 id=\"可变股权资本的组合最优临界分数\">5.5.3\n可变股权资本的组合最优临界分数</h3>\n<h3 id=\"巴塞尔协议对-roc-曲线的影响\">5.5.4 巴塞尔协议对 ROC\n曲线的影响</h3>\n<h2 id=\"消费和企业贷款组合的信用风险建模\">5.6\n消费和企业贷款组合的信用风险建模</h2>\n<h3 id=\"企业信用模型的发展\">5.6.1 企业信用模型的发展</h3>\n<h3 id=\"基于信誉的消费结构模型\">5.6.2 基于信誉的消费结构模型</h3>\n<h3 id=\"基于负担能力的消费结构模型\">5.6.3\n基于负担能力的消费结构模型</h3>\n<h3 id=\"基于风险函数的消费简约模型\">5.6.4\n基于风险函数的消费简约模型</h3>\n<h3 id=\"基于-markov-链的消费简约模型\">5.6.5 基于 Markov\n链的消费简约模型</h3>\n<h2 id=\"消费信贷组合的压力测试\">5.7 消费信贷组合的压力测试</h2>\n<h3 id=\"巴塞尔协议中的压力测试\">5.7.1 巴塞尔协议中的压力测试</h3>\n<h3 id=\"敏感分析和情景分析\">5.7.2 敏感分析和情景分析</h3>\n<h3 id=\"违约概率的静态压力测试方法\">5.7.3\n违约概率的静态压力测试方法</h3>\n<h3 id=\"动态相关模型\">5.7.4 动态相关模型</h3>\n<h3 id=\"基于模型的动态方法\">5.7.5 基于模型的动态方法</h3>\n<h3 id=\"lgd-和-ead-的压力测试\">5.7.6 LGD 和 EAD 的压力测试</h3>\n","site":{"data":{}},"wordcount":4304,"excerpt":"","more":"<h1 id=\"前言\">前言</h1>\n<p>本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（\npricing ）、利润（ profit ）与组合（ portfolio\n）出发，进行了详细的探讨和论述。</p>\n<p>这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：</p>\n<ul>\n<li><p>贷款机构如何根据违约风险差异化定价。</p></li>\n<li><p>贷款机构如何把违约评分变成利润评分。</p></li>\n<li><p>如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。</p></li>\n</ul>\n<h1 id=\"消费信用和信用评分简介\">1 消费信用和信用评分简介</h1>\n<h2 id=\"引言消费信用的重要性和影响力\">1.1\n引言：消费信用的重要性和影响力</h2>\n<p>讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。</p>\n<h2 id=\"违约信用评分的历史背景\">1.2 违约信用评分的历史背景</h2>\n<ul>\n<li><p>申请评分 - A卡</p>\n<p>信用评分技术诞生于 20 世纪 50\n年代，当时的学者认识到用来分类的<strong>统计学方法</strong>可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分\n-\n申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。</p>\n<p>这里也提到了最常见的风险是申请者在获得贷款后12个月内出现90天及以上的逾期，<strong>这个只是坏客户定义的一种</strong>。</p>\n<p>根据这样的坏客户定义得到的模型分数，讲究<strong>排序正确</strong>。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。</p></li>\n<li><p>行为评分 - B卡</p>\n<p>行为评分技术诞生于20世纪80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分\n-\n贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。</p></li>\n</ul>\n<h2 id=\"贷款机构的目标\">1.3 贷款机构的目标</h2>\n<h3 id=\"银行的目标\">1.3.1 银行的目标</h3>\n<p>主要目标之一是让贷款带来最多的利润，也就是需要利润率最优。 <span\nclass=\"math display\">\\[\nprofit\\% = \\frac{profit}{principal}\n\\]</span>\n另一个目标是将贷款组合（可以理解为多笔贷款的总额）的风险回报控制在可接受的范围内。</p>\n<p>第三个目标是扩大贷款组合的规模。</p>\n<h3 id=\"贷款过程\">1.3.2贷款过程</h3>\n<ul>\n<li><p>获得资金</p>\n<p>通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。</p></li>\n<li><p>建立消费贷款组合</p>\n<p>找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。</p></li>\n</ul>\n<blockquote>\n<p>这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。<strong>这里定价指的是定利率而不是额度。</strong></p>\n<p>这里也提到了利润评分重点在于<strong>估计从借款人（ borrower\n）那里可能获得的现金流</strong>，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。</p>\n</blockquote>\n<h2 id=\"贷款决策的建模工具\">1.4 贷款决策的建模工具</h2>\n<p>银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，<strong>本质上都是决策问题</strong>。这里主要介绍了<strong>影响图（\ninfluence diagram ）</strong>和<strong>决策树（ decision tree\n）</strong>两种工具。</p>\n<h3 id=\"影响图\">1.4.1 影响图</h3>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Influence_diagram\">Influence\ndiagram - Wikipedia</a></p>\n</blockquote>\n<p>一张影响图由三类节点（ node ）组成，之间由线（ arc\n）连接。三类节点是：</p>\n<ul>\n<li>决策（ 用矩形表示 ）</li>\n<li>随机事件（ 用圆圈表示 ）</li>\n<li>结果（ 用菱形表示 ）</li>\n</ul>\n<p>如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y\n会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y\n的节点不同时，具有以下三种不同的含义。</p>\n<ul>\n<li>Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。</li>\n<li>Y 是一个随机事件，那么条件概率 <span\nclass=\"math inline\">\\(P(Y|X)\\)</span> 和非条件概率 <span\nclass=\"math inline\">\\(P(Y)\\)</span> 并不相同。</li>\n<li>Y 是一个结果，那么说明该结果受到了 X 的影响。</li>\n</ul>\n<h3 id=\"消费信贷中的申请决策影响图\">1.4.2\n消费信贷中的申请决策影响图</h3>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%BE.png\"\nalt=\"消费信贷中的申请决策影响图\" />\n<figcaption aria-hidden=\"true\">消费信贷中的申请决策影响图</figcaption>\n</figure>\n<h3 id=\"决策树\">1.4.3 决策树</h3>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Decision_tree\">Decision tree -\nWikipedia</a></p>\n</blockquote>\n<p>决策树中同样有三种类型的节点：</p>\n<ul>\n<li>决策（用矩形表示）</li>\n<li>随机事件（用圆圈表示）</li>\n<li>回报（ pay off ，用每条路径末端的数值表示）</li>\n</ul>\n<p><strong>值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。</strong></p>\n<h3 id=\"消费信贷决策树\">1.4.4 消费信贷决策树</h3>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91.png\"\nalt=\"消费信贷决策树\" />\n<figcaption aria-hidden=\"true\">消费信贷决策树</figcaption>\n</figure>\n<p>假设借款人接受贷款概率 <span class=\"math inline\">\\(q\\)</span>\n暂不影响决策。接受申请的条件是申请者的预测风险 <span\nclass=\"math inline\">\\(X\\)</span> （ <span\nclass=\"math inline\">\\(X\\)</span> 可能为高也可能为低）满足： <span\nclass=\"math display\">\\[\np(X)g+(1-p(X))(-l)&gt;0\n\\]</span> 如果要考虑接受贷款的概率 <span\nclass=\"math inline\">\\(q\\)</span> 与每笔贷款的贷前管理费用 <span\nclass=\"math inline\">\\(c\\)</span> ，那么接受申请的条件变为： <span\nclass=\"math display\">\\[\nq[p(X)g+(1-p(X))(-l)]&gt;c\n\\]</span></p>\n<h3 id=\"策略树\">1.4.5 策略树</h3>\n<h2 id=\"概率比率和分数\">1.5 概率、比率和分数</h2>\n<h3 id=\"概率和比率\">1.5.1 概率和比率</h3>\n<p>提到了三种相互关联的方法来描述好借款人的可能性：</p>\n<ul>\n<li>事件发生的概率（ probability ） <span\nclass=\"math inline\">\\(P(good)\\)</span> 。</li>\n<li>事件发生的比率（ odds ，好坏比） <span\nclass=\"math inline\">\\(odds=\\frac{P(good)}{P(bad)}\\)</span> 。</li>\n<li>包含了估计事件发生比率的所需信息的分数（ score ）或指数（ index\n）。</li>\n</ul>\n<h3 id=\"总体比率和信息比率\">1.5.2 总体比率和信息比率</h3>\n<p><strong>这里很重要地提到了分离了总体比率和信息比率的概念，当总体样本好坏比发生变化时，信息比率不变，总体比率会变。</strong>我的理解是提到了信息比率可以用来带来排序，而并不会受行情影响。对于贷款来讲，行情变坏时，仅能保持排序不变。</p>\n<p><strong>证据权重 WOE （ weights of evidence）的公式为：</strong>\n<span class=\"math display\">\\[\nWOE=ln(odds)=ln(\\frac{P(bad)}{P(good)})\n\\]</span> 相较于原始总体比率，证据权重是具有信息 x 或分数 s\n的人群的好人比率的对数。WOE\n为正表明这个组的好人概率比全部总体要好；若为负，则表明这组比总体要差一些。</p>\n<h3 id=\"分数一个充分统计量\">1.5.3 分数：一个充分统计量</h3>\n<h3 id=\"对数比率分数\">1.5.4 对数比率分数</h3>\n<h3 id=\"对数比率分数的分解\">1.5.5 对数比率分数的分解</h3>\n<h3 id=\"朴素-bayes-评分卡的构建\">1.5.6 朴素 Bayes 评分卡的构建</h3>\n<h3 id=\"分数分布\">1.5.7 分数分布</h3>\n<h2 id=\"分数的变换\">1.6 分数的变换</h2>\n<h3 id=\"缩放自然分数\">1.6.1 缩放自然分数</h3>\n<h3 id=\"缩放正态分布的分数\">1.6.2 缩放正态分布的分数</h3>\n<h3 id=\"多级评分卡\">1.6.3 多级评分卡</h3>\n<h3 id=\"风险率和时变分数\">1.6.4 风险率和时变分数</h3>\n<h3 id=\"离散时间风险概率\">1.6.5 离散时间风险概率</h3>\n<h2 id=\"贷款的回收和成本\">1.7 贷款的回收和成本</h2>\n<h3 id=\"单期贷款的回报率模型\">1.7.1 单期贷款的回报率模型</h3>\n<h3 id=\"单期企业债券的回报率模型\">1.7.2 单期企业债券的回报率模型</h3>\n<h3 id=\"消费贷款的利润率和回报率\">1.7.3 消费贷款的利润率和回报率</h3>\n<h3 id=\"两期回报率模型\">1.7.4 两期回报率模型</h3>\n<h3 id=\"多期贷款\">1.7.5 多期贷款</h3>\n<h2 id=\"评分卡构建的基本原理\">1.8 评分卡构建的基本原理</h2>\n<h3 id=\"建立评分卡的基本方法\">1.8.1 建立评分卡的基本方法</h3>\n<h3 id=\"拒绝推断\">1.8.2 拒绝推断</h3>\n<h3 id=\"行为评分\">1.8.3 行为评分</h3>\n<h3 id=\"数据样本\">1.8.4 数据样本</h3>\n<h3 id=\"数据检验和整理\">1.8.5 数据检验和整理</h3>\n<h3 id=\"样本细分\">1.8.6 样本细分</h3>\n<h3 id=\"训练和检验样本\">1.8.7 训练和检验样本</h3>\n<h3 id=\"剔除特征变量\">1.8.8 剔除特征变量</h3>\n<h3 id=\"特征粗分类\">1.8.9 特征粗分类</h3>\n<h3 id=\"卡方和信息统计量\">1.8.10 卡方和信息统计量</h3>\n<h3 id=\"粗分类生成新变量\">1.8.11 粗分类生成新变量</h3>\n<h3 id=\"评分卡最终形成和检验\">1.8.12 评分卡最终形成和检验</h3>\n<h2 id=\"逻辑回归评分卡\">1.9 逻辑回归评分卡</h2>\n<h2 id=\"其他建立评分卡的方法\">1.10 其他建立评分卡的方法</h2>\n<h3 id=\"线性回归\">1.10.1 线性回归</h3>\n<h3 id=\"散度最大化\">1.10.2 散度最大化</h3>\n<h3 id=\"线性规划\">1.10.3 线性规划</h3>\n<h3 id=\"分类树\">1.10.4 分类树</h3>\n<h1 id=\"评分系统的评估\">2 评分系统的评估</h1>\n<h2 id=\"评分卡质量的评估\">2.1 评分卡质量的评估</h2>\n<h3 id=\"交叉验证法\">2.1.1 交叉验证法</h3>\n<h3 id=\"自展法\">2.1.2 自展法</h3>\n<h2 id=\"判别能力的测量\">2.2 判别能力的测量</h2>\n<h3 id=\"散度与信息量\">2.2.1 散度与信息量</h3>\n<h3 id=\"马氏距离\">2.2.2 马氏距离</h3>\n<h3 id=\"ks-统计量\">2.2.3 KS 统计量</h3>\n<h3 id=\"d-一致性统计量与-u-统计量\">2.2.4 D 一致性统计量与 U 统计量</h3>\n<h2 id=\"roc-曲线和-gini-系数\">2.3 ROC 曲线和 Gini 系数</h2>\n<h3 id=\"gini-系数和-auroc\">2.3.1 Gini 系数和 AUROC</h3>\n<h3 id=\"roc-曲线与-d-统计量ks统计量的关系\">2.3.2 ROC 曲线与 D\n统计量、KS统计量的关系</h3>\n<h3 id=\"gini-系数的边界\">2.3.3 Gini 系数的边界</h3>\n<h3 id=\"roc-曲线和商业决策\">2.3.4 ROC 曲线和商业决策</h3>\n<h3 id=\"cap-曲线与准确率\">2.3.5 CAP 曲线与准确率</h3>\n<h2 id=\"评分卡细分对判别能力的影响\">2.4 评分卡细分对判别能力的影响</h2>\n<h3 id=\"样本细分对-gini-系数的影响\">2.4.1 样本细分对 Gini\n系数的影响</h3>\n<h3 id=\"样本细分对-ks-统计量的影响\">2.4.2 样本细分对 KS\n统计量的影响</h3>\n<h3 id=\"样本细分对散度的影响\">2.4.3 样本细分对散度的影响</h3>\n<h2 id=\"评分卡预测概率的校准\">2.5 评分卡预测概率的校准</h2>\n<h3 id=\"二项检验\">2.5.1 二项检验</h3>\n<h3 id=\"二项检验的正态近似\">2.5.2 二项检验的正态近似</h3>\n<h3 id=\"卡方检验\">2.5.3 卡方检验</h3>\n<h2 id=\"分类预测正确程度的衡量\">2.6 分类预测正确程度的衡量</h2>\n<h3 id=\"混淆矩阵\">2.6.1 混淆矩阵</h3>\n<h3 id=\"第一类错误和第二类错误敏感度和特异度\">2.6.2\n第一类错误和第二类错误，敏感度和特异度</h3>\n<h3 id=\"交换集合\">2.6.3 交换集合</h3>\n<h3 id=\"最小错误成本\">2.6.4 最小错误成本</h3>\n<h1 id=\"基于风险定价\">3 基于风险定价</h1>\n<h2 id=\"消费信贷中的可变定价\">3.1 消费信贷中的可变定价</h2>\n<h3 id=\"可变定价\">3.1.1 可变定价</h3>\n<h3 id=\"差异化定价\">3.1.2 差异化定价</h3>\n<h3 id=\"响应率和接受率\">3.1.3 响应率和接受率</h3>\n<h2 id=\"无风险利率响应函数和最优定价\">3.2\n无风险利率响应函数和最优定价</h2>\n<h3 id=\"无风险响应率\">3.2.1 无风险响应率</h3>\n<h3 id=\"弹性\">3.2.2 弹性</h3>\n<h3 id=\"最大支付意愿\">3.2.3 最大支付意愿</h3>\n<h3 id=\"常见的响应函数\">3.2.4 常见的响应函数</h3>\n<h3 id=\"最优定价\">3.2.5 最优定价</h3>\n<h2 id=\"风险响应关系逆向选择和负担能力\">3.3\n风险响应关系，逆向选择和负担能力</h2>\n<h3 id=\"风险响应关系\">3.3.1 风险响应关系</h3>\n<h3 id=\"逆向选择\">3.3.2 逆向选择</h3>\n<h3 id=\"风险响应关系和逆向选择的区别\">3.3.3\n风险响应关系和逆向选择的区别</h3>\n<h3 id=\"负担能力\">3.3.4 负担能力</h3>\n<h2 id=\"基于风险的响应函数和定价\">3.4 基于风险的响应函数和定价</h2>\n<h3 id=\"基于风险的好人概率\">3.4.1 基于风险的好人概率</h3>\n<h3 id=\"基于风险的最优利率\">3.4.2 基于风险的最优利率</h3>\n<h3 id=\"无逆向选择的最优利率\">3.4.3 无逆向选择的最优利率</h3>\n<h3 id=\"有逆向选择的最优利率\">3.4.4 有逆向选择的最优利率</h3>\n<h2 id=\"多种优惠条件下的接受概率\">3.5 多种优惠条件下的接受概率</h2>\n<h3 id=\"贷款的多种优惠条件\">3.5.1 贷款的多种优惠条件</h3>\n<h3 id=\"逻辑接受概率函数\">3.5.2 逻辑接受概率函数</h3>\n<h3 id=\"线性规划估计最大支付意愿\">3.5.3 线性规划估计最大支付意愿</h3>\n<h3 id=\"加速生命模型估计最大支付意愿\">3.5.4\n加速生命模型估计最大支付意愿</h3>\n<h2 id=\"借贷博弈定价模型\">3.6 借贷博弈定价模型</h2>\n<h1 id=\"利润评分和动态模型\">4 利润评分和动态模型</h1>\n<h2 id=\"行为评分和账户动态管理\">4.1 行为评分和账户动态管理</h2>\n<h3 id=\"账户管理和利润率\">4.1.1 账户管理和利润率</h3>\n<h3 id=\"行为分数\">4.1.2 行为分数</h3>\n<h2 id=\"利润评分和风险回报矩阵\">4.2 利润评分和风险回报矩阵</h2>\n<h3 id=\"客户层面和产品层面的评分\">4.2.1 客户层面和产品层面的评分</h3>\n<h3 id=\"风险回报矩阵\">4.2.2 风险回报矩阵</h3>\n<h3 id=\"风险回报矩阵里的最优策略\">4.2.3 风险回报矩阵里的最优策略</h3>\n<h3 id=\"消费行为的动态估计\">4.2.4 消费行为的动态估计</h3>\n<h2 id=\"账户行为的-markov-链模型\">4.3 账户行为的 Markov 链模型</h2>\n<h3 id=\"markov-链的定义\">4.3.1 Markov 链的定义</h3>\n<h3 id=\"消费信用中的-markov-链模型\">4.3.2 消费信用中的 Markov\n链模型</h3>\n<h3 id=\"markov-链的参数估计和假设检验\">4.3.3 Markov\n链的参数估计和假设检验</h3>\n<h3 id=\"markov-链模型的延伸\">4.3.4 Markov 链模型的延伸</h3>\n<h2 id=\"markov-的利润率决策模型\">4.4 Markov 的利润率决策模型</h2>\n<h2 id=\"生存分析的违约评分系统\">4.5 生存分析的违约评分系统</h2>\n<h3 id=\"何时违约\">4.5.1 何时违约</h3>\n<h3 id=\"生存分析\">4.5.2 生存分析</h3>\n<h3 id=\"比例风险模型\">4.5.3 比例风险模型</h3>\n<h3 id=\"cox-比例风险模型\">4.5.4 Cox 比例风险模型</h3>\n<h3 id=\"建立比例风险模型\">4.5.5 建立比例风险模型</h3>\n<h3 id=\"比例风险行为分数\">4.5.6 比例风险行为分数</h3>\n<h2 id=\"生存分析利润模型\">4.6 生存分析利润模型</h2>\n<h3 id=\"生存分析计算利润率\">4.6.1 生存分析计算利润率</h3>\n<h3 id=\"风险竞争\">4.6.2 风险竞争</h3>\n<h1 id=\"组合信用风险和巴塞尔协议\">5 组合信用风险和巴塞尔协议</h1>\n<h2 id=\"组合信用风险\">5.1 组合信用风险</h2>\n<h3 id=\"组合层面的度量\">5.1.1 组合层面的度量</h3>\n<h3 id=\"组合层面的违约概率\">5.1.2 组合层面的违约概率</h3>\n<h3 id=\"违约损失率和组合层面的损失\">5.1.3\n违约损失率和组合层面的损失</h3>\n<h2 id=\"经济和监管资本\">5.2 经济和监管资本</h2>\n<h3 id=\"资产和负债\">5.2.1 资产和负债</h3>\n<h3 id=\"贷款中的风险\">5.2.2 贷款中的风险</h3>\n<h3 id=\"监管和经济资本\">5.2.3 监管和经济资本</h3>\n<h2 id=\"巴塞尔资本协议概述\">5.3 巴塞尔资本协议概述</h2>\n<h3 id=\"历史\">5.3.1 历史</h3>\n<h3 id=\"期望损失意外损失监管资本和在险价值\">5.3.2\n期望损失、意外损失、监管资本和在险价值</h3>\n<h3 id=\"组合不变性\">5.3.3 组合不变性</h3>\n<h3 id=\"巴塞尔模型中的监管资本\">5.3.4 巴塞尔模型中的监管资本</h3>\n<h3 id=\"消费信用的巴塞尔方程\">5.3.5 消费信用的巴塞尔方程</h3>\n<h3 id=\"小结\">5.3.6 小结</h3>\n<h2 id=\"巴塞尔新资本协议对信用评分的影响\">5.4\n巴塞尔新资本协议对信用评分的影响</h2>\n<h3 id=\"三角关系\">5.4.1 三角关系</h3>\n<h3 id=\"违约的定义\">5.4.2 违约的定义</h3>\n<h3 id=\"时点和周期违约概率\">5.4.3 时点和周期违约概率</h3>\n<h3 id=\"校准\">5.4.4 校准</h3>\n<h3 id=\"消费贷款中的企业信用模型\">5.4.5 消费贷款中的企业信用模型</h3>\n<h3 id=\"违约暴露\">5.4.6 违约暴露</h3>\n<h3 id=\"违约损失率\">5.4.7 违约损失率</h3>\n<h2 id=\"监管资本和最优临界分数\">5.5 监管资本和最优临界分数</h2>\n<h3 id=\"个人贷款接受决策的建模\">5.5.1 个人贷款接受决策的建模</h3>\n<h3 id=\"给定股权资本的组合最优临界分数\">5.5.2\n给定股权资本的组合最优临界分数</h3>\n<h3 id=\"可变股权资本的组合最优临界分数\">5.5.3\n可变股权资本的组合最优临界分数</h3>\n<h3 id=\"巴塞尔协议对-roc-曲线的影响\">5.5.4 巴塞尔协议对 ROC\n曲线的影响</h3>\n<h2 id=\"消费和企业贷款组合的信用风险建模\">5.6\n消费和企业贷款组合的信用风险建模</h2>\n<h3 id=\"企业信用模型的发展\">5.6.1 企业信用模型的发展</h3>\n<h3 id=\"基于信誉的消费结构模型\">5.6.2 基于信誉的消费结构模型</h3>\n<h3 id=\"基于负担能力的消费结构模型\">5.6.3\n基于负担能力的消费结构模型</h3>\n<h3 id=\"基于风险函数的消费简约模型\">5.6.4\n基于风险函数的消费简约模型</h3>\n<h3 id=\"基于-markov-链的消费简约模型\">5.6.5 基于 Markov\n链的消费简约模型</h3>\n<h2 id=\"消费信贷组合的压力测试\">5.7 消费信贷组合的压力测试</h2>\n<h3 id=\"巴塞尔协议中的压力测试\">5.7.1 巴塞尔协议中的压力测试</h3>\n<h3 id=\"敏感分析和情景分析\">5.7.2 敏感分析和情景分析</h3>\n<h3 id=\"违约概率的静态压力测试方法\">5.7.3\n违约概率的静态压力测试方法</h3>\n<h3 id=\"动态相关模型\">5.7.4 动态相关模型</h3>\n<h3 id=\"基于模型的动态方法\">5.7.5 基于模型的动态方法</h3>\n<h3 id=\"lgd-和-ead-的压力测试\">5.7.6 LGD 和 EAD 的压力测试</h3>\n"},{"title":"《敏捷实战指南》 - 读书笔记","date":"2022-07-25T15:00:34.000Z","_content":"\n# 1. 引论\n\n这里用了一个叫做预测法的东西作为对比。作者提到，本书适用于：\n\n- 对于预测法与敏捷方法难以取舍的项目团队。\n- 试图解决快速创新和复杂性问题的项目团队。\n- 致力于团队改进的项目团队。\n\n本书的目的是：\n\n- 帮助项目取得成功。\n- 帮助项目团队顺利交付商业价值。\n- 满足客户的期望和需求。\n\n看第一章所述内容似乎是解决新技术应用到现有的项目上，但寻求不降低项目开发效率的项目管理思路，称之为敏捷思维模式。\n\n# 2. 敏捷概述\n\n## 2.1 可确定的工作与高度不确定的工作\n\n项目工作包括两种不同类型：\n\n- 可确定的工作 - 执行的不确定性和风险通常较低，归宿是自动化。\n- 高度不确定的工作 - 探索性工作，项目变化速度快，复杂性和风险高。\n\n这里提到了**预测法**，其实就是传统开发过程，大概类似可行性分析、需求分析、总体设计、详细设计、编码、测试、部署上线的软件开发流程。这种流程应对变更的能力稍微有点弱（其实就是每一个阶段的质量都必须充分的保证，给人犯错的空间比较小），所以这个时候需要一种在短时间内探讨可行性，根据评估和反馈快速调整的开发过程（给试错的空间，这里跟高度不确定性相呼应），也就是敏捷方法。\n\n## 2.2 《敏捷宣言》及思维模式\n\n- 四大价值观\n  - 重视个体以及互动而不是过程和工具。\n  \n    > 这个应该是为了发掘更多可改善的地方。\n  - 可用的软件而不是完整的文档。\n  \n    > 这个大概是讲软件比较完善的时候再沉淀一下弄文档？不然对项目专家的依赖度也太高了。\n  - 客户合作而不是合同谈判。\n  \n    > 这个应该是针对深入业务这一点所说的吧。但是感觉这两个并没有对立关系。\n  - 应对变更而不是遵循计划。\n  \n    > 个人觉得这点恐怕对团队的能力要求有点高。\n\n> 上面所说的是敏捷开发的一个价值观，总体来讲我觉得对整个团队里每个人能力的要求都要比传统的高一点，这个不太好做其实。\n\n- 十二大原则\n  - 最高目标，通过尽早持续交付有价值的软件来满足客户的需求。\n  \n    > 比起传统方法多了个快。\n  - 欢迎对需求提出变更，善于利用变更，以帮助客户获得竞争优势。\n  \n    > 其实需求变更这个东西怎么说呢，软件开发者不太想要。至少能不停变更需求的软件与定好需求的软件不是一个价格，基于需求要变更这个前提，敏捷开发会比传统方法舒服。\n  - 要经常交付可用的软件。\n  \n    > 这里应该是指局部交付，以避免所有东西都做出来结果发现不尽人意这种情况，通过这种方式尽快找出错误。\n  - 项目实施过程中，业务人员与开发人员必须始终通力合作。\n  \n    > 这一点我个人是非常赞同的。很多时候，开发人员从技术上提升的代价比更深入理解业务大很多。\n  - 善于激励项目人员，给予他们所需的环境和支持，并相信他们能够完成任务。 \n  \n    > 我觉得看人。\n  - 无论是对开发团队还是团队内部，信息传达最有效的方法都是面对面交谈。\n  \n    > 确实。\n  - 可用的软件是衡量进度的首要衡量标准。 \n  \n    > 类似于 Talk is cheap, show me your code.\n  - 敏捷过程提倡可持续的开发。项目发起人、开发人员和用户应该都能够始终保证持续步调稳定性。 \n  \n    > 对开发人员的状态是个考验。\n  - 对技术的精益求精以及对设计的不断完善将提高敏捷性。 \n  \n    > 其实这点是不是敏捷开发都一样的。\n  - 简洁，即尽最大可能减少不必要的工作。\n  \n    > 这点对管理者是个考验。\n  - 最佳的架构、需求和设计将出自组织团队。\n  \n    > 对组织团队有点依赖，不过要敏捷的话确实只有这样。\n  - 团队定期反省怎样做才能更有效，并相应地调整团队地行为。\n  \n    > 这点讲究开发过程的变化。\n\n## 2.3 精益与看板方法\n\n重点在于：\n\n- 交付价值\n\n  > 我觉得是指客户满意度这方面来讲。\n\n- 尊重人\n\n  > 对客户来讲确实尊重，对开发者来讲其实有点压榨的意思，当然也可以说是信任开发者，这个恐怕得看人。\n\n- 减少浪费\n\n  > 这点对项目经理（专家）要求会高一点。\n\n- 透明化\n\n  > 这个确实是优点，可以看到每个人在干嘛。\n\n- 适应变更\n\n  > 这个有点像是附加价值。\n\n- 持续改善\n\n  > 比起改善更强调持续。这种对项目发起人的要求会高一点，可能会出现一种情况，就是项目发起人指负责规划并不参与做项目，由开发技术员做，感觉提供价值方面不太好说。\n\n## 2.4 不确定性、风险和生命周期选择\n\n这里不确定性指需求的不确定性与技术的不确定性两方面，风险指返工的风险。\n\n这里提倡用较小的工作增量验证自身的工作，相当于是每做一个模块的东西，就去汇报验证看是否满足需求，即使返工也只是很小的返工这种方式。\n\n- 非常短的反馈循环。\n- 频繁调整过程。\n- 重新进行优先级排序。\n- 定期更新计划。\n- 频繁交付。\n\n但是这里也明确说了并不是什么都适合敏捷开发，如果一项任务没有中间成果，或者没有原型的时候，比较适合主用预测法去开发，用敏捷方法去管理新的迭代需求和增量交付成果。\n\n当技术和需求的不确定性都很高的时候，为了使项目可靠，需要先遏制其中一个不确定性的变量。\n\n> 从这一节开始，我觉得他讲得有点道理。\n\n# 3. 生命周期选择\n\n这里详细说明了 4 种生命周期的定义：\n\n- 预测型生命周期 - 提前进行大量的计划工作，然后一次性执行；执行时一个连续的过程。\n- 迭代型生命周期 - 这种方法允许对未完成的工作进行反馈，从而改进和修改该工作。\n- 增量型生命周期 - 这种方法向客户提供各个已完成的，可能立即使用的可交付成果。\n- 敏捷型生命周期 - 这种方法既有迭代，也有增量，便于完善工作，频繁交付。\n\n## 3.1 项目生命周期的特征\n\n| 方法   | 需求 | 活动               | 交付             | 目标                                   |\n| ------ | ---- | ------------------ | ---------------- | -------------------------------------- |\n| 预测型 | 固定 | 整个项目仅执行一次 | 一次交付         | 管理成本                               |\n| 迭代型 | 动态 | 反复执行直至修正   | 一次交付         | 解决方案的正确性                       |\n| 增量型 | 动态 | 对给定增量执行一次 | 频繁更小规模交付 | 速度                                   |\n| 敏捷型 | 动态 | 反复执行直至修正   | 频繁小规模交付   | 通过频繁小规模交付和反馈实现的客户价值 |\n\n选择哪一个生命周期取决于需求的变更程度与交付频率。\n\n|                | 需求变更低 | 需求变更高 |\n| -------------- | ---------- | ---------- |\n| **交付频率高** | 增量型     | 敏捷型     |\n| **交付频率低** | 预测型     | 迭代型     |\n\n### 3.1.1 预测型生命周期的特征\n\n```mermaid\ngraph LR\ndemand(需求)-->analysis\nanalysis(分析)-->design\ndesign(设计)-->code\ncode(构建)-->test\ntest(测试)-->deploy(交付)\n```\n\n强调部门划分、有效、顺序的工作。有点谋定而后动的意思，好处自然就是计划非常清晰明了，文档也易构建。坏处就是可能在开发之前就得确定好明确的需求，除此之外还需要对技术有充分的了解，应对需求不确定性和技术不确定性的能力太弱。\n\n### 3.1.2 迭代型生命周期的特征\n\n```mermaid\ngraph LR\nanalysis(需求)-->phase2(分析与设计)\nphase2-->|概念验证| phase2\nphase2-->phase3(构建与测试)\nphase3-->|改善| phase3\nphase3-->deploy(交付)\n```\n\n有点类似与一个学习的开发过程。通过连续的原型或概念验证来改进产品或成果。在同一个时间盒内可能涉及到长达数周时间的迭代。生命周期可能会很长，因为它是为了学习而优化，而不是为交付速度而优化。\n\n### 3.1.3 增量型生命周期的特征\n\n```mermaid\ngraph LR\ndemand(需求) --> phase1\nphase1(分析-设计-构建-测试-交付) --> phase2(分析-设计-构建-测试-交付)\nphase2 --> phase3(分析-设计-构建-测试-交付)\n```\n\n一点一点的交付，突出交付速度快，减少潜在返工。\n\n### 3.1.4 敏捷生命周期的特征\n\n```mermaid\ngraph LR\nphase1(需求-分析-设计-构建-测试) --> phase2(需求-分析-设计-构建-测试)\nphase2 --> deploy1(交付)\ndeploy1(交付) --> phase3(需求-分析-设计-构建-测试)\nphase3 --> phase4(需求-分析-设计-构建-测试)\nphase4 --> phase5(需求-分析-设计-构建-测试)\nphase5 --> deploy2(交付)\n```\n\n类似增量型和迭代型的结合体。\n\n### 3.1.5 敏捷适用性筛选器\n\n### 3.1.6 混合生命周期的特征\n\n依据不同的目标在项目不同的模块选择不同的开发方法。\n\n### 3.1.7 结合了敏捷和预测的方法\n\n### 3.1.8 以预测法为主、敏捷方法为辅的方法\n\n### 3.1.9 以敏捷方法为主、预测法为辅的方法\n\n### 3.1.10 符合目的的混合生命周期\n\n要根据目的去选择开发方法。\n\n### 3.1.11 混合型生命周期作为过渡策略\n\n在预测法的项目上去使用敏捷方法作为过渡而不是一开始就在大项目上使用敏捷方法。\n\n## 3.2 混合敏捷方法\n\n敏捷方法有很多，根据需要进行组合。\n\n## 3.3 影响裁剪的项目因素\n\n| 项目因素             | 裁剪方案                                                     |\n| -------------------- | ------------------------------------------------------------ |\n| 对不稳定需求的适应   | 使用节奏（定期时间盒）帮助团队进行演示、回顾与理解新任务。   |\n| 改进速度不够快       | 更频繁地回归并选择改进措施。                                 |\n| 工作流容易被打断     | 利用看板让工作可见，分配任务优先级。                         |\n| 产品增量质量不佳     | 以测试为重点。                                               |\n| 多团队协同           | 精心制定一种符合项目背景的方法。                             |\n| 团队成员缺乏敏捷经验 | 培养敏捷思维模式和敏捷原则的基本原理。使用特定敏捷方法前开研讨会。 |\n\n# 4. 实施敏捷：创建敏捷环境\n\n## 4.1 从敏捷思维模式开始\n\n从几个问题开始：\n\n- 项目团队如何以敏捷方式行动？\n- 为了使下一交付周期受益，团队需要快速交付哪些成果并获得早期反馈？\n- 团队如何以一种透明的方式行动？\n- 为了专注于高优先级的目标，可以避免哪些工作？\n- 仆人式领导对团队达成目标有何益处？\n\n## 4.2 仆人式领导为团队赋权\n\n仆人式领导使通过对团队服务来领导团队的实践，它注重理解和关注团队成员的需要和发展，旨在使团队尽可能达到最高成绩。\n\n### 4.2.1 仆人式领导的职责\n\n- 促进合作。\n- 审视阻碍敏捷的过程，努力使其合理化。\n- 鼓励团队成员，让人尽其才。\n- 培养团队发展。\n\n### 4.2.2 项目经理在敏捷环境中的角色\n\n项目经理作为技术人员的服务者而不是管理者。\n\n### 4.2.3 项目经理应用仆人式领导\n\n要把责任分配给有能力的人。\n\n## 4.3 团队构成\n\n### 4.3.1 敏捷团队\n\n| 属性                             | 目标                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| 专门人团                         | 专心，提高工作效率；少于十人的小型团队。                     |\n| 跨职能团队成员                   | 频繁开发交付；作为独立团队交付；整合工作；向团队内部外部提供反馈。 |\n| 集中办公或有能力应对办公地点不同 | 改善沟通；挺高团队动力；知识共享；降低学习成本；合作。       |\n| 通才和专家组成的混合团队         | 专家提供专门技能，通才提供从事不同工作的灵活性；团队具有专业能力，体现在都称为通才型专家。 |\n| 稳定的工作环境                   | 彼此依赖；对工作方法相互认同；简化团队成本；知识资本的保证和发展。 |\n\n> 这，感觉对技术人员的要求也太高了。感觉不太可行。\n\n### 4.3.2 敏捷的角色\n\n- 跨职能团队成员\n\n- 产品负责人\n\n  > 我感觉这个才是真正的大佬。\n\n- 团队促进者\n\n  > 听起来有点玄乎。Scrum Master 居然是这个，我说实话不能接受。\n\n### 4.3.3 通才型专家\n\n知识广度够，也有专攻的 T 字型人才。\n\n### 4.3.4 团队结构\n\n以产品为主，将人员组织到跨职能的团队中。\n\n> 做东西来讲这点挺好，问题就是这个知识和技术积累有点困难。\n\n### 4.3.5 专职小组成员\n\n这里阐述在这个团队里专职工作的小组成员比较重要。分散尽力去做多个项目会造成切换时的效率浪费。\n\n### 4.3.6 团队工作场所\n\n独立的私人办公区域与定期开会合作交流。\n\n### 4.3.7 克服组织孤岛\n\n平等的话语权，意见都能被听到并得到考虑。\n\n> 前提是有话语权的人有足够水平的见解和技术吧。\n\n# 5. 实施敏捷：在敏捷环境中交付\n\n## 5.1 项目章程和团队章程\n\n章程：\n\n- 项目重要的原因\n- 团队前景方向\n- 项目目标\n\n敏捷项目章程：\n\n- 项目愿景 - 我们为什么要做这个项目？\n- 项目远景或项目目标的一部分 - 谁会从中受益？如何受益？\n- 项目的发布标准 - 达到哪些条件才意味着项目完成？\n- 预期的工作流 - 我们将怎样合作？\n\n团队章程：\n\n- 团队价值观。\n- 工作协议，“就绪”如何定义，这是团队可以接受工作的前提；“完成”如何定义，达成一致；考虑时间盒，使用工作过程限制。\n- 基本规则，有关一个人在会议发言上的规定。\n- 团队规范，团队如何对待会议时间。\n\n## 5.2 常见敏捷实践\n\n### 5.2.1 回顾\n\n团队定期反省如何能够做到更加有效，并相应地调整团队的行为。\n\n### 5.2.2 待办事项列表编制\n\n所有工作的有序列表，故事。\n\n### 5.2.3 待办事项列表的细化\n\n任务，可能是即时制定的，也可能是迭代会上制定的，也可以是多次会议讨论（比较陌生的项目）。\n\n### 5.2.4 每日站会\n\n过一下看板和任务盒。回答以下问题：\n\n- 基于迭代的敏捷\n\n  - 上次站会以来我都完成了什么？\n\n  - 从现在到下一次站会，我计划完成什么？\n\n  - 我的障碍是什么？\n\n- 基于流程的敏捷\n\n  - 我们还需要做些什么来推进这一工作？\n  - 有人在做看板上没有的事情吗？\n  - 作为一个团队，我们需要完成什么？\n  - 工作流程是否存在瓶颈或障碍？\n\n### 5.2.5 展示/评审\n\n故事完成后，展示时，产品负责人接受或拒绝故事。\n\n### 5.2.6 规划基于迭代的敏捷\n\n反复计划与学习。\n\n> 这块我感觉是为了敏捷而敏捷。\n\n### 5.2.7 帮助团队交付价值的执行实践\n\n- 持续集成\n- 在不同层面测试\n- 验收测试驱动开发\n- 测试驱动开发\n- 刺探（时间盒研究或实验）\n\n### 5.2.8 迭代和增量如何帮助交付工作产品\n\n迭代帮助团队为交付和多种反馈创建一个节奏。\n\n增量帮助团队频繁交付。\n\n## 5.3 解决敏捷项目的挑战\n\n| 痛点                                 | 解决                                         |\n| ------------------------------------ | -------------------------------------------- |\n| 目标或任务不明确                     | 愿景、使命。                                 |\n| 工作协议不明确                       | 价值观、原则和工作协议。                     |\n| 团队环境不明确                       | 边界、承诺资产和前瞻性分析。                 |\n| 需求不明确                           | 帮助发起人和相关方制定产品愿景。             |\n| 用户体验不佳                         | 设计实践早期让用户参与。                     |\n| 估算不准确                           | 分解故事。进一步细估。                       |\n| 工作分配或进展不明确                 | 自我管理工作。看板，每日站会。               |\n| 团队面临障碍                         | 仆人式领导消除，消除不了就上报。             |\n| 产品待办事项不完善导致工作延误、超时 | 产品负责人和团队一起研讨故事。“就绪”的定义。 |\n| 缺陷                                 | 完成工作的定义。                             |\n| 工作未完成                           | 为完成工作定义。                             |\n| 技术债务                             | 重构，测试。                                 |\n| 产品复杂性过高                       | 提倡简单，思考简单。                         |\n| 合作进展缓慢                         | 仆人式领导负责协调。                         |\n| 前期工作过多导致返工                 | 不要做过多的工作，通过刺探来学习。           |\n| 错误的开始                           | 产品负责人的重要性。                         |\n| 待办事项无序                         | 创建不同优先级。                             |\n| 不均匀的工作流程                     | 计划对应团队的能力。                         |\n| 相关方要求无法满足                   | 仆人式领导与产品负责人一起工作。             |\n| 意想不到或不可预见的延误             | 团队更频繁地检查工作流。                     |\n| 孤立的团队，而不是跨职能团队         | 讲明是以产品为主的团队而不是以职能。         |\n\n## 5.4 敏捷项目的衡量指标\n\n定义完成和拒绝。\n\n### 5.4.1 敏捷团队的衡量结果\n\n倾向使用基于经验和价值的衡量指标，而不是预测型衡量指标。\n\n# 6. 关于项目敏捷性的组织考虑因素\n\n## 6.1 组织变革管理\n\n### 6.1.1 变革管理驱动因素\n\n- 与加速交付相关的变革。\n- 与敏捷方法相关的变革。\n\n### 6.1.2 变革就绪情况\n\n变革友好型特征：\n\n- 管理层的变革意愿。\n- 组织在员工认知、审核和评估方式上做出改变的意愿。\n- 集中或分散项目、项目于集和项目组合管理职能。\n- 专注于短期预算和指标而不是长期目标。\n- 人才管理成熟度和能力。\n\n## 6.2 组织文化\n\n### 6.2.1 创建安全环境\n\n安全、诚实、透明。\n\n### 6.2.2 评估文化\n\n- 探索 or 执行\n- 速度 or 稳定性\n- 数量 or 质量\n- 灵活性 or 可预测性\n\n## 6.3 采购和合同\n\n- 多层结构。\n- 强调价值交付。\n- 总价增量。\n- 固定时间和材料。\n- 累进的时间和材料。\n- 提前取消方案。\n- 动态范围方案。\n- 团队扩充。\n- 支持全方位供应商。\n\n\n\n","source":"_posts/《敏捷实战指南》.md","raw":"---\ntitle: 《敏捷实战指南》 - 读书笔记\ndate: 2022-07-25 23:00:34\ncategories: [Management]\ntags: [management, develop, scrum]\n---\n\n# 1. 引论\n\n这里用了一个叫做预测法的东西作为对比。作者提到，本书适用于：\n\n- 对于预测法与敏捷方法难以取舍的项目团队。\n- 试图解决快速创新和复杂性问题的项目团队。\n- 致力于团队改进的项目团队。\n\n本书的目的是：\n\n- 帮助项目取得成功。\n- 帮助项目团队顺利交付商业价值。\n- 满足客户的期望和需求。\n\n看第一章所述内容似乎是解决新技术应用到现有的项目上，但寻求不降低项目开发效率的项目管理思路，称之为敏捷思维模式。\n\n# 2. 敏捷概述\n\n## 2.1 可确定的工作与高度不确定的工作\n\n项目工作包括两种不同类型：\n\n- 可确定的工作 - 执行的不确定性和风险通常较低，归宿是自动化。\n- 高度不确定的工作 - 探索性工作，项目变化速度快，复杂性和风险高。\n\n这里提到了**预测法**，其实就是传统开发过程，大概类似可行性分析、需求分析、总体设计、详细设计、编码、测试、部署上线的软件开发流程。这种流程应对变更的能力稍微有点弱（其实就是每一个阶段的质量都必须充分的保证，给人犯错的空间比较小），所以这个时候需要一种在短时间内探讨可行性，根据评估和反馈快速调整的开发过程（给试错的空间，这里跟高度不确定性相呼应），也就是敏捷方法。\n\n## 2.2 《敏捷宣言》及思维模式\n\n- 四大价值观\n  - 重视个体以及互动而不是过程和工具。\n  \n    > 这个应该是为了发掘更多可改善的地方。\n  - 可用的软件而不是完整的文档。\n  \n    > 这个大概是讲软件比较完善的时候再沉淀一下弄文档？不然对项目专家的依赖度也太高了。\n  - 客户合作而不是合同谈判。\n  \n    > 这个应该是针对深入业务这一点所说的吧。但是感觉这两个并没有对立关系。\n  - 应对变更而不是遵循计划。\n  \n    > 个人觉得这点恐怕对团队的能力要求有点高。\n\n> 上面所说的是敏捷开发的一个价值观，总体来讲我觉得对整个团队里每个人能力的要求都要比传统的高一点，这个不太好做其实。\n\n- 十二大原则\n  - 最高目标，通过尽早持续交付有价值的软件来满足客户的需求。\n  \n    > 比起传统方法多了个快。\n  - 欢迎对需求提出变更，善于利用变更，以帮助客户获得竞争优势。\n  \n    > 其实需求变更这个东西怎么说呢，软件开发者不太想要。至少能不停变更需求的软件与定好需求的软件不是一个价格，基于需求要变更这个前提，敏捷开发会比传统方法舒服。\n  - 要经常交付可用的软件。\n  \n    > 这里应该是指局部交付，以避免所有东西都做出来结果发现不尽人意这种情况，通过这种方式尽快找出错误。\n  - 项目实施过程中，业务人员与开发人员必须始终通力合作。\n  \n    > 这一点我个人是非常赞同的。很多时候，开发人员从技术上提升的代价比更深入理解业务大很多。\n  - 善于激励项目人员，给予他们所需的环境和支持，并相信他们能够完成任务。 \n  \n    > 我觉得看人。\n  - 无论是对开发团队还是团队内部，信息传达最有效的方法都是面对面交谈。\n  \n    > 确实。\n  - 可用的软件是衡量进度的首要衡量标准。 \n  \n    > 类似于 Talk is cheap, show me your code.\n  - 敏捷过程提倡可持续的开发。项目发起人、开发人员和用户应该都能够始终保证持续步调稳定性。 \n  \n    > 对开发人员的状态是个考验。\n  - 对技术的精益求精以及对设计的不断完善将提高敏捷性。 \n  \n    > 其实这点是不是敏捷开发都一样的。\n  - 简洁，即尽最大可能减少不必要的工作。\n  \n    > 这点对管理者是个考验。\n  - 最佳的架构、需求和设计将出自组织团队。\n  \n    > 对组织团队有点依赖，不过要敏捷的话确实只有这样。\n  - 团队定期反省怎样做才能更有效，并相应地调整团队地行为。\n  \n    > 这点讲究开发过程的变化。\n\n## 2.3 精益与看板方法\n\n重点在于：\n\n- 交付价值\n\n  > 我觉得是指客户满意度这方面来讲。\n\n- 尊重人\n\n  > 对客户来讲确实尊重，对开发者来讲其实有点压榨的意思，当然也可以说是信任开发者，这个恐怕得看人。\n\n- 减少浪费\n\n  > 这点对项目经理（专家）要求会高一点。\n\n- 透明化\n\n  > 这个确实是优点，可以看到每个人在干嘛。\n\n- 适应变更\n\n  > 这个有点像是附加价值。\n\n- 持续改善\n\n  > 比起改善更强调持续。这种对项目发起人的要求会高一点，可能会出现一种情况，就是项目发起人指负责规划并不参与做项目，由开发技术员做，感觉提供价值方面不太好说。\n\n## 2.4 不确定性、风险和生命周期选择\n\n这里不确定性指需求的不确定性与技术的不确定性两方面，风险指返工的风险。\n\n这里提倡用较小的工作增量验证自身的工作，相当于是每做一个模块的东西，就去汇报验证看是否满足需求，即使返工也只是很小的返工这种方式。\n\n- 非常短的反馈循环。\n- 频繁调整过程。\n- 重新进行优先级排序。\n- 定期更新计划。\n- 频繁交付。\n\n但是这里也明确说了并不是什么都适合敏捷开发，如果一项任务没有中间成果，或者没有原型的时候，比较适合主用预测法去开发，用敏捷方法去管理新的迭代需求和增量交付成果。\n\n当技术和需求的不确定性都很高的时候，为了使项目可靠，需要先遏制其中一个不确定性的变量。\n\n> 从这一节开始，我觉得他讲得有点道理。\n\n# 3. 生命周期选择\n\n这里详细说明了 4 种生命周期的定义：\n\n- 预测型生命周期 - 提前进行大量的计划工作，然后一次性执行；执行时一个连续的过程。\n- 迭代型生命周期 - 这种方法允许对未完成的工作进行反馈，从而改进和修改该工作。\n- 增量型生命周期 - 这种方法向客户提供各个已完成的，可能立即使用的可交付成果。\n- 敏捷型生命周期 - 这种方法既有迭代，也有增量，便于完善工作，频繁交付。\n\n## 3.1 项目生命周期的特征\n\n| 方法   | 需求 | 活动               | 交付             | 目标                                   |\n| ------ | ---- | ------------------ | ---------------- | -------------------------------------- |\n| 预测型 | 固定 | 整个项目仅执行一次 | 一次交付         | 管理成本                               |\n| 迭代型 | 动态 | 反复执行直至修正   | 一次交付         | 解决方案的正确性                       |\n| 增量型 | 动态 | 对给定增量执行一次 | 频繁更小规模交付 | 速度                                   |\n| 敏捷型 | 动态 | 反复执行直至修正   | 频繁小规模交付   | 通过频繁小规模交付和反馈实现的客户价值 |\n\n选择哪一个生命周期取决于需求的变更程度与交付频率。\n\n|                | 需求变更低 | 需求变更高 |\n| -------------- | ---------- | ---------- |\n| **交付频率高** | 增量型     | 敏捷型     |\n| **交付频率低** | 预测型     | 迭代型     |\n\n### 3.1.1 预测型生命周期的特征\n\n```mermaid\ngraph LR\ndemand(需求)-->analysis\nanalysis(分析)-->design\ndesign(设计)-->code\ncode(构建)-->test\ntest(测试)-->deploy(交付)\n```\n\n强调部门划分、有效、顺序的工作。有点谋定而后动的意思，好处自然就是计划非常清晰明了，文档也易构建。坏处就是可能在开发之前就得确定好明确的需求，除此之外还需要对技术有充分的了解，应对需求不确定性和技术不确定性的能力太弱。\n\n### 3.1.2 迭代型生命周期的特征\n\n```mermaid\ngraph LR\nanalysis(需求)-->phase2(分析与设计)\nphase2-->|概念验证| phase2\nphase2-->phase3(构建与测试)\nphase3-->|改善| phase3\nphase3-->deploy(交付)\n```\n\n有点类似与一个学习的开发过程。通过连续的原型或概念验证来改进产品或成果。在同一个时间盒内可能涉及到长达数周时间的迭代。生命周期可能会很长，因为它是为了学习而优化，而不是为交付速度而优化。\n\n### 3.1.3 增量型生命周期的特征\n\n```mermaid\ngraph LR\ndemand(需求) --> phase1\nphase1(分析-设计-构建-测试-交付) --> phase2(分析-设计-构建-测试-交付)\nphase2 --> phase3(分析-设计-构建-测试-交付)\n```\n\n一点一点的交付，突出交付速度快，减少潜在返工。\n\n### 3.1.4 敏捷生命周期的特征\n\n```mermaid\ngraph LR\nphase1(需求-分析-设计-构建-测试) --> phase2(需求-分析-设计-构建-测试)\nphase2 --> deploy1(交付)\ndeploy1(交付) --> phase3(需求-分析-设计-构建-测试)\nphase3 --> phase4(需求-分析-设计-构建-测试)\nphase4 --> phase5(需求-分析-设计-构建-测试)\nphase5 --> deploy2(交付)\n```\n\n类似增量型和迭代型的结合体。\n\n### 3.1.5 敏捷适用性筛选器\n\n### 3.1.6 混合生命周期的特征\n\n依据不同的目标在项目不同的模块选择不同的开发方法。\n\n### 3.1.7 结合了敏捷和预测的方法\n\n### 3.1.8 以预测法为主、敏捷方法为辅的方法\n\n### 3.1.9 以敏捷方法为主、预测法为辅的方法\n\n### 3.1.10 符合目的的混合生命周期\n\n要根据目的去选择开发方法。\n\n### 3.1.11 混合型生命周期作为过渡策略\n\n在预测法的项目上去使用敏捷方法作为过渡而不是一开始就在大项目上使用敏捷方法。\n\n## 3.2 混合敏捷方法\n\n敏捷方法有很多，根据需要进行组合。\n\n## 3.3 影响裁剪的项目因素\n\n| 项目因素             | 裁剪方案                                                     |\n| -------------------- | ------------------------------------------------------------ |\n| 对不稳定需求的适应   | 使用节奏（定期时间盒）帮助团队进行演示、回顾与理解新任务。   |\n| 改进速度不够快       | 更频繁地回归并选择改进措施。                                 |\n| 工作流容易被打断     | 利用看板让工作可见，分配任务优先级。                         |\n| 产品增量质量不佳     | 以测试为重点。                                               |\n| 多团队协同           | 精心制定一种符合项目背景的方法。                             |\n| 团队成员缺乏敏捷经验 | 培养敏捷思维模式和敏捷原则的基本原理。使用特定敏捷方法前开研讨会。 |\n\n# 4. 实施敏捷：创建敏捷环境\n\n## 4.1 从敏捷思维模式开始\n\n从几个问题开始：\n\n- 项目团队如何以敏捷方式行动？\n- 为了使下一交付周期受益，团队需要快速交付哪些成果并获得早期反馈？\n- 团队如何以一种透明的方式行动？\n- 为了专注于高优先级的目标，可以避免哪些工作？\n- 仆人式领导对团队达成目标有何益处？\n\n## 4.2 仆人式领导为团队赋权\n\n仆人式领导使通过对团队服务来领导团队的实践，它注重理解和关注团队成员的需要和发展，旨在使团队尽可能达到最高成绩。\n\n### 4.2.1 仆人式领导的职责\n\n- 促进合作。\n- 审视阻碍敏捷的过程，努力使其合理化。\n- 鼓励团队成员，让人尽其才。\n- 培养团队发展。\n\n### 4.2.2 项目经理在敏捷环境中的角色\n\n项目经理作为技术人员的服务者而不是管理者。\n\n### 4.2.3 项目经理应用仆人式领导\n\n要把责任分配给有能力的人。\n\n## 4.3 团队构成\n\n### 4.3.1 敏捷团队\n\n| 属性                             | 目标                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| 专门人团                         | 专心，提高工作效率；少于十人的小型团队。                     |\n| 跨职能团队成员                   | 频繁开发交付；作为独立团队交付；整合工作；向团队内部外部提供反馈。 |\n| 集中办公或有能力应对办公地点不同 | 改善沟通；挺高团队动力；知识共享；降低学习成本；合作。       |\n| 通才和专家组成的混合团队         | 专家提供专门技能，通才提供从事不同工作的灵活性；团队具有专业能力，体现在都称为通才型专家。 |\n| 稳定的工作环境                   | 彼此依赖；对工作方法相互认同；简化团队成本；知识资本的保证和发展。 |\n\n> 这，感觉对技术人员的要求也太高了。感觉不太可行。\n\n### 4.3.2 敏捷的角色\n\n- 跨职能团队成员\n\n- 产品负责人\n\n  > 我感觉这个才是真正的大佬。\n\n- 团队促进者\n\n  > 听起来有点玄乎。Scrum Master 居然是这个，我说实话不能接受。\n\n### 4.3.3 通才型专家\n\n知识广度够，也有专攻的 T 字型人才。\n\n### 4.3.4 团队结构\n\n以产品为主，将人员组织到跨职能的团队中。\n\n> 做东西来讲这点挺好，问题就是这个知识和技术积累有点困难。\n\n### 4.3.5 专职小组成员\n\n这里阐述在这个团队里专职工作的小组成员比较重要。分散尽力去做多个项目会造成切换时的效率浪费。\n\n### 4.3.6 团队工作场所\n\n独立的私人办公区域与定期开会合作交流。\n\n### 4.3.7 克服组织孤岛\n\n平等的话语权，意见都能被听到并得到考虑。\n\n> 前提是有话语权的人有足够水平的见解和技术吧。\n\n# 5. 实施敏捷：在敏捷环境中交付\n\n## 5.1 项目章程和团队章程\n\n章程：\n\n- 项目重要的原因\n- 团队前景方向\n- 项目目标\n\n敏捷项目章程：\n\n- 项目愿景 - 我们为什么要做这个项目？\n- 项目远景或项目目标的一部分 - 谁会从中受益？如何受益？\n- 项目的发布标准 - 达到哪些条件才意味着项目完成？\n- 预期的工作流 - 我们将怎样合作？\n\n团队章程：\n\n- 团队价值观。\n- 工作协议，“就绪”如何定义，这是团队可以接受工作的前提；“完成”如何定义，达成一致；考虑时间盒，使用工作过程限制。\n- 基本规则，有关一个人在会议发言上的规定。\n- 团队规范，团队如何对待会议时间。\n\n## 5.2 常见敏捷实践\n\n### 5.2.1 回顾\n\n团队定期反省如何能够做到更加有效，并相应地调整团队的行为。\n\n### 5.2.2 待办事项列表编制\n\n所有工作的有序列表，故事。\n\n### 5.2.3 待办事项列表的细化\n\n任务，可能是即时制定的，也可能是迭代会上制定的，也可以是多次会议讨论（比较陌生的项目）。\n\n### 5.2.4 每日站会\n\n过一下看板和任务盒。回答以下问题：\n\n- 基于迭代的敏捷\n\n  - 上次站会以来我都完成了什么？\n\n  - 从现在到下一次站会，我计划完成什么？\n\n  - 我的障碍是什么？\n\n- 基于流程的敏捷\n\n  - 我们还需要做些什么来推进这一工作？\n  - 有人在做看板上没有的事情吗？\n  - 作为一个团队，我们需要完成什么？\n  - 工作流程是否存在瓶颈或障碍？\n\n### 5.2.5 展示/评审\n\n故事完成后，展示时，产品负责人接受或拒绝故事。\n\n### 5.2.6 规划基于迭代的敏捷\n\n反复计划与学习。\n\n> 这块我感觉是为了敏捷而敏捷。\n\n### 5.2.7 帮助团队交付价值的执行实践\n\n- 持续集成\n- 在不同层面测试\n- 验收测试驱动开发\n- 测试驱动开发\n- 刺探（时间盒研究或实验）\n\n### 5.2.8 迭代和增量如何帮助交付工作产品\n\n迭代帮助团队为交付和多种反馈创建一个节奏。\n\n增量帮助团队频繁交付。\n\n## 5.3 解决敏捷项目的挑战\n\n| 痛点                                 | 解决                                         |\n| ------------------------------------ | -------------------------------------------- |\n| 目标或任务不明确                     | 愿景、使命。                                 |\n| 工作协议不明确                       | 价值观、原则和工作协议。                     |\n| 团队环境不明确                       | 边界、承诺资产和前瞻性分析。                 |\n| 需求不明确                           | 帮助发起人和相关方制定产品愿景。             |\n| 用户体验不佳                         | 设计实践早期让用户参与。                     |\n| 估算不准确                           | 分解故事。进一步细估。                       |\n| 工作分配或进展不明确                 | 自我管理工作。看板，每日站会。               |\n| 团队面临障碍                         | 仆人式领导消除，消除不了就上报。             |\n| 产品待办事项不完善导致工作延误、超时 | 产品负责人和团队一起研讨故事。“就绪”的定义。 |\n| 缺陷                                 | 完成工作的定义。                             |\n| 工作未完成                           | 为完成工作定义。                             |\n| 技术债务                             | 重构，测试。                                 |\n| 产品复杂性过高                       | 提倡简单，思考简单。                         |\n| 合作进展缓慢                         | 仆人式领导负责协调。                         |\n| 前期工作过多导致返工                 | 不要做过多的工作，通过刺探来学习。           |\n| 错误的开始                           | 产品负责人的重要性。                         |\n| 待办事项无序                         | 创建不同优先级。                             |\n| 不均匀的工作流程                     | 计划对应团队的能力。                         |\n| 相关方要求无法满足                   | 仆人式领导与产品负责人一起工作。             |\n| 意想不到或不可预见的延误             | 团队更频繁地检查工作流。                     |\n| 孤立的团队，而不是跨职能团队         | 讲明是以产品为主的团队而不是以职能。         |\n\n## 5.4 敏捷项目的衡量指标\n\n定义完成和拒绝。\n\n### 5.4.1 敏捷团队的衡量结果\n\n倾向使用基于经验和价值的衡量指标，而不是预测型衡量指标。\n\n# 6. 关于项目敏捷性的组织考虑因素\n\n## 6.1 组织变革管理\n\n### 6.1.1 变革管理驱动因素\n\n- 与加速交付相关的变革。\n- 与敏捷方法相关的变革。\n\n### 6.1.2 变革就绪情况\n\n变革友好型特征：\n\n- 管理层的变革意愿。\n- 组织在员工认知、审核和评估方式上做出改变的意愿。\n- 集中或分散项目、项目于集和项目组合管理职能。\n- 专注于短期预算和指标而不是长期目标。\n- 人才管理成熟度和能力。\n\n## 6.2 组织文化\n\n### 6.2.1 创建安全环境\n\n安全、诚实、透明。\n\n### 6.2.2 评估文化\n\n- 探索 or 执行\n- 速度 or 稳定性\n- 数量 or 质量\n- 灵活性 or 可预测性\n\n## 6.3 采购和合同\n\n- 多层结构。\n- 强调价值交付。\n- 总价增量。\n- 固定时间和材料。\n- 累进的时间和材料。\n- 提前取消方案。\n- 动态范围方案。\n- 团队扩充。\n- 支持全方位供应商。\n\n\n\n","slug":"《敏捷实战指南》","published":1,"updated":"2022-08-11T15:43:07.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1hb00aj142pde627dsw","content":"<h1 id=\"引论\">1. 引论</h1>\n<p>这里用了一个叫做预测法的东西作为对比。作者提到，本书适用于：</p>\n<ul>\n<li>对于预测法与敏捷方法难以取舍的项目团队。</li>\n<li>试图解决快速创新和复杂性问题的项目团队。</li>\n<li>致力于团队改进的项目团队。</li>\n</ul>\n<p>本书的目的是：</p>\n<ul>\n<li>帮助项目取得成功。</li>\n<li>帮助项目团队顺利交付商业价值。</li>\n<li>满足客户的期望和需求。</li>\n</ul>\n<p>看第一章所述内容似乎是解决新技术应用到现有的项目上，但寻求不降低项目开发效率的项目管理思路，称之为敏捷思维模式。</p>\n<h1 id=\"敏捷概述\">2. 敏捷概述</h1>\n<h2 id=\"可确定的工作与高度不确定的工作\">2.1\n可确定的工作与高度不确定的工作</h2>\n<p>项目工作包括两种不同类型：</p>\n<ul>\n<li>可确定的工作 - 执行的不确定性和风险通常较低，归宿是自动化。</li>\n<li>高度不确定的工作 - 探索性工作，项目变化速度快，复杂性和风险高。</li>\n</ul>\n<p>这里提到了<strong>预测法</strong>，其实就是传统开发过程，大概类似可行性分析、需求分析、总体设计、详细设计、编码、测试、部署上线的软件开发流程。这种流程应对变更的能力稍微有点弱（其实就是每一个阶段的质量都必须充分的保证，给人犯错的空间比较小），所以这个时候需要一种在短时间内探讨可行性，根据评估和反馈快速调整的开发过程（给试错的空间，这里跟高度不确定性相呼应），也就是敏捷方法。</p>\n<h2 id=\"敏捷宣言及思维模式\">2.2 《敏捷宣言》及思维模式</h2>\n<ul>\n<li>四大价值观\n<ul>\n<li><p>重视个体以及互动而不是过程和工具。</p>\n<blockquote>\n<p>这个应该是为了发掘更多可改善的地方。</p>\n</blockquote></li>\n<li><p>可用的软件而不是完整的文档。</p>\n<blockquote>\n<p>这个大概是讲软件比较完善的时候再沉淀一下弄文档？不然对项目专家的依赖度也太高了。</p>\n</blockquote></li>\n<li><p>客户合作而不是合同谈判。</p>\n<blockquote>\n<p>这个应该是针对深入业务这一点所说的吧。但是感觉这两个并没有对立关系。</p>\n</blockquote></li>\n<li><p>应对变更而不是遵循计划。</p>\n<blockquote>\n<p>个人觉得这点恐怕对团队的能力要求有点高。</p>\n</blockquote></li>\n</ul></li>\n</ul>\n<blockquote>\n<p>上面所说的是敏捷开发的一个价值观，总体来讲我觉得对整个团队里每个人能力的要求都要比传统的高一点，这个不太好做其实。</p>\n</blockquote>\n<ul>\n<li>十二大原则\n<ul>\n<li><p>最高目标，通过尽早持续交付有价值的软件来满足客户的需求。</p>\n<blockquote>\n<p>比起传统方法多了个快。</p>\n</blockquote></li>\n<li><p>欢迎对需求提出变更，善于利用变更，以帮助客户获得竞争优势。</p>\n<blockquote>\n<p>其实需求变更这个东西怎么说呢，软件开发者不太想要。至少能不停变更需求的软件与定好需求的软件不是一个价格，基于需求要变更这个前提，敏捷开发会比传统方法舒服。</p>\n</blockquote></li>\n<li><p>要经常交付可用的软件。</p>\n<blockquote>\n<p>这里应该是指局部交付，以避免所有东西都做出来结果发现不尽人意这种情况，通过这种方式尽快找出错误。</p>\n</blockquote></li>\n<li><p>项目实施过程中，业务人员与开发人员必须始终通力合作。</p>\n<blockquote>\n<p>这一点我个人是非常赞同的。很多时候，开发人员从技术上提升的代价比更深入理解业务大很多。</p>\n</blockquote></li>\n<li><p>善于激励项目人员，给予他们所需的环境和支持，并相信他们能够完成任务。</p>\n<blockquote>\n<p>我觉得看人。</p>\n</blockquote></li>\n<li><p>无论是对开发团队还是团队内部，信息传达最有效的方法都是面对面交谈。</p>\n<blockquote>\n<p>确实。</p>\n</blockquote></li>\n<li><p>可用的软件是衡量进度的首要衡量标准。</p>\n<blockquote>\n<p>类似于 Talk is cheap, show me your code.</p>\n</blockquote></li>\n<li><p>敏捷过程提倡可持续的开发。项目发起人、开发人员和用户应该都能够始终保证持续步调稳定性。</p>\n<blockquote>\n<p>对开发人员的状态是个考验。</p>\n</blockquote></li>\n<li><p>对技术的精益求精以及对设计的不断完善将提高敏捷性。</p>\n<blockquote>\n<p>其实这点是不是敏捷开发都一样的。</p>\n</blockquote></li>\n<li><p>简洁，即尽最大可能减少不必要的工作。</p>\n<blockquote>\n<p>这点对管理者是个考验。</p>\n</blockquote></li>\n<li><p>最佳的架构、需求和设计将出自组织团队。</p>\n<blockquote>\n<p>对组织团队有点依赖，不过要敏捷的话确实只有这样。</p>\n</blockquote></li>\n<li><p>团队定期反省怎样做才能更有效，并相应地调整团队地行为。</p>\n<blockquote>\n<p>这点讲究开发过程的变化。</p>\n</blockquote></li>\n</ul></li>\n</ul>\n<h2 id=\"精益与看板方法\">2.3 精益与看板方法</h2>\n<p>重点在于：</p>\n<ul>\n<li><p>交付价值</p>\n<blockquote>\n<p>我觉得是指客户满意度这方面来讲。</p>\n</blockquote></li>\n<li><p>尊重人</p>\n<blockquote>\n<p>对客户来讲确实尊重，对开发者来讲其实有点压榨的意思，当然也可以说是信任开发者，这个恐怕得看人。</p>\n</blockquote></li>\n<li><p>减少浪费</p>\n<blockquote>\n<p>这点对项目经理（专家）要求会高一点。</p>\n</blockquote></li>\n<li><p>透明化</p>\n<blockquote>\n<p>这个确实是优点，可以看到每个人在干嘛。</p>\n</blockquote></li>\n<li><p>适应变更</p>\n<blockquote>\n<p>这个有点像是附加价值。</p>\n</blockquote></li>\n<li><p>持续改善</p>\n<blockquote>\n<p>比起改善更强调持续。这种对项目发起人的要求会高一点，可能会出现一种情况，就是项目发起人指负责规划并不参与做项目，由开发技术员做，感觉提供价值方面不太好说。</p>\n</blockquote></li>\n</ul>\n<h2 id=\"不确定性风险和生命周期选择\">2.4\n不确定性、风险和生命周期选择</h2>\n<p>这里不确定性指需求的不确定性与技术的不确定性两方面，风险指返工的风险。</p>\n<p>这里提倡用较小的工作增量验证自身的工作，相当于是每做一个模块的东西，就去汇报验证看是否满足需求，即使返工也只是很小的返工这种方式。</p>\n<ul>\n<li>非常短的反馈循环。</li>\n<li>频繁调整过程。</li>\n<li>重新进行优先级排序。</li>\n<li>定期更新计划。</li>\n<li>频繁交付。</li>\n</ul>\n<p>但是这里也明确说了并不是什么都适合敏捷开发，如果一项任务没有中间成果，或者没有原型的时候，比较适合主用预测法去开发，用敏捷方法去管理新的迭代需求和增量交付成果。</p>\n<p>当技术和需求的不确定性都很高的时候，为了使项目可靠，需要先遏制其中一个不确定性的变量。</p>\n<blockquote>\n<p>从这一节开始，我觉得他讲得有点道理。</p>\n</blockquote>\n<h1 id=\"生命周期选择\">3. 生命周期选择</h1>\n<p>这里详细说明了 4 种生命周期的定义：</p>\n<ul>\n<li>预测型生命周期 -\n提前进行大量的计划工作，然后一次性执行；执行时一个连续的过程。</li>\n<li>迭代型生命周期 -\n这种方法允许对未完成的工作进行反馈，从而改进和修改该工作。</li>\n<li>增量型生命周期 -\n这种方法向客户提供各个已完成的，可能立即使用的可交付成果。</li>\n<li>敏捷型生命周期 -\n这种方法既有迭代，也有增量，便于完善工作，频繁交付。</li>\n</ul>\n<h2 id=\"项目生命周期的特征\">3.1 项目生命周期的特征</h2>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>需求</th>\n<th>活动</th>\n<th>交付</th>\n<th>目标</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>预测型</td>\n<td>固定</td>\n<td>整个项目仅执行一次</td>\n<td>一次交付</td>\n<td>管理成本</td>\n</tr>\n<tr class=\"even\">\n<td>迭代型</td>\n<td>动态</td>\n<td>反复执行直至修正</td>\n<td>一次交付</td>\n<td>解决方案的正确性</td>\n</tr>\n<tr class=\"odd\">\n<td>增量型</td>\n<td>动态</td>\n<td>对给定增量执行一次</td>\n<td>频繁更小规模交付</td>\n<td>速度</td>\n</tr>\n<tr class=\"even\">\n<td>敏捷型</td>\n<td>动态</td>\n<td>反复执行直至修正</td>\n<td>频繁小规模交付</td>\n<td>通过频繁小规模交付和反馈实现的客户价值</td>\n</tr>\n</tbody>\n</table>\n<p>选择哪一个生命周期取决于需求的变更程度与交付频率。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>需求变更低</th>\n<th>需求变更高</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>交付频率高</strong></td>\n<td>增量型</td>\n<td>敏捷型</td>\n</tr>\n<tr class=\"even\">\n<td><strong>交付频率低</strong></td>\n<td>预测型</td>\n<td>迭代型</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"预测型生命周期的特征\">3.1.1 预测型生命周期的特征</h3>\n<pre><code class=\" mermaid\">graph LR\ndemand(需求)--&gt;analysis\nanalysis(分析)--&gt;design\ndesign(设计)--&gt;code\ncode(构建)--&gt;test\ntest(测试)--&gt;deploy(交付)</code></pre>\n<p>强调部门划分、有效、顺序的工作。有点谋定而后动的意思，好处自然就是计划非常清晰明了，文档也易构建。坏处就是可能在开发之前就得确定好明确的需求，除此之外还需要对技术有充分的了解，应对需求不确定性和技术不确定性的能力太弱。</p>\n<h3 id=\"迭代型生命周期的特征\">3.1.2 迭代型生命周期的特征</h3>\n<pre><code class=\" mermaid\">graph LR\nanalysis(需求)--&gt;phase2(分析与设计)\nphase2--&gt;|概念验证| phase2\nphase2--&gt;phase3(构建与测试)\nphase3--&gt;|改善| phase3\nphase3--&gt;deploy(交付)</code></pre>\n<p>有点类似与一个学习的开发过程。通过连续的原型或概念验证来改进产品或成果。在同一个时间盒内可能涉及到长达数周时间的迭代。生命周期可能会很长，因为它是为了学习而优化，而不是为交付速度而优化。</p>\n<h3 id=\"增量型生命周期的特征\">3.1.3 增量型生命周期的特征</h3>\n<pre><code class=\" mermaid\">graph LR\ndemand(需求) --&gt; phase1\nphase1(分析-设计-构建-测试-交付) --&gt; phase2(分析-设计-构建-测试-交付)\nphase2 --&gt; phase3(分析-设计-构建-测试-交付)</code></pre>\n<p>一点一点的交付，突出交付速度快，减少潜在返工。</p>\n<h3 id=\"敏捷生命周期的特征\">3.1.4 敏捷生命周期的特征</h3>\n<pre><code class=\" mermaid\">graph LR\nphase1(需求-分析-设计-构建-测试) --&gt; phase2(需求-分析-设计-构建-测试)\nphase2 --&gt; deploy1(交付)\ndeploy1(交付) --&gt; phase3(需求-分析-设计-构建-测试)\nphase3 --&gt; phase4(需求-分析-设计-构建-测试)\nphase4 --&gt; phase5(需求-分析-设计-构建-测试)\nphase5 --&gt; deploy2(交付)</code></pre>\n<p>类似增量型和迭代型的结合体。</p>\n<h3 id=\"敏捷适用性筛选器\">3.1.5 敏捷适用性筛选器</h3>\n<h3 id=\"混合生命周期的特征\">3.1.6 混合生命周期的特征</h3>\n<p>依据不同的目标在项目不同的模块选择不同的开发方法。</p>\n<h3 id=\"结合了敏捷和预测的方法\">3.1.7 结合了敏捷和预测的方法</h3>\n<h3 id=\"以预测法为主敏捷方法为辅的方法\">3.1.8\n以预测法为主、敏捷方法为辅的方法</h3>\n<h3 id=\"以敏捷方法为主预测法为辅的方法\">3.1.9\n以敏捷方法为主、预测法为辅的方法</h3>\n<h3 id=\"符合目的的混合生命周期\">3.1.10 符合目的的混合生命周期</h3>\n<p>要根据目的去选择开发方法。</p>\n<h3 id=\"混合型生命周期作为过渡策略\">3.1.11\n混合型生命周期作为过渡策略</h3>\n<p>在预测法的项目上去使用敏捷方法作为过渡而不是一开始就在大项目上使用敏捷方法。</p>\n<h2 id=\"混合敏捷方法\">3.2 混合敏捷方法</h2>\n<p>敏捷方法有很多，根据需要进行组合。</p>\n<h2 id=\"影响裁剪的项目因素\">3.3 影响裁剪的项目因素</h2>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>项目因素</th>\n<th>裁剪方案</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>对不稳定需求的适应</td>\n<td>使用节奏（定期时间盒）帮助团队进行演示、回顾与理解新任务。</td>\n</tr>\n<tr class=\"even\">\n<td>改进速度不够快</td>\n<td>更频繁地回归并选择改进措施。</td>\n</tr>\n<tr class=\"odd\">\n<td>工作流容易被打断</td>\n<td>利用看板让工作可见，分配任务优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>产品增量质量不佳</td>\n<td>以测试为重点。</td>\n</tr>\n<tr class=\"odd\">\n<td>多团队协同</td>\n<td>精心制定一种符合项目背景的方法。</td>\n</tr>\n<tr class=\"even\">\n<td>团队成员缺乏敏捷经验</td>\n<td>培养敏捷思维模式和敏捷原则的基本原理。使用特定敏捷方法前开研讨会。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"实施敏捷创建敏捷环境\">4. 实施敏捷：创建敏捷环境</h1>\n<h2 id=\"从敏捷思维模式开始\">4.1 从敏捷思维模式开始</h2>\n<p>从几个问题开始：</p>\n<ul>\n<li>项目团队如何以敏捷方式行动？</li>\n<li>为了使下一交付周期受益，团队需要快速交付哪些成果并获得早期反馈？</li>\n<li>团队如何以一种透明的方式行动？</li>\n<li>为了专注于高优先级的目标，可以避免哪些工作？</li>\n<li>仆人式领导对团队达成目标有何益处？</li>\n</ul>\n<h2 id=\"仆人式领导为团队赋权\">4.2 仆人式领导为团队赋权</h2>\n<p>仆人式领导使通过对团队服务来领导团队的实践，它注重理解和关注团队成员的需要和发展，旨在使团队尽可能达到最高成绩。</p>\n<h3 id=\"仆人式领导的职责\">4.2.1 仆人式领导的职责</h3>\n<ul>\n<li>促进合作。</li>\n<li>审视阻碍敏捷的过程，努力使其合理化。</li>\n<li>鼓励团队成员，让人尽其才。</li>\n<li>培养团队发展。</li>\n</ul>\n<h3 id=\"项目经理在敏捷环境中的角色\">4.2.2\n项目经理在敏捷环境中的角色</h3>\n<p>项目经理作为技术人员的服务者而不是管理者。</p>\n<h3 id=\"项目经理应用仆人式领导\">4.2.3 项目经理应用仆人式领导</h3>\n<p>要把责任分配给有能力的人。</p>\n<h2 id=\"团队构成\">4.3 团队构成</h2>\n<h3 id=\"敏捷团队\">4.3.1 敏捷团队</h3>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>属性</th>\n<th>目标</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>专门人团</td>\n<td>专心，提高工作效率；少于十人的小型团队。</td>\n</tr>\n<tr class=\"even\">\n<td>跨职能团队成员</td>\n<td>频繁开发交付；作为独立团队交付；整合工作；向团队内部外部提供反馈。</td>\n</tr>\n<tr class=\"odd\">\n<td>集中办公或有能力应对办公地点不同</td>\n<td>改善沟通；挺高团队动力；知识共享；降低学习成本；合作。</td>\n</tr>\n<tr class=\"even\">\n<td>通才和专家组成的混合团队</td>\n<td>专家提供专门技能，通才提供从事不同工作的灵活性；团队具有专业能力，体现在都称为通才型专家。</td>\n</tr>\n<tr class=\"odd\">\n<td>稳定的工作环境</td>\n<td>彼此依赖；对工作方法相互认同；简化团队成本；知识资本的保证和发展。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>这，感觉对技术人员的要求也太高了。感觉不太可行。</p>\n</blockquote>\n<h3 id=\"敏捷的角色\">4.3.2 敏捷的角色</h3>\n<ul>\n<li><p>跨职能团队成员</p></li>\n<li><p>产品负责人</p>\n<blockquote>\n<p>我感觉这个才是真正的大佬。</p>\n</blockquote></li>\n<li><p>团队促进者</p>\n<blockquote>\n<p>听起来有点玄乎。Scrum Master 居然是这个，我说实话不能接受。</p>\n</blockquote></li>\n</ul>\n<h3 id=\"通才型专家\">4.3.3 通才型专家</h3>\n<p>知识广度够，也有专攻的 T 字型人才。</p>\n<h3 id=\"团队结构\">4.3.4 团队结构</h3>\n<p>以产品为主，将人员组织到跨职能的团队中。</p>\n<blockquote>\n<p>做东西来讲这点挺好，问题就是这个知识和技术积累有点困难。</p>\n</blockquote>\n<h3 id=\"专职小组成员\">4.3.5 专职小组成员</h3>\n<p>这里阐述在这个团队里专职工作的小组成员比较重要。分散尽力去做多个项目会造成切换时的效率浪费。</p>\n<h3 id=\"团队工作场所\">4.3.6 团队工作场所</h3>\n<p>独立的私人办公区域与定期开会合作交流。</p>\n<h3 id=\"克服组织孤岛\">4.3.7 克服组织孤岛</h3>\n<p>平等的话语权，意见都能被听到并得到考虑。</p>\n<blockquote>\n<p>前提是有话语权的人有足够水平的见解和技术吧。</p>\n</blockquote>\n<h1 id=\"实施敏捷在敏捷环境中交付\">5. 实施敏捷：在敏捷环境中交付</h1>\n<h2 id=\"项目章程和团队章程\">5.1 项目章程和团队章程</h2>\n<p>章程：</p>\n<ul>\n<li>项目重要的原因</li>\n<li>团队前景方向</li>\n<li>项目目标</li>\n</ul>\n<p>敏捷项目章程：</p>\n<ul>\n<li>项目愿景 - 我们为什么要做这个项目？</li>\n<li>项目远景或项目目标的一部分 - 谁会从中受益？如何受益？</li>\n<li>项目的发布标准 - 达到哪些条件才意味着项目完成？</li>\n<li>预期的工作流 - 我们将怎样合作？</li>\n</ul>\n<p>团队章程：</p>\n<ul>\n<li>团队价值观。</li>\n<li>工作协议，“就绪”如何定义，这是团队可以接受工作的前提；“完成”如何定义，达成一致；考虑时间盒，使用工作过程限制。</li>\n<li>基本规则，有关一个人在会议发言上的规定。</li>\n<li>团队规范，团队如何对待会议时间。</li>\n</ul>\n<h2 id=\"常见敏捷实践\">5.2 常见敏捷实践</h2>\n<h3 id=\"回顾\">5.2.1 回顾</h3>\n<p>团队定期反省如何能够做到更加有效，并相应地调整团队的行为。</p>\n<h3 id=\"待办事项列表编制\">5.2.2 待办事项列表编制</h3>\n<p>所有工作的有序列表，故事。</p>\n<h3 id=\"待办事项列表的细化\">5.2.3 待办事项列表的细化</h3>\n<p>任务，可能是即时制定的，也可能是迭代会上制定的，也可以是多次会议讨论（比较陌生的项目）。</p>\n<h3 id=\"每日站会\">5.2.4 每日站会</h3>\n<p>过一下看板和任务盒。回答以下问题：</p>\n<ul>\n<li><p>基于迭代的敏捷</p>\n<ul>\n<li><p>上次站会以来我都完成了什么？</p></li>\n<li><p>从现在到下一次站会，我计划完成什么？</p></li>\n<li><p>我的障碍是什么？</p></li>\n</ul></li>\n<li><p>基于流程的敏捷</p>\n<ul>\n<li>我们还需要做些什么来推进这一工作？</li>\n<li>有人在做看板上没有的事情吗？</li>\n<li>作为一个团队，我们需要完成什么？</li>\n<li>工作流程是否存在瓶颈或障碍？</li>\n</ul></li>\n</ul>\n<h3 id=\"展示评审\">5.2.5 展示/评审</h3>\n<p>故事完成后，展示时，产品负责人接受或拒绝故事。</p>\n<h3 id=\"规划基于迭代的敏捷\">5.2.6 规划基于迭代的敏捷</h3>\n<p>反复计划与学习。</p>\n<blockquote>\n<p>这块我感觉是为了敏捷而敏捷。</p>\n</blockquote>\n<h3 id=\"帮助团队交付价值的执行实践\">5.2.7\n帮助团队交付价值的执行实践</h3>\n<ul>\n<li>持续集成</li>\n<li>在不同层面测试</li>\n<li>验收测试驱动开发</li>\n<li>测试驱动开发</li>\n<li>刺探（时间盒研究或实验）</li>\n</ul>\n<h3 id=\"迭代和增量如何帮助交付工作产品\">5.2.8\n迭代和增量如何帮助交付工作产品</h3>\n<p>迭代帮助团队为交付和多种反馈创建一个节奏。</p>\n<p>增量帮助团队频繁交付。</p>\n<h2 id=\"解决敏捷项目的挑战\">5.3 解决敏捷项目的挑战</h2>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>痛点</th>\n<th>解决</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>目标或任务不明确</td>\n<td>愿景、使命。</td>\n</tr>\n<tr class=\"even\">\n<td>工作协议不明确</td>\n<td>价值观、原则和工作协议。</td>\n</tr>\n<tr class=\"odd\">\n<td>团队环境不明确</td>\n<td>边界、承诺资产和前瞻性分析。</td>\n</tr>\n<tr class=\"even\">\n<td>需求不明确</td>\n<td>帮助发起人和相关方制定产品愿景。</td>\n</tr>\n<tr class=\"odd\">\n<td>用户体验不佳</td>\n<td>设计实践早期让用户参与。</td>\n</tr>\n<tr class=\"even\">\n<td>估算不准确</td>\n<td>分解故事。进一步细估。</td>\n</tr>\n<tr class=\"odd\">\n<td>工作分配或进展不明确</td>\n<td>自我管理工作。看板，每日站会。</td>\n</tr>\n<tr class=\"even\">\n<td>团队面临障碍</td>\n<td>仆人式领导消除，消除不了就上报。</td>\n</tr>\n<tr class=\"odd\">\n<td>产品待办事项不完善导致工作延误、超时</td>\n<td>产品负责人和团队一起研讨故事。“就绪”的定义。</td>\n</tr>\n<tr class=\"even\">\n<td>缺陷</td>\n<td>完成工作的定义。</td>\n</tr>\n<tr class=\"odd\">\n<td>工作未完成</td>\n<td>为完成工作定义。</td>\n</tr>\n<tr class=\"even\">\n<td>技术债务</td>\n<td>重构，测试。</td>\n</tr>\n<tr class=\"odd\">\n<td>产品复杂性过高</td>\n<td>提倡简单，思考简单。</td>\n</tr>\n<tr class=\"even\">\n<td>合作进展缓慢</td>\n<td>仆人式领导负责协调。</td>\n</tr>\n<tr class=\"odd\">\n<td>前期工作过多导致返工</td>\n<td>不要做过多的工作，通过刺探来学习。</td>\n</tr>\n<tr class=\"even\">\n<td>错误的开始</td>\n<td>产品负责人的重要性。</td>\n</tr>\n<tr class=\"odd\">\n<td>待办事项无序</td>\n<td>创建不同优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>不均匀的工作流程</td>\n<td>计划对应团队的能力。</td>\n</tr>\n<tr class=\"odd\">\n<td>相关方要求无法满足</td>\n<td>仆人式领导与产品负责人一起工作。</td>\n</tr>\n<tr class=\"even\">\n<td>意想不到或不可预见的延误</td>\n<td>团队更频繁地检查工作流。</td>\n</tr>\n<tr class=\"odd\">\n<td>孤立的团队，而不是跨职能团队</td>\n<td>讲明是以产品为主的团队而不是以职能。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"敏捷项目的衡量指标\">5.4 敏捷项目的衡量指标</h2>\n<p>定义完成和拒绝。</p>\n<h3 id=\"敏捷团队的衡量结果\">5.4.1 敏捷团队的衡量结果</h3>\n<p>倾向使用基于经验和价值的衡量指标，而不是预测型衡量指标。</p>\n<h1 id=\"关于项目敏捷性的组织考虑因素\">6.\n关于项目敏捷性的组织考虑因素</h1>\n<h2 id=\"组织变革管理\">6.1 组织变革管理</h2>\n<h3 id=\"变革管理驱动因素\">6.1.1 变革管理驱动因素</h3>\n<ul>\n<li>与加速交付相关的变革。</li>\n<li>与敏捷方法相关的变革。</li>\n</ul>\n<h3 id=\"变革就绪情况\">6.1.2 变革就绪情况</h3>\n<p>变革友好型特征：</p>\n<ul>\n<li>管理层的变革意愿。</li>\n<li>组织在员工认知、审核和评估方式上做出改变的意愿。</li>\n<li>集中或分散项目、项目于集和项目组合管理职能。</li>\n<li>专注于短期预算和指标而不是长期目标。</li>\n<li>人才管理成熟度和能力。</li>\n</ul>\n<h2 id=\"组织文化\">6.2 组织文化</h2>\n<h3 id=\"创建安全环境\">6.2.1 创建安全环境</h3>\n<p>安全、诚实、透明。</p>\n<h3 id=\"评估文化\">6.2.2 评估文化</h3>\n<ul>\n<li>探索 or 执行</li>\n<li>速度 or 稳定性</li>\n<li>数量 or 质量</li>\n<li>灵活性 or 可预测性</li>\n</ul>\n<h2 id=\"采购和合同\">6.3 采购和合同</h2>\n<ul>\n<li>多层结构。</li>\n<li>强调价值交付。</li>\n<li>总价增量。</li>\n<li>固定时间和材料。</li>\n<li>累进的时间和材料。</li>\n<li>提前取消方案。</li>\n<li>动态范围方案。</li>\n<li>团队扩充。</li>\n<li>支持全方位供应商。</li>\n</ul>\n","site":{"data":{}},"wordcount":5823,"excerpt":"","more":"<h1 id=\"引论\">1. 引论</h1>\n<p>这里用了一个叫做预测法的东西作为对比。作者提到，本书适用于：</p>\n<ul>\n<li>对于预测法与敏捷方法难以取舍的项目团队。</li>\n<li>试图解决快速创新和复杂性问题的项目团队。</li>\n<li>致力于团队改进的项目团队。</li>\n</ul>\n<p>本书的目的是：</p>\n<ul>\n<li>帮助项目取得成功。</li>\n<li>帮助项目团队顺利交付商业价值。</li>\n<li>满足客户的期望和需求。</li>\n</ul>\n<p>看第一章所述内容似乎是解决新技术应用到现有的项目上，但寻求不降低项目开发效率的项目管理思路，称之为敏捷思维模式。</p>\n<h1 id=\"敏捷概述\">2. 敏捷概述</h1>\n<h2 id=\"可确定的工作与高度不确定的工作\">2.1\n可确定的工作与高度不确定的工作</h2>\n<p>项目工作包括两种不同类型：</p>\n<ul>\n<li>可确定的工作 - 执行的不确定性和风险通常较低，归宿是自动化。</li>\n<li>高度不确定的工作 - 探索性工作，项目变化速度快，复杂性和风险高。</li>\n</ul>\n<p>这里提到了<strong>预测法</strong>，其实就是传统开发过程，大概类似可行性分析、需求分析、总体设计、详细设计、编码、测试、部署上线的软件开发流程。这种流程应对变更的能力稍微有点弱（其实就是每一个阶段的质量都必须充分的保证，给人犯错的空间比较小），所以这个时候需要一种在短时间内探讨可行性，根据评估和反馈快速调整的开发过程（给试错的空间，这里跟高度不确定性相呼应），也就是敏捷方法。</p>\n<h2 id=\"敏捷宣言及思维模式\">2.2 《敏捷宣言》及思维模式</h2>\n<ul>\n<li>四大价值观\n<ul>\n<li><p>重视个体以及互动而不是过程和工具。</p>\n<blockquote>\n<p>这个应该是为了发掘更多可改善的地方。</p>\n</blockquote></li>\n<li><p>可用的软件而不是完整的文档。</p>\n<blockquote>\n<p>这个大概是讲软件比较完善的时候再沉淀一下弄文档？不然对项目专家的依赖度也太高了。</p>\n</blockquote></li>\n<li><p>客户合作而不是合同谈判。</p>\n<blockquote>\n<p>这个应该是针对深入业务这一点所说的吧。但是感觉这两个并没有对立关系。</p>\n</blockquote></li>\n<li><p>应对变更而不是遵循计划。</p>\n<blockquote>\n<p>个人觉得这点恐怕对团队的能力要求有点高。</p>\n</blockquote></li>\n</ul></li>\n</ul>\n<blockquote>\n<p>上面所说的是敏捷开发的一个价值观，总体来讲我觉得对整个团队里每个人能力的要求都要比传统的高一点，这个不太好做其实。</p>\n</blockquote>\n<ul>\n<li>十二大原则\n<ul>\n<li><p>最高目标，通过尽早持续交付有价值的软件来满足客户的需求。</p>\n<blockquote>\n<p>比起传统方法多了个快。</p>\n</blockquote></li>\n<li><p>欢迎对需求提出变更，善于利用变更，以帮助客户获得竞争优势。</p>\n<blockquote>\n<p>其实需求变更这个东西怎么说呢，软件开发者不太想要。至少能不停变更需求的软件与定好需求的软件不是一个价格，基于需求要变更这个前提，敏捷开发会比传统方法舒服。</p>\n</blockquote></li>\n<li><p>要经常交付可用的软件。</p>\n<blockquote>\n<p>这里应该是指局部交付，以避免所有东西都做出来结果发现不尽人意这种情况，通过这种方式尽快找出错误。</p>\n</blockquote></li>\n<li><p>项目实施过程中，业务人员与开发人员必须始终通力合作。</p>\n<blockquote>\n<p>这一点我个人是非常赞同的。很多时候，开发人员从技术上提升的代价比更深入理解业务大很多。</p>\n</blockquote></li>\n<li><p>善于激励项目人员，给予他们所需的环境和支持，并相信他们能够完成任务。</p>\n<blockquote>\n<p>我觉得看人。</p>\n</blockquote></li>\n<li><p>无论是对开发团队还是团队内部，信息传达最有效的方法都是面对面交谈。</p>\n<blockquote>\n<p>确实。</p>\n</blockquote></li>\n<li><p>可用的软件是衡量进度的首要衡量标准。</p>\n<blockquote>\n<p>类似于 Talk is cheap, show me your code.</p>\n</blockquote></li>\n<li><p>敏捷过程提倡可持续的开发。项目发起人、开发人员和用户应该都能够始终保证持续步调稳定性。</p>\n<blockquote>\n<p>对开发人员的状态是个考验。</p>\n</blockquote></li>\n<li><p>对技术的精益求精以及对设计的不断完善将提高敏捷性。</p>\n<blockquote>\n<p>其实这点是不是敏捷开发都一样的。</p>\n</blockquote></li>\n<li><p>简洁，即尽最大可能减少不必要的工作。</p>\n<blockquote>\n<p>这点对管理者是个考验。</p>\n</blockquote></li>\n<li><p>最佳的架构、需求和设计将出自组织团队。</p>\n<blockquote>\n<p>对组织团队有点依赖，不过要敏捷的话确实只有这样。</p>\n</blockquote></li>\n<li><p>团队定期反省怎样做才能更有效，并相应地调整团队地行为。</p>\n<blockquote>\n<p>这点讲究开发过程的变化。</p>\n</blockquote></li>\n</ul></li>\n</ul>\n<h2 id=\"精益与看板方法\">2.3 精益与看板方法</h2>\n<p>重点在于：</p>\n<ul>\n<li><p>交付价值</p>\n<blockquote>\n<p>我觉得是指客户满意度这方面来讲。</p>\n</blockquote></li>\n<li><p>尊重人</p>\n<blockquote>\n<p>对客户来讲确实尊重，对开发者来讲其实有点压榨的意思，当然也可以说是信任开发者，这个恐怕得看人。</p>\n</blockquote></li>\n<li><p>减少浪费</p>\n<blockquote>\n<p>这点对项目经理（专家）要求会高一点。</p>\n</blockquote></li>\n<li><p>透明化</p>\n<blockquote>\n<p>这个确实是优点，可以看到每个人在干嘛。</p>\n</blockquote></li>\n<li><p>适应变更</p>\n<blockquote>\n<p>这个有点像是附加价值。</p>\n</blockquote></li>\n<li><p>持续改善</p>\n<blockquote>\n<p>比起改善更强调持续。这种对项目发起人的要求会高一点，可能会出现一种情况，就是项目发起人指负责规划并不参与做项目，由开发技术员做，感觉提供价值方面不太好说。</p>\n</blockquote></li>\n</ul>\n<h2 id=\"不确定性风险和生命周期选择\">2.4\n不确定性、风险和生命周期选择</h2>\n<p>这里不确定性指需求的不确定性与技术的不确定性两方面，风险指返工的风险。</p>\n<p>这里提倡用较小的工作增量验证自身的工作，相当于是每做一个模块的东西，就去汇报验证看是否满足需求，即使返工也只是很小的返工这种方式。</p>\n<ul>\n<li>非常短的反馈循环。</li>\n<li>频繁调整过程。</li>\n<li>重新进行优先级排序。</li>\n<li>定期更新计划。</li>\n<li>频繁交付。</li>\n</ul>\n<p>但是这里也明确说了并不是什么都适合敏捷开发，如果一项任务没有中间成果，或者没有原型的时候，比较适合主用预测法去开发，用敏捷方法去管理新的迭代需求和增量交付成果。</p>\n<p>当技术和需求的不确定性都很高的时候，为了使项目可靠，需要先遏制其中一个不确定性的变量。</p>\n<blockquote>\n<p>从这一节开始，我觉得他讲得有点道理。</p>\n</blockquote>\n<h1 id=\"生命周期选择\">3. 生命周期选择</h1>\n<p>这里详细说明了 4 种生命周期的定义：</p>\n<ul>\n<li>预测型生命周期 -\n提前进行大量的计划工作，然后一次性执行；执行时一个连续的过程。</li>\n<li>迭代型生命周期 -\n这种方法允许对未完成的工作进行反馈，从而改进和修改该工作。</li>\n<li>增量型生命周期 -\n这种方法向客户提供各个已完成的，可能立即使用的可交付成果。</li>\n<li>敏捷型生命周期 -\n这种方法既有迭代，也有增量，便于完善工作，频繁交付。</li>\n</ul>\n<h2 id=\"项目生命周期的特征\">3.1 项目生命周期的特征</h2>\n<table>\n<colgroup>\n<col style=\"width: 7%\" />\n<col style=\"width: 4%\" />\n<col style=\"width: 21%\" />\n<col style=\"width: 19%\" />\n<col style=\"width: 46%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>需求</th>\n<th>活动</th>\n<th>交付</th>\n<th>目标</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>预测型</td>\n<td>固定</td>\n<td>整个项目仅执行一次</td>\n<td>一次交付</td>\n<td>管理成本</td>\n</tr>\n<tr class=\"even\">\n<td>迭代型</td>\n<td>动态</td>\n<td>反复执行直至修正</td>\n<td>一次交付</td>\n<td>解决方案的正确性</td>\n</tr>\n<tr class=\"odd\">\n<td>增量型</td>\n<td>动态</td>\n<td>对给定增量执行一次</td>\n<td>频繁更小规模交付</td>\n<td>速度</td>\n</tr>\n<tr class=\"even\">\n<td>敏捷型</td>\n<td>动态</td>\n<td>反复执行直至修正</td>\n<td>频繁小规模交付</td>\n<td>通过频繁小规模交付和反馈实现的客户价值</td>\n</tr>\n</tbody>\n</table>\n<p>选择哪一个生命周期取决于需求的变更程度与交付频率。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>需求变更低</th>\n<th>需求变更高</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>交付频率高</strong></td>\n<td>增量型</td>\n<td>敏捷型</td>\n</tr>\n<tr class=\"even\">\n<td><strong>交付频率低</strong></td>\n<td>预测型</td>\n<td>迭代型</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"预测型生命周期的特征\">3.1.1 预测型生命周期的特征</h3>\n<pre><code class=\"hljs mermaid\">graph LR\ndemand(需求)--&gt;analysis\nanalysis(分析)--&gt;design\ndesign(设计)--&gt;code\ncode(构建)--&gt;test\ntest(测试)--&gt;deploy(交付)</code></pre>\n<p>强调部门划分、有效、顺序的工作。有点谋定而后动的意思，好处自然就是计划非常清晰明了，文档也易构建。坏处就是可能在开发之前就得确定好明确的需求，除此之外还需要对技术有充分的了解，应对需求不确定性和技术不确定性的能力太弱。</p>\n<h3 id=\"迭代型生命周期的特征\">3.1.2 迭代型生命周期的特征</h3>\n<pre><code class=\"hljs mermaid\">graph LR\nanalysis(需求)--&gt;phase2(分析与设计)\nphase2--&gt;|概念验证| phase2\nphase2--&gt;phase3(构建与测试)\nphase3--&gt;|改善| phase3\nphase3--&gt;deploy(交付)</code></pre>\n<p>有点类似与一个学习的开发过程。通过连续的原型或概念验证来改进产品或成果。在同一个时间盒内可能涉及到长达数周时间的迭代。生命周期可能会很长，因为它是为了学习而优化，而不是为交付速度而优化。</p>\n<h3 id=\"增量型生命周期的特征\">3.1.3 增量型生命周期的特征</h3>\n<pre><code class=\"hljs mermaid\">graph LR\ndemand(需求) --&gt; phase1\nphase1(分析-设计-构建-测试-交付) --&gt; phase2(分析-设计-构建-测试-交付)\nphase2 --&gt; phase3(分析-设计-构建-测试-交付)</code></pre>\n<p>一点一点的交付，突出交付速度快，减少潜在返工。</p>\n<h3 id=\"敏捷生命周期的特征\">3.1.4 敏捷生命周期的特征</h3>\n<pre><code class=\"hljs mermaid\">graph LR\nphase1(需求-分析-设计-构建-测试) --&gt; phase2(需求-分析-设计-构建-测试)\nphase2 --&gt; deploy1(交付)\ndeploy1(交付) --&gt; phase3(需求-分析-设计-构建-测试)\nphase3 --&gt; phase4(需求-分析-设计-构建-测试)\nphase4 --&gt; phase5(需求-分析-设计-构建-测试)\nphase5 --&gt; deploy2(交付)</code></pre>\n<p>类似增量型和迭代型的结合体。</p>\n<h3 id=\"敏捷适用性筛选器\">3.1.5 敏捷适用性筛选器</h3>\n<h3 id=\"混合生命周期的特征\">3.1.6 混合生命周期的特征</h3>\n<p>依据不同的目标在项目不同的模块选择不同的开发方法。</p>\n<h3 id=\"结合了敏捷和预测的方法\">3.1.7 结合了敏捷和预测的方法</h3>\n<h3 id=\"以预测法为主敏捷方法为辅的方法\">3.1.8\n以预测法为主、敏捷方法为辅的方法</h3>\n<h3 id=\"以敏捷方法为主预测法为辅的方法\">3.1.9\n以敏捷方法为主、预测法为辅的方法</h3>\n<h3 id=\"符合目的的混合生命周期\">3.1.10 符合目的的混合生命周期</h3>\n<p>要根据目的去选择开发方法。</p>\n<h3 id=\"混合型生命周期作为过渡策略\">3.1.11\n混合型生命周期作为过渡策略</h3>\n<p>在预测法的项目上去使用敏捷方法作为过渡而不是一开始就在大项目上使用敏捷方法。</p>\n<h2 id=\"混合敏捷方法\">3.2 混合敏捷方法</h2>\n<p>敏捷方法有很多，根据需要进行组合。</p>\n<h2 id=\"影响裁剪的项目因素\">3.3 影响裁剪的项目因素</h2>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 75%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>项目因素</th>\n<th>裁剪方案</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>对不稳定需求的适应</td>\n<td>使用节奏（定期时间盒）帮助团队进行演示、回顾与理解新任务。</td>\n</tr>\n<tr class=\"even\">\n<td>改进速度不够快</td>\n<td>更频繁地回归并选择改进措施。</td>\n</tr>\n<tr class=\"odd\">\n<td>工作流容易被打断</td>\n<td>利用看板让工作可见，分配任务优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>产品增量质量不佳</td>\n<td>以测试为重点。</td>\n</tr>\n<tr class=\"odd\">\n<td>多团队协同</td>\n<td>精心制定一种符合项目背景的方法。</td>\n</tr>\n<tr class=\"even\">\n<td>团队成员缺乏敏捷经验</td>\n<td>培养敏捷思维模式和敏捷原则的基本原理。使用特定敏捷方法前开研讨会。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"实施敏捷创建敏捷环境\">4. 实施敏捷：创建敏捷环境</h1>\n<h2 id=\"从敏捷思维模式开始\">4.1 从敏捷思维模式开始</h2>\n<p>从几个问题开始：</p>\n<ul>\n<li>项目团队如何以敏捷方式行动？</li>\n<li>为了使下一交付周期受益，团队需要快速交付哪些成果并获得早期反馈？</li>\n<li>团队如何以一种透明的方式行动？</li>\n<li>为了专注于高优先级的目标，可以避免哪些工作？</li>\n<li>仆人式领导对团队达成目标有何益处？</li>\n</ul>\n<h2 id=\"仆人式领导为团队赋权\">4.2 仆人式领导为团队赋权</h2>\n<p>仆人式领导使通过对团队服务来领导团队的实践，它注重理解和关注团队成员的需要和发展，旨在使团队尽可能达到最高成绩。</p>\n<h3 id=\"仆人式领导的职责\">4.2.1 仆人式领导的职责</h3>\n<ul>\n<li>促进合作。</li>\n<li>审视阻碍敏捷的过程，努力使其合理化。</li>\n<li>鼓励团队成员，让人尽其才。</li>\n<li>培养团队发展。</li>\n</ul>\n<h3 id=\"项目经理在敏捷环境中的角色\">4.2.2\n项目经理在敏捷环境中的角色</h3>\n<p>项目经理作为技术人员的服务者而不是管理者。</p>\n<h3 id=\"项目经理应用仆人式领导\">4.2.3 项目经理应用仆人式领导</h3>\n<p>要把责任分配给有能力的人。</p>\n<h2 id=\"团队构成\">4.3 团队构成</h2>\n<h3 id=\"敏捷团队\">4.3.1 敏捷团队</h3>\n<table>\n<colgroup>\n<col style=\"width: 34%\" />\n<col style=\"width: 65%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>属性</th>\n<th>目标</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>专门人团</td>\n<td>专心，提高工作效率；少于十人的小型团队。</td>\n</tr>\n<tr class=\"even\">\n<td>跨职能团队成员</td>\n<td>频繁开发交付；作为独立团队交付；整合工作；向团队内部外部提供反馈。</td>\n</tr>\n<tr class=\"odd\">\n<td>集中办公或有能力应对办公地点不同</td>\n<td>改善沟通；挺高团队动力；知识共享；降低学习成本；合作。</td>\n</tr>\n<tr class=\"even\">\n<td>通才和专家组成的混合团队</td>\n<td>专家提供专门技能，通才提供从事不同工作的灵活性；团队具有专业能力，体现在都称为通才型专家。</td>\n</tr>\n<tr class=\"odd\">\n<td>稳定的工作环境</td>\n<td>彼此依赖；对工作方法相互认同；简化团队成本；知识资本的保证和发展。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>这，感觉对技术人员的要求也太高了。感觉不太可行。</p>\n</blockquote>\n<h3 id=\"敏捷的角色\">4.3.2 敏捷的角色</h3>\n<ul>\n<li><p>跨职能团队成员</p></li>\n<li><p>产品负责人</p>\n<blockquote>\n<p>我感觉这个才是真正的大佬。</p>\n</blockquote></li>\n<li><p>团队促进者</p>\n<blockquote>\n<p>听起来有点玄乎。Scrum Master 居然是这个，我说实话不能接受。</p>\n</blockquote></li>\n</ul>\n<h3 id=\"通才型专家\">4.3.3 通才型专家</h3>\n<p>知识广度够，也有专攻的 T 字型人才。</p>\n<h3 id=\"团队结构\">4.3.4 团队结构</h3>\n<p>以产品为主，将人员组织到跨职能的团队中。</p>\n<blockquote>\n<p>做东西来讲这点挺好，问题就是这个知识和技术积累有点困难。</p>\n</blockquote>\n<h3 id=\"专职小组成员\">4.3.5 专职小组成员</h3>\n<p>这里阐述在这个团队里专职工作的小组成员比较重要。分散尽力去做多个项目会造成切换时的效率浪费。</p>\n<h3 id=\"团队工作场所\">4.3.6 团队工作场所</h3>\n<p>独立的私人办公区域与定期开会合作交流。</p>\n<h3 id=\"克服组织孤岛\">4.3.7 克服组织孤岛</h3>\n<p>平等的话语权，意见都能被听到并得到考虑。</p>\n<blockquote>\n<p>前提是有话语权的人有足够水平的见解和技术吧。</p>\n</blockquote>\n<h1 id=\"实施敏捷在敏捷环境中交付\">5. 实施敏捷：在敏捷环境中交付</h1>\n<h2 id=\"项目章程和团队章程\">5.1 项目章程和团队章程</h2>\n<p>章程：</p>\n<ul>\n<li>项目重要的原因</li>\n<li>团队前景方向</li>\n<li>项目目标</li>\n</ul>\n<p>敏捷项目章程：</p>\n<ul>\n<li>项目愿景 - 我们为什么要做这个项目？</li>\n<li>项目远景或项目目标的一部分 - 谁会从中受益？如何受益？</li>\n<li>项目的发布标准 - 达到哪些条件才意味着项目完成？</li>\n<li>预期的工作流 - 我们将怎样合作？</li>\n</ul>\n<p>团队章程：</p>\n<ul>\n<li>团队价值观。</li>\n<li>工作协议，“就绪”如何定义，这是团队可以接受工作的前提；“完成”如何定义，达成一致；考虑时间盒，使用工作过程限制。</li>\n<li>基本规则，有关一个人在会议发言上的规定。</li>\n<li>团队规范，团队如何对待会议时间。</li>\n</ul>\n<h2 id=\"常见敏捷实践\">5.2 常见敏捷实践</h2>\n<h3 id=\"回顾\">5.2.1 回顾</h3>\n<p>团队定期反省如何能够做到更加有效，并相应地调整团队的行为。</p>\n<h3 id=\"待办事项列表编制\">5.2.2 待办事项列表编制</h3>\n<p>所有工作的有序列表，故事。</p>\n<h3 id=\"待办事项列表的细化\">5.2.3 待办事项列表的细化</h3>\n<p>任务，可能是即时制定的，也可能是迭代会上制定的，也可以是多次会议讨论（比较陌生的项目）。</p>\n<h3 id=\"每日站会\">5.2.4 每日站会</h3>\n<p>过一下看板和任务盒。回答以下问题：</p>\n<ul>\n<li><p>基于迭代的敏捷</p>\n<ul>\n<li><p>上次站会以来我都完成了什么？</p></li>\n<li><p>从现在到下一次站会，我计划完成什么？</p></li>\n<li><p>我的障碍是什么？</p></li>\n</ul></li>\n<li><p>基于流程的敏捷</p>\n<ul>\n<li>我们还需要做些什么来推进这一工作？</li>\n<li>有人在做看板上没有的事情吗？</li>\n<li>作为一个团队，我们需要完成什么？</li>\n<li>工作流程是否存在瓶颈或障碍？</li>\n</ul></li>\n</ul>\n<h3 id=\"展示评审\">5.2.5 展示/评审</h3>\n<p>故事完成后，展示时，产品负责人接受或拒绝故事。</p>\n<h3 id=\"规划基于迭代的敏捷\">5.2.6 规划基于迭代的敏捷</h3>\n<p>反复计划与学习。</p>\n<blockquote>\n<p>这块我感觉是为了敏捷而敏捷。</p>\n</blockquote>\n<h3 id=\"帮助团队交付价值的执行实践\">5.2.7\n帮助团队交付价值的执行实践</h3>\n<ul>\n<li>持续集成</li>\n<li>在不同层面测试</li>\n<li>验收测试驱动开发</li>\n<li>测试驱动开发</li>\n<li>刺探（时间盒研究或实验）</li>\n</ul>\n<h3 id=\"迭代和增量如何帮助交付工作产品\">5.2.8\n迭代和增量如何帮助交付工作产品</h3>\n<p>迭代帮助团队为交付和多种反馈创建一个节奏。</p>\n<p>增量帮助团队频繁交付。</p>\n<h2 id=\"解决敏捷项目的挑战\">5.3 解决敏捷项目的挑战</h2>\n<table>\n<colgroup>\n<col style=\"width: 45%\" />\n<col style=\"width: 55%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>痛点</th>\n<th>解决</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>目标或任务不明确</td>\n<td>愿景、使命。</td>\n</tr>\n<tr class=\"even\">\n<td>工作协议不明确</td>\n<td>价值观、原则和工作协议。</td>\n</tr>\n<tr class=\"odd\">\n<td>团队环境不明确</td>\n<td>边界、承诺资产和前瞻性分析。</td>\n</tr>\n<tr class=\"even\">\n<td>需求不明确</td>\n<td>帮助发起人和相关方制定产品愿景。</td>\n</tr>\n<tr class=\"odd\">\n<td>用户体验不佳</td>\n<td>设计实践早期让用户参与。</td>\n</tr>\n<tr class=\"even\">\n<td>估算不准确</td>\n<td>分解故事。进一步细估。</td>\n</tr>\n<tr class=\"odd\">\n<td>工作分配或进展不明确</td>\n<td>自我管理工作。看板，每日站会。</td>\n</tr>\n<tr class=\"even\">\n<td>团队面临障碍</td>\n<td>仆人式领导消除，消除不了就上报。</td>\n</tr>\n<tr class=\"odd\">\n<td>产品待办事项不完善导致工作延误、超时</td>\n<td>产品负责人和团队一起研讨故事。“就绪”的定义。</td>\n</tr>\n<tr class=\"even\">\n<td>缺陷</td>\n<td>完成工作的定义。</td>\n</tr>\n<tr class=\"odd\">\n<td>工作未完成</td>\n<td>为完成工作定义。</td>\n</tr>\n<tr class=\"even\">\n<td>技术债务</td>\n<td>重构，测试。</td>\n</tr>\n<tr class=\"odd\">\n<td>产品复杂性过高</td>\n<td>提倡简单，思考简单。</td>\n</tr>\n<tr class=\"even\">\n<td>合作进展缓慢</td>\n<td>仆人式领导负责协调。</td>\n</tr>\n<tr class=\"odd\">\n<td>前期工作过多导致返工</td>\n<td>不要做过多的工作，通过刺探来学习。</td>\n</tr>\n<tr class=\"even\">\n<td>错误的开始</td>\n<td>产品负责人的重要性。</td>\n</tr>\n<tr class=\"odd\">\n<td>待办事项无序</td>\n<td>创建不同优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>不均匀的工作流程</td>\n<td>计划对应团队的能力。</td>\n</tr>\n<tr class=\"odd\">\n<td>相关方要求无法满足</td>\n<td>仆人式领导与产品负责人一起工作。</td>\n</tr>\n<tr class=\"even\">\n<td>意想不到或不可预见的延误</td>\n<td>团队更频繁地检查工作流。</td>\n</tr>\n<tr class=\"odd\">\n<td>孤立的团队，而不是跨职能团队</td>\n<td>讲明是以产品为主的团队而不是以职能。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"敏捷项目的衡量指标\">5.4 敏捷项目的衡量指标</h2>\n<p>定义完成和拒绝。</p>\n<h3 id=\"敏捷团队的衡量结果\">5.4.1 敏捷团队的衡量结果</h3>\n<p>倾向使用基于经验和价值的衡量指标，而不是预测型衡量指标。</p>\n<h1 id=\"关于项目敏捷性的组织考虑因素\">6.\n关于项目敏捷性的组织考虑因素</h1>\n<h2 id=\"组织变革管理\">6.1 组织变革管理</h2>\n<h3 id=\"变革管理驱动因素\">6.1.1 变革管理驱动因素</h3>\n<ul>\n<li>与加速交付相关的变革。</li>\n<li>与敏捷方法相关的变革。</li>\n</ul>\n<h3 id=\"变革就绪情况\">6.1.2 变革就绪情况</h3>\n<p>变革友好型特征：</p>\n<ul>\n<li>管理层的变革意愿。</li>\n<li>组织在员工认知、审核和评估方式上做出改变的意愿。</li>\n<li>集中或分散项目、项目于集和项目组合管理职能。</li>\n<li>专注于短期预算和指标而不是长期目标。</li>\n<li>人才管理成熟度和能力。</li>\n</ul>\n<h2 id=\"组织文化\">6.2 组织文化</h2>\n<h3 id=\"创建安全环境\">6.2.1 创建安全环境</h3>\n<p>安全、诚实、透明。</p>\n<h3 id=\"评估文化\">6.2.2 评估文化</h3>\n<ul>\n<li>探索 or 执行</li>\n<li>速度 or 稳定性</li>\n<li>数量 or 质量</li>\n<li>灵活性 or 可预测性</li>\n</ul>\n<h2 id=\"采购和合同\">6.3 采购和合同</h2>\n<ul>\n<li>多层结构。</li>\n<li>强调价值交付。</li>\n<li>总价增量。</li>\n<li>固定时间和材料。</li>\n<li>累进的时间和材料。</li>\n<li>提前取消方案。</li>\n<li>动态范围方案。</li>\n<li>团队扩充。</li>\n<li>支持全方位供应商。</li>\n</ul>\n"},{"title":"《信用评分工具：自动化信用管理的理论与实践》 - 读书笔记","date":"2022-06-19T08:13:25.000Z","_content":"\n# 大纲\n\n全书共 8 个部分，分别为：\n\n- 背景设定 - 讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔 loan 做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。\n\n  > 1. 信用评分及其业务 - 什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。\n  > 2. 信用微历史 - 关于信用供给、信用评分、征信机构和评级机构的简要历史。\n  > 3. 信用评分原理 - 如何进行信用评分、怎样建立评分卡。\n\n- 风险业务 - 针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。\n\n  > 4. 风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。\n  > 5. 决策科学 - 信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。\n  > 6. 企业风险评估 - 对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。\n\n- 数学和统计 - 介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。\n\n  > 7. 预测统计 - 因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。\n  > 8. 区分度的测量 - 用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。\n  > 9. 零碎内容 - 描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。\n  > 10. 头脑与机器 - 所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。\n\n- 数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。\n\n  > 11. 数据考虑 - 建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。\n  > 12. 数据来源 - 讨论从客户、内部系统和征信机构获取信息。\n  > 13. 评分结构 - 关注评分卡的定制和架设、数据整合和不同来源数据的匹配。\n  > 14. 信息共享 - 征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。\n  > 15. 数据准备 - 开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。\n\n- 评分卡开发 - 这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把**简单、可解释性强的模型**作为评分卡开发时的选择这个倾向。\n\n  > Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for Private Companies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.\n\n  作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的`可行性分析->需求分析->总体设计->详细设计`有着异曲同工之妙。作者把开发前大体的步骤划分为如下：\n\n  - 项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。\n  - 数据收集 - 从数据来源提取大小合适的样本。\n  - 好坏定义 - 不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。\n  - 样本分层 - 决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）\n  - 确定模型 - 开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。\n  - 决策策略 - 不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。\n\n  开发的完整流程如下：\n\n  > 16. 变量转换 - 分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。\n  > 17. 特征选取 - 确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。\n  > 18. 样本分层 - 是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。\n  > 19. 拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。\n  > 20. 模型校准 - 用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。\n  > 21. 检验交付 - 用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。\n  > 22. 开发管理 - 评分卡开发的流程管理和安排。\n\n- 实施和使用 - 遵循**Wiklund提供的框架**，介绍模型部署与模型监控相关内容。\n\n  > 在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。\n  >\n  > Handbook of credit scoring[M]. Global Professional Publishi, 2001.\n  \n  > 23. 实施安装 - 绿地开发（ Greenfield Software Development, 指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield Software Development, 指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。\n  > 24. 管理控制 - 验证审查，保证分数合理有效。\n  > 25. 跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。\n  > 26. 金融财务 - 损失准备金、风险定价和利润率等问题。\n  \n- 信用风险管理周期 - 这里提到风险管理周期可以分为五个阶段，`市场营销->申请审批->账户管理->催收->回收`。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。\n\n  - 分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。\n  - 吸引（ solicitation ） - 设计和实施营销活动，吸引潜在客户办理业务。\n  - 获取（ acquisition ） - 获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。\n  - 管理（ management ） - 对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。\n  - 催收（ collections ） - 重点关注早期的违约和维持客户关系。\n  - 追踪（ tracing ） - 尝试联系并找到一些因没有更新住址或联系方式而失联的客户。\n  - 回收（ rehabilitation ） - 处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。\n\n  除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。\n\n  > 27. 市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。\n  > 28. 申请审批 - 选择客户的操作。\n  > 29. 账户管理 - 询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。\n  > 30. 催收回收 - 违约原因和催收流程、催收时机和催收策略。\n  > 31. 欺诈防范 - 趋势、类型和工具。\n\n- 监管环境 - 介绍一些对金融机构的监管内容。\n\n  > 32. 监管概念 - 最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。\n  > 33. 隐私保护 - 贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。\n  > 34. 禁止歧视 - 涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。\n  > 35. 公平信贷 - 确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。\n  > 36. 资本要求 - 主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。\n  > 37. 了解客户 - 提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。\n  > 38. 国家差异 - 对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。\n\n# 第一部分 - 背景设定\n\n## 第 1 章 - 信用评分及其业务\n\n### 1.1 什么是信用评分\n\n### 1.2 在哪儿使用信用评分？\n\n#### 1.2.1 数据来源\n\n#### 1.2.2 信用风险管理周期\n\n#### 1.2.3 行为偏好\n\n### 为什么要使用信用评分？\n\n#### 1.3.1 如何影响贷款机构？\n\n#### 1.3.2 对客户的影响\n\n### 1.4 信用评分如何影响信用供给？\n\n### 1.5 小结\n\n## 第 2 章 - 信用微历史\n\n### 2.1 信用的历史\n\n#### 2.1.1 古代历史\n\n#### 2.1.2 中世纪到 19 世纪\n\n#### 2.1.3 20 世纪\n\n### 2.2 信用评分的历史\n\n#### 2.2.1 开拓时期\n\n#### 2.2.2 自动化时期\n\n#### 2.2.3 扩张时期\n\n### 2.3 征信机构的历史\n\n#### 2.3.1 18 世纪中期以前\n\n#### 2.3.2 19 世纪 90 年代以后\n\n#### 2.3.3 20 世纪 60 年代以后\n\n#### 2.3.4 国际\n\n### 2.4 评级机构的历史\n\n### 2.5 小结\n\n## 第三章 - 评分信用原理\n\n### 3.1 评分卡是什么\n\n#### 3.1.1 评分卡的形态\n\n#### 3.1.2 如何开发评分卡\n\n#### 3.1.3 预测能力如何评估\n\n#### 3.1.4 评分卡的偏差是如何出现的\n\n#### 3.1.5 如何应对以上问题\n\n### 3.2 采用何种测量方法\n\n#### 3.2.1 流程与策略\n\n#### 3.2.2 如何开发评分卡\n\n#### 3.2.3 违约概率和损失程度\n\n### 3.3 评分卡的开发流程\n\n#### 3.3.1 项目准备\n\n#### 3.3.2 数据准备\n\n#### 3.3.3 建模分析\n\n#### 3.3.4 模型确定\n\n#### 3.3.5 决策制定和策略\n\n#### 3.3.6 安全保护\n\n### 3.4 什么会影响评分卡\n\n#### 3.4.1 经济偏移\n\n#### 3.4.2 市场偏移\n\n#### 3.4.3 操作偏移\n\n#### 3.4.4 目标偏移\n\n#### 3.4.5 不明偏移\n\n### 3.5 小结\n\n# 第二部分 - 风险业务\n\n## 第 4 章 - 风险理论\n\n### 4.1 风险相关术语\n\n#### 4.1.1 风险关联\n\n#### 4.1.2 风险环境\n\n#### 4.1.3 风险类型\n\n### 4.2 数据与模型\n\n#### 4.2.1 数据类型\n\n#### 4.2.2 模型类型\n\n#### 4.2.3 人为判断\n\n#### 4.2.4 专家系统\n\n### 4.3 小结\n\n## 第 5 章 - 决策科学\n\n### 5.1 自适应控制\n\n### 5.2 成为主人\n\n#### 5.2.1 冠军挑战\n\n#### 5.2.2 优化\n\n#### 5.2.3 策略推断\n\n### 5.3 小结\n\n## 第 6 章 - 企业风险评估\n\n### 6.1 风险评估基础\n\n#### 6.1.1 数据来源\n\n#### 6.1.2 风险模型\n\n#### 6.1.3 风险等级\n\n### 6.2 中小企业贷款\n\n#### 6.2.1 关系型贷款\n\n#### 6.2.2 交易型贷款\n\n### 6.3 财务比率评分\n\n#### 6.3.1 理论先驱\n\n#### 6.3.2 预测比率\n\n#### 6.3.3 限制因素\n\n#### 6.3.4 评级机构\n\n#### 6.3.5 内部评级\n\n### 6.4 信用评级机构\n\n#### 6.4.1 字母等级\n\n#### 6.4.2 评级类型\n\n#### 6.4.3 存在问题\n\n#### 6.4.4 研究重点\n\n### 6.5 前瞻数据建模\n\n#### 6.5.1 历史分析\n\n#### 6.5.2 结构模型\n\n#### 6.5.3 简约模型\n\n### 6.6 小结\n\n# 第三部分 - 数学和统计\n\n## 第 7 章 - 预测统计\n\n### 7.1 模型概述\n\n### 7.2 参数模型\n\n#### 7.2.1 线性模型\n\n#### 7.2.2 判别分析\n\n#### 7.2.3 逻辑回归\n\n### 7.3 非参模型\n\n#### 7.3.1 决策树\n\n#### 7.3.2 神经网络\n\n#### 7.3.3 遗传算法\n\n#### 7.3.4 K 近邻法\n\n#### 7.3.5 线性规划\n\n### 7.4 关键假设\n\n#### 7.4.1 数据因素\n\n#### 7.4.2 统计假设\n\n#### 7.4.3 解决方法\n\n### 7.5 结果比较\n\n## 第 8 章 - 区分度的测量\n\n### 8.1 错误的分类矩阵\n\n| 混淆矩阵            | **实际好 Good** | **实际坏 Bad** |\n| ------------------- | --------------- | -------------- |\n| **预测好 Positive** | TP              | FN             |\n| **预测坏 Negative** | FP              | TN             |\n\n在预测不正确的情况下，分为两种错误：\n\n- 把实际好的预测为坏（ FN ） - False Negative，意为假负，也就是说实际上是正的，被称为**第一类错误**。\n- 把实际坏的预测为好（ FP ） - False Negative，意为假正，也就是说实际上是负的，被称为**第二类错误**。\n\n### 8.2 Kullback 散度\n\n> Kullback S. Information theory and statistics[M]. Courier Corporation, 1997.\n>\n\n Kullback 散度用于测量两个频率分布的差异。在信用评分中，它的表现形式有两种：\n\n- 信息值（ Information Value, IV ）\n- 稳定指数（ Stability Index ）\n\n他们都建立在证据权重（ Weight of Evidence, WOE ）的基础上。\n\n#### 8.2.1 证据权重\n\n$$\nWOE_i=ln(\\frac{N_i}{\\sum N})/(\\frac{P_i}{\\sum P})=ln(\\frac{N_i}{P_i})-ln(\\frac{\\sum N}{\\sum P})\n$$\n\n其中 N 代表没有触发坏客户定义，也就是好客户。P 代表触发坏客户定义，也就是坏客户。那么 $\\frac{N_i}{\\sum N}$ 其实意思就是为好客户的概率，P 也一样，所以上面的公式也可以写为\n$$\nWOE_i=ln(\\frac{P(bad)_i}{P(good)_i})\n$$\n它反映了某个特征的某个值（或组）的**相对风险**，很明显为 WOE 代表了该组的相对风险更小，为负代表该组相对分箱更大。\n\n#### 8.2.2 信息值\n\n$$\nIV=\\sum^{n}_{i=1}[(\\frac{N_i}{\\sum N}-\\frac{P_i}{\\sum P})\\times WOE_i]=\\sum^{n}_{i=1}[\\frac{count(i)}{count(n)}\\times WOE_i]\n$$\n\n\n\n#### 8.2.3 稳定指数\n\n### 8.3 KS 统计量\n\n### 8.4 相关系数\n\n#### 8.4.1 Pearson 积矩\n\n#### 8.4.2 Spearman 秩序\n\n#### 8.4.3 洛伦兹曲线\n\n#### 8.4.4 基尼系数\n\n#### 8.4.5 ROC 曲线\n\n### 8.5 卡方检验\n\n### 8.6 准确性检验\n\n#### 8.6.1 概率论\n\n#### 8.6.2 二项分布\n\n#### 8.6.3 HL统计量\n\n#### 8.6.4 对数似然\n\n### 8.7 小结\n\n## 第 9 章 - 零碎内容\n\n### 9.1 描述方法\n\n#### 9.1.1 聚类分析\n\n#### 9.1.2 因子分析\n\n### 9.2 预报方法\n\n#### 9.2.1 马尔可夫链\n\n#### 9.2.2 生存分析\n\n### 9.3 其他概念\n\n#### 9.3.1 相关性\n\n#### 9.3.2 交叉性\n\n#### 9.3.3 单调性\n\n#### 9.3.4 标准化\n\n### 9.4 开发报告\n\n#### 9.4.1 特征分析报告\n\n#### 9.4.2 分数分布报告\n\n#### 9.4.3 新业务策略表\n\n### 9.5 小结\n\n## 第 10 章 - 头脑与机器\n\n### 10.1 人员和项目\n\n#### 10.1.1 评分卡开发人员\n\n#### 10.1.2 外部供应商\n\n#### 10.1.3 内部资源\n\n#### 10.1.4 项目组\n\n#### 10.1.5 指导委员会\n\n### 10.2 软件\n\n#### 10.2.1 评分卡开发\n\n#### 10.2.1 决策引擎\n\n### 10.3 小结\n\n# 第四部分 - 数据\n\n## 第 11 章 - 数据考虑\n\n### 11.1 数据透明度\n\n> 数据透明度指充分评估风险所需的数据充足程度。\n\n建模的最终目标是获取一个信用度的测量标准，这个标准合适与否取决于借款人数据对我们的透明程度（了解借款人的信息有多全面，特征衍生前的特征）。\n\n不透明的数据通常表现为：\n\n- 缺乏信用记录。\n- 信息不友好。指结构化数据的存储结构不合理，或者数据对信用度影响的逻辑难以建立。\n- 高度复杂。指非结构化数据，例如语音，图像等，可能有用但是我们不知道怎么用。\n\n如果数据透明度不够，贷款机构面临两种选择：\n\n1. 提高贷款利率，作为风险溢价。\n2. 投入额外成本来确定有用信息，例如购买第三方数据源的数据。\n\n那么数据透明度是由数据的数量和质量决定的，就引入了下两章。\n\n### 11.2 数据数量\n\n> 数据的深度和广度，由可得性和同质性决定。\n\n#### 11.2.1 深度和广度\n\n> 样本量（深度）和变量数量（广度）。\n\n最小样本量是 1500 个好样本、 1500 个坏样本、 1000 个拒绝样本。\n\n最终模型一般包含 6~25 个特征。\n\n#### 11.2.2 同质性\n\n> 同质性决定样本是否可以合并处理。\n\n同质性是样本分群的问题。主要要考虑以下 3 点：\n\n1. 目标定义\n2. 数据来源\n3. 交叉作用\n\n以上 3 点有问题的样本都应该分开，然后用不同的模型去处理。\n\n有时我们会遇到在某群体的样本表现高度同质，这种时候应该去寻找新的数据源扩大数据的广度。\n\n#### 11.2.3 可得性\n\n> 数据获取面临的来自系统、权限或法律的限制。\n\n数据采集、系统升级时的数据更新（这里指丢失记录）、反歧视、数据隐私、信息共享。\n\n### 11.3 数据质量\n\n> 数据能否符合某具体需求。高质量的数据应该具备相关性、准确性、完备性、时效性和一致性。\n>\n> 在很多情况下，风险管理所用的信息通常只是为截然不同的目的而设计的处理系统的副产品，而且前端系统对数据质量通常缺乏具体的要求，从而虚弱了其产生信息的质量。\n\n#### 11.3.1 关联性\n\n> 数据要与结果有关，能够为分数和决策提供有意义的帮助。\n\n首要关注的是数据的相关关系而非因果关系。\n\n四个问题：\n\n1. 如果特征可测量，它的预测能力怎么样？\n2. 如果特征不可测量，是否有证据证明它在其他方面有价值？\n3. 特征数据是否在需要时可获取，如果不能怎么办？\n4. 特征在逻辑上是否有意义？\n\n#### 11.3.2 准确性\n\n> 通过正确地获取、加工和储存数据使其准确反映真实状况。\n\n数据不准确主要集中在两方面：\n\n1. 流程设计不完善 - 表格设计、数据采集、系统错误和匹配等方面的问题。\n   - 记账错误 - 数据不正确、不一致或重复。\n   - 漏账错误 - 字段为空或记录缺失。\n2. 作弊 - 为提高申请通过的可能性，申请表答案可能被篡改。\n\n#### 11.3.3 完备性\n\n> 数据包含所有所需信息，允许个别或整条记录有缺失。\n\n特征层面上的完备与样本记录层面上的完备。\n\n#### 11.3.4 时效性\n\n> 数据随时更新。超过一定期限后，数据就会失效。\n\n如 A 卡的特征年龄是基于客户申请时间的年龄，而不是现在的年龄。\n\n对于老客户，更多地依赖行为数据而非申请数据。\n\n#### 11.3.5 一致性\n\n> 随时间推移数据意义保持一致。就算数据有误，也希望一致有误，这样还可以加以利用。\n\n主要是指系统、流程或某参数更新时造成同样的输入不同的输出问题。\n\n重大突发事件也可能造成数据的意义不一致。\n\n#### 11.3.6 对征信机构的影响\n\nCFA 建议贷款机构在作决策时不要局限于一家征信机构的信息。\n\n### 11.4 数据设计\n\n> 定义数据的类型。从实践或统计的角度出发，考虑数据缺失、分母为零的特例和数据设计的问题，最大化数据的价值。\n\n#### 11.4.1 数据类型\n\n> 统计上及实践中描述数据的术语和对特殊情况的处理。\n\n数据的两个维度：\n\n- 记录（ record ） - 单个样本的细节。\n- 字段（ field ）、特征（ characteristic ）、变量（ variable ），这三者都是一个东西。\n\n**统计上的分类：**\n\n| 变量类别 | 类别含义                                                     |\n| -------- | ------------------------------------------------------------ |\n| 分类变量 | 由定性特征确定的分组情况，例如性别（男、女）或颜色（黄、红、蓝）。没有顺序和大小。 |\n| 二元变量 | 仅由两种类别构成，例如“是/否”等一对反义词。又称为二分类变量。信用评分中目标变量大多是二分类变量，例如目标客户（好、坏）。 |\n| 名义变量 | 用标签（名字）或代码（字母/数字）表示的变量。没有顺序和大小。 |\n| 顺序变量 | 只表示一个序列中的相对位置，不表示相对距离的大小，通常和主观评价有关，例如优秀、良好、一般、差。有顺序没有大小。 |\n| 数值变量 | 用整数或实数表示，有顺序有大小，能进行数值运算，比如年龄（整岁）。 |\n| 连续变量 | 存在于连续的序列中，可能值的数量无限，存在最大值和最小值，用实数表示，例如温度、重量、距离和时间。 |\n| 离散变量 | 分离或者不连续的变量，用实数表示。并不代表没有顺序和大小。   |\n| 基数变量 | 离散的，但特指一个集合内的数量。通常等价于离散变量。         |\n\n**实践中的分类：**\n\n| 变量类别         | 类别含义                                                     |\n| ---------------- | ------------------------------------------------------------ |\n| 编码（名义）     | 用符号或数字表现的类别。                                     |\n| 金额（近似连续） | 以货币金额表示的内容，例如余额、额度、交易额，可以计算总数、平均数、趋势、最小值、最大值、范围、极限等。 |\n| 次数（离散）     | 发生的数量，例如子女的数量（来自申请者）、逾期次数（来自贷款机构）、查询次数（来自征信机构）。 |\n| 比率（连续）     | 两个数值相除的结果，最常用于按照规模对金额标准化，例如资产负债率。 |\n| 时间（离散）     | 距离某特定事件（账户开立、账户激活、某次评估）发生的时间，通常按天或月计算。 |\n| 分数（近似连续） | 表示未来某事件发生的概率（打分）。在一些情况下，一个分数可以用来计算另一个分数（比如通过第三方数据的评分卡制作内部的评分卡）。 |\n| 等级（序数）     | 和分数类似，不过它代表一个分数范围，或被主观确定。           |\n\n提到了变量处理的基础方法，主要分为两种：\n\n- 转换特征 - 比如 `birthday` 本身可能并不能作为合适的特征使用，那么我们用某一时间（例如客户申请时间）减去出生日期换算成年就得到了 `age` 这个特征。\n- 特征生成\n  - 多项式生成 - 生成交叉项，例如 `sklearn` 里的 `PolynomialFeatures` 方法。\n  - 计算比率 - 例如计算负债比。\n\n**特例（缺失值、异常值处理）：**\n\n- 数据缺失 - 未找到（不清楚真实是否发生）、无记录（真实发生）、未发生（真实未发生）等。\n- 账户状态 - 同一个特征里没有用相同单位，如一部分是值，一部分是字符。\n- 分母为零 - 除数不能为 0 ，这种情况可以用一个接近 0 的值代替。\n- 分母为负 - 计算比率或比例时，出现了分子分母同时为负的情况。\n\n对缺失值和异常值，一般用一个特殊编号来记录。\n\n#### 11.4.2 表格设计\n\n> 收集数据的表格设计。\n\n最大的挑战在于尽可能获取更多地相关数据，但数据又不过量。\n\n表格的处理方式取决于表格设置的答案时定性的还是定量的。\n\n**数值结果**\n\n分为 3 种：\n\n1. 数值本身。\n2. 计算输入值。\n3. 数值范围。\n\n例如不需要申请者填写年龄，直接填写年龄段和生日；金额上不填某段，填入具体的数值；负债收入比率不需要申请者计算，直接填入负债值和收入值。\n\n**分类结果**\n\n难点在于确定特征的选择范围。\n\n不是直接填空，而是一个选择范围的下拉菜单。\n\n将问题分为更多的维度，例如职业和教育的问题分为行业、工作层级、最高学历、就业现状等维度。\n\n### 11.5 小结\n\n这章探讨了数据透明度、数据数量、数据质量和设计相关方面的问题。目的就是为了提高数据透明度，正是因为数据透明度的提高使得贷款机构对客户有更多的了解，从而可以扩大贷款规模。\n\n## 第 12 章 - 数据来源\n\n### 12.1 客户信息\n\n#### 12.1.1 申请表\n\n#### 12.1.2 财务信息\n\n### 12.2 内部信息\n\n#### 12.2.1 数据类型\n\n#### 12.2.2 数据库类型\n\n#### 12.2.3 客户关系管理\n\n### 12.3 征信数据\n\n#### 12.3.1 查询检索\n\n#### 12.3.2 公共信息\n\n#### 12.3.3 共享数据\n\n#### 12.3.4 欺诈预警\n\n#### 12.3.5 征信分数\n\n#### 12.3.6 地理指标\n\n#### 12.3.7 其他来源\n\n### 12.4 小结\n\n## 第 13 章 - 评分机构\n\n### 13.1 定制服务\n\n#### 13.1.1 通用评分卡\n\n#### 13.1.2 定制评分卡\n\n#### 13.1.3 专家模型\n\n### 13.2 系统架设\n\n### 13.3 数据整合\n\n#### 13.3.1 独立分数\n\n#### 13.3.2 离散分数\n\n#### 13.3.3 合并分数\n\n#### 13.3.4 决策矩阵\n\n### 13.4 信用评分\n\n### 13.5 数据匹配\n\n### 13.6 小结\n\n## 第 14 章 - 信息共享\n\n### 14.1 征信机构\n\n#### 14.1.1 公共与民营\n\n#### 14.1.2 正面信息与负面信息\n\n### 14.2 参与合作\n\n#### 14.2.1 互惠原则\n\n#### 14.2.2 促进因素\n\n#### 14.2.3 阻碍因素\n\n### 14.3 小结\n\n## 第 15 章 - 数据准备\n\n### 15.1 数据获取\n\n#### 15.1.1 申请数据\n\n#### 15.1.2 征信数据\n\n#### 15.1.3 观测数据\n\n#### 15.1.4 表现数据\n\n#### 15.1.5 数据整合\n\n### 15.2 好坏定义\n\n作者强调了好坏定义的重要性，提到了**好坏定义是建模过程中仅次于数据的重要因素，用来设定目标变量。**\n\n![好坏定义](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206201247059.png)\n\n#### 15.2.1 选择状态\n\n指观测期的状态，分为以下4类：\n\n- 排除 - 如果某个子群体的分数不影响对其决策，作者建议排除。和拒绝不一样的地方是这类样本不需要做拒绝推断。\n- 拒绝 - 出于政策规则或者决策规则的样本不需要做拒绝推断。\n- 未采用 - 客户没有接受贷款机构提供的贷款合同，也就是准入了但未做成。可能是价格、利率、合同条款让客户觉得不适。\n- 双方接受 - 只有这类样本会有真实的表现。\n\n#### 15.2.2 表现状态\n\n指表现期的状态，分为以下4类：\n\n- 排除 - 评分卡计划目标之外的结果，比如申请评分卡中出现了欺诈行为或客户去世。这类占比不宜超过总体的 3%。\n\n- 不定 - 指灰样本，申请评分卡的不定率应设定在 5%~15%，行为评分卡的不定率设定在 10%~20%。这里提到设定灰样本有 3 个理由。\n\n  - 技术逾期造成的疑似不良行为 - 我觉得应该是指像美国 ACH 那样的延时得知交易结果的支付方式对标签定义的影响。\n  - 公司策略\n  - 使好坏定义更加清晰。\n\n  这里也讨论了关于提前还款的人是好样本还是不定样本。这类人是可以当作好样本建模的。\n\n- 好样本 - 我们表示欢迎的样本。\n\n- 坏样本 - 我们表示回避的样本。\n\n#### 15.2.3 当前状态和最坏状态\n\n当前状态和最坏状态是指用结果时点的状态（当前状态）还是整个结果期最坏的状态（最坏状态）来确定“不可恢复点”（ point of no return ），也就是去找出账户不会再从坏变好的时间点。\n\n行为评分中，巴塞尔协议 II 要求使用 90 天内最坏最坏状态的定义。申请评分中两种方式都可以。使用当前状态可以确保误判和由坏变好的账户不会被误判，使用最坏状态则对可能是坏的账户更加敏感。\n\n一般情况下，当前状态的常见定义是逾期 60 天，最坏状态的定义是逾期 90 天。\n\n#### 15.2.4 定义设定\n\n定义有 3 种方式：\n\n- 共识 - 内部专家经验判断。\n- 规定 - 由外部机构设定，确保一致性。（这个主要是方便供别人参考吧）\n- 经验（原文应该是 experience ，我个人觉得翻译成**历史**更合适） - 根据自身的历史数据实证分析。提到了滚动率分析，不过并没有讲具体怎么做。\n\n#### 15.2.5 好坏定义标准\n\n讲到好坏定义需要符合 3 个特点：**相关、充足、透明。**\n\n### 15.3 时间窗口\n\n时间窗口组成有一些相关概念，这里讲到了：\n\n- 观测（ observation ） - 指对数据进行观测，作为预测变量。\n- 结果（ outcome ） - 指分析数据观测的结果，确定目标。\n- 日期/月份 - 指信息采集的时间。\n- 窗口（ window ） - 指一段时间。\n\n这些概念的组合就跟时间窗口有很密切的关系了：\n\n- 观测期（ observation window ） - 也叫观察期，指观测点之前的一段时间。\n- 观测日期（ observation date ） - 也叫观测点，位于观测期与表现期之间，指采集数据的日期。\n- 结果期 （ outcome window ） - 也叫表现期，客户表现趋于成熟的时间段。\n\n- 结果日期（ outcome date ） - 指同一样本表现结果的日期。\n\n这两个窗口非常重要，**观测期用于收集用户数据**，例如银行流水等信息，**观测期太短可能会导致变量预测效果不佳**；**表现期用于评价模型的标签（ Y ）多久之后趋于稳定**，随着时间的累加，违约率会增加但是边际增长率降低，**表现期太短可能会存在坏客户风险暴露不充分这样的情况**。在选择合适的观测期与表现期时，需要考虑**账户成熟、样本信息缺失、数据老化**三个因素。\n\n### 15.4 样本设计\n\n#### 15.4.1 样本类型\n\n#### 15.4.2 最大和最小样本量\n\n#### 15.4.3 分层随机抽样\n\n### 15.5 小结\n\n# 第五部分 - 评分卡开发\n\n## 第 16 章 - 变量转换\n\n### 16.1 转换方法\n\n#### 16.1.1 虚拟变量\n\n#### 16.1.2 风险变量\n\n#### 16.1.3 方法选择\n\n### 16.2 粗细分类\n\n#### 16.2.1 特征分析报告\n\n#### 16.2.2 细分类\n\n#### 16.2.3 粗分类\n\n### 16.3 统计量的应用\n\n#### 16.3.1 预测能力测度\n\n#### 16.3.2 粗分类例子\n\n### 16.4 池化算法\n\n#### 16.4.1 非邻池化\n\n#### 16.4.2 相邻池化\n\n#### 16.4.3 单调相邻池化\n\n### 16.5 实际案例\n\n#### 16.5.1 法院判决\n\n#### 16.5.2 行业种类\n\n#### 16.5.3 职业种类\n\n### 16.6 小结\n\n## 第 17 章 - 特征选取\n\n### 17.1 参考因素\n\n### 17.2 预测能力\n\n### 17.3 降维方法\n\n#### 17.3.1 建模处理\n\n#### 17.3.2 相关矩阵\n\n#### 17.3.3 因子分析\n\n### 17.4 变量输入\n\n#### 17.4.1 分步\n\n#### 17.4.2 分块\n\n### 17.5 小结\n\n## 第 18 章 - 样本分层\n\n### 18.1 驱动因素\n\n### 18.2 识别交叉的作用\n\n### 18.3 处理交叉的作用\n\n### 18.4 小结\n\n## 第 19 章 - 拒绝推断\n\n### 19.1 推断原理\n\n### 19.2 总体流动\n\n### 19.3 表现赋值\n\n### 19.4 特殊类别\n\n### 19.5 推断方法\n\n#### 19.5.1 随机补充\n\n#### 19.5.2 展开法\n\n#### 19.5.3 外推法\n\n#### 19.5.4 同生表现法\n\n### 19.6 小结\n\n## 第 20 章 - 模型校准\n\n### 20.1 分数分段\n\n#### 20.1.1 CH 统计量\n\n#### 20.1.2 基准方法\n\n#### 20.1.3 边际风险边界\n\n### 20.2 线性变换\n\n#### 20.2.1 线性变动\n\n#### 20.2.2 比率缩放\n\n### 20.3 线性规划重构\n\n### 20.4 小结\n\n## 第 21 章 - 检验交付\n\n### 21.1 组成成分\n\n#### 21.1.1 开发依据\n\n#### 21.1.2 持续检验\n\n#### 21.1.3 回溯测试\n\n### 21.2 差别效果\n\n### 21.3 小结\n\n## 第 22 章 - 开发管理\n\n### 22.1 进程安排\n\n### 22.2 高效操作\n\n#### 22.2.1 重复利用\n\n#### 22.2.2 重新建模\n\n### 22.3 小结\n\n# 第六部分 - 实施和使用\n\n## 第 23 章 - 实施安装\n\n### 23.1 自动化决策\n\n#### 23.1.1 自动化程度\n\n#### 23.1.2 职责\n\n#### 23.1.3 员工沟通\n\n#### 23.1.4 客户教育\n\n### 23.2 安装和测试\n\n#### 23.2.1 数据、资源和切换\n\n#### 23.2.2 测试\n\n### 23.3 小结\n\n## 第 24 章 - 管理控制\n\n### 24.1 政策规则\n\n### 24.2 撤销\n\n### 24.3 移交\n\n#### 24.3.1 信息验证\n\n#### 24.3.2 账户情况\n\n### 24.4 控制\n\n#### 24.4.1 竞争环境\n\n#### 24.4.2 评分及策略控制\n\n#### 24.4.3 撤销控制\n\n### 24.5 小结\n\n## 第 25 章 - 跟踪监控\n\n### 25.1 组合分析\n\n#### 25.1.1 逾期分布\n\n#### 25.1.2 转移矩阵\n\n### 25.2 表现跟踪\n\n#### 25.2.1 模型表现\n\n#### 25.2.2 账龄分析\n\n#### 25.2.3 分数错配\n\n### 25.3 偏移报告\n\n#### 25.3.1 总体稳定性报告\n\n#### 25.3.2 分数偏移报告\n\n#### 25.3.3 特征分析\n\n### 25.4 选择过程\n\n#### 25.4.1 决策过程\n\n#### 25.4.2 分数决策\n\n#### 25.4.3 政策规则\n\n#### 25.4.4 人为撤销\n\n### 25.5 小结\n\n## 第 26 章 - 金融财务\n\n### 26.1 坏账准备\n\n### 26.2 直接损失估计\n\n#### 26.2.1 净流量法\n\n#### 26.2.2 转移矩阵法\n\n### 26.3 损失估计\n\n#### 26.3.1 损失概率\n\n#### 26.3.2 损失程度\n\n#### 26.3.3 预测分析\n\n### 26.4 利润模型\n\n#### 26.4.1 利润来源\n\n#### 26.4.2 利润决策\n\n#### 26.4.3 利润评分\n\n### 26.5 风险定价\n\n#### 26.5.1 理论实践\n\n#### 26.5.2 行为变化\n\n#### 26.5.3 战略考虑\n\n#### 26.5.4 客户影响\n\n### 26.6 小结\n\n# 第七部分 - 信用风险管理周期\n\n## 第 27 章 - 市场营销\n\n### 27.1 广告媒体\n\n### 27.2 数量与质量\n\n### 27.3 初步筛选\n\n### 27.4 市场数据\n\n### 27.5 小结\n\n## 第 28 章 - 申请审批\n\n### 28.1 收集潜在客户信息\n\n#### 28.1.1 获取申请信息\n\n#### 28.1.2 纸质数据采集\n\n#### 28.1.3 初筛和清洗\n\n### 28.2 策略分类\n\n### 28.3 决策执行\n\n#### 28.3.1 拒绝\n\n#### 28.3.2 接受\n\n### 28.4 小结\n\n## 第 29 章 - 账户管理\n\n### 29.1 额度类型\n\n### 29.2 超额管理\n\n#### 29.2.1 支票账户\n\n#### 29.2.2 信用卡授权\n\n#### 29.2.3 客户知情效应\n\n### 29.3 更多限额和其他功能\n\n#### 29.3.1 提额请求\n\n#### 29.3.2 提高额度\n\n#### 29.3.3 额度复核\n\n#### 29.3.4 交叉销售\n\n#### 29.3.5 重获客户\n\n### 29.4 小结\n\n## 第 30 章 - 催收回收\n\n### 30.1 概述\n\n### 30.2 时机策略\n\n### 30.3 催收评分\n\n### 30.4 小结\n\n## 第 31 章 - 欺诈防范\n\n### 31.1 欺诈类型\n\n### 31.2 欺诈侦测工具\n\n### 31.3 欺诈防范策略\n\n### 31.4 欺诈评分\n\n### 31.5 小结\n\n# 第八部分 - 监管环境\n\n## 第 32 章 - 监管理念\n\n### 32.1 最佳实践\n\n### 32.2 善良治理\n\n### 32.3 商业道德和社会责任\n\n### 32.4 合规等级\n\n### 32.5 小结\n\n## 第 33 章 - 隐私保护\n\n### 33.1 背景\n\n#### 33.1.1 历史概况\n\n#### 33.1.2 Tournier 案件\n\n#### 33.1.3 OECD 数据隐私指引\n\n#### 33.1.4 欧洲理事会公约\n\n#### 33.1.5 欧盟数据保护指令\n\n#### 33.1.6 特殊情况\n\n### 33.2 原则\n\n#### 33.2.1 收集方式\n\n#### 33.2.2 合理目的\n\n#### 33.2.3 信息质量\n\n#### 33.2.4 信息使用\n\n#### 33.2.5 信息披露\n\n#### 33.2.6 主体权利\n\n#### 33.2.7 信息安全\n\n### 33.3 小结\n\n## 第 34 章 - 禁止歧视\n\n### 34.1 何为歧视\n\n### 34.2 存疑特征\n\n### 34.3 小结\n\n## 第 35 章 - 公平信贷\n\n### 35.1 掠夺性放贷\n\n### 35.2 不负责放贷\n\n### 35.3 负责任放贷\n\n### 35.4 小结\n\n## 第 36 章 - 资本要求\n\n### 36.1 巴塞尔协议 I\n\n### 36.2 巴塞尔协议 II\n\n#### 36.2.1 标准法\n\n#### 36.2.2 内部评级法\n\n#### 36.2.3 风险暴露类别\n\n#### 36.2.4 违约定义\n\n#### 36.2.5 评级意义\n\n#### 36.2.6 执行问题\n\n### 36.3 风险加权资产的计算\n\n### 36.4 小结\n\n## 第 37 章 - 了解客户\n\n### 37.1 尽职调查要求\n\n### 37.2 客户身份识别要求\n\n## 第 38 章 - 国家差异\n\n国家差异汇总表：\n\n|                                    | 美国            | 加拿大   | 英国            | 澳大利亚        | 南非     |\n| ---------------------------------- | --------------- | -------- | --------------- | --------------- | -------- |\n| 背景情况                           |                 |          |                 |                 |          |\n| 个人识别码                         | SSN             | SIN      | 无              | SSN             | ID       |\n| 支付档案名称                       | 共享信息        | 正面信息 | 白色数据 /CAIS  | 无              | 支付档案 |\n| 负债占国民净生产总值的比例（1999） | 16.1            | 14.4     | 5.7             | 7.7             | 未知     |\n| 征信机构                           |                 |          |                 |                 |          |\n| 民营征信机构（1999）               | 19 世纪 90 年代 | 1919 年  | 20 世纪 60 年代 | 20 世纪 30 年代 | 1901年   |\n| TransUnion                         | 有              | 有       | 无              | 其他机构        | 有       |\n| Equifax                            | 有              | 有       | 有              | 其他机构        | 无       |\n| Experian                           | 有              | 无       | 有              | 其他机构        | 有       |\n\n### 38.1 美国\n\n美国是最早设立法律影响信用评分的国家。\n\n[《公平信用报告法》（ Fair Credit Reporting Act ）](https://www.ftc.gov/legal-library/browse/statutes/fair-credit-reporting-act)\n\n保证了数据的隐私和准确，限制征信机构只能用与信用相关的信息，包括正面信息。\n\n[《平等信贷机会法》（Equal Credit Opportunity Act）](https://www.ftc.gov/legal-library/browse/statutes/equal-credit-opportunity-act)\n\n反对消费信贷歧视，包括申请者的种族、肤色、信仰、国籍、性别、婚姻、年龄或接受公共援助资助信息。\n\n对于年龄这个特征，只要不歧视老年人就可以使用。\n\n贷款机构需要向被拒的申请人提供拒绝的明确原因。\n\n### 38.2 加拿大\n\n### 38.3 英国\n\n### 38.4 澳大利亚\n\n### 38.5 南非\n","source":"_posts/《信用评分工具：自动化信用管理的理论与实践》.md","raw":"---\ntitle: 《信用评分工具：自动化信用管理的理论与实践》 - 读书笔记\ndate: 2022-06-19 16:13:25\ncategories: [Economics&Finance, RiskControl]\ntags: [credit, scorecard, risk control]\n---\n\n# 大纲\n\n全书共 8 个部分，分别为：\n\n- 背景设定 - 讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔 loan 做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。\n\n  > 1. 信用评分及其业务 - 什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。\n  > 2. 信用微历史 - 关于信用供给、信用评分、征信机构和评级机构的简要历史。\n  > 3. 信用评分原理 - 如何进行信用评分、怎样建立评分卡。\n\n- 风险业务 - 针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。\n\n  > 4. 风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。\n  > 5. 决策科学 - 信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。\n  > 6. 企业风险评估 - 对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。\n\n- 数学和统计 - 介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。\n\n  > 7. 预测统计 - 因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。\n  > 8. 区分度的测量 - 用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。\n  > 9. 零碎内容 - 描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。\n  > 10. 头脑与机器 - 所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。\n\n- 数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。\n\n  > 11. 数据考虑 - 建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。\n  > 12. 数据来源 - 讨论从客户、内部系统和征信机构获取信息。\n  > 13. 评分结构 - 关注评分卡的定制和架设、数据整合和不同来源数据的匹配。\n  > 14. 信息共享 - 征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。\n  > 15. 数据准备 - 开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。\n\n- 评分卡开发 - 这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把**简单、可解释性强的模型**作为评分卡开发时的选择这个倾向。\n\n  > Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for Private Companies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.\n\n  作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的`可行性分析->需求分析->总体设计->详细设计`有着异曲同工之妙。作者把开发前大体的步骤划分为如下：\n\n  - 项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。\n  - 数据收集 - 从数据来源提取大小合适的样本。\n  - 好坏定义 - 不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。\n  - 样本分层 - 决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）\n  - 确定模型 - 开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。\n  - 决策策略 - 不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。\n\n  开发的完整流程如下：\n\n  > 16. 变量转换 - 分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。\n  > 17. 特征选取 - 确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。\n  > 18. 样本分层 - 是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。\n  > 19. 拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。\n  > 20. 模型校准 - 用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。\n  > 21. 检验交付 - 用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。\n  > 22. 开发管理 - 评分卡开发的流程管理和安排。\n\n- 实施和使用 - 遵循**Wiklund提供的框架**，介绍模型部署与模型监控相关内容。\n\n  > 在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。\n  >\n  > Handbook of credit scoring[M]. Global Professional Publishi, 2001.\n  \n  > 23. 实施安装 - 绿地开发（ Greenfield Software Development, 指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield Software Development, 指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。\n  > 24. 管理控制 - 验证审查，保证分数合理有效。\n  > 25. 跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。\n  > 26. 金融财务 - 损失准备金、风险定价和利润率等问题。\n  \n- 信用风险管理周期 - 这里提到风险管理周期可以分为五个阶段，`市场营销->申请审批->账户管理->催收->回收`。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。\n\n  - 分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。\n  - 吸引（ solicitation ） - 设计和实施营销活动，吸引潜在客户办理业务。\n  - 获取（ acquisition ） - 获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。\n  - 管理（ management ） - 对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。\n  - 催收（ collections ） - 重点关注早期的违约和维持客户关系。\n  - 追踪（ tracing ） - 尝试联系并找到一些因没有更新住址或联系方式而失联的客户。\n  - 回收（ rehabilitation ） - 处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。\n\n  除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。\n\n  > 27. 市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。\n  > 28. 申请审批 - 选择客户的操作。\n  > 29. 账户管理 - 询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。\n  > 30. 催收回收 - 违约原因和催收流程、催收时机和催收策略。\n  > 31. 欺诈防范 - 趋势、类型和工具。\n\n- 监管环境 - 介绍一些对金融机构的监管内容。\n\n  > 32. 监管概念 - 最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。\n  > 33. 隐私保护 - 贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。\n  > 34. 禁止歧视 - 涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。\n  > 35. 公平信贷 - 确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。\n  > 36. 资本要求 - 主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。\n  > 37. 了解客户 - 提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。\n  > 38. 国家差异 - 对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。\n\n# 第一部分 - 背景设定\n\n## 第 1 章 - 信用评分及其业务\n\n### 1.1 什么是信用评分\n\n### 1.2 在哪儿使用信用评分？\n\n#### 1.2.1 数据来源\n\n#### 1.2.2 信用风险管理周期\n\n#### 1.2.3 行为偏好\n\n### 为什么要使用信用评分？\n\n#### 1.3.1 如何影响贷款机构？\n\n#### 1.3.2 对客户的影响\n\n### 1.4 信用评分如何影响信用供给？\n\n### 1.5 小结\n\n## 第 2 章 - 信用微历史\n\n### 2.1 信用的历史\n\n#### 2.1.1 古代历史\n\n#### 2.1.2 中世纪到 19 世纪\n\n#### 2.1.3 20 世纪\n\n### 2.2 信用评分的历史\n\n#### 2.2.1 开拓时期\n\n#### 2.2.2 自动化时期\n\n#### 2.2.3 扩张时期\n\n### 2.3 征信机构的历史\n\n#### 2.3.1 18 世纪中期以前\n\n#### 2.3.2 19 世纪 90 年代以后\n\n#### 2.3.3 20 世纪 60 年代以后\n\n#### 2.3.4 国际\n\n### 2.4 评级机构的历史\n\n### 2.5 小结\n\n## 第三章 - 评分信用原理\n\n### 3.1 评分卡是什么\n\n#### 3.1.1 评分卡的形态\n\n#### 3.1.2 如何开发评分卡\n\n#### 3.1.3 预测能力如何评估\n\n#### 3.1.4 评分卡的偏差是如何出现的\n\n#### 3.1.5 如何应对以上问题\n\n### 3.2 采用何种测量方法\n\n#### 3.2.1 流程与策略\n\n#### 3.2.2 如何开发评分卡\n\n#### 3.2.3 违约概率和损失程度\n\n### 3.3 评分卡的开发流程\n\n#### 3.3.1 项目准备\n\n#### 3.3.2 数据准备\n\n#### 3.3.3 建模分析\n\n#### 3.3.4 模型确定\n\n#### 3.3.5 决策制定和策略\n\n#### 3.3.6 安全保护\n\n### 3.4 什么会影响评分卡\n\n#### 3.4.1 经济偏移\n\n#### 3.4.2 市场偏移\n\n#### 3.4.3 操作偏移\n\n#### 3.4.4 目标偏移\n\n#### 3.4.5 不明偏移\n\n### 3.5 小结\n\n# 第二部分 - 风险业务\n\n## 第 4 章 - 风险理论\n\n### 4.1 风险相关术语\n\n#### 4.1.1 风险关联\n\n#### 4.1.2 风险环境\n\n#### 4.1.3 风险类型\n\n### 4.2 数据与模型\n\n#### 4.2.1 数据类型\n\n#### 4.2.2 模型类型\n\n#### 4.2.3 人为判断\n\n#### 4.2.4 专家系统\n\n### 4.3 小结\n\n## 第 5 章 - 决策科学\n\n### 5.1 自适应控制\n\n### 5.2 成为主人\n\n#### 5.2.1 冠军挑战\n\n#### 5.2.2 优化\n\n#### 5.2.3 策略推断\n\n### 5.3 小结\n\n## 第 6 章 - 企业风险评估\n\n### 6.1 风险评估基础\n\n#### 6.1.1 数据来源\n\n#### 6.1.2 风险模型\n\n#### 6.1.3 风险等级\n\n### 6.2 中小企业贷款\n\n#### 6.2.1 关系型贷款\n\n#### 6.2.2 交易型贷款\n\n### 6.3 财务比率评分\n\n#### 6.3.1 理论先驱\n\n#### 6.3.2 预测比率\n\n#### 6.3.3 限制因素\n\n#### 6.3.4 评级机构\n\n#### 6.3.5 内部评级\n\n### 6.4 信用评级机构\n\n#### 6.4.1 字母等级\n\n#### 6.4.2 评级类型\n\n#### 6.4.3 存在问题\n\n#### 6.4.4 研究重点\n\n### 6.5 前瞻数据建模\n\n#### 6.5.1 历史分析\n\n#### 6.5.2 结构模型\n\n#### 6.5.3 简约模型\n\n### 6.6 小结\n\n# 第三部分 - 数学和统计\n\n## 第 7 章 - 预测统计\n\n### 7.1 模型概述\n\n### 7.2 参数模型\n\n#### 7.2.1 线性模型\n\n#### 7.2.2 判别分析\n\n#### 7.2.3 逻辑回归\n\n### 7.3 非参模型\n\n#### 7.3.1 决策树\n\n#### 7.3.2 神经网络\n\n#### 7.3.3 遗传算法\n\n#### 7.3.4 K 近邻法\n\n#### 7.3.5 线性规划\n\n### 7.4 关键假设\n\n#### 7.4.1 数据因素\n\n#### 7.4.2 统计假设\n\n#### 7.4.3 解决方法\n\n### 7.5 结果比较\n\n## 第 8 章 - 区分度的测量\n\n### 8.1 错误的分类矩阵\n\n| 混淆矩阵            | **实际好 Good** | **实际坏 Bad** |\n| ------------------- | --------------- | -------------- |\n| **预测好 Positive** | TP              | FN             |\n| **预测坏 Negative** | FP              | TN             |\n\n在预测不正确的情况下，分为两种错误：\n\n- 把实际好的预测为坏（ FN ） - False Negative，意为假负，也就是说实际上是正的，被称为**第一类错误**。\n- 把实际坏的预测为好（ FP ） - False Negative，意为假正，也就是说实际上是负的，被称为**第二类错误**。\n\n### 8.2 Kullback 散度\n\n> Kullback S. Information theory and statistics[M]. Courier Corporation, 1997.\n>\n\n Kullback 散度用于测量两个频率分布的差异。在信用评分中，它的表现形式有两种：\n\n- 信息值（ Information Value, IV ）\n- 稳定指数（ Stability Index ）\n\n他们都建立在证据权重（ Weight of Evidence, WOE ）的基础上。\n\n#### 8.2.1 证据权重\n\n$$\nWOE_i=ln(\\frac{N_i}{\\sum N})/(\\frac{P_i}{\\sum P})=ln(\\frac{N_i}{P_i})-ln(\\frac{\\sum N}{\\sum P})\n$$\n\n其中 N 代表没有触发坏客户定义，也就是好客户。P 代表触发坏客户定义，也就是坏客户。那么 $\\frac{N_i}{\\sum N}$ 其实意思就是为好客户的概率，P 也一样，所以上面的公式也可以写为\n$$\nWOE_i=ln(\\frac{P(bad)_i}{P(good)_i})\n$$\n它反映了某个特征的某个值（或组）的**相对风险**，很明显为 WOE 代表了该组的相对风险更小，为负代表该组相对分箱更大。\n\n#### 8.2.2 信息值\n\n$$\nIV=\\sum^{n}_{i=1}[(\\frac{N_i}{\\sum N}-\\frac{P_i}{\\sum P})\\times WOE_i]=\\sum^{n}_{i=1}[\\frac{count(i)}{count(n)}\\times WOE_i]\n$$\n\n\n\n#### 8.2.3 稳定指数\n\n### 8.3 KS 统计量\n\n### 8.4 相关系数\n\n#### 8.4.1 Pearson 积矩\n\n#### 8.4.2 Spearman 秩序\n\n#### 8.4.3 洛伦兹曲线\n\n#### 8.4.4 基尼系数\n\n#### 8.4.5 ROC 曲线\n\n### 8.5 卡方检验\n\n### 8.6 准确性检验\n\n#### 8.6.1 概率论\n\n#### 8.6.2 二项分布\n\n#### 8.6.3 HL统计量\n\n#### 8.6.4 对数似然\n\n### 8.7 小结\n\n## 第 9 章 - 零碎内容\n\n### 9.1 描述方法\n\n#### 9.1.1 聚类分析\n\n#### 9.1.2 因子分析\n\n### 9.2 预报方法\n\n#### 9.2.1 马尔可夫链\n\n#### 9.2.2 生存分析\n\n### 9.3 其他概念\n\n#### 9.3.1 相关性\n\n#### 9.3.2 交叉性\n\n#### 9.3.3 单调性\n\n#### 9.3.4 标准化\n\n### 9.4 开发报告\n\n#### 9.4.1 特征分析报告\n\n#### 9.4.2 分数分布报告\n\n#### 9.4.3 新业务策略表\n\n### 9.5 小结\n\n## 第 10 章 - 头脑与机器\n\n### 10.1 人员和项目\n\n#### 10.1.1 评分卡开发人员\n\n#### 10.1.2 外部供应商\n\n#### 10.1.3 内部资源\n\n#### 10.1.4 项目组\n\n#### 10.1.5 指导委员会\n\n### 10.2 软件\n\n#### 10.2.1 评分卡开发\n\n#### 10.2.1 决策引擎\n\n### 10.3 小结\n\n# 第四部分 - 数据\n\n## 第 11 章 - 数据考虑\n\n### 11.1 数据透明度\n\n> 数据透明度指充分评估风险所需的数据充足程度。\n\n建模的最终目标是获取一个信用度的测量标准，这个标准合适与否取决于借款人数据对我们的透明程度（了解借款人的信息有多全面，特征衍生前的特征）。\n\n不透明的数据通常表现为：\n\n- 缺乏信用记录。\n- 信息不友好。指结构化数据的存储结构不合理，或者数据对信用度影响的逻辑难以建立。\n- 高度复杂。指非结构化数据，例如语音，图像等，可能有用但是我们不知道怎么用。\n\n如果数据透明度不够，贷款机构面临两种选择：\n\n1. 提高贷款利率，作为风险溢价。\n2. 投入额外成本来确定有用信息，例如购买第三方数据源的数据。\n\n那么数据透明度是由数据的数量和质量决定的，就引入了下两章。\n\n### 11.2 数据数量\n\n> 数据的深度和广度，由可得性和同质性决定。\n\n#### 11.2.1 深度和广度\n\n> 样本量（深度）和变量数量（广度）。\n\n最小样本量是 1500 个好样本、 1500 个坏样本、 1000 个拒绝样本。\n\n最终模型一般包含 6~25 个特征。\n\n#### 11.2.2 同质性\n\n> 同质性决定样本是否可以合并处理。\n\n同质性是样本分群的问题。主要要考虑以下 3 点：\n\n1. 目标定义\n2. 数据来源\n3. 交叉作用\n\n以上 3 点有问题的样本都应该分开，然后用不同的模型去处理。\n\n有时我们会遇到在某群体的样本表现高度同质，这种时候应该去寻找新的数据源扩大数据的广度。\n\n#### 11.2.3 可得性\n\n> 数据获取面临的来自系统、权限或法律的限制。\n\n数据采集、系统升级时的数据更新（这里指丢失记录）、反歧视、数据隐私、信息共享。\n\n### 11.3 数据质量\n\n> 数据能否符合某具体需求。高质量的数据应该具备相关性、准确性、完备性、时效性和一致性。\n>\n> 在很多情况下，风险管理所用的信息通常只是为截然不同的目的而设计的处理系统的副产品，而且前端系统对数据质量通常缺乏具体的要求，从而虚弱了其产生信息的质量。\n\n#### 11.3.1 关联性\n\n> 数据要与结果有关，能够为分数和决策提供有意义的帮助。\n\n首要关注的是数据的相关关系而非因果关系。\n\n四个问题：\n\n1. 如果特征可测量，它的预测能力怎么样？\n2. 如果特征不可测量，是否有证据证明它在其他方面有价值？\n3. 特征数据是否在需要时可获取，如果不能怎么办？\n4. 特征在逻辑上是否有意义？\n\n#### 11.3.2 准确性\n\n> 通过正确地获取、加工和储存数据使其准确反映真实状况。\n\n数据不准确主要集中在两方面：\n\n1. 流程设计不完善 - 表格设计、数据采集、系统错误和匹配等方面的问题。\n   - 记账错误 - 数据不正确、不一致或重复。\n   - 漏账错误 - 字段为空或记录缺失。\n2. 作弊 - 为提高申请通过的可能性，申请表答案可能被篡改。\n\n#### 11.3.3 完备性\n\n> 数据包含所有所需信息，允许个别或整条记录有缺失。\n\n特征层面上的完备与样本记录层面上的完备。\n\n#### 11.3.4 时效性\n\n> 数据随时更新。超过一定期限后，数据就会失效。\n\n如 A 卡的特征年龄是基于客户申请时间的年龄，而不是现在的年龄。\n\n对于老客户，更多地依赖行为数据而非申请数据。\n\n#### 11.3.5 一致性\n\n> 随时间推移数据意义保持一致。就算数据有误，也希望一致有误，这样还可以加以利用。\n\n主要是指系统、流程或某参数更新时造成同样的输入不同的输出问题。\n\n重大突发事件也可能造成数据的意义不一致。\n\n#### 11.3.6 对征信机构的影响\n\nCFA 建议贷款机构在作决策时不要局限于一家征信机构的信息。\n\n### 11.4 数据设计\n\n> 定义数据的类型。从实践或统计的角度出发，考虑数据缺失、分母为零的特例和数据设计的问题，最大化数据的价值。\n\n#### 11.4.1 数据类型\n\n> 统计上及实践中描述数据的术语和对特殊情况的处理。\n\n数据的两个维度：\n\n- 记录（ record ） - 单个样本的细节。\n- 字段（ field ）、特征（ characteristic ）、变量（ variable ），这三者都是一个东西。\n\n**统计上的分类：**\n\n| 变量类别 | 类别含义                                                     |\n| -------- | ------------------------------------------------------------ |\n| 分类变量 | 由定性特征确定的分组情况，例如性别（男、女）或颜色（黄、红、蓝）。没有顺序和大小。 |\n| 二元变量 | 仅由两种类别构成，例如“是/否”等一对反义词。又称为二分类变量。信用评分中目标变量大多是二分类变量，例如目标客户（好、坏）。 |\n| 名义变量 | 用标签（名字）或代码（字母/数字）表示的变量。没有顺序和大小。 |\n| 顺序变量 | 只表示一个序列中的相对位置，不表示相对距离的大小，通常和主观评价有关，例如优秀、良好、一般、差。有顺序没有大小。 |\n| 数值变量 | 用整数或实数表示，有顺序有大小，能进行数值运算，比如年龄（整岁）。 |\n| 连续变量 | 存在于连续的序列中，可能值的数量无限，存在最大值和最小值，用实数表示，例如温度、重量、距离和时间。 |\n| 离散变量 | 分离或者不连续的变量，用实数表示。并不代表没有顺序和大小。   |\n| 基数变量 | 离散的，但特指一个集合内的数量。通常等价于离散变量。         |\n\n**实践中的分类：**\n\n| 变量类别         | 类别含义                                                     |\n| ---------------- | ------------------------------------------------------------ |\n| 编码（名义）     | 用符号或数字表现的类别。                                     |\n| 金额（近似连续） | 以货币金额表示的内容，例如余额、额度、交易额，可以计算总数、平均数、趋势、最小值、最大值、范围、极限等。 |\n| 次数（离散）     | 发生的数量，例如子女的数量（来自申请者）、逾期次数（来自贷款机构）、查询次数（来自征信机构）。 |\n| 比率（连续）     | 两个数值相除的结果，最常用于按照规模对金额标准化，例如资产负债率。 |\n| 时间（离散）     | 距离某特定事件（账户开立、账户激活、某次评估）发生的时间，通常按天或月计算。 |\n| 分数（近似连续） | 表示未来某事件发生的概率（打分）。在一些情况下，一个分数可以用来计算另一个分数（比如通过第三方数据的评分卡制作内部的评分卡）。 |\n| 等级（序数）     | 和分数类似，不过它代表一个分数范围，或被主观确定。           |\n\n提到了变量处理的基础方法，主要分为两种：\n\n- 转换特征 - 比如 `birthday` 本身可能并不能作为合适的特征使用，那么我们用某一时间（例如客户申请时间）减去出生日期换算成年就得到了 `age` 这个特征。\n- 特征生成\n  - 多项式生成 - 生成交叉项，例如 `sklearn` 里的 `PolynomialFeatures` 方法。\n  - 计算比率 - 例如计算负债比。\n\n**特例（缺失值、异常值处理）：**\n\n- 数据缺失 - 未找到（不清楚真实是否发生）、无记录（真实发生）、未发生（真实未发生）等。\n- 账户状态 - 同一个特征里没有用相同单位，如一部分是值，一部分是字符。\n- 分母为零 - 除数不能为 0 ，这种情况可以用一个接近 0 的值代替。\n- 分母为负 - 计算比率或比例时，出现了分子分母同时为负的情况。\n\n对缺失值和异常值，一般用一个特殊编号来记录。\n\n#### 11.4.2 表格设计\n\n> 收集数据的表格设计。\n\n最大的挑战在于尽可能获取更多地相关数据，但数据又不过量。\n\n表格的处理方式取决于表格设置的答案时定性的还是定量的。\n\n**数值结果**\n\n分为 3 种：\n\n1. 数值本身。\n2. 计算输入值。\n3. 数值范围。\n\n例如不需要申请者填写年龄，直接填写年龄段和生日；金额上不填某段，填入具体的数值；负债收入比率不需要申请者计算，直接填入负债值和收入值。\n\n**分类结果**\n\n难点在于确定特征的选择范围。\n\n不是直接填空，而是一个选择范围的下拉菜单。\n\n将问题分为更多的维度，例如职业和教育的问题分为行业、工作层级、最高学历、就业现状等维度。\n\n### 11.5 小结\n\n这章探讨了数据透明度、数据数量、数据质量和设计相关方面的问题。目的就是为了提高数据透明度，正是因为数据透明度的提高使得贷款机构对客户有更多的了解，从而可以扩大贷款规模。\n\n## 第 12 章 - 数据来源\n\n### 12.1 客户信息\n\n#### 12.1.1 申请表\n\n#### 12.1.2 财务信息\n\n### 12.2 内部信息\n\n#### 12.2.1 数据类型\n\n#### 12.2.2 数据库类型\n\n#### 12.2.3 客户关系管理\n\n### 12.3 征信数据\n\n#### 12.3.1 查询检索\n\n#### 12.3.2 公共信息\n\n#### 12.3.3 共享数据\n\n#### 12.3.4 欺诈预警\n\n#### 12.3.5 征信分数\n\n#### 12.3.6 地理指标\n\n#### 12.3.7 其他来源\n\n### 12.4 小结\n\n## 第 13 章 - 评分机构\n\n### 13.1 定制服务\n\n#### 13.1.1 通用评分卡\n\n#### 13.1.2 定制评分卡\n\n#### 13.1.3 专家模型\n\n### 13.2 系统架设\n\n### 13.3 数据整合\n\n#### 13.3.1 独立分数\n\n#### 13.3.2 离散分数\n\n#### 13.3.3 合并分数\n\n#### 13.3.4 决策矩阵\n\n### 13.4 信用评分\n\n### 13.5 数据匹配\n\n### 13.6 小结\n\n## 第 14 章 - 信息共享\n\n### 14.1 征信机构\n\n#### 14.1.1 公共与民营\n\n#### 14.1.2 正面信息与负面信息\n\n### 14.2 参与合作\n\n#### 14.2.1 互惠原则\n\n#### 14.2.2 促进因素\n\n#### 14.2.3 阻碍因素\n\n### 14.3 小结\n\n## 第 15 章 - 数据准备\n\n### 15.1 数据获取\n\n#### 15.1.1 申请数据\n\n#### 15.1.2 征信数据\n\n#### 15.1.3 观测数据\n\n#### 15.1.4 表现数据\n\n#### 15.1.5 数据整合\n\n### 15.2 好坏定义\n\n作者强调了好坏定义的重要性，提到了**好坏定义是建模过程中仅次于数据的重要因素，用来设定目标变量。**\n\n![好坏定义](https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206201247059.png)\n\n#### 15.2.1 选择状态\n\n指观测期的状态，分为以下4类：\n\n- 排除 - 如果某个子群体的分数不影响对其决策，作者建议排除。和拒绝不一样的地方是这类样本不需要做拒绝推断。\n- 拒绝 - 出于政策规则或者决策规则的样本不需要做拒绝推断。\n- 未采用 - 客户没有接受贷款机构提供的贷款合同，也就是准入了但未做成。可能是价格、利率、合同条款让客户觉得不适。\n- 双方接受 - 只有这类样本会有真实的表现。\n\n#### 15.2.2 表现状态\n\n指表现期的状态，分为以下4类：\n\n- 排除 - 评分卡计划目标之外的结果，比如申请评分卡中出现了欺诈行为或客户去世。这类占比不宜超过总体的 3%。\n\n- 不定 - 指灰样本，申请评分卡的不定率应设定在 5%~15%，行为评分卡的不定率设定在 10%~20%。这里提到设定灰样本有 3 个理由。\n\n  - 技术逾期造成的疑似不良行为 - 我觉得应该是指像美国 ACH 那样的延时得知交易结果的支付方式对标签定义的影响。\n  - 公司策略\n  - 使好坏定义更加清晰。\n\n  这里也讨论了关于提前还款的人是好样本还是不定样本。这类人是可以当作好样本建模的。\n\n- 好样本 - 我们表示欢迎的样本。\n\n- 坏样本 - 我们表示回避的样本。\n\n#### 15.2.3 当前状态和最坏状态\n\n当前状态和最坏状态是指用结果时点的状态（当前状态）还是整个结果期最坏的状态（最坏状态）来确定“不可恢复点”（ point of no return ），也就是去找出账户不会再从坏变好的时间点。\n\n行为评分中，巴塞尔协议 II 要求使用 90 天内最坏最坏状态的定义。申请评分中两种方式都可以。使用当前状态可以确保误判和由坏变好的账户不会被误判，使用最坏状态则对可能是坏的账户更加敏感。\n\n一般情况下，当前状态的常见定义是逾期 60 天，最坏状态的定义是逾期 90 天。\n\n#### 15.2.4 定义设定\n\n定义有 3 种方式：\n\n- 共识 - 内部专家经验判断。\n- 规定 - 由外部机构设定，确保一致性。（这个主要是方便供别人参考吧）\n- 经验（原文应该是 experience ，我个人觉得翻译成**历史**更合适） - 根据自身的历史数据实证分析。提到了滚动率分析，不过并没有讲具体怎么做。\n\n#### 15.2.5 好坏定义标准\n\n讲到好坏定义需要符合 3 个特点：**相关、充足、透明。**\n\n### 15.3 时间窗口\n\n时间窗口组成有一些相关概念，这里讲到了：\n\n- 观测（ observation ） - 指对数据进行观测，作为预测变量。\n- 结果（ outcome ） - 指分析数据观测的结果，确定目标。\n- 日期/月份 - 指信息采集的时间。\n- 窗口（ window ） - 指一段时间。\n\n这些概念的组合就跟时间窗口有很密切的关系了：\n\n- 观测期（ observation window ） - 也叫观察期，指观测点之前的一段时间。\n- 观测日期（ observation date ） - 也叫观测点，位于观测期与表现期之间，指采集数据的日期。\n- 结果期 （ outcome window ） - 也叫表现期，客户表现趋于成熟的时间段。\n\n- 结果日期（ outcome date ） - 指同一样本表现结果的日期。\n\n这两个窗口非常重要，**观测期用于收集用户数据**，例如银行流水等信息，**观测期太短可能会导致变量预测效果不佳**；**表现期用于评价模型的标签（ Y ）多久之后趋于稳定**，随着时间的累加，违约率会增加但是边际增长率降低，**表现期太短可能会存在坏客户风险暴露不充分这样的情况**。在选择合适的观测期与表现期时，需要考虑**账户成熟、样本信息缺失、数据老化**三个因素。\n\n### 15.4 样本设计\n\n#### 15.4.1 样本类型\n\n#### 15.4.2 最大和最小样本量\n\n#### 15.4.3 分层随机抽样\n\n### 15.5 小结\n\n# 第五部分 - 评分卡开发\n\n## 第 16 章 - 变量转换\n\n### 16.1 转换方法\n\n#### 16.1.1 虚拟变量\n\n#### 16.1.2 风险变量\n\n#### 16.1.3 方法选择\n\n### 16.2 粗细分类\n\n#### 16.2.1 特征分析报告\n\n#### 16.2.2 细分类\n\n#### 16.2.3 粗分类\n\n### 16.3 统计量的应用\n\n#### 16.3.1 预测能力测度\n\n#### 16.3.2 粗分类例子\n\n### 16.4 池化算法\n\n#### 16.4.1 非邻池化\n\n#### 16.4.2 相邻池化\n\n#### 16.4.3 单调相邻池化\n\n### 16.5 实际案例\n\n#### 16.5.1 法院判决\n\n#### 16.5.2 行业种类\n\n#### 16.5.3 职业种类\n\n### 16.6 小结\n\n## 第 17 章 - 特征选取\n\n### 17.1 参考因素\n\n### 17.2 预测能力\n\n### 17.3 降维方法\n\n#### 17.3.1 建模处理\n\n#### 17.3.2 相关矩阵\n\n#### 17.3.3 因子分析\n\n### 17.4 变量输入\n\n#### 17.4.1 分步\n\n#### 17.4.2 分块\n\n### 17.5 小结\n\n## 第 18 章 - 样本分层\n\n### 18.1 驱动因素\n\n### 18.2 识别交叉的作用\n\n### 18.3 处理交叉的作用\n\n### 18.4 小结\n\n## 第 19 章 - 拒绝推断\n\n### 19.1 推断原理\n\n### 19.2 总体流动\n\n### 19.3 表现赋值\n\n### 19.4 特殊类别\n\n### 19.5 推断方法\n\n#### 19.5.1 随机补充\n\n#### 19.5.2 展开法\n\n#### 19.5.3 外推法\n\n#### 19.5.4 同生表现法\n\n### 19.6 小结\n\n## 第 20 章 - 模型校准\n\n### 20.1 分数分段\n\n#### 20.1.1 CH 统计量\n\n#### 20.1.2 基准方法\n\n#### 20.1.3 边际风险边界\n\n### 20.2 线性变换\n\n#### 20.2.1 线性变动\n\n#### 20.2.2 比率缩放\n\n### 20.3 线性规划重构\n\n### 20.4 小结\n\n## 第 21 章 - 检验交付\n\n### 21.1 组成成分\n\n#### 21.1.1 开发依据\n\n#### 21.1.2 持续检验\n\n#### 21.1.3 回溯测试\n\n### 21.2 差别效果\n\n### 21.3 小结\n\n## 第 22 章 - 开发管理\n\n### 22.1 进程安排\n\n### 22.2 高效操作\n\n#### 22.2.1 重复利用\n\n#### 22.2.2 重新建模\n\n### 22.3 小结\n\n# 第六部分 - 实施和使用\n\n## 第 23 章 - 实施安装\n\n### 23.1 自动化决策\n\n#### 23.1.1 自动化程度\n\n#### 23.1.2 职责\n\n#### 23.1.3 员工沟通\n\n#### 23.1.4 客户教育\n\n### 23.2 安装和测试\n\n#### 23.2.1 数据、资源和切换\n\n#### 23.2.2 测试\n\n### 23.3 小结\n\n## 第 24 章 - 管理控制\n\n### 24.1 政策规则\n\n### 24.2 撤销\n\n### 24.3 移交\n\n#### 24.3.1 信息验证\n\n#### 24.3.2 账户情况\n\n### 24.4 控制\n\n#### 24.4.1 竞争环境\n\n#### 24.4.2 评分及策略控制\n\n#### 24.4.3 撤销控制\n\n### 24.5 小结\n\n## 第 25 章 - 跟踪监控\n\n### 25.1 组合分析\n\n#### 25.1.1 逾期分布\n\n#### 25.1.2 转移矩阵\n\n### 25.2 表现跟踪\n\n#### 25.2.1 模型表现\n\n#### 25.2.2 账龄分析\n\n#### 25.2.3 分数错配\n\n### 25.3 偏移报告\n\n#### 25.3.1 总体稳定性报告\n\n#### 25.3.2 分数偏移报告\n\n#### 25.3.3 特征分析\n\n### 25.4 选择过程\n\n#### 25.4.1 决策过程\n\n#### 25.4.2 分数决策\n\n#### 25.4.3 政策规则\n\n#### 25.4.4 人为撤销\n\n### 25.5 小结\n\n## 第 26 章 - 金融财务\n\n### 26.1 坏账准备\n\n### 26.2 直接损失估计\n\n#### 26.2.1 净流量法\n\n#### 26.2.2 转移矩阵法\n\n### 26.3 损失估计\n\n#### 26.3.1 损失概率\n\n#### 26.3.2 损失程度\n\n#### 26.3.3 预测分析\n\n### 26.4 利润模型\n\n#### 26.4.1 利润来源\n\n#### 26.4.2 利润决策\n\n#### 26.4.3 利润评分\n\n### 26.5 风险定价\n\n#### 26.5.1 理论实践\n\n#### 26.5.2 行为变化\n\n#### 26.5.3 战略考虑\n\n#### 26.5.4 客户影响\n\n### 26.6 小结\n\n# 第七部分 - 信用风险管理周期\n\n## 第 27 章 - 市场营销\n\n### 27.1 广告媒体\n\n### 27.2 数量与质量\n\n### 27.3 初步筛选\n\n### 27.4 市场数据\n\n### 27.5 小结\n\n## 第 28 章 - 申请审批\n\n### 28.1 收集潜在客户信息\n\n#### 28.1.1 获取申请信息\n\n#### 28.1.2 纸质数据采集\n\n#### 28.1.3 初筛和清洗\n\n### 28.2 策略分类\n\n### 28.3 决策执行\n\n#### 28.3.1 拒绝\n\n#### 28.3.2 接受\n\n### 28.4 小结\n\n## 第 29 章 - 账户管理\n\n### 29.1 额度类型\n\n### 29.2 超额管理\n\n#### 29.2.1 支票账户\n\n#### 29.2.2 信用卡授权\n\n#### 29.2.3 客户知情效应\n\n### 29.3 更多限额和其他功能\n\n#### 29.3.1 提额请求\n\n#### 29.3.2 提高额度\n\n#### 29.3.3 额度复核\n\n#### 29.3.4 交叉销售\n\n#### 29.3.5 重获客户\n\n### 29.4 小结\n\n## 第 30 章 - 催收回收\n\n### 30.1 概述\n\n### 30.2 时机策略\n\n### 30.3 催收评分\n\n### 30.4 小结\n\n## 第 31 章 - 欺诈防范\n\n### 31.1 欺诈类型\n\n### 31.2 欺诈侦测工具\n\n### 31.3 欺诈防范策略\n\n### 31.4 欺诈评分\n\n### 31.5 小结\n\n# 第八部分 - 监管环境\n\n## 第 32 章 - 监管理念\n\n### 32.1 最佳实践\n\n### 32.2 善良治理\n\n### 32.3 商业道德和社会责任\n\n### 32.4 合规等级\n\n### 32.5 小结\n\n## 第 33 章 - 隐私保护\n\n### 33.1 背景\n\n#### 33.1.1 历史概况\n\n#### 33.1.2 Tournier 案件\n\n#### 33.1.3 OECD 数据隐私指引\n\n#### 33.1.4 欧洲理事会公约\n\n#### 33.1.5 欧盟数据保护指令\n\n#### 33.1.6 特殊情况\n\n### 33.2 原则\n\n#### 33.2.1 收集方式\n\n#### 33.2.2 合理目的\n\n#### 33.2.3 信息质量\n\n#### 33.2.4 信息使用\n\n#### 33.2.5 信息披露\n\n#### 33.2.6 主体权利\n\n#### 33.2.7 信息安全\n\n### 33.3 小结\n\n## 第 34 章 - 禁止歧视\n\n### 34.1 何为歧视\n\n### 34.2 存疑特征\n\n### 34.3 小结\n\n## 第 35 章 - 公平信贷\n\n### 35.1 掠夺性放贷\n\n### 35.2 不负责放贷\n\n### 35.3 负责任放贷\n\n### 35.4 小结\n\n## 第 36 章 - 资本要求\n\n### 36.1 巴塞尔协议 I\n\n### 36.2 巴塞尔协议 II\n\n#### 36.2.1 标准法\n\n#### 36.2.2 内部评级法\n\n#### 36.2.3 风险暴露类别\n\n#### 36.2.4 违约定义\n\n#### 36.2.5 评级意义\n\n#### 36.2.6 执行问题\n\n### 36.3 风险加权资产的计算\n\n### 36.4 小结\n\n## 第 37 章 - 了解客户\n\n### 37.1 尽职调查要求\n\n### 37.2 客户身份识别要求\n\n## 第 38 章 - 国家差异\n\n国家差异汇总表：\n\n|                                    | 美国            | 加拿大   | 英国            | 澳大利亚        | 南非     |\n| ---------------------------------- | --------------- | -------- | --------------- | --------------- | -------- |\n| 背景情况                           |                 |          |                 |                 |          |\n| 个人识别码                         | SSN             | SIN      | 无              | SSN             | ID       |\n| 支付档案名称                       | 共享信息        | 正面信息 | 白色数据 /CAIS  | 无              | 支付档案 |\n| 负债占国民净生产总值的比例（1999） | 16.1            | 14.4     | 5.7             | 7.7             | 未知     |\n| 征信机构                           |                 |          |                 |                 |          |\n| 民营征信机构（1999）               | 19 世纪 90 年代 | 1919 年  | 20 世纪 60 年代 | 20 世纪 30 年代 | 1901年   |\n| TransUnion                         | 有              | 有       | 无              | 其他机构        | 有       |\n| Equifax                            | 有              | 有       | 有              | 其他机构        | 无       |\n| Experian                           | 有              | 无       | 有              | 其他机构        | 有       |\n\n### 38.1 美国\n\n美国是最早设立法律影响信用评分的国家。\n\n[《公平信用报告法》（ Fair Credit Reporting Act ）](https://www.ftc.gov/legal-library/browse/statutes/fair-credit-reporting-act)\n\n保证了数据的隐私和准确，限制征信机构只能用与信用相关的信息，包括正面信息。\n\n[《平等信贷机会法》（Equal Credit Opportunity Act）](https://www.ftc.gov/legal-library/browse/statutes/equal-credit-opportunity-act)\n\n反对消费信贷歧视，包括申请者的种族、肤色、信仰、国籍、性别、婚姻、年龄或接受公共援助资助信息。\n\n对于年龄这个特征，只要不歧视老年人就可以使用。\n\n贷款机构需要向被拒的申请人提供拒绝的明确原因。\n\n### 38.2 加拿大\n\n### 38.3 英国\n\n### 38.4 澳大利亚\n\n### 38.5 南非\n","slug":"《信用评分工具：自动化信用管理的理论与实践》","published":1,"updated":"2022-08-11T15:43:07.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6p7t1hb00am142payfr9ruf","content":"<h1 id=\"大纲\">大纲</h1>\n<p>全书共 8 个部分，分别为：</p>\n<ul>\n<li><p>背景设定 -\n讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔\nloan\n做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。</p>\n<blockquote>\n<ol type=\"1\">\n<li>信用评分及其业务 -\n什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。</li>\n<li>信用微历史 -\n关于信用供给、信用评分、征信机构和评级机构的简要历史。</li>\n<li>信用评分原理 - 如何进行信用评分、怎样建立评分卡。</li>\n</ol>\n</blockquote></li>\n<li><p>风险业务 -\n针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。</p>\n<blockquote>\n<ol start=\"4\" type=\"1\">\n<li>风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。</li>\n<li>决策科学 -\n信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。</li>\n<li>企业风险评估 -\n对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。</li>\n</ol>\n</blockquote></li>\n<li><p>数学和统计 -\n介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。</p>\n<blockquote>\n<ol start=\"7\" type=\"1\">\n<li>预测统计 -\n因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。</li>\n<li>区分度的测量 -\n用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。</li>\n<li>零碎内容 -\n描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。</li>\n<li>头脑与机器 -\n所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。</li>\n</ol>\n</blockquote></li>\n<li><p>数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。</p>\n<blockquote>\n<ol start=\"11\" type=\"1\">\n<li>数据考虑 -\n建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。</li>\n<li>数据来源 - 讨论从客户、内部系统和征信机构获取信息。</li>\n<li>评分结构 -\n关注评分卡的定制和架设、数据整合和不同来源数据的匹配。</li>\n<li>信息共享 -\n征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。</li>\n<li>数据准备 -\n开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。</li>\n</ol>\n</blockquote></li>\n<li><p>评分卡开发 -\n这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把<strong>简单、可解释性强的模型</strong>作为评分卡开发时的选择这个倾向。</p>\n<blockquote>\n<p>Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for Private\nCompanies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.</p>\n</blockquote>\n<p>作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的<code>可行性分析-&gt;需求分析-&gt;总体设计-&gt;详细设计</code>有着异曲同工之妙。作者把开发前大体的步骤划分为如下：</p>\n<ul>\n<li>项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。</li>\n<li>数据收集 - 从数据来源提取大小合适的样本。</li>\n<li>好坏定义 -\n不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。</li>\n<li>样本分层 -\n决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）</li>\n<li>确定模型 -\n开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。</li>\n<li>决策策略 -\n不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。</li>\n</ul>\n<p>开发的完整流程如下：</p>\n<blockquote>\n<ol start=\"16\" type=\"1\">\n<li>变量转换 -\n分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。</li>\n<li>特征选取 -\n确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。</li>\n<li>样本分层 -\n是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。</li>\n<li>拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。</li>\n<li>模型校准 -\n用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。</li>\n<li>检验交付 -\n用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。</li>\n<li>开发管理 - 评分卡开发的流程管理和安排。</li>\n</ol>\n</blockquote></li>\n<li><p>实施和使用 -\n遵循<strong>Wiklund提供的框架</strong>，介绍模型部署与模型监控相关内容。</p>\n<blockquote>\n<p>在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。</p>\n<p>Handbook of credit scoring[M]. Global Professional Publishi,\n2001.</p>\n</blockquote>\n<blockquote>\n<ol start=\"23\" type=\"1\">\n<li>实施安装 - 绿地开发（ Greenfield Software Development,\n指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield Software\nDevelopment,\n指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。</li>\n<li>管理控制 - 验证审查，保证分数合理有效。</li>\n<li>跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。</li>\n<li>金融财务 - 损失准备金、风险定价和利润率等问题。</li>\n</ol>\n</blockquote></li>\n<li><p>信用风险管理周期 -\n这里提到风险管理周期可以分为五个阶段，<code>市场营销-&gt;申请审批-&gt;账户管理-&gt;催收-&gt;回收</code>。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。</p>\n<ul>\n<li>分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。</li>\n<li>吸引（ solicitation ） -\n设计和实施营销活动，吸引潜在客户办理业务。</li>\n<li>获取（ acquisition ） -\n获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。</li>\n<li>管理（ management ） -\n对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。</li>\n<li>催收（ collections ） - 重点关注早期的违约和维持客户关系。</li>\n<li>追踪（ tracing ） -\n尝试联系并找到一些因没有更新住址或联系方式而失联的客户。</li>\n<li>回收（ rehabilitation ） -\n处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。</li>\n</ul>\n<p>除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。</p>\n<blockquote>\n<ol start=\"27\" type=\"1\">\n<li>市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。</li>\n<li>申请审批 - 选择客户的操作。</li>\n<li>账户管理 -\n询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。</li>\n<li>催收回收 - 违约原因和催收流程、催收时机和催收策略。</li>\n<li>欺诈防范 - 趋势、类型和工具。</li>\n</ol>\n</blockquote></li>\n<li><p>监管环境 - 介绍一些对金融机构的监管内容。</p>\n<blockquote>\n<ol start=\"32\" type=\"1\">\n<li>监管概念 -\n最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。</li>\n<li>隐私保护 -\n贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。</li>\n<li>禁止歧视 -\n涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。</li>\n<li>公平信贷 -\n确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。</li>\n<li>资本要求 -\n主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。</li>\n<li>了解客户 -\n提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。</li>\n<li>国家差异 -\n对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。</li>\n</ol>\n</blockquote></li>\n</ul>\n<h1 id=\"第一部分---背景设定\">第一部分 - 背景设定</h1>\n<h2 id=\"第-1-章---信用评分及其业务\">第 1 章 - 信用评分及其业务</h2>\n<h3 id=\"什么是信用评分\">1.1 什么是信用评分</h3>\n<h3 id=\"在哪儿使用信用评分\">1.2 在哪儿使用信用评分？</h3>\n<h4 id=\"数据来源\">1.2.1 数据来源</h4>\n<h4 id=\"信用风险管理周期\">1.2.2 信用风险管理周期</h4>\n<h4 id=\"行为偏好\">1.2.3 行为偏好</h4>\n<h3 id=\"为什么要使用信用评分\">为什么要使用信用评分？</h3>\n<h4 id=\"如何影响贷款机构\">1.3.1 如何影响贷款机构？</h4>\n<h4 id=\"对客户的影响\">1.3.2 对客户的影响</h4>\n<h3 id=\"信用评分如何影响信用供给\">1.4 信用评分如何影响信用供给？</h3>\n<h3 id=\"小结\">1.5 小结</h3>\n<h2 id=\"第-2-章---信用微历史\">第 2 章 - 信用微历史</h2>\n<h3 id=\"信用的历史\">2.1 信用的历史</h3>\n<h4 id=\"古代历史\">2.1.1 古代历史</h4>\n<h4 id=\"中世纪到-19-世纪\">2.1.2 中世纪到 19 世纪</h4>\n<h4 id=\"世纪\">2.1.3 20 世纪</h4>\n<h3 id=\"信用评分的历史\">2.2 信用评分的历史</h3>\n<h4 id=\"开拓时期\">2.2.1 开拓时期</h4>\n<h4 id=\"自动化时期\">2.2.2 自动化时期</h4>\n<h4 id=\"扩张时期\">2.2.3 扩张时期</h4>\n<h3 id=\"征信机构的历史\">2.3 征信机构的历史</h3>\n<h4 id=\"世纪中期以前\">2.3.1 18 世纪中期以前</h4>\n<h4 id=\"世纪-90-年代以后\">2.3.2 19 世纪 90 年代以后</h4>\n<h4 id=\"世纪-60-年代以后\">2.3.3 20 世纪 60 年代以后</h4>\n<h4 id=\"国际\">2.3.4 国际</h4>\n<h3 id=\"评级机构的历史\">2.4 评级机构的历史</h3>\n<h3 id=\"小结-1\">2.5 小结</h3>\n<h2 id=\"第三章---评分信用原理\">第三章 - 评分信用原理</h2>\n<h3 id=\"评分卡是什么\">3.1 评分卡是什么</h3>\n<h4 id=\"评分卡的形态\">3.1.1 评分卡的形态</h4>\n<h4 id=\"如何开发评分卡\">3.1.2 如何开发评分卡</h4>\n<h4 id=\"预测能力如何评估\">3.1.3 预测能力如何评估</h4>\n<h4 id=\"评分卡的偏差是如何出现的\">3.1.4 评分卡的偏差是如何出现的</h4>\n<h4 id=\"如何应对以上问题\">3.1.5 如何应对以上问题</h4>\n<h3 id=\"采用何种测量方法\">3.2 采用何种测量方法</h3>\n<h4 id=\"流程与策略\">3.2.1 流程与策略</h4>\n<h4 id=\"如何开发评分卡-1\">3.2.2 如何开发评分卡</h4>\n<h4 id=\"违约概率和损失程度\">3.2.3 违约概率和损失程度</h4>\n<h3 id=\"评分卡的开发流程\">3.3 评分卡的开发流程</h3>\n<h4 id=\"项目准备\">3.3.1 项目准备</h4>\n<h4 id=\"数据准备\">3.3.2 数据准备</h4>\n<h4 id=\"建模分析\">3.3.3 建模分析</h4>\n<h4 id=\"模型确定\">3.3.4 模型确定</h4>\n<h4 id=\"决策制定和策略\">3.3.5 决策制定和策略</h4>\n<h4 id=\"安全保护\">3.3.6 安全保护</h4>\n<h3 id=\"什么会影响评分卡\">3.4 什么会影响评分卡</h3>\n<h4 id=\"经济偏移\">3.4.1 经济偏移</h4>\n<h4 id=\"市场偏移\">3.4.2 市场偏移</h4>\n<h4 id=\"操作偏移\">3.4.3 操作偏移</h4>\n<h4 id=\"目标偏移\">3.4.4 目标偏移</h4>\n<h4 id=\"不明偏移\">3.4.5 不明偏移</h4>\n<h3 id=\"小结-2\">3.5 小结</h3>\n<h1 id=\"第二部分---风险业务\">第二部分 - 风险业务</h1>\n<h2 id=\"第-4-章---风险理论\">第 4 章 - 风险理论</h2>\n<h3 id=\"风险相关术语\">4.1 风险相关术语</h3>\n<h4 id=\"风险关联\">4.1.1 风险关联</h4>\n<h4 id=\"风险环境\">4.1.2 风险环境</h4>\n<h4 id=\"风险类型\">4.1.3 风险类型</h4>\n<h3 id=\"数据与模型\">4.2 数据与模型</h3>\n<h4 id=\"数据类型\">4.2.1 数据类型</h4>\n<h4 id=\"模型类型\">4.2.2 模型类型</h4>\n<h4 id=\"人为判断\">4.2.3 人为判断</h4>\n<h4 id=\"专家系统\">4.2.4 专家系统</h4>\n<h3 id=\"小结-3\">4.3 小结</h3>\n<h2 id=\"第-5-章---决策科学\">第 5 章 - 决策科学</h2>\n<h3 id=\"自适应控制\">5.1 自适应控制</h3>\n<h3 id=\"成为主人\">5.2 成为主人</h3>\n<h4 id=\"冠军挑战\">5.2.1 冠军挑战</h4>\n<h4 id=\"优化\">5.2.2 优化</h4>\n<h4 id=\"策略推断\">5.2.3 策略推断</h4>\n<h3 id=\"小结-4\">5.3 小结</h3>\n<h2 id=\"第-6-章---企业风险评估\">第 6 章 - 企业风险评估</h2>\n<h3 id=\"风险评估基础\">6.1 风险评估基础</h3>\n<h4 id=\"数据来源-1\">6.1.1 数据来源</h4>\n<h4 id=\"风险模型\">6.1.2 风险模型</h4>\n<h4 id=\"风险等级\">6.1.3 风险等级</h4>\n<h3 id=\"中小企业贷款\">6.2 中小企业贷款</h3>\n<h4 id=\"关系型贷款\">6.2.1 关系型贷款</h4>\n<h4 id=\"交易型贷款\">6.2.2 交易型贷款</h4>\n<h3 id=\"财务比率评分\">6.3 财务比率评分</h3>\n<h4 id=\"理论先驱\">6.3.1 理论先驱</h4>\n<h4 id=\"预测比率\">6.3.2 预测比率</h4>\n<h4 id=\"限制因素\">6.3.3 限制因素</h4>\n<h4 id=\"评级机构\">6.3.4 评级机构</h4>\n<h4 id=\"内部评级\">6.3.5 内部评级</h4>\n<h3 id=\"信用评级机构\">6.4 信用评级机构</h3>\n<h4 id=\"字母等级\">6.4.1 字母等级</h4>\n<h4 id=\"评级类型\">6.4.2 评级类型</h4>\n<h4 id=\"存在问题\">6.4.3 存在问题</h4>\n<h4 id=\"研究重点\">6.4.4 研究重点</h4>\n<h3 id=\"前瞻数据建模\">6.5 前瞻数据建模</h3>\n<h4 id=\"历史分析\">6.5.1 历史分析</h4>\n<h4 id=\"结构模型\">6.5.2 结构模型</h4>\n<h4 id=\"简约模型\">6.5.3 简约模型</h4>\n<h3 id=\"小结-5\">6.6 小结</h3>\n<h1 id=\"第三部分---数学和统计\">第三部分 - 数学和统计</h1>\n<h2 id=\"第-7-章---预测统计\">第 7 章 - 预测统计</h2>\n<h3 id=\"模型概述\">7.1 模型概述</h3>\n<h3 id=\"参数模型\">7.2 参数模型</h3>\n<h4 id=\"线性模型\">7.2.1 线性模型</h4>\n<h4 id=\"判别分析\">7.2.2 判别分析</h4>\n<h4 id=\"逻辑回归\">7.2.3 逻辑回归</h4>\n<h3 id=\"非参模型\">7.3 非参模型</h3>\n<h4 id=\"决策树\">7.3.1 决策树</h4>\n<h4 id=\"神经网络\">7.3.2 神经网络</h4>\n<h4 id=\"遗传算法\">7.3.3 遗传算法</h4>\n<h4 id=\"k-近邻法\">7.3.4 K 近邻法</h4>\n<h4 id=\"线性规划\">7.3.5 线性规划</h4>\n<h3 id=\"关键假设\">7.4 关键假设</h3>\n<h4 id=\"数据因素\">7.4.1 数据因素</h4>\n<h4 id=\"统计假设\">7.4.2 统计假设</h4>\n<h4 id=\"解决方法\">7.4.3 解决方法</h4>\n<h3 id=\"结果比较\">7.5 结果比较</h3>\n<h2 id=\"第-8-章---区分度的测量\">第 8 章 - 区分度的测量</h2>\n<h3 id=\"错误的分类矩阵\">8.1 错误的分类矩阵</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>混淆矩阵</th>\n<th><strong>实际好 Good</strong></th>\n<th><strong>实际坏 Bad</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>预测好 Positive</strong></td>\n<td>TP</td>\n<td>FN</td>\n</tr>\n<tr class=\"even\">\n<td><strong>预测坏 Negative</strong></td>\n<td>FP</td>\n<td>TN</td>\n</tr>\n</tbody>\n</table>\n<p>在预测不正确的情况下，分为两种错误：</p>\n<ul>\n<li>把实际好的预测为坏（ FN ） - False\nNegative，意为假负，也就是说实际上是正的，被称为<strong>第一类错误</strong>。</li>\n<li>把实际坏的预测为好（ FP ） - False\nNegative，意为假正，也就是说实际上是负的，被称为<strong>第二类错误</strong>。</li>\n</ul>\n<h3 id=\"kullback-散度\">8.2 Kullback 散度</h3>\n<blockquote>\n<p>Kullback S. Information theory and statistics[M]. Courier\nCorporation, 1997.</p>\n</blockquote>\n<p>Kullback\n散度用于测量两个频率分布的差异。在信用评分中，它的表现形式有两种：</p>\n<ul>\n<li>信息值（ Information Value, IV ）</li>\n<li>稳定指数（ Stability Index ）</li>\n</ul>\n<p>他们都建立在证据权重（ Weight of Evidence, WOE ）的基础上。</p>\n<h4 id=\"证据权重\">8.2.1 证据权重</h4>\n<p><span class=\"math display\">\\[\nWOE_i=ln(\\frac{N_i}{\\sum N})/(\\frac{P_i}{\\sum\nP})=ln(\\frac{N_i}{P_i})-ln(\\frac{\\sum N}{\\sum P})\n\\]</span></p>\n<p>其中 N 代表没有触发坏客户定义，也就是好客户。P\n代表触发坏客户定义，也就是坏客户。那么 <span\nclass=\"math inline\">\\(\\frac{N_i}{\\sum N}\\)</span>\n其实意思就是为好客户的概率，P 也一样，所以上面的公式也可以写为 <span\nclass=\"math display\">\\[\nWOE_i=ln(\\frac{P(bad)_i}{P(good)_i})\n\\]</span>\n它反映了某个特征的某个值（或组）的<strong>相对风险</strong>，很明显为\nWOE 代表了该组的相对风险更小，为负代表该组相对分箱更大。</p>\n<h4 id=\"信息值\">8.2.2 信息值</h4>\n<p><span class=\"math display\">\\[\nIV=\\sum^{n}_{i=1}[(\\frac{N_i}{\\sum N}-\\frac{P_i}{\\sum P})\\times\nWOE_i]=\\sum^{n}_{i=1}[\\frac{count(i)}{count(n)}\\times WOE_i]\n\\]</span></p>\n<h4 id=\"稳定指数\">8.2.3 稳定指数</h4>\n<h3 id=\"ks-统计量\">8.3 KS 统计量</h3>\n<h3 id=\"相关系数\">8.4 相关系数</h3>\n<h4 id=\"pearson-积矩\">8.4.1 Pearson 积矩</h4>\n<h4 id=\"spearman-秩序\">8.4.2 Spearman 秩序</h4>\n<h4 id=\"洛伦兹曲线\">8.4.3 洛伦兹曲线</h4>\n<h4 id=\"基尼系数\">8.4.4 基尼系数</h4>\n<h4 id=\"roc-曲线\">8.4.5 ROC 曲线</h4>\n<h3 id=\"卡方检验\">8.5 卡方检验</h3>\n<h3 id=\"准确性检验\">8.6 准确性检验</h3>\n<h4 id=\"概率论\">8.6.1 概率论</h4>\n<h4 id=\"二项分布\">8.6.2 二项分布</h4>\n<h4 id=\"hl统计量\">8.6.3 HL统计量</h4>\n<h4 id=\"对数似然\">8.6.4 对数似然</h4>\n<h3 id=\"小结-6\">8.7 小结</h3>\n<h2 id=\"第-9-章---零碎内容\">第 9 章 - 零碎内容</h2>\n<h3 id=\"描述方法\">9.1 描述方法</h3>\n<h4 id=\"聚类分析\">9.1.1 聚类分析</h4>\n<h4 id=\"因子分析\">9.1.2 因子分析</h4>\n<h3 id=\"预报方法\">9.2 预报方法</h3>\n<h4 id=\"马尔可夫链\">9.2.1 马尔可夫链</h4>\n<h4 id=\"生存分析\">9.2.2 生存分析</h4>\n<h3 id=\"其他概念\">9.3 其他概念</h3>\n<h4 id=\"相关性\">9.3.1 相关性</h4>\n<h4 id=\"交叉性\">9.3.2 交叉性</h4>\n<h4 id=\"单调性\">9.3.3 单调性</h4>\n<h4 id=\"标准化\">9.3.4 标准化</h4>\n<h3 id=\"开发报告\">9.4 开发报告</h3>\n<h4 id=\"特征分析报告\">9.4.1 特征分析报告</h4>\n<h4 id=\"分数分布报告\">9.4.2 分数分布报告</h4>\n<h4 id=\"新业务策略表\">9.4.3 新业务策略表</h4>\n<h3 id=\"小结-7\">9.5 小结</h3>\n<h2 id=\"第-10-章---头脑与机器\">第 10 章 - 头脑与机器</h2>\n<h3 id=\"人员和项目\">10.1 人员和项目</h3>\n<h4 id=\"评分卡开发人员\">10.1.1 评分卡开发人员</h4>\n<h4 id=\"外部供应商\">10.1.2 外部供应商</h4>\n<h4 id=\"内部资源\">10.1.3 内部资源</h4>\n<h4 id=\"项目组\">10.1.4 项目组</h4>\n<h4 id=\"指导委员会\">10.1.5 指导委员会</h4>\n<h3 id=\"软件\">10.2 软件</h3>\n<h4 id=\"评分卡开发\">10.2.1 评分卡开发</h4>\n<h4 id=\"决策引擎\">10.2.1 决策引擎</h4>\n<h3 id=\"小结-8\">10.3 小结</h3>\n<h1 id=\"第四部分---数据\">第四部分 - 数据</h1>\n<h2 id=\"第-11-章---数据考虑\">第 11 章 - 数据考虑</h2>\n<h3 id=\"数据透明度\">11.1 数据透明度</h3>\n<blockquote>\n<p>数据透明度指充分评估风险所需的数据充足程度。</p>\n</blockquote>\n<p>建模的最终目标是获取一个信用度的测量标准，这个标准合适与否取决于借款人数据对我们的透明程度（了解借款人的信息有多全面，特征衍生前的特征）。</p>\n<p>不透明的数据通常表现为：</p>\n<ul>\n<li>缺乏信用记录。</li>\n<li>信息不友好。指结构化数据的存储结构不合理，或者数据对信用度影响的逻辑难以建立。</li>\n<li>高度复杂。指非结构化数据，例如语音，图像等，可能有用但是我们不知道怎么用。</li>\n</ul>\n<p>如果数据透明度不够，贷款机构面临两种选择：</p>\n<ol type=\"1\">\n<li>提高贷款利率，作为风险溢价。</li>\n<li>投入额外成本来确定有用信息，例如购买第三方数据源的数据。</li>\n</ol>\n<p>那么数据透明度是由数据的数量和质量决定的，就引入了下两章。</p>\n<h3 id=\"数据数量\">11.2 数据数量</h3>\n<blockquote>\n<p>数据的深度和广度，由可得性和同质性决定。</p>\n</blockquote>\n<h4 id=\"深度和广度\">11.2.1 深度和广度</h4>\n<blockquote>\n<p>样本量（深度）和变量数量（广度）。</p>\n</blockquote>\n<p>最小样本量是 1500 个好样本、 1500 个坏样本、 1000 个拒绝样本。</p>\n<p>最终模型一般包含 6~25 个特征。</p>\n<h4 id=\"同质性\">11.2.2 同质性</h4>\n<blockquote>\n<p>同质性决定样本是否可以合并处理。</p>\n</blockquote>\n<p>同质性是样本分群的问题。主要要考虑以下 3 点：</p>\n<ol type=\"1\">\n<li>目标定义</li>\n<li>数据来源</li>\n<li>交叉作用</li>\n</ol>\n<p>以上 3 点有问题的样本都应该分开，然后用不同的模型去处理。</p>\n<p>有时我们会遇到在某群体的样本表现高度同质，这种时候应该去寻找新的数据源扩大数据的广度。</p>\n<h4 id=\"可得性\">11.2.3 可得性</h4>\n<blockquote>\n<p>数据获取面临的来自系统、权限或法律的限制。</p>\n</blockquote>\n<p>数据采集、系统升级时的数据更新（这里指丢失记录）、反歧视、数据隐私、信息共享。</p>\n<h3 id=\"数据质量\">11.3 数据质量</h3>\n<blockquote>\n<p>数据能否符合某具体需求。高质量的数据应该具备相关性、准确性、完备性、时效性和一致性。</p>\n<p>在很多情况下，风险管理所用的信息通常只是为截然不同的目的而设计的处理系统的副产品，而且前端系统对数据质量通常缺乏具体的要求，从而虚弱了其产生信息的质量。</p>\n</blockquote>\n<h4 id=\"关联性\">11.3.1 关联性</h4>\n<blockquote>\n<p>数据要与结果有关，能够为分数和决策提供有意义的帮助。</p>\n</blockquote>\n<p>首要关注的是数据的相关关系而非因果关系。</p>\n<p>四个问题：</p>\n<ol type=\"1\">\n<li>如果特征可测量，它的预测能力怎么样？</li>\n<li>如果特征不可测量，是否有证据证明它在其他方面有价值？</li>\n<li>特征数据是否在需要时可获取，如果不能怎么办？</li>\n<li>特征在逻辑上是否有意义？</li>\n</ol>\n<h4 id=\"准确性\">11.3.2 准确性</h4>\n<blockquote>\n<p>通过正确地获取、加工和储存数据使其准确反映真实状况。</p>\n</blockquote>\n<p>数据不准确主要集中在两方面：</p>\n<ol type=\"1\">\n<li>流程设计不完善 - 表格设计、数据采集、系统错误和匹配等方面的问题。\n<ul>\n<li>记账错误 - 数据不正确、不一致或重复。</li>\n<li>漏账错误 - 字段为空或记录缺失。</li>\n</ul></li>\n<li>作弊 - 为提高申请通过的可能性，申请表答案可能被篡改。</li>\n</ol>\n<h4 id=\"完备性\">11.3.3 完备性</h4>\n<blockquote>\n<p>数据包含所有所需信息，允许个别或整条记录有缺失。</p>\n</blockquote>\n<p>特征层面上的完备与样本记录层面上的完备。</p>\n<h4 id=\"时效性\">11.3.4 时效性</h4>\n<blockquote>\n<p>数据随时更新。超过一定期限后，数据就会失效。</p>\n</blockquote>\n<p>如 A 卡的特征年龄是基于客户申请时间的年龄，而不是现在的年龄。</p>\n<p>对于老客户，更多地依赖行为数据而非申请数据。</p>\n<h4 id=\"一致性\">11.3.5 一致性</h4>\n<blockquote>\n<p>随时间推移数据意义保持一致。就算数据有误，也希望一致有误，这样还可以加以利用。</p>\n</blockquote>\n<p>主要是指系统、流程或某参数更新时造成同样的输入不同的输出问题。</p>\n<p>重大突发事件也可能造成数据的意义不一致。</p>\n<h4 id=\"对征信机构的影响\">11.3.6 对征信机构的影响</h4>\n<p>CFA 建议贷款机构在作决策时不要局限于一家征信机构的信息。</p>\n<h3 id=\"数据设计\">11.4 数据设计</h3>\n<blockquote>\n<p>定义数据的类型。从实践或统计的角度出发，考虑数据缺失、分母为零的特例和数据设计的问题，最大化数据的价值。</p>\n</blockquote>\n<h4 id=\"数据类型-1\">11.4.1 数据类型</h4>\n<blockquote>\n<p>统计上及实践中描述数据的术语和对特殊情况的处理。</p>\n</blockquote>\n<p>数据的两个维度：</p>\n<ul>\n<li>记录（ record ） - 单个样本的细节。</li>\n<li>字段（ field ）、特征（ characteristic ）、变量（ variable\n），这三者都是一个东西。</li>\n</ul>\n<p><strong>统计上的分类：</strong></p>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>变量类别</th>\n<th>类别含义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>分类变量</td>\n<td>由定性特征确定的分组情况，例如性别（男、女）或颜色（黄、红、蓝）。没有顺序和大小。</td>\n</tr>\n<tr class=\"even\">\n<td>二元变量</td>\n<td>仅由两种类别构成，例如“是/否”等一对反义词。又称为二分类变量。信用评分中目标变量大多是二分类变量，例如目标客户（好、坏）。</td>\n</tr>\n<tr class=\"odd\">\n<td>名义变量</td>\n<td>用标签（名字）或代码（字母/数字）表示的变量。没有顺序和大小。</td>\n</tr>\n<tr class=\"even\">\n<td>顺序变量</td>\n<td>只表示一个序列中的相对位置，不表示相对距离的大小，通常和主观评价有关，例如优秀、良好、一般、差。有顺序没有大小。</td>\n</tr>\n<tr class=\"odd\">\n<td>数值变量</td>\n<td>用整数或实数表示，有顺序有大小，能进行数值运算，比如年龄（整岁）。</td>\n</tr>\n<tr class=\"even\">\n<td>连续变量</td>\n<td>存在于连续的序列中，可能值的数量无限，存在最大值和最小值，用实数表示，例如温度、重量、距离和时间。</td>\n</tr>\n<tr class=\"odd\">\n<td>离散变量</td>\n<td>分离或者不连续的变量，用实数表示。并不代表没有顺序和大小。</td>\n</tr>\n<tr class=\"even\">\n<td>基数变量</td>\n<td>离散的，但特指一个集合内的数量。通常等价于离散变量。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>实践中的分类：</strong></p>\n<table>\n\n<thead>\n<tr class=\"header\">\n<th>变量类别</th>\n<th>类别含义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>编码（名义）</td>\n<td>用符号或数字表现的类别。</td>\n</tr>\n<tr class=\"even\">\n<td>金额（近似连续）</td>\n<td>以货币金额表示的内容，例如余额、额度、交易额，可以计算总数、平均数、趋势、最小值、最大值、范围、极限等。</td>\n</tr>\n<tr class=\"odd\">\n<td>次数（离散）</td>\n<td>发生的数量，例如子女的数量（来自申请者）、逾期次数（来自贷款机构）、查询次数（来自征信机构）。</td>\n</tr>\n<tr class=\"even\">\n<td>比率（连续）</td>\n<td>两个数值相除的结果，最常用于按照规模对金额标准化，例如资产负债率。</td>\n</tr>\n<tr class=\"odd\">\n<td>时间（离散）</td>\n<td>距离某特定事件（账户开立、账户激活、某次评估）发生的时间，通常按天或月计算。</td>\n</tr>\n<tr class=\"even\">\n<td>分数（近似连续）</td>\n<td>表示未来某事件发生的概率（打分）。在一些情况下，一个分数可以用来计算另一个分数（比如通过第三方数据的评分卡制作内部的评分卡）。</td>\n</tr>\n<tr class=\"odd\">\n<td>等级（序数）</td>\n<td>和分数类似，不过它代表一个分数范围，或被主观确定。</td>\n</tr>\n</tbody>\n</table>\n<p>提到了变量处理的基础方法，主要分为两种：</p>\n<ul>\n<li>转换特征 - 比如 <code>birthday</code>\n本身可能并不能作为合适的特征使用，那么我们用某一时间（例如客户申请时间）减去出生日期换算成年就得到了\n<code>age</code> 这个特征。</li>\n<li>特征生成\n<ul>\n<li>多项式生成 - 生成交叉项，例如 <code>sklearn</code> 里的\n<code>PolynomialFeatures</code> 方法。</li>\n<li>计算比率 - 例如计算负债比。</li>\n</ul></li>\n</ul>\n<p><strong>特例（缺失值、异常值处理）：</strong></p>\n<ul>\n<li>数据缺失 -\n未找到（不清楚真实是否发生）、无记录（真实发生）、未发生（真实未发生）等。</li>\n<li>账户状态 -\n同一个特征里没有用相同单位，如一部分是值，一部分是字符。</li>\n<li>分母为零 - 除数不能为 0 ，这种情况可以用一个接近 0 的值代替。</li>\n<li>分母为负 - 计算比率或比例时，出现了分子分母同时为负的情况。</li>\n</ul>\n<p>对缺失值和异常值，一般用一个特殊编号来记录。</p>\n<h4 id=\"表格设计\">11.4.2 表格设计</h4>\n<blockquote>\n<p>收集数据的表格设计。</p>\n</blockquote>\n<p>最大的挑战在于尽可能获取更多地相关数据，但数据又不过量。</p>\n<p>表格的处理方式取决于表格设置的答案时定性的还是定量的。</p>\n<p><strong>数值结果</strong></p>\n<p>分为 3 种：</p>\n<ol type=\"1\">\n<li>数值本身。</li>\n<li>计算输入值。</li>\n<li>数值范围。</li>\n</ol>\n<p>例如不需要申请者填写年龄，直接填写年龄段和生日；金额上不填某段，填入具体的数值；负债收入比率不需要申请者计算，直接填入负债值和收入值。</p>\n<p><strong>分类结果</strong></p>\n<p>难点在于确定特征的选择范围。</p>\n<p>不是直接填空，而是一个选择范围的下拉菜单。</p>\n<p>将问题分为更多的维度，例如职业和教育的问题分为行业、工作层级、最高学历、就业现状等维度。</p>\n<h3 id=\"小结-9\">11.5 小结</h3>\n<p>这章探讨了数据透明度、数据数量、数据质量和设计相关方面的问题。目的就是为了提高数据透明度，正是因为数据透明度的提高使得贷款机构对客户有更多的了解，从而可以扩大贷款规模。</p>\n<h2 id=\"第-12-章---数据来源\">第 12 章 - 数据来源</h2>\n<h3 id=\"客户信息\">12.1 客户信息</h3>\n<h4 id=\"申请表\">12.1.1 申请表</h4>\n<h4 id=\"财务信息\">12.1.2 财务信息</h4>\n<h3 id=\"内部信息\">12.2 内部信息</h3>\n<h4 id=\"数据类型-2\">12.2.1 数据类型</h4>\n<h4 id=\"数据库类型\">12.2.2 数据库类型</h4>\n<h4 id=\"客户关系管理\">12.2.3 客户关系管理</h4>\n<h3 id=\"征信数据\">12.3 征信数据</h3>\n<h4 id=\"查询检索\">12.3.1 查询检索</h4>\n<h4 id=\"公共信息\">12.3.2 公共信息</h4>\n<h4 id=\"共享数据\">12.3.3 共享数据</h4>\n<h4 id=\"欺诈预警\">12.3.4 欺诈预警</h4>\n<h4 id=\"征信分数\">12.3.5 征信分数</h4>\n<h4 id=\"地理指标\">12.3.6 地理指标</h4>\n<h4 id=\"其他来源\">12.3.7 其他来源</h4>\n<h3 id=\"小结-10\">12.4 小结</h3>\n<h2 id=\"第-13-章---评分机构\">第 13 章 - 评分机构</h2>\n<h3 id=\"定制服务\">13.1 定制服务</h3>\n<h4 id=\"通用评分卡\">13.1.1 通用评分卡</h4>\n<h4 id=\"定制评分卡\">13.1.2 定制评分卡</h4>\n<h4 id=\"专家模型\">13.1.3 专家模型</h4>\n<h3 id=\"系统架设\">13.2 系统架设</h3>\n<h3 id=\"数据整合\">13.3 数据整合</h3>\n<h4 id=\"独立分数\">13.3.1 独立分数</h4>\n<h4 id=\"离散分数\">13.3.2 离散分数</h4>\n<h4 id=\"合并分数\">13.3.3 合并分数</h4>\n<h4 id=\"决策矩阵\">13.3.4 决策矩阵</h4>\n<h3 id=\"信用评分\">13.4 信用评分</h3>\n<h3 id=\"数据匹配\">13.5 数据匹配</h3>\n<h3 id=\"小结-11\">13.6 小结</h3>\n<h2 id=\"第-14-章---信息共享\">第 14 章 - 信息共享</h2>\n<h3 id=\"征信机构\">14.1 征信机构</h3>\n<h4 id=\"公共与民营\">14.1.1 公共与民营</h4>\n<h4 id=\"正面信息与负面信息\">14.1.2 正面信息与负面信息</h4>\n<h3 id=\"参与合作\">14.2 参与合作</h3>\n<h4 id=\"互惠原则\">14.2.1 互惠原则</h4>\n<h4 id=\"促进因素\">14.2.2 促进因素</h4>\n<h4 id=\"阻碍因素\">14.2.3 阻碍因素</h4>\n<h3 id=\"小结-12\">14.3 小结</h3>\n<h2 id=\"第-15-章---数据准备\">第 15 章 - 数据准备</h2>\n<h3 id=\"数据获取\">15.1 数据获取</h3>\n<h4 id=\"申请数据\">15.1.1 申请数据</h4>\n<h4 id=\"征信数据-1\">15.1.2 征信数据</h4>\n<h4 id=\"观测数据\">15.1.3 观测数据</h4>\n<h4 id=\"表现数据\">15.1.4 表现数据</h4>\n<h4 id=\"数据整合-1\">15.1.5 数据整合</h4>\n<h3 id=\"好坏定义\">15.2 好坏定义</h3>\n<p>作者强调了好坏定义的重要性，提到了<strong>好坏定义是建模过程中仅次于数据的重要因素，用来设定目标变量。</strong></p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206201247059.png\"\nalt=\"好坏定义\" />\n<figcaption aria-hidden=\"true\">好坏定义</figcaption>\n</figure>\n<h4 id=\"选择状态\">15.2.1 选择状态</h4>\n<p>指观测期的状态，分为以下4类：</p>\n<ul>\n<li>排除 -\n如果某个子群体的分数不影响对其决策，作者建议排除。和拒绝不一样的地方是这类样本不需要做拒绝推断。</li>\n<li>拒绝 - 出于政策规则或者决策规则的样本不需要做拒绝推断。</li>\n<li>未采用 -\n客户没有接受贷款机构提供的贷款合同，也就是准入了但未做成。可能是价格、利率、合同条款让客户觉得不适。</li>\n<li>双方接受 - 只有这类样本会有真实的表现。</li>\n</ul>\n<h4 id=\"表现状态\">15.2.2 表现状态</h4>\n<p>指表现期的状态，分为以下4类：</p>\n<ul>\n<li><p>排除 -\n评分卡计划目标之外的结果，比如申请评分卡中出现了欺诈行为或客户去世。这类占比不宜超过总体的\n3%。</p></li>\n<li><p>不定 - 指灰样本，申请评分卡的不定率应设定在\n5%~15%，行为评分卡的不定率设定在 10%~20%。这里提到设定灰样本有 3\n个理由。</p>\n<ul>\n<li>技术逾期造成的疑似不良行为 - 我觉得应该是指像美国 ACH\n那样的延时得知交易结果的支付方式对标签定义的影响。</li>\n<li>公司策略</li>\n<li>使好坏定义更加清晰。</li>\n</ul>\n<p>这里也讨论了关于提前还款的人是好样本还是不定样本。这类人是可以当作好样本建模的。</p></li>\n<li><p>好样本 - 我们表示欢迎的样本。</p></li>\n<li><p>坏样本 - 我们表示回避的样本。</p></li>\n</ul>\n<h4 id=\"当前状态和最坏状态\">15.2.3 当前状态和最坏状态</h4>\n<p>当前状态和最坏状态是指用结果时点的状态（当前状态）还是整个结果期最坏的状态（最坏状态）来确定“不可恢复点”（\npoint of no return ），也就是去找出账户不会再从坏变好的时间点。</p>\n<p>行为评分中，巴塞尔协议 II 要求使用 90\n天内最坏最坏状态的定义。申请评分中两种方式都可以。使用当前状态可以确保误判和由坏变好的账户不会被误判，使用最坏状态则对可能是坏的账户更加敏感。</p>\n<p>一般情况下，当前状态的常见定义是逾期 60 天，最坏状态的定义是逾期 90\n天。</p>\n<h4 id=\"定义设定\">15.2.4 定义设定</h4>\n<p>定义有 3 种方式：</p>\n<ul>\n<li>共识 - 内部专家经验判断。</li>\n<li>规定 -\n由外部机构设定，确保一致性。（这个主要是方便供别人参考吧）</li>\n<li>经验（原文应该是 experience\n，我个人觉得翻译成<strong>历史</strong>更合适） -\n根据自身的历史数据实证分析。提到了滚动率分析，不过并没有讲具体怎么做。</li>\n</ul>\n<h4 id=\"好坏定义标准\">15.2.5 好坏定义标准</h4>\n<p>讲到好坏定义需要符合 3\n个特点：<strong>相关、充足、透明。</strong></p>\n<h3 id=\"时间窗口\">15.3 时间窗口</h3>\n<p>时间窗口组成有一些相关概念，这里讲到了：</p>\n<ul>\n<li>观测（ observation ） - 指对数据进行观测，作为预测变量。</li>\n<li>结果（ outcome ） - 指分析数据观测的结果，确定目标。</li>\n<li>日期/月份 - 指信息采集的时间。</li>\n<li>窗口（ window ） - 指一段时间。</li>\n</ul>\n<p>这些概念的组合就跟时间窗口有很密切的关系了：</p>\n<ul>\n<li><p>观测期（ observation window ） -\n也叫观察期，指观测点之前的一段时间。</p></li>\n<li><p>观测日期（ observation date ） -\n也叫观测点，位于观测期与表现期之间，指采集数据的日期。</p></li>\n<li><p>结果期 （ outcome window ） -\n也叫表现期，客户表现趋于成熟的时间段。</p></li>\n<li><p>结果日期（ outcome date ） - 指同一样本表现结果的日期。</p></li>\n</ul>\n<p>这两个窗口非常重要，<strong>观测期用于收集用户数据</strong>，例如银行流水等信息，<strong>观测期太短可能会导致变量预测效果不佳</strong>；<strong>表现期用于评价模型的标签（\nY\n）多久之后趋于稳定</strong>，随着时间的累加，违约率会增加但是边际增长率降低，<strong>表现期太短可能会存在坏客户风险暴露不充分这样的情况</strong>。在选择合适的观测期与表现期时，需要考虑<strong>账户成熟、样本信息缺失、数据老化</strong>三个因素。</p>\n<h3 id=\"样本设计\">15.4 样本设计</h3>\n<h4 id=\"样本类型\">15.4.1 样本类型</h4>\n<h4 id=\"最大和最小样本量\">15.4.2 最大和最小样本量</h4>\n<h4 id=\"分层随机抽样\">15.4.3 分层随机抽样</h4>\n<h3 id=\"小结-13\">15.5 小结</h3>\n<h1 id=\"第五部分---评分卡开发\">第五部分 - 评分卡开发</h1>\n<h2 id=\"第-16-章---变量转换\">第 16 章 - 变量转换</h2>\n<h3 id=\"转换方法\">16.1 转换方法</h3>\n<h4 id=\"虚拟变量\">16.1.1 虚拟变量</h4>\n<h4 id=\"风险变量\">16.1.2 风险变量</h4>\n<h4 id=\"方法选择\">16.1.3 方法选择</h4>\n<h3 id=\"粗细分类\">16.2 粗细分类</h3>\n<h4 id=\"特征分析报告-1\">16.2.1 特征分析报告</h4>\n<h4 id=\"细分类\">16.2.2 细分类</h4>\n<h4 id=\"粗分类\">16.2.3 粗分类</h4>\n<h3 id=\"统计量的应用\">16.3 统计量的应用</h3>\n<h4 id=\"预测能力测度\">16.3.1 预测能力测度</h4>\n<h4 id=\"粗分类例子\">16.3.2 粗分类例子</h4>\n<h3 id=\"池化算法\">16.4 池化算法</h3>\n<h4 id=\"非邻池化\">16.4.1 非邻池化</h4>\n<h4 id=\"相邻池化\">16.4.2 相邻池化</h4>\n<h4 id=\"单调相邻池化\">16.4.3 单调相邻池化</h4>\n<h3 id=\"实际案例\">16.5 实际案例</h3>\n<h4 id=\"法院判决\">16.5.1 法院判决</h4>\n<h4 id=\"行业种类\">16.5.2 行业种类</h4>\n<h4 id=\"职业种类\">16.5.3 职业种类</h4>\n<h3 id=\"小结-14\">16.6 小结</h3>\n<h2 id=\"第-17-章---特征选取\">第 17 章 - 特征选取</h2>\n<h3 id=\"参考因素\">17.1 参考因素</h3>\n<h3 id=\"预测能力\">17.2 预测能力</h3>\n<h3 id=\"降维方法\">17.3 降维方法</h3>\n<h4 id=\"建模处理\">17.3.1 建模处理</h4>\n<h4 id=\"相关矩阵\">17.3.2 相关矩阵</h4>\n<h4 id=\"因子分析-1\">17.3.3 因子分析</h4>\n<h3 id=\"变量输入\">17.4 变量输入</h3>\n<h4 id=\"分步\">17.4.1 分步</h4>\n<h4 id=\"分块\">17.4.2 分块</h4>\n<h3 id=\"小结-15\">17.5 小结</h3>\n<h2 id=\"第-18-章---样本分层\">第 18 章 - 样本分层</h2>\n<h3 id=\"驱动因素\">18.1 驱动因素</h3>\n<h3 id=\"识别交叉的作用\">18.2 识别交叉的作用</h3>\n<h3 id=\"处理交叉的作用\">18.3 处理交叉的作用</h3>\n<h3 id=\"小结-16\">18.4 小结</h3>\n<h2 id=\"第-19-章---拒绝推断\">第 19 章 - 拒绝推断</h2>\n<h3 id=\"推断原理\">19.1 推断原理</h3>\n<h3 id=\"总体流动\">19.2 总体流动</h3>\n<h3 id=\"表现赋值\">19.3 表现赋值</h3>\n<h3 id=\"特殊类别\">19.4 特殊类别</h3>\n<h3 id=\"推断方法\">19.5 推断方法</h3>\n<h4 id=\"随机补充\">19.5.1 随机补充</h4>\n<h4 id=\"展开法\">19.5.2 展开法</h4>\n<h4 id=\"外推法\">19.5.3 外推法</h4>\n<h4 id=\"同生表现法\">19.5.4 同生表现法</h4>\n<h3 id=\"小结-17\">19.6 小结</h3>\n<h2 id=\"第-20-章---模型校准\">第 20 章 - 模型校准</h2>\n<h3 id=\"分数分段\">20.1 分数分段</h3>\n<h4 id=\"ch-统计量\">20.1.1 CH 统计量</h4>\n<h4 id=\"基准方法\">20.1.2 基准方法</h4>\n<h4 id=\"边际风险边界\">20.1.3 边际风险边界</h4>\n<h3 id=\"线性变换\">20.2 线性变换</h3>\n<h4 id=\"线性变动\">20.2.1 线性变动</h4>\n<h4 id=\"比率缩放\">20.2.2 比率缩放</h4>\n<h3 id=\"线性规划重构\">20.3 线性规划重构</h3>\n<h3 id=\"小结-18\">20.4 小结</h3>\n<h2 id=\"第-21-章---检验交付\">第 21 章 - 检验交付</h2>\n<h3 id=\"组成成分\">21.1 组成成分</h3>\n<h4 id=\"开发依据\">21.1.1 开发依据</h4>\n<h4 id=\"持续检验\">21.1.2 持续检验</h4>\n<h4 id=\"回溯测试\">21.1.3 回溯测试</h4>\n<h3 id=\"差别效果\">21.2 差别效果</h3>\n<h3 id=\"小结-19\">21.3 小结</h3>\n<h2 id=\"第-22-章---开发管理\">第 22 章 - 开发管理</h2>\n<h3 id=\"进程安排\">22.1 进程安排</h3>\n<h3 id=\"高效操作\">22.2 高效操作</h3>\n<h4 id=\"重复利用\">22.2.1 重复利用</h4>\n<h4 id=\"重新建模\">22.2.2 重新建模</h4>\n<h3 id=\"小结-20\">22.3 小结</h3>\n<h1 id=\"第六部分---实施和使用\">第六部分 - 实施和使用</h1>\n<h2 id=\"第-23-章---实施安装\">第 23 章 - 实施安装</h2>\n<h3 id=\"自动化决策\">23.1 自动化决策</h3>\n<h4 id=\"自动化程度\">23.1.1 自动化程度</h4>\n<h4 id=\"职责\">23.1.2 职责</h4>\n<h4 id=\"员工沟通\">23.1.3 员工沟通</h4>\n<h4 id=\"客户教育\">23.1.4 客户教育</h4>\n<h3 id=\"安装和测试\">23.2 安装和测试</h3>\n<h4 id=\"数据资源和切换\">23.2.1 数据、资源和切换</h4>\n<h4 id=\"测试\">23.2.2 测试</h4>\n<h3 id=\"小结-21\">23.3 小结</h3>\n<h2 id=\"第-24-章---管理控制\">第 24 章 - 管理控制</h2>\n<h3 id=\"政策规则\">24.1 政策规则</h3>\n<h3 id=\"撤销\">24.2 撤销</h3>\n<h3 id=\"移交\">24.3 移交</h3>\n<h4 id=\"信息验证\">24.3.1 信息验证</h4>\n<h4 id=\"账户情况\">24.3.2 账户情况</h4>\n<h3 id=\"控制\">24.4 控制</h3>\n<h4 id=\"竞争环境\">24.4.1 竞争环境</h4>\n<h4 id=\"评分及策略控制\">24.4.2 评分及策略控制</h4>\n<h4 id=\"撤销控制\">24.4.3 撤销控制</h4>\n<h3 id=\"小结-22\">24.5 小结</h3>\n<h2 id=\"第-25-章---跟踪监控\">第 25 章 - 跟踪监控</h2>\n<h3 id=\"组合分析\">25.1 组合分析</h3>\n<h4 id=\"逾期分布\">25.1.1 逾期分布</h4>\n<h4 id=\"转移矩阵\">25.1.2 转移矩阵</h4>\n<h3 id=\"表现跟踪\">25.2 表现跟踪</h3>\n<h4 id=\"模型表现\">25.2.1 模型表现</h4>\n<h4 id=\"账龄分析\">25.2.2 账龄分析</h4>\n<h4 id=\"分数错配\">25.2.3 分数错配</h4>\n<h3 id=\"偏移报告\">25.3 偏移报告</h3>\n<h4 id=\"总体稳定性报告\">25.3.1 总体稳定性报告</h4>\n<h4 id=\"分数偏移报告\">25.3.2 分数偏移报告</h4>\n<h4 id=\"特征分析\">25.3.3 特征分析</h4>\n<h3 id=\"选择过程\">25.4 选择过程</h3>\n<h4 id=\"决策过程\">25.4.1 决策过程</h4>\n<h4 id=\"分数决策\">25.4.2 分数决策</h4>\n<h4 id=\"政策规则-1\">25.4.3 政策规则</h4>\n<h4 id=\"人为撤销\">25.4.4 人为撤销</h4>\n<h3 id=\"小结-23\">25.5 小结</h3>\n<h2 id=\"第-26-章---金融财务\">第 26 章 - 金融财务</h2>\n<h3 id=\"坏账准备\">26.1 坏账准备</h3>\n<h3 id=\"直接损失估计\">26.2 直接损失估计</h3>\n<h4 id=\"净流量法\">26.2.1 净流量法</h4>\n<h4 id=\"转移矩阵法\">26.2.2 转移矩阵法</h4>\n<h3 id=\"损失估计\">26.3 损失估计</h3>\n<h4 id=\"损失概率\">26.3.1 损失概率</h4>\n<h4 id=\"损失程度\">26.3.2 损失程度</h4>\n<h4 id=\"预测分析\">26.3.3 预测分析</h4>\n<h3 id=\"利润模型\">26.4 利润模型</h3>\n<h4 id=\"利润来源\">26.4.1 利润来源</h4>\n<h4 id=\"利润决策\">26.4.2 利润决策</h4>\n<h4 id=\"利润评分\">26.4.3 利润评分</h4>\n<h3 id=\"风险定价\">26.5 风险定价</h3>\n<h4 id=\"理论实践\">26.5.1 理论实践</h4>\n<h4 id=\"行为变化\">26.5.2 行为变化</h4>\n<h4 id=\"战略考虑\">26.5.3 战略考虑</h4>\n<h4 id=\"客户影响\">26.5.4 客户影响</h4>\n<h3 id=\"小结-24\">26.6 小结</h3>\n<h1 id=\"第七部分---信用风险管理周期\">第七部分 - 信用风险管理周期</h1>\n<h2 id=\"第-27-章---市场营销\">第 27 章 - 市场营销</h2>\n<h3 id=\"广告媒体\">27.1 广告媒体</h3>\n<h3 id=\"数量与质量\">27.2 数量与质量</h3>\n<h3 id=\"初步筛选\">27.3 初步筛选</h3>\n<h3 id=\"市场数据\">27.4 市场数据</h3>\n<h3 id=\"小结-25\">27.5 小结</h3>\n<h2 id=\"第-28-章---申请审批\">第 28 章 - 申请审批</h2>\n<h3 id=\"收集潜在客户信息\">28.1 收集潜在客户信息</h3>\n<h4 id=\"获取申请信息\">28.1.1 获取申请信息</h4>\n<h4 id=\"纸质数据采集\">28.1.2 纸质数据采集</h4>\n<h4 id=\"初筛和清洗\">28.1.3 初筛和清洗</h4>\n<h3 id=\"策略分类\">28.2 策略分类</h3>\n<h3 id=\"决策执行\">28.3 决策执行</h3>\n<h4 id=\"拒绝\">28.3.1 拒绝</h4>\n<h4 id=\"接受\">28.3.2 接受</h4>\n<h3 id=\"小结-26\">28.4 小结</h3>\n<h2 id=\"第-29-章---账户管理\">第 29 章 - 账户管理</h2>\n<h3 id=\"额度类型\">29.1 额度类型</h3>\n<h3 id=\"超额管理\">29.2 超额管理</h3>\n<h4 id=\"支票账户\">29.2.1 支票账户</h4>\n<h4 id=\"信用卡授权\">29.2.2 信用卡授权</h4>\n<h4 id=\"客户知情效应\">29.2.3 客户知情效应</h4>\n<h3 id=\"更多限额和其他功能\">29.3 更多限额和其他功能</h3>\n<h4 id=\"提额请求\">29.3.1 提额请求</h4>\n<h4 id=\"提高额度\">29.3.2 提高额度</h4>\n<h4 id=\"额度复核\">29.3.3 额度复核</h4>\n<h4 id=\"交叉销售\">29.3.4 交叉销售</h4>\n<h4 id=\"重获客户\">29.3.5 重获客户</h4>\n<h3 id=\"小结-27\">29.4 小结</h3>\n<h2 id=\"第-30-章---催收回收\">第 30 章 - 催收回收</h2>\n<h3 id=\"概述\">30.1 概述</h3>\n<h3 id=\"时机策略\">30.2 时机策略</h3>\n<h3 id=\"催收评分\">30.3 催收评分</h3>\n<h3 id=\"小结-28\">30.4 小结</h3>\n<h2 id=\"第-31-章---欺诈防范\">第 31 章 - 欺诈防范</h2>\n<h3 id=\"欺诈类型\">31.1 欺诈类型</h3>\n<h3 id=\"欺诈侦测工具\">31.2 欺诈侦测工具</h3>\n<h3 id=\"欺诈防范策略\">31.3 欺诈防范策略</h3>\n<h3 id=\"欺诈评分\">31.4 欺诈评分</h3>\n<h3 id=\"小结-29\">31.5 小结</h3>\n<h1 id=\"第八部分---监管环境\">第八部分 - 监管环境</h1>\n<h2 id=\"第-32-章---监管理念\">第 32 章 - 监管理念</h2>\n<h3 id=\"最佳实践\">32.1 最佳实践</h3>\n<h3 id=\"善良治理\">32.2 善良治理</h3>\n<h3 id=\"商业道德和社会责任\">32.3 商业道德和社会责任</h3>\n<h3 id=\"合规等级\">32.4 合规等级</h3>\n<h3 id=\"小结-30\">32.5 小结</h3>\n<h2 id=\"第-33-章---隐私保护\">第 33 章 - 隐私保护</h2>\n<h3 id=\"背景\">33.1 背景</h3>\n<h4 id=\"历史概况\">33.1.1 历史概况</h4>\n<h4 id=\"tournier-案件\">33.1.2 Tournier 案件</h4>\n<h4 id=\"oecd-数据隐私指引\">33.1.3 OECD 数据隐私指引</h4>\n<h4 id=\"欧洲理事会公约\">33.1.4 欧洲理事会公约</h4>\n<h4 id=\"欧盟数据保护指令\">33.1.5 欧盟数据保护指令</h4>\n<h4 id=\"特殊情况\">33.1.6 特殊情况</h4>\n<h3 id=\"原则\">33.2 原则</h3>\n<h4 id=\"收集方式\">33.2.1 收集方式</h4>\n<h4 id=\"合理目的\">33.2.2 合理目的</h4>\n<h4 id=\"信息质量\">33.2.3 信息质量</h4>\n<h4 id=\"信息使用\">33.2.4 信息使用</h4>\n<h4 id=\"信息披露\">33.2.5 信息披露</h4>\n<h4 id=\"主体权利\">33.2.6 主体权利</h4>\n<h4 id=\"信息安全\">33.2.7 信息安全</h4>\n<h3 id=\"小结-31\">33.3 小结</h3>\n<h2 id=\"第-34-章---禁止歧视\">第 34 章 - 禁止歧视</h2>\n<h3 id=\"何为歧视\">34.1 何为歧视</h3>\n<h3 id=\"存疑特征\">34.2 存疑特征</h3>\n<h3 id=\"小结-32\">34.3 小结</h3>\n<h2 id=\"第-35-章---公平信贷\">第 35 章 - 公平信贷</h2>\n<h3 id=\"掠夺性放贷\">35.1 掠夺性放贷</h3>\n<h3 id=\"不负责放贷\">35.2 不负责放贷</h3>\n<h3 id=\"负责任放贷\">35.3 负责任放贷</h3>\n<h3 id=\"小结-33\">35.4 小结</h3>\n<h2 id=\"第-36-章---资本要求\">第 36 章 - 资本要求</h2>\n<h3 id=\"巴塞尔协议-i\">36.1 巴塞尔协议 I</h3>\n<h3 id=\"巴塞尔协议-ii\">36.2 巴塞尔协议 II</h3>\n<h4 id=\"标准法\">36.2.1 标准法</h4>\n<h4 id=\"内部评级法\">36.2.2 内部评级法</h4>\n<h4 id=\"风险暴露类别\">36.2.3 风险暴露类别</h4>\n<h4 id=\"违约定义\">36.2.4 违约定义</h4>\n<h4 id=\"评级意义\">36.2.5 评级意义</h4>\n<h4 id=\"执行问题\">36.2.6 执行问题</h4>\n<h3 id=\"风险加权资产的计算\">36.3 风险加权资产的计算</h3>\n<h3 id=\"小结-34\">36.4 小结</h3>\n<h2 id=\"第-37-章---了解客户\">第 37 章 - 了解客户</h2>\n<h3 id=\"尽职调查要求\">37.1 尽职调查要求</h3>\n<h3 id=\"客户身份识别要求\">37.2 客户身份识别要求</h3>\n<h2 id=\"第-38-章---国家差异\">第 38 章 - 国家差异</h2>\n<p>国家差异汇总表：</p>\n<table style=\"width:100%;\">\n\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>美国</th>\n<th>加拿大</th>\n<th>英国</th>\n<th>澳大利亚</th>\n<th>南非</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>背景情况</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>个人识别码</td>\n<td>SSN</td>\n<td>SIN</td>\n<td>无</td>\n<td>SSN</td>\n<td>ID</td>\n</tr>\n<tr class=\"odd\">\n<td>支付档案名称</td>\n<td>共享信息</td>\n<td>正面信息</td>\n<td>白色数据 /CAIS</td>\n<td>无</td>\n<td>支付档案</td>\n</tr>\n<tr class=\"even\">\n<td>负债占国民净生产总值的比例（1999）</td>\n<td>16.1</td>\n<td>14.4</td>\n<td>5.7</td>\n<td>7.7</td>\n<td>未知</td>\n</tr>\n<tr class=\"odd\">\n<td>征信机构</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>民营征信机构（1999）</td>\n<td>19 世纪 90 年代</td>\n<td>1919 年</td>\n<td>20 世纪 60 年代</td>\n<td>20 世纪 30 年代</td>\n<td>1901年</td>\n</tr>\n<tr class=\"odd\">\n<td>TransUnion</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>其他机构</td>\n<td>有</td>\n</tr>\n<tr class=\"even\">\n<td>Equifax</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>其他机构</td>\n<td>无</td>\n</tr>\n<tr class=\"odd\">\n<td>Experian</td>\n<td>有</td>\n<td>无</td>\n<td>有</td>\n<td>其他机构</td>\n<td>有</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"美国\">38.1 美国</h3>\n<p>美国是最早设立法律影响信用评分的国家。</p>\n<p><a\nhref=\"https://www.ftc.gov/legal-library/browse/statutes/fair-credit-reporting-act\">《公平信用报告法》（\nFair Credit Reporting Act ）</a></p>\n<p>保证了数据的隐私和准确，限制征信机构只能用与信用相关的信息，包括正面信息。</p>\n<p><a\nhref=\"https://www.ftc.gov/legal-library/browse/statutes/equal-credit-opportunity-act\">《平等信贷机会法》（Equal\nCredit Opportunity Act）</a></p>\n<p>反对消费信贷歧视，包括申请者的种族、肤色、信仰、国籍、性别、婚姻、年龄或接受公共援助资助信息。</p>\n<p>对于年龄这个特征，只要不歧视老年人就可以使用。</p>\n<p>贷款机构需要向被拒的申请人提供拒绝的明确原因。</p>\n<h3 id=\"加拿大\">38.2 加拿大</h3>\n<h3 id=\"英国\">38.3 英国</h3>\n<h3 id=\"澳大利亚\">38.4 澳大利亚</h3>\n<h3 id=\"南非\">38.5 南非</h3>\n","site":{"data":{}},"wordcount":12291,"excerpt":"","more":"<h1 id=\"大纲\">大纲</h1>\n<p>全书共 8 个部分，分别为：</p>\n<ul>\n<li><p>背景设定 -\n讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔\nloan\n做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。</p>\n<blockquote>\n<ol type=\"1\">\n<li>信用评分及其业务 -\n什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。</li>\n<li>信用微历史 -\n关于信用供给、信用评分、征信机构和评级机构的简要历史。</li>\n<li>信用评分原理 - 如何进行信用评分、怎样建立评分卡。</li>\n</ol>\n</blockquote></li>\n<li><p>风险业务 -\n针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。</p>\n<blockquote>\n<ol start=\"4\" type=\"1\">\n<li>风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。</li>\n<li>决策科学 -\n信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。</li>\n<li>企业风险评估 -\n对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。</li>\n</ol>\n</blockquote></li>\n<li><p>数学和统计 -\n介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。</p>\n<blockquote>\n<ol start=\"7\" type=\"1\">\n<li>预测统计 -\n因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。</li>\n<li>区分度的测量 -\n用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。</li>\n<li>零碎内容 -\n描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。</li>\n<li>头脑与机器 -\n所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。</li>\n</ol>\n</blockquote></li>\n<li><p>数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。</p>\n<blockquote>\n<ol start=\"11\" type=\"1\">\n<li>数据考虑 -\n建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。</li>\n<li>数据来源 - 讨论从客户、内部系统和征信机构获取信息。</li>\n<li>评分结构 -\n关注评分卡的定制和架设、数据整合和不同来源数据的匹配。</li>\n<li>信息共享 -\n征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。</li>\n<li>数据准备 -\n开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。</li>\n</ol>\n</blockquote></li>\n<li><p>评分卡开发 -\n这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把<strong>简单、可解释性强的模型</strong>作为评分卡开发时的选择这个倾向。</p>\n<blockquote>\n<p>Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for Private\nCompanies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.</p>\n</blockquote>\n<p>作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的<code>可行性分析-&gt;需求分析-&gt;总体设计-&gt;详细设计</code>有着异曲同工之妙。作者把开发前大体的步骤划分为如下：</p>\n<ul>\n<li>项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。</li>\n<li>数据收集 - 从数据来源提取大小合适的样本。</li>\n<li>好坏定义 -\n不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。</li>\n<li>样本分层 -\n决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）</li>\n<li>确定模型 -\n开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。</li>\n<li>决策策略 -\n不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。</li>\n</ul>\n<p>开发的完整流程如下：</p>\n<blockquote>\n<ol start=\"16\" type=\"1\">\n<li>变量转换 -\n分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。</li>\n<li>特征选取 -\n确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。</li>\n<li>样本分层 -\n是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。</li>\n<li>拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。</li>\n<li>模型校准 -\n用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。</li>\n<li>检验交付 -\n用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。</li>\n<li>开发管理 - 评分卡开发的流程管理和安排。</li>\n</ol>\n</blockquote></li>\n<li><p>实施和使用 -\n遵循<strong>Wiklund提供的框架</strong>，介绍模型部署与模型监控相关内容。</p>\n<blockquote>\n<p>在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。</p>\n<p>Handbook of credit scoring[M]. Global Professional Publishi,\n2001.</p>\n</blockquote>\n<blockquote>\n<ol start=\"23\" type=\"1\">\n<li>实施安装 - 绿地开发（ Greenfield Software Development,\n指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield Software\nDevelopment,\n指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。</li>\n<li>管理控制 - 验证审查，保证分数合理有效。</li>\n<li>跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。</li>\n<li>金融财务 - 损失准备金、风险定价和利润率等问题。</li>\n</ol>\n</blockquote></li>\n<li><p>信用风险管理周期 -\n这里提到风险管理周期可以分为五个阶段，<code>市场营销-&gt;申请审批-&gt;账户管理-&gt;催收-&gt;回收</code>。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。</p>\n<ul>\n<li>分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。</li>\n<li>吸引（ solicitation ） -\n设计和实施营销活动，吸引潜在客户办理业务。</li>\n<li>获取（ acquisition ） -\n获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。</li>\n<li>管理（ management ） -\n对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。</li>\n<li>催收（ collections ） - 重点关注早期的违约和维持客户关系。</li>\n<li>追踪（ tracing ） -\n尝试联系并找到一些因没有更新住址或联系方式而失联的客户。</li>\n<li>回收（ rehabilitation ） -\n处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。</li>\n</ul>\n<p>除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。</p>\n<blockquote>\n<ol start=\"27\" type=\"1\">\n<li>市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。</li>\n<li>申请审批 - 选择客户的操作。</li>\n<li>账户管理 -\n询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。</li>\n<li>催收回收 - 违约原因和催收流程、催收时机和催收策略。</li>\n<li>欺诈防范 - 趋势、类型和工具。</li>\n</ol>\n</blockquote></li>\n<li><p>监管环境 - 介绍一些对金融机构的监管内容。</p>\n<blockquote>\n<ol start=\"32\" type=\"1\">\n<li>监管概念 -\n最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。</li>\n<li>隐私保护 -\n贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。</li>\n<li>禁止歧视 -\n涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。</li>\n<li>公平信贷 -\n确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。</li>\n<li>资本要求 -\n主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。</li>\n<li>了解客户 -\n提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。</li>\n<li>国家差异 -\n对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。</li>\n</ol>\n</blockquote></li>\n</ul>\n<h1 id=\"第一部分---背景设定\">第一部分 - 背景设定</h1>\n<h2 id=\"第-1-章---信用评分及其业务\">第 1 章 - 信用评分及其业务</h2>\n<h3 id=\"什么是信用评分\">1.1 什么是信用评分</h3>\n<h3 id=\"在哪儿使用信用评分\">1.2 在哪儿使用信用评分？</h3>\n<h4 id=\"数据来源\">1.2.1 数据来源</h4>\n<h4 id=\"信用风险管理周期\">1.2.2 信用风险管理周期</h4>\n<h4 id=\"行为偏好\">1.2.3 行为偏好</h4>\n<h3 id=\"为什么要使用信用评分\">为什么要使用信用评分？</h3>\n<h4 id=\"如何影响贷款机构\">1.3.1 如何影响贷款机构？</h4>\n<h4 id=\"对客户的影响\">1.3.2 对客户的影响</h4>\n<h3 id=\"信用评分如何影响信用供给\">1.4 信用评分如何影响信用供给？</h3>\n<h3 id=\"小结\">1.5 小结</h3>\n<h2 id=\"第-2-章---信用微历史\">第 2 章 - 信用微历史</h2>\n<h3 id=\"信用的历史\">2.1 信用的历史</h3>\n<h4 id=\"古代历史\">2.1.1 古代历史</h4>\n<h4 id=\"中世纪到-19-世纪\">2.1.2 中世纪到 19 世纪</h4>\n<h4 id=\"世纪\">2.1.3 20 世纪</h4>\n<h3 id=\"信用评分的历史\">2.2 信用评分的历史</h3>\n<h4 id=\"开拓时期\">2.2.1 开拓时期</h4>\n<h4 id=\"自动化时期\">2.2.2 自动化时期</h4>\n<h4 id=\"扩张时期\">2.2.3 扩张时期</h4>\n<h3 id=\"征信机构的历史\">2.3 征信机构的历史</h3>\n<h4 id=\"世纪中期以前\">2.3.1 18 世纪中期以前</h4>\n<h4 id=\"世纪-90-年代以后\">2.3.2 19 世纪 90 年代以后</h4>\n<h4 id=\"世纪-60-年代以后\">2.3.3 20 世纪 60 年代以后</h4>\n<h4 id=\"国际\">2.3.4 国际</h4>\n<h3 id=\"评级机构的历史\">2.4 评级机构的历史</h3>\n<h3 id=\"小结-1\">2.5 小结</h3>\n<h2 id=\"第三章---评分信用原理\">第三章 - 评分信用原理</h2>\n<h3 id=\"评分卡是什么\">3.1 评分卡是什么</h3>\n<h4 id=\"评分卡的形态\">3.1.1 评分卡的形态</h4>\n<h4 id=\"如何开发评分卡\">3.1.2 如何开发评分卡</h4>\n<h4 id=\"预测能力如何评估\">3.1.3 预测能力如何评估</h4>\n<h4 id=\"评分卡的偏差是如何出现的\">3.1.4 评分卡的偏差是如何出现的</h4>\n<h4 id=\"如何应对以上问题\">3.1.5 如何应对以上问题</h4>\n<h3 id=\"采用何种测量方法\">3.2 采用何种测量方法</h3>\n<h4 id=\"流程与策略\">3.2.1 流程与策略</h4>\n<h4 id=\"如何开发评分卡-1\">3.2.2 如何开发评分卡</h4>\n<h4 id=\"违约概率和损失程度\">3.2.3 违约概率和损失程度</h4>\n<h3 id=\"评分卡的开发流程\">3.3 评分卡的开发流程</h3>\n<h4 id=\"项目准备\">3.3.1 项目准备</h4>\n<h4 id=\"数据准备\">3.3.2 数据准备</h4>\n<h4 id=\"建模分析\">3.3.3 建模分析</h4>\n<h4 id=\"模型确定\">3.3.4 模型确定</h4>\n<h4 id=\"决策制定和策略\">3.3.5 决策制定和策略</h4>\n<h4 id=\"安全保护\">3.3.6 安全保护</h4>\n<h3 id=\"什么会影响评分卡\">3.4 什么会影响评分卡</h3>\n<h4 id=\"经济偏移\">3.4.1 经济偏移</h4>\n<h4 id=\"市场偏移\">3.4.2 市场偏移</h4>\n<h4 id=\"操作偏移\">3.4.3 操作偏移</h4>\n<h4 id=\"目标偏移\">3.4.4 目标偏移</h4>\n<h4 id=\"不明偏移\">3.4.5 不明偏移</h4>\n<h3 id=\"小结-2\">3.5 小结</h3>\n<h1 id=\"第二部分---风险业务\">第二部分 - 风险业务</h1>\n<h2 id=\"第-4-章---风险理论\">第 4 章 - 风险理论</h2>\n<h3 id=\"风险相关术语\">4.1 风险相关术语</h3>\n<h4 id=\"风险关联\">4.1.1 风险关联</h4>\n<h4 id=\"风险环境\">4.1.2 风险环境</h4>\n<h4 id=\"风险类型\">4.1.3 风险类型</h4>\n<h3 id=\"数据与模型\">4.2 数据与模型</h3>\n<h4 id=\"数据类型\">4.2.1 数据类型</h4>\n<h4 id=\"模型类型\">4.2.2 模型类型</h4>\n<h4 id=\"人为判断\">4.2.3 人为判断</h4>\n<h4 id=\"专家系统\">4.2.4 专家系统</h4>\n<h3 id=\"小结-3\">4.3 小结</h3>\n<h2 id=\"第-5-章---决策科学\">第 5 章 - 决策科学</h2>\n<h3 id=\"自适应控制\">5.1 自适应控制</h3>\n<h3 id=\"成为主人\">5.2 成为主人</h3>\n<h4 id=\"冠军挑战\">5.2.1 冠军挑战</h4>\n<h4 id=\"优化\">5.2.2 优化</h4>\n<h4 id=\"策略推断\">5.2.3 策略推断</h4>\n<h3 id=\"小结-4\">5.3 小结</h3>\n<h2 id=\"第-6-章---企业风险评估\">第 6 章 - 企业风险评估</h2>\n<h3 id=\"风险评估基础\">6.1 风险评估基础</h3>\n<h4 id=\"数据来源-1\">6.1.1 数据来源</h4>\n<h4 id=\"风险模型\">6.1.2 风险模型</h4>\n<h4 id=\"风险等级\">6.1.3 风险等级</h4>\n<h3 id=\"中小企业贷款\">6.2 中小企业贷款</h3>\n<h4 id=\"关系型贷款\">6.2.1 关系型贷款</h4>\n<h4 id=\"交易型贷款\">6.2.2 交易型贷款</h4>\n<h3 id=\"财务比率评分\">6.3 财务比率评分</h3>\n<h4 id=\"理论先驱\">6.3.1 理论先驱</h4>\n<h4 id=\"预测比率\">6.3.2 预测比率</h4>\n<h4 id=\"限制因素\">6.3.3 限制因素</h4>\n<h4 id=\"评级机构\">6.3.4 评级机构</h4>\n<h4 id=\"内部评级\">6.3.5 内部评级</h4>\n<h3 id=\"信用评级机构\">6.4 信用评级机构</h3>\n<h4 id=\"字母等级\">6.4.1 字母等级</h4>\n<h4 id=\"评级类型\">6.4.2 评级类型</h4>\n<h4 id=\"存在问题\">6.4.3 存在问题</h4>\n<h4 id=\"研究重点\">6.4.4 研究重点</h4>\n<h3 id=\"前瞻数据建模\">6.5 前瞻数据建模</h3>\n<h4 id=\"历史分析\">6.5.1 历史分析</h4>\n<h4 id=\"结构模型\">6.5.2 结构模型</h4>\n<h4 id=\"简约模型\">6.5.3 简约模型</h4>\n<h3 id=\"小结-5\">6.6 小结</h3>\n<h1 id=\"第三部分---数学和统计\">第三部分 - 数学和统计</h1>\n<h2 id=\"第-7-章---预测统计\">第 7 章 - 预测统计</h2>\n<h3 id=\"模型概述\">7.1 模型概述</h3>\n<h3 id=\"参数模型\">7.2 参数模型</h3>\n<h4 id=\"线性模型\">7.2.1 线性模型</h4>\n<h4 id=\"判别分析\">7.2.2 判别分析</h4>\n<h4 id=\"逻辑回归\">7.2.3 逻辑回归</h4>\n<h3 id=\"非参模型\">7.3 非参模型</h3>\n<h4 id=\"决策树\">7.3.1 决策树</h4>\n<h4 id=\"神经网络\">7.3.2 神经网络</h4>\n<h4 id=\"遗传算法\">7.3.3 遗传算法</h4>\n<h4 id=\"k-近邻法\">7.3.4 K 近邻法</h4>\n<h4 id=\"线性规划\">7.3.5 线性规划</h4>\n<h3 id=\"关键假设\">7.4 关键假设</h3>\n<h4 id=\"数据因素\">7.4.1 数据因素</h4>\n<h4 id=\"统计假设\">7.4.2 统计假设</h4>\n<h4 id=\"解决方法\">7.4.3 解决方法</h4>\n<h3 id=\"结果比较\">7.5 结果比较</h3>\n<h2 id=\"第-8-章---区分度的测量\">第 8 章 - 区分度的测量</h2>\n<h3 id=\"错误的分类矩阵\">8.1 错误的分类矩阵</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>混淆矩阵</th>\n<th><strong>实际好 Good</strong></th>\n<th><strong>实际坏 Bad</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>预测好 Positive</strong></td>\n<td>TP</td>\n<td>FN</td>\n</tr>\n<tr class=\"even\">\n<td><strong>预测坏 Negative</strong></td>\n<td>FP</td>\n<td>TN</td>\n</tr>\n</tbody>\n</table>\n<p>在预测不正确的情况下，分为两种错误：</p>\n<ul>\n<li>把实际好的预测为坏（ FN ） - False\nNegative，意为假负，也就是说实际上是正的，被称为<strong>第一类错误</strong>。</li>\n<li>把实际坏的预测为好（ FP ） - False\nNegative，意为假正，也就是说实际上是负的，被称为<strong>第二类错误</strong>。</li>\n</ul>\n<h3 id=\"kullback-散度\">8.2 Kullback 散度</h3>\n<blockquote>\n<p>Kullback S. Information theory and statistics[M]. Courier\nCorporation, 1997.</p>\n</blockquote>\n<p>Kullback\n散度用于测量两个频率分布的差异。在信用评分中，它的表现形式有两种：</p>\n<ul>\n<li>信息值（ Information Value, IV ）</li>\n<li>稳定指数（ Stability Index ）</li>\n</ul>\n<p>他们都建立在证据权重（ Weight of Evidence, WOE ）的基础上。</p>\n<h4 id=\"证据权重\">8.2.1 证据权重</h4>\n<p><span class=\"math display\">\\[\nWOE_i=ln(\\frac{N_i}{\\sum N})/(\\frac{P_i}{\\sum\nP})=ln(\\frac{N_i}{P_i})-ln(\\frac{\\sum N}{\\sum P})\n\\]</span></p>\n<p>其中 N 代表没有触发坏客户定义，也就是好客户。P\n代表触发坏客户定义，也就是坏客户。那么 <span\nclass=\"math inline\">\\(\\frac{N_i}{\\sum N}\\)</span>\n其实意思就是为好客户的概率，P 也一样，所以上面的公式也可以写为 <span\nclass=\"math display\">\\[\nWOE_i=ln(\\frac{P(bad)_i}{P(good)_i})\n\\]</span>\n它反映了某个特征的某个值（或组）的<strong>相对风险</strong>，很明显为\nWOE 代表了该组的相对风险更小，为负代表该组相对分箱更大。</p>\n<h4 id=\"信息值\">8.2.2 信息值</h4>\n<p><span class=\"math display\">\\[\nIV=\\sum^{n}_{i=1}[(\\frac{N_i}{\\sum N}-\\frac{P_i}{\\sum P})\\times\nWOE_i]=\\sum^{n}_{i=1}[\\frac{count(i)}{count(n)}\\times WOE_i]\n\\]</span></p>\n<h4 id=\"稳定指数\">8.2.3 稳定指数</h4>\n<h3 id=\"ks-统计量\">8.3 KS 统计量</h3>\n<h3 id=\"相关系数\">8.4 相关系数</h3>\n<h4 id=\"pearson-积矩\">8.4.1 Pearson 积矩</h4>\n<h4 id=\"spearman-秩序\">8.4.2 Spearman 秩序</h4>\n<h4 id=\"洛伦兹曲线\">8.4.3 洛伦兹曲线</h4>\n<h4 id=\"基尼系数\">8.4.4 基尼系数</h4>\n<h4 id=\"roc-曲线\">8.4.5 ROC 曲线</h4>\n<h3 id=\"卡方检验\">8.5 卡方检验</h3>\n<h3 id=\"准确性检验\">8.6 准确性检验</h3>\n<h4 id=\"概率论\">8.6.1 概率论</h4>\n<h4 id=\"二项分布\">8.6.2 二项分布</h4>\n<h4 id=\"hl统计量\">8.6.3 HL统计量</h4>\n<h4 id=\"对数似然\">8.6.4 对数似然</h4>\n<h3 id=\"小结-6\">8.7 小结</h3>\n<h2 id=\"第-9-章---零碎内容\">第 9 章 - 零碎内容</h2>\n<h3 id=\"描述方法\">9.1 描述方法</h3>\n<h4 id=\"聚类分析\">9.1.1 聚类分析</h4>\n<h4 id=\"因子分析\">9.1.2 因子分析</h4>\n<h3 id=\"预报方法\">9.2 预报方法</h3>\n<h4 id=\"马尔可夫链\">9.2.1 马尔可夫链</h4>\n<h4 id=\"生存分析\">9.2.2 生存分析</h4>\n<h3 id=\"其他概念\">9.3 其他概念</h3>\n<h4 id=\"相关性\">9.3.1 相关性</h4>\n<h4 id=\"交叉性\">9.3.2 交叉性</h4>\n<h4 id=\"单调性\">9.3.3 单调性</h4>\n<h4 id=\"标准化\">9.3.4 标准化</h4>\n<h3 id=\"开发报告\">9.4 开发报告</h3>\n<h4 id=\"特征分析报告\">9.4.1 特征分析报告</h4>\n<h4 id=\"分数分布报告\">9.4.2 分数分布报告</h4>\n<h4 id=\"新业务策略表\">9.4.3 新业务策略表</h4>\n<h3 id=\"小结-7\">9.5 小结</h3>\n<h2 id=\"第-10-章---头脑与机器\">第 10 章 - 头脑与机器</h2>\n<h3 id=\"人员和项目\">10.1 人员和项目</h3>\n<h4 id=\"评分卡开发人员\">10.1.1 评分卡开发人员</h4>\n<h4 id=\"外部供应商\">10.1.2 外部供应商</h4>\n<h4 id=\"内部资源\">10.1.3 内部资源</h4>\n<h4 id=\"项目组\">10.1.4 项目组</h4>\n<h4 id=\"指导委员会\">10.1.5 指导委员会</h4>\n<h3 id=\"软件\">10.2 软件</h3>\n<h4 id=\"评分卡开发\">10.2.1 评分卡开发</h4>\n<h4 id=\"决策引擎\">10.2.1 决策引擎</h4>\n<h3 id=\"小结-8\">10.3 小结</h3>\n<h1 id=\"第四部分---数据\">第四部分 - 数据</h1>\n<h2 id=\"第-11-章---数据考虑\">第 11 章 - 数据考虑</h2>\n<h3 id=\"数据透明度\">11.1 数据透明度</h3>\n<blockquote>\n<p>数据透明度指充分评估风险所需的数据充足程度。</p>\n</blockquote>\n<p>建模的最终目标是获取一个信用度的测量标准，这个标准合适与否取决于借款人数据对我们的透明程度（了解借款人的信息有多全面，特征衍生前的特征）。</p>\n<p>不透明的数据通常表现为：</p>\n<ul>\n<li>缺乏信用记录。</li>\n<li>信息不友好。指结构化数据的存储结构不合理，或者数据对信用度影响的逻辑难以建立。</li>\n<li>高度复杂。指非结构化数据，例如语音，图像等，可能有用但是我们不知道怎么用。</li>\n</ul>\n<p>如果数据透明度不够，贷款机构面临两种选择：</p>\n<ol type=\"1\">\n<li>提高贷款利率，作为风险溢价。</li>\n<li>投入额外成本来确定有用信息，例如购买第三方数据源的数据。</li>\n</ol>\n<p>那么数据透明度是由数据的数量和质量决定的，就引入了下两章。</p>\n<h3 id=\"数据数量\">11.2 数据数量</h3>\n<blockquote>\n<p>数据的深度和广度，由可得性和同质性决定。</p>\n</blockquote>\n<h4 id=\"深度和广度\">11.2.1 深度和广度</h4>\n<blockquote>\n<p>样本量（深度）和变量数量（广度）。</p>\n</blockquote>\n<p>最小样本量是 1500 个好样本、 1500 个坏样本、 1000 个拒绝样本。</p>\n<p>最终模型一般包含 6~25 个特征。</p>\n<h4 id=\"同质性\">11.2.2 同质性</h4>\n<blockquote>\n<p>同质性决定样本是否可以合并处理。</p>\n</blockquote>\n<p>同质性是样本分群的问题。主要要考虑以下 3 点：</p>\n<ol type=\"1\">\n<li>目标定义</li>\n<li>数据来源</li>\n<li>交叉作用</li>\n</ol>\n<p>以上 3 点有问题的样本都应该分开，然后用不同的模型去处理。</p>\n<p>有时我们会遇到在某群体的样本表现高度同质，这种时候应该去寻找新的数据源扩大数据的广度。</p>\n<h4 id=\"可得性\">11.2.3 可得性</h4>\n<blockquote>\n<p>数据获取面临的来自系统、权限或法律的限制。</p>\n</blockquote>\n<p>数据采集、系统升级时的数据更新（这里指丢失记录）、反歧视、数据隐私、信息共享。</p>\n<h3 id=\"数据质量\">11.3 数据质量</h3>\n<blockquote>\n<p>数据能否符合某具体需求。高质量的数据应该具备相关性、准确性、完备性、时效性和一致性。</p>\n<p>在很多情况下，风险管理所用的信息通常只是为截然不同的目的而设计的处理系统的副产品，而且前端系统对数据质量通常缺乏具体的要求，从而虚弱了其产生信息的质量。</p>\n</blockquote>\n<h4 id=\"关联性\">11.3.1 关联性</h4>\n<blockquote>\n<p>数据要与结果有关，能够为分数和决策提供有意义的帮助。</p>\n</blockquote>\n<p>首要关注的是数据的相关关系而非因果关系。</p>\n<p>四个问题：</p>\n<ol type=\"1\">\n<li>如果特征可测量，它的预测能力怎么样？</li>\n<li>如果特征不可测量，是否有证据证明它在其他方面有价值？</li>\n<li>特征数据是否在需要时可获取，如果不能怎么办？</li>\n<li>特征在逻辑上是否有意义？</li>\n</ol>\n<h4 id=\"准确性\">11.3.2 准确性</h4>\n<blockquote>\n<p>通过正确地获取、加工和储存数据使其准确反映真实状况。</p>\n</blockquote>\n<p>数据不准确主要集中在两方面：</p>\n<ol type=\"1\">\n<li>流程设计不完善 - 表格设计、数据采集、系统错误和匹配等方面的问题。\n<ul>\n<li>记账错误 - 数据不正确、不一致或重复。</li>\n<li>漏账错误 - 字段为空或记录缺失。</li>\n</ul></li>\n<li>作弊 - 为提高申请通过的可能性，申请表答案可能被篡改。</li>\n</ol>\n<h4 id=\"完备性\">11.3.3 完备性</h4>\n<blockquote>\n<p>数据包含所有所需信息，允许个别或整条记录有缺失。</p>\n</blockquote>\n<p>特征层面上的完备与样本记录层面上的完备。</p>\n<h4 id=\"时效性\">11.3.4 时效性</h4>\n<blockquote>\n<p>数据随时更新。超过一定期限后，数据就会失效。</p>\n</blockquote>\n<p>如 A 卡的特征年龄是基于客户申请时间的年龄，而不是现在的年龄。</p>\n<p>对于老客户，更多地依赖行为数据而非申请数据。</p>\n<h4 id=\"一致性\">11.3.5 一致性</h4>\n<blockquote>\n<p>随时间推移数据意义保持一致。就算数据有误，也希望一致有误，这样还可以加以利用。</p>\n</blockquote>\n<p>主要是指系统、流程或某参数更新时造成同样的输入不同的输出问题。</p>\n<p>重大突发事件也可能造成数据的意义不一致。</p>\n<h4 id=\"对征信机构的影响\">11.3.6 对征信机构的影响</h4>\n<p>CFA 建议贷款机构在作决策时不要局限于一家征信机构的信息。</p>\n<h3 id=\"数据设计\">11.4 数据设计</h3>\n<blockquote>\n<p>定义数据的类型。从实践或统计的角度出发，考虑数据缺失、分母为零的特例和数据设计的问题，最大化数据的价值。</p>\n</blockquote>\n<h4 id=\"数据类型-1\">11.4.1 数据类型</h4>\n<blockquote>\n<p>统计上及实践中描述数据的术语和对特殊情况的处理。</p>\n</blockquote>\n<p>数据的两个维度：</p>\n<ul>\n<li>记录（ record ） - 单个样本的细节。</li>\n<li>字段（ field ）、特征（ characteristic ）、变量（ variable\n），这三者都是一个东西。</li>\n</ul>\n<p><strong>统计上的分类：</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 11%\" />\n<col style=\"width: 88%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>变量类别</th>\n<th>类别含义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>分类变量</td>\n<td>由定性特征确定的分组情况，例如性别（男、女）或颜色（黄、红、蓝）。没有顺序和大小。</td>\n</tr>\n<tr class=\"even\">\n<td>二元变量</td>\n<td>仅由两种类别构成，例如“是/否”等一对反义词。又称为二分类变量。信用评分中目标变量大多是二分类变量，例如目标客户（好、坏）。</td>\n</tr>\n<tr class=\"odd\">\n<td>名义变量</td>\n<td>用标签（名字）或代码（字母/数字）表示的变量。没有顺序和大小。</td>\n</tr>\n<tr class=\"even\">\n<td>顺序变量</td>\n<td>只表示一个序列中的相对位置，不表示相对距离的大小，通常和主观评价有关，例如优秀、良好、一般、差。有顺序没有大小。</td>\n</tr>\n<tr class=\"odd\">\n<td>数值变量</td>\n<td>用整数或实数表示，有顺序有大小，能进行数值运算，比如年龄（整岁）。</td>\n</tr>\n<tr class=\"even\">\n<td>连续变量</td>\n<td>存在于连续的序列中，可能值的数量无限，存在最大值和最小值，用实数表示，例如温度、重量、距离和时间。</td>\n</tr>\n<tr class=\"odd\">\n<td>离散变量</td>\n<td>分离或者不连续的变量，用实数表示。并不代表没有顺序和大小。</td>\n</tr>\n<tr class=\"even\">\n<td>基数变量</td>\n<td>离散的，但特指一个集合内的数量。通常等价于离散变量。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>实践中的分类：</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 21%\" />\n<col style=\"width: 78%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>变量类别</th>\n<th>类别含义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>编码（名义）</td>\n<td>用符号或数字表现的类别。</td>\n</tr>\n<tr class=\"even\">\n<td>金额（近似连续）</td>\n<td>以货币金额表示的内容，例如余额、额度、交易额，可以计算总数、平均数、趋势、最小值、最大值、范围、极限等。</td>\n</tr>\n<tr class=\"odd\">\n<td>次数（离散）</td>\n<td>发生的数量，例如子女的数量（来自申请者）、逾期次数（来自贷款机构）、查询次数（来自征信机构）。</td>\n</tr>\n<tr class=\"even\">\n<td>比率（连续）</td>\n<td>两个数值相除的结果，最常用于按照规模对金额标准化，例如资产负债率。</td>\n</tr>\n<tr class=\"odd\">\n<td>时间（离散）</td>\n<td>距离某特定事件（账户开立、账户激活、某次评估）发生的时间，通常按天或月计算。</td>\n</tr>\n<tr class=\"even\">\n<td>分数（近似连续）</td>\n<td>表示未来某事件发生的概率（打分）。在一些情况下，一个分数可以用来计算另一个分数（比如通过第三方数据的评分卡制作内部的评分卡）。</td>\n</tr>\n<tr class=\"odd\">\n<td>等级（序数）</td>\n<td>和分数类似，不过它代表一个分数范围，或被主观确定。</td>\n</tr>\n</tbody>\n</table>\n<p>提到了变量处理的基础方法，主要分为两种：</p>\n<ul>\n<li>转换特征 - 比如 <code>birthday</code>\n本身可能并不能作为合适的特征使用，那么我们用某一时间（例如客户申请时间）减去出生日期换算成年就得到了\n<code>age</code> 这个特征。</li>\n<li>特征生成\n<ul>\n<li>多项式生成 - 生成交叉项，例如 <code>sklearn</code> 里的\n<code>PolynomialFeatures</code> 方法。</li>\n<li>计算比率 - 例如计算负债比。</li>\n</ul></li>\n</ul>\n<p><strong>特例（缺失值、异常值处理）：</strong></p>\n<ul>\n<li>数据缺失 -\n未找到（不清楚真实是否发生）、无记录（真实发生）、未发生（真实未发生）等。</li>\n<li>账户状态 -\n同一个特征里没有用相同单位，如一部分是值，一部分是字符。</li>\n<li>分母为零 - 除数不能为 0 ，这种情况可以用一个接近 0 的值代替。</li>\n<li>分母为负 - 计算比率或比例时，出现了分子分母同时为负的情况。</li>\n</ul>\n<p>对缺失值和异常值，一般用一个特殊编号来记录。</p>\n<h4 id=\"表格设计\">11.4.2 表格设计</h4>\n<blockquote>\n<p>收集数据的表格设计。</p>\n</blockquote>\n<p>最大的挑战在于尽可能获取更多地相关数据，但数据又不过量。</p>\n<p>表格的处理方式取决于表格设置的答案时定性的还是定量的。</p>\n<p><strong>数值结果</strong></p>\n<p>分为 3 种：</p>\n<ol type=\"1\">\n<li>数值本身。</li>\n<li>计算输入值。</li>\n<li>数值范围。</li>\n</ol>\n<p>例如不需要申请者填写年龄，直接填写年龄段和生日；金额上不填某段，填入具体的数值；负债收入比率不需要申请者计算，直接填入负债值和收入值。</p>\n<p><strong>分类结果</strong></p>\n<p>难点在于确定特征的选择范围。</p>\n<p>不是直接填空，而是一个选择范围的下拉菜单。</p>\n<p>将问题分为更多的维度，例如职业和教育的问题分为行业、工作层级、最高学历、就业现状等维度。</p>\n<h3 id=\"小结-9\">11.5 小结</h3>\n<p>这章探讨了数据透明度、数据数量、数据质量和设计相关方面的问题。目的就是为了提高数据透明度，正是因为数据透明度的提高使得贷款机构对客户有更多的了解，从而可以扩大贷款规模。</p>\n<h2 id=\"第-12-章---数据来源\">第 12 章 - 数据来源</h2>\n<h3 id=\"客户信息\">12.1 客户信息</h3>\n<h4 id=\"申请表\">12.1.1 申请表</h4>\n<h4 id=\"财务信息\">12.1.2 财务信息</h4>\n<h3 id=\"内部信息\">12.2 内部信息</h3>\n<h4 id=\"数据类型-2\">12.2.1 数据类型</h4>\n<h4 id=\"数据库类型\">12.2.2 数据库类型</h4>\n<h4 id=\"客户关系管理\">12.2.3 客户关系管理</h4>\n<h3 id=\"征信数据\">12.3 征信数据</h3>\n<h4 id=\"查询检索\">12.3.1 查询检索</h4>\n<h4 id=\"公共信息\">12.3.2 公共信息</h4>\n<h4 id=\"共享数据\">12.3.3 共享数据</h4>\n<h4 id=\"欺诈预警\">12.3.4 欺诈预警</h4>\n<h4 id=\"征信分数\">12.3.5 征信分数</h4>\n<h4 id=\"地理指标\">12.3.6 地理指标</h4>\n<h4 id=\"其他来源\">12.3.7 其他来源</h4>\n<h3 id=\"小结-10\">12.4 小结</h3>\n<h2 id=\"第-13-章---评分机构\">第 13 章 - 评分机构</h2>\n<h3 id=\"定制服务\">13.1 定制服务</h3>\n<h4 id=\"通用评分卡\">13.1.1 通用评分卡</h4>\n<h4 id=\"定制评分卡\">13.1.2 定制评分卡</h4>\n<h4 id=\"专家模型\">13.1.3 专家模型</h4>\n<h3 id=\"系统架设\">13.2 系统架设</h3>\n<h3 id=\"数据整合\">13.3 数据整合</h3>\n<h4 id=\"独立分数\">13.3.1 独立分数</h4>\n<h4 id=\"离散分数\">13.3.2 离散分数</h4>\n<h4 id=\"合并分数\">13.3.3 合并分数</h4>\n<h4 id=\"决策矩阵\">13.3.4 决策矩阵</h4>\n<h3 id=\"信用评分\">13.4 信用评分</h3>\n<h3 id=\"数据匹配\">13.5 数据匹配</h3>\n<h3 id=\"小结-11\">13.6 小结</h3>\n<h2 id=\"第-14-章---信息共享\">第 14 章 - 信息共享</h2>\n<h3 id=\"征信机构\">14.1 征信机构</h3>\n<h4 id=\"公共与民营\">14.1.1 公共与民营</h4>\n<h4 id=\"正面信息与负面信息\">14.1.2 正面信息与负面信息</h4>\n<h3 id=\"参与合作\">14.2 参与合作</h3>\n<h4 id=\"互惠原则\">14.2.1 互惠原则</h4>\n<h4 id=\"促进因素\">14.2.2 促进因素</h4>\n<h4 id=\"阻碍因素\">14.2.3 阻碍因素</h4>\n<h3 id=\"小结-12\">14.3 小结</h3>\n<h2 id=\"第-15-章---数据准备\">第 15 章 - 数据准备</h2>\n<h3 id=\"数据获取\">15.1 数据获取</h3>\n<h4 id=\"申请数据\">15.1.1 申请数据</h4>\n<h4 id=\"征信数据-1\">15.1.2 征信数据</h4>\n<h4 id=\"观测数据\">15.1.3 观测数据</h4>\n<h4 id=\"表现数据\">15.1.4 表现数据</h4>\n<h4 id=\"数据整合-1\">15.1.5 数据整合</h4>\n<h3 id=\"好坏定义\">15.2 好坏定义</h3>\n<p>作者强调了好坏定义的重要性，提到了<strong>好坏定义是建模过程中仅次于数据的重要因素，用来设定目标变量。</strong></p>\n<figure>\n<img\nsrc=\"https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206201247059.png\"\nalt=\"好坏定义\" />\n<figcaption aria-hidden=\"true\">好坏定义</figcaption>\n</figure>\n<h4 id=\"选择状态\">15.2.1 选择状态</h4>\n<p>指观测期的状态，分为以下4类：</p>\n<ul>\n<li>排除 -\n如果某个子群体的分数不影响对其决策，作者建议排除。和拒绝不一样的地方是这类样本不需要做拒绝推断。</li>\n<li>拒绝 - 出于政策规则或者决策规则的样本不需要做拒绝推断。</li>\n<li>未采用 -\n客户没有接受贷款机构提供的贷款合同，也就是准入了但未做成。可能是价格、利率、合同条款让客户觉得不适。</li>\n<li>双方接受 - 只有这类样本会有真实的表现。</li>\n</ul>\n<h4 id=\"表现状态\">15.2.2 表现状态</h4>\n<p>指表现期的状态，分为以下4类：</p>\n<ul>\n<li><p>排除 -\n评分卡计划目标之外的结果，比如申请评分卡中出现了欺诈行为或客户去世。这类占比不宜超过总体的\n3%。</p></li>\n<li><p>不定 - 指灰样本，申请评分卡的不定率应设定在\n5%~15%，行为评分卡的不定率设定在 10%~20%。这里提到设定灰样本有 3\n个理由。</p>\n<ul>\n<li>技术逾期造成的疑似不良行为 - 我觉得应该是指像美国 ACH\n那样的延时得知交易结果的支付方式对标签定义的影响。</li>\n<li>公司策略</li>\n<li>使好坏定义更加清晰。</li>\n</ul>\n<p>这里也讨论了关于提前还款的人是好样本还是不定样本。这类人是可以当作好样本建模的。</p></li>\n<li><p>好样本 - 我们表示欢迎的样本。</p></li>\n<li><p>坏样本 - 我们表示回避的样本。</p></li>\n</ul>\n<h4 id=\"当前状态和最坏状态\">15.2.3 当前状态和最坏状态</h4>\n<p>当前状态和最坏状态是指用结果时点的状态（当前状态）还是整个结果期最坏的状态（最坏状态）来确定“不可恢复点”（\npoint of no return ），也就是去找出账户不会再从坏变好的时间点。</p>\n<p>行为评分中，巴塞尔协议 II 要求使用 90\n天内最坏最坏状态的定义。申请评分中两种方式都可以。使用当前状态可以确保误判和由坏变好的账户不会被误判，使用最坏状态则对可能是坏的账户更加敏感。</p>\n<p>一般情况下，当前状态的常见定义是逾期 60 天，最坏状态的定义是逾期 90\n天。</p>\n<h4 id=\"定义设定\">15.2.4 定义设定</h4>\n<p>定义有 3 种方式：</p>\n<ul>\n<li>共识 - 内部专家经验判断。</li>\n<li>规定 -\n由外部机构设定，确保一致性。（这个主要是方便供别人参考吧）</li>\n<li>经验（原文应该是 experience\n，我个人觉得翻译成<strong>历史</strong>更合适） -\n根据自身的历史数据实证分析。提到了滚动率分析，不过并没有讲具体怎么做。</li>\n</ul>\n<h4 id=\"好坏定义标准\">15.2.5 好坏定义标准</h4>\n<p>讲到好坏定义需要符合 3\n个特点：<strong>相关、充足、透明。</strong></p>\n<h3 id=\"时间窗口\">15.3 时间窗口</h3>\n<p>时间窗口组成有一些相关概念，这里讲到了：</p>\n<ul>\n<li>观测（ observation ） - 指对数据进行观测，作为预测变量。</li>\n<li>结果（ outcome ） - 指分析数据观测的结果，确定目标。</li>\n<li>日期/月份 - 指信息采集的时间。</li>\n<li>窗口（ window ） - 指一段时间。</li>\n</ul>\n<p>这些概念的组合就跟时间窗口有很密切的关系了：</p>\n<ul>\n<li><p>观测期（ observation window ） -\n也叫观察期，指观测点之前的一段时间。</p></li>\n<li><p>观测日期（ observation date ） -\n也叫观测点，位于观测期与表现期之间，指采集数据的日期。</p></li>\n<li><p>结果期 （ outcome window ） -\n也叫表现期，客户表现趋于成熟的时间段。</p></li>\n<li><p>结果日期（ outcome date ） - 指同一样本表现结果的日期。</p></li>\n</ul>\n<p>这两个窗口非常重要，<strong>观测期用于收集用户数据</strong>，例如银行流水等信息，<strong>观测期太短可能会导致变量预测效果不佳</strong>；<strong>表现期用于评价模型的标签（\nY\n）多久之后趋于稳定</strong>，随着时间的累加，违约率会增加但是边际增长率降低，<strong>表现期太短可能会存在坏客户风险暴露不充分这样的情况</strong>。在选择合适的观测期与表现期时，需要考虑<strong>账户成熟、样本信息缺失、数据老化</strong>三个因素。</p>\n<h3 id=\"样本设计\">15.4 样本设计</h3>\n<h4 id=\"样本类型\">15.4.1 样本类型</h4>\n<h4 id=\"最大和最小样本量\">15.4.2 最大和最小样本量</h4>\n<h4 id=\"分层随机抽样\">15.4.3 分层随机抽样</h4>\n<h3 id=\"小结-13\">15.5 小结</h3>\n<h1 id=\"第五部分---评分卡开发\">第五部分 - 评分卡开发</h1>\n<h2 id=\"第-16-章---变量转换\">第 16 章 - 变量转换</h2>\n<h3 id=\"转换方法\">16.1 转换方法</h3>\n<h4 id=\"虚拟变量\">16.1.1 虚拟变量</h4>\n<h4 id=\"风险变量\">16.1.2 风险变量</h4>\n<h4 id=\"方法选择\">16.1.3 方法选择</h4>\n<h3 id=\"粗细分类\">16.2 粗细分类</h3>\n<h4 id=\"特征分析报告-1\">16.2.1 特征分析报告</h4>\n<h4 id=\"细分类\">16.2.2 细分类</h4>\n<h4 id=\"粗分类\">16.2.3 粗分类</h4>\n<h3 id=\"统计量的应用\">16.3 统计量的应用</h3>\n<h4 id=\"预测能力测度\">16.3.1 预测能力测度</h4>\n<h4 id=\"粗分类例子\">16.3.2 粗分类例子</h4>\n<h3 id=\"池化算法\">16.4 池化算法</h3>\n<h4 id=\"非邻池化\">16.4.1 非邻池化</h4>\n<h4 id=\"相邻池化\">16.4.2 相邻池化</h4>\n<h4 id=\"单调相邻池化\">16.4.3 单调相邻池化</h4>\n<h3 id=\"实际案例\">16.5 实际案例</h3>\n<h4 id=\"法院判决\">16.5.1 法院判决</h4>\n<h4 id=\"行业种类\">16.5.2 行业种类</h4>\n<h4 id=\"职业种类\">16.5.3 职业种类</h4>\n<h3 id=\"小结-14\">16.6 小结</h3>\n<h2 id=\"第-17-章---特征选取\">第 17 章 - 特征选取</h2>\n<h3 id=\"参考因素\">17.1 参考因素</h3>\n<h3 id=\"预测能力\">17.2 预测能力</h3>\n<h3 id=\"降维方法\">17.3 降维方法</h3>\n<h4 id=\"建模处理\">17.3.1 建模处理</h4>\n<h4 id=\"相关矩阵\">17.3.2 相关矩阵</h4>\n<h4 id=\"因子分析-1\">17.3.3 因子分析</h4>\n<h3 id=\"变量输入\">17.4 变量输入</h3>\n<h4 id=\"分步\">17.4.1 分步</h4>\n<h4 id=\"分块\">17.4.2 分块</h4>\n<h3 id=\"小结-15\">17.5 小结</h3>\n<h2 id=\"第-18-章---样本分层\">第 18 章 - 样本分层</h2>\n<h3 id=\"驱动因素\">18.1 驱动因素</h3>\n<h3 id=\"识别交叉的作用\">18.2 识别交叉的作用</h3>\n<h3 id=\"处理交叉的作用\">18.3 处理交叉的作用</h3>\n<h3 id=\"小结-16\">18.4 小结</h3>\n<h2 id=\"第-19-章---拒绝推断\">第 19 章 - 拒绝推断</h2>\n<h3 id=\"推断原理\">19.1 推断原理</h3>\n<h3 id=\"总体流动\">19.2 总体流动</h3>\n<h3 id=\"表现赋值\">19.3 表现赋值</h3>\n<h3 id=\"特殊类别\">19.4 特殊类别</h3>\n<h3 id=\"推断方法\">19.5 推断方法</h3>\n<h4 id=\"随机补充\">19.5.1 随机补充</h4>\n<h4 id=\"展开法\">19.5.2 展开法</h4>\n<h4 id=\"外推法\">19.5.3 外推法</h4>\n<h4 id=\"同生表现法\">19.5.4 同生表现法</h4>\n<h3 id=\"小结-17\">19.6 小结</h3>\n<h2 id=\"第-20-章---模型校准\">第 20 章 - 模型校准</h2>\n<h3 id=\"分数分段\">20.1 分数分段</h3>\n<h4 id=\"ch-统计量\">20.1.1 CH 统计量</h4>\n<h4 id=\"基准方法\">20.1.2 基准方法</h4>\n<h4 id=\"边际风险边界\">20.1.3 边际风险边界</h4>\n<h3 id=\"线性变换\">20.2 线性变换</h3>\n<h4 id=\"线性变动\">20.2.1 线性变动</h4>\n<h4 id=\"比率缩放\">20.2.2 比率缩放</h4>\n<h3 id=\"线性规划重构\">20.3 线性规划重构</h3>\n<h3 id=\"小结-18\">20.4 小结</h3>\n<h2 id=\"第-21-章---检验交付\">第 21 章 - 检验交付</h2>\n<h3 id=\"组成成分\">21.1 组成成分</h3>\n<h4 id=\"开发依据\">21.1.1 开发依据</h4>\n<h4 id=\"持续检验\">21.1.2 持续检验</h4>\n<h4 id=\"回溯测试\">21.1.3 回溯测试</h4>\n<h3 id=\"差别效果\">21.2 差别效果</h3>\n<h3 id=\"小结-19\">21.3 小结</h3>\n<h2 id=\"第-22-章---开发管理\">第 22 章 - 开发管理</h2>\n<h3 id=\"进程安排\">22.1 进程安排</h3>\n<h3 id=\"高效操作\">22.2 高效操作</h3>\n<h4 id=\"重复利用\">22.2.1 重复利用</h4>\n<h4 id=\"重新建模\">22.2.2 重新建模</h4>\n<h3 id=\"小结-20\">22.3 小结</h3>\n<h1 id=\"第六部分---实施和使用\">第六部分 - 实施和使用</h1>\n<h2 id=\"第-23-章---实施安装\">第 23 章 - 实施安装</h2>\n<h3 id=\"自动化决策\">23.1 自动化决策</h3>\n<h4 id=\"自动化程度\">23.1.1 自动化程度</h4>\n<h4 id=\"职责\">23.1.2 职责</h4>\n<h4 id=\"员工沟通\">23.1.3 员工沟通</h4>\n<h4 id=\"客户教育\">23.1.4 客户教育</h4>\n<h3 id=\"安装和测试\">23.2 安装和测试</h3>\n<h4 id=\"数据资源和切换\">23.2.1 数据、资源和切换</h4>\n<h4 id=\"测试\">23.2.2 测试</h4>\n<h3 id=\"小结-21\">23.3 小结</h3>\n<h2 id=\"第-24-章---管理控制\">第 24 章 - 管理控制</h2>\n<h3 id=\"政策规则\">24.1 政策规则</h3>\n<h3 id=\"撤销\">24.2 撤销</h3>\n<h3 id=\"移交\">24.3 移交</h3>\n<h4 id=\"信息验证\">24.3.1 信息验证</h4>\n<h4 id=\"账户情况\">24.3.2 账户情况</h4>\n<h3 id=\"控制\">24.4 控制</h3>\n<h4 id=\"竞争环境\">24.4.1 竞争环境</h4>\n<h4 id=\"评分及策略控制\">24.4.2 评分及策略控制</h4>\n<h4 id=\"撤销控制\">24.4.3 撤销控制</h4>\n<h3 id=\"小结-22\">24.5 小结</h3>\n<h2 id=\"第-25-章---跟踪监控\">第 25 章 - 跟踪监控</h2>\n<h3 id=\"组合分析\">25.1 组合分析</h3>\n<h4 id=\"逾期分布\">25.1.1 逾期分布</h4>\n<h4 id=\"转移矩阵\">25.1.2 转移矩阵</h4>\n<h3 id=\"表现跟踪\">25.2 表现跟踪</h3>\n<h4 id=\"模型表现\">25.2.1 模型表现</h4>\n<h4 id=\"账龄分析\">25.2.2 账龄分析</h4>\n<h4 id=\"分数错配\">25.2.3 分数错配</h4>\n<h3 id=\"偏移报告\">25.3 偏移报告</h3>\n<h4 id=\"总体稳定性报告\">25.3.1 总体稳定性报告</h4>\n<h4 id=\"分数偏移报告\">25.3.2 分数偏移报告</h4>\n<h4 id=\"特征分析\">25.3.3 特征分析</h4>\n<h3 id=\"选择过程\">25.4 选择过程</h3>\n<h4 id=\"决策过程\">25.4.1 决策过程</h4>\n<h4 id=\"分数决策\">25.4.2 分数决策</h4>\n<h4 id=\"政策规则-1\">25.4.3 政策规则</h4>\n<h4 id=\"人为撤销\">25.4.4 人为撤销</h4>\n<h3 id=\"小结-23\">25.5 小结</h3>\n<h2 id=\"第-26-章---金融财务\">第 26 章 - 金融财务</h2>\n<h3 id=\"坏账准备\">26.1 坏账准备</h3>\n<h3 id=\"直接损失估计\">26.2 直接损失估计</h3>\n<h4 id=\"净流量法\">26.2.1 净流量法</h4>\n<h4 id=\"转移矩阵法\">26.2.2 转移矩阵法</h4>\n<h3 id=\"损失估计\">26.3 损失估计</h3>\n<h4 id=\"损失概率\">26.3.1 损失概率</h4>\n<h4 id=\"损失程度\">26.3.2 损失程度</h4>\n<h4 id=\"预测分析\">26.3.3 预测分析</h4>\n<h3 id=\"利润模型\">26.4 利润模型</h3>\n<h4 id=\"利润来源\">26.4.1 利润来源</h4>\n<h4 id=\"利润决策\">26.4.2 利润决策</h4>\n<h4 id=\"利润评分\">26.4.3 利润评分</h4>\n<h3 id=\"风险定价\">26.5 风险定价</h3>\n<h4 id=\"理论实践\">26.5.1 理论实践</h4>\n<h4 id=\"行为变化\">26.5.2 行为变化</h4>\n<h4 id=\"战略考虑\">26.5.3 战略考虑</h4>\n<h4 id=\"客户影响\">26.5.4 客户影响</h4>\n<h3 id=\"小结-24\">26.6 小结</h3>\n<h1 id=\"第七部分---信用风险管理周期\">第七部分 - 信用风险管理周期</h1>\n<h2 id=\"第-27-章---市场营销\">第 27 章 - 市场营销</h2>\n<h3 id=\"广告媒体\">27.1 广告媒体</h3>\n<h3 id=\"数量与质量\">27.2 数量与质量</h3>\n<h3 id=\"初步筛选\">27.3 初步筛选</h3>\n<h3 id=\"市场数据\">27.4 市场数据</h3>\n<h3 id=\"小结-25\">27.5 小结</h3>\n<h2 id=\"第-28-章---申请审批\">第 28 章 - 申请审批</h2>\n<h3 id=\"收集潜在客户信息\">28.1 收集潜在客户信息</h3>\n<h4 id=\"获取申请信息\">28.1.1 获取申请信息</h4>\n<h4 id=\"纸质数据采集\">28.1.2 纸质数据采集</h4>\n<h4 id=\"初筛和清洗\">28.1.3 初筛和清洗</h4>\n<h3 id=\"策略分类\">28.2 策略分类</h3>\n<h3 id=\"决策执行\">28.3 决策执行</h3>\n<h4 id=\"拒绝\">28.3.1 拒绝</h4>\n<h4 id=\"接受\">28.3.2 接受</h4>\n<h3 id=\"小结-26\">28.4 小结</h3>\n<h2 id=\"第-29-章---账户管理\">第 29 章 - 账户管理</h2>\n<h3 id=\"额度类型\">29.1 额度类型</h3>\n<h3 id=\"超额管理\">29.2 超额管理</h3>\n<h4 id=\"支票账户\">29.2.1 支票账户</h4>\n<h4 id=\"信用卡授权\">29.2.2 信用卡授权</h4>\n<h4 id=\"客户知情效应\">29.2.3 客户知情效应</h4>\n<h3 id=\"更多限额和其他功能\">29.3 更多限额和其他功能</h3>\n<h4 id=\"提额请求\">29.3.1 提额请求</h4>\n<h4 id=\"提高额度\">29.3.2 提高额度</h4>\n<h4 id=\"额度复核\">29.3.3 额度复核</h4>\n<h4 id=\"交叉销售\">29.3.4 交叉销售</h4>\n<h4 id=\"重获客户\">29.3.5 重获客户</h4>\n<h3 id=\"小结-27\">29.4 小结</h3>\n<h2 id=\"第-30-章---催收回收\">第 30 章 - 催收回收</h2>\n<h3 id=\"概述\">30.1 概述</h3>\n<h3 id=\"时机策略\">30.2 时机策略</h3>\n<h3 id=\"催收评分\">30.3 催收评分</h3>\n<h3 id=\"小结-28\">30.4 小结</h3>\n<h2 id=\"第-31-章---欺诈防范\">第 31 章 - 欺诈防范</h2>\n<h3 id=\"欺诈类型\">31.1 欺诈类型</h3>\n<h3 id=\"欺诈侦测工具\">31.2 欺诈侦测工具</h3>\n<h3 id=\"欺诈防范策略\">31.3 欺诈防范策略</h3>\n<h3 id=\"欺诈评分\">31.4 欺诈评分</h3>\n<h3 id=\"小结-29\">31.5 小结</h3>\n<h1 id=\"第八部分---监管环境\">第八部分 - 监管环境</h1>\n<h2 id=\"第-32-章---监管理念\">第 32 章 - 监管理念</h2>\n<h3 id=\"最佳实践\">32.1 最佳实践</h3>\n<h3 id=\"善良治理\">32.2 善良治理</h3>\n<h3 id=\"商业道德和社会责任\">32.3 商业道德和社会责任</h3>\n<h3 id=\"合规等级\">32.4 合规等级</h3>\n<h3 id=\"小结-30\">32.5 小结</h3>\n<h2 id=\"第-33-章---隐私保护\">第 33 章 - 隐私保护</h2>\n<h3 id=\"背景\">33.1 背景</h3>\n<h4 id=\"历史概况\">33.1.1 历史概况</h4>\n<h4 id=\"tournier-案件\">33.1.2 Tournier 案件</h4>\n<h4 id=\"oecd-数据隐私指引\">33.1.3 OECD 数据隐私指引</h4>\n<h4 id=\"欧洲理事会公约\">33.1.4 欧洲理事会公约</h4>\n<h4 id=\"欧盟数据保护指令\">33.1.5 欧盟数据保护指令</h4>\n<h4 id=\"特殊情况\">33.1.6 特殊情况</h4>\n<h3 id=\"原则\">33.2 原则</h3>\n<h4 id=\"收集方式\">33.2.1 收集方式</h4>\n<h4 id=\"合理目的\">33.2.2 合理目的</h4>\n<h4 id=\"信息质量\">33.2.3 信息质量</h4>\n<h4 id=\"信息使用\">33.2.4 信息使用</h4>\n<h4 id=\"信息披露\">33.2.5 信息披露</h4>\n<h4 id=\"主体权利\">33.2.6 主体权利</h4>\n<h4 id=\"信息安全\">33.2.7 信息安全</h4>\n<h3 id=\"小结-31\">33.3 小结</h3>\n<h2 id=\"第-34-章---禁止歧视\">第 34 章 - 禁止歧视</h2>\n<h3 id=\"何为歧视\">34.1 何为歧视</h3>\n<h3 id=\"存疑特征\">34.2 存疑特征</h3>\n<h3 id=\"小结-32\">34.3 小结</h3>\n<h2 id=\"第-35-章---公平信贷\">第 35 章 - 公平信贷</h2>\n<h3 id=\"掠夺性放贷\">35.1 掠夺性放贷</h3>\n<h3 id=\"不负责放贷\">35.2 不负责放贷</h3>\n<h3 id=\"负责任放贷\">35.3 负责任放贷</h3>\n<h3 id=\"小结-33\">35.4 小结</h3>\n<h2 id=\"第-36-章---资本要求\">第 36 章 - 资本要求</h2>\n<h3 id=\"巴塞尔协议-i\">36.1 巴塞尔协议 I</h3>\n<h3 id=\"巴塞尔协议-ii\">36.2 巴塞尔协议 II</h3>\n<h4 id=\"标准法\">36.2.1 标准法</h4>\n<h4 id=\"内部评级法\">36.2.2 内部评级法</h4>\n<h4 id=\"风险暴露类别\">36.2.3 风险暴露类别</h4>\n<h4 id=\"违约定义\">36.2.4 违约定义</h4>\n<h4 id=\"评级意义\">36.2.5 评级意义</h4>\n<h4 id=\"执行问题\">36.2.6 执行问题</h4>\n<h3 id=\"风险加权资产的计算\">36.3 风险加权资产的计算</h3>\n<h3 id=\"小结-34\">36.4 小结</h3>\n<h2 id=\"第-37-章---了解客户\">第 37 章 - 了解客户</h2>\n<h3 id=\"尽职调查要求\">37.1 尽职调查要求</h3>\n<h3 id=\"客户身份识别要求\">37.2 客户身份识别要求</h3>\n<h2 id=\"第-38-章---国家差异\">第 38 章 - 国家差异</h2>\n<p>国家差异汇总表：</p>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 35%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 8%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 8%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>美国</th>\n<th>加拿大</th>\n<th>英国</th>\n<th>澳大利亚</th>\n<th>南非</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>背景情况</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>个人识别码</td>\n<td>SSN</td>\n<td>SIN</td>\n<td>无</td>\n<td>SSN</td>\n<td>ID</td>\n</tr>\n<tr class=\"odd\">\n<td>支付档案名称</td>\n<td>共享信息</td>\n<td>正面信息</td>\n<td>白色数据 /CAIS</td>\n<td>无</td>\n<td>支付档案</td>\n</tr>\n<tr class=\"even\">\n<td>负债占国民净生产总值的比例（1999）</td>\n<td>16.1</td>\n<td>14.4</td>\n<td>5.7</td>\n<td>7.7</td>\n<td>未知</td>\n</tr>\n<tr class=\"odd\">\n<td>征信机构</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>民营征信机构（1999）</td>\n<td>19 世纪 90 年代</td>\n<td>1919 年</td>\n<td>20 世纪 60 年代</td>\n<td>20 世纪 30 年代</td>\n<td>1901年</td>\n</tr>\n<tr class=\"odd\">\n<td>TransUnion</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>其他机构</td>\n<td>有</td>\n</tr>\n<tr class=\"even\">\n<td>Equifax</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>其他机构</td>\n<td>无</td>\n</tr>\n<tr class=\"odd\">\n<td>Experian</td>\n<td>有</td>\n<td>无</td>\n<td>有</td>\n<td>其他机构</td>\n<td>有</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"美国\">38.1 美国</h3>\n<p>美国是最早设立法律影响信用评分的国家。</p>\n<p><a\nhref=\"https://www.ftc.gov/legal-library/browse/statutes/fair-credit-reporting-act\">《公平信用报告法》（\nFair Credit Reporting Act ）</a></p>\n<p>保证了数据的隐私和准确，限制征信机构只能用与信用相关的信息，包括正面信息。</p>\n<p><a\nhref=\"https://www.ftc.gov/legal-library/browse/statutes/equal-credit-opportunity-act\">《平等信贷机会法》（Equal\nCredit Opportunity Act）</a></p>\n<p>反对消费信贷歧视，包括申请者的种族、肤色、信仰、国籍、性别、婚姻、年龄或接受公共援助资助信息。</p>\n<p>对于年龄这个特征，只要不歧视老年人就可以使用。</p>\n<p>贷款机构需要向被拒的申请人提供拒绝的明确原因。</p>\n<h3 id=\"加拿大\">38.2 加拿大</h3>\n<h3 id=\"英国\">38.3 英国</h3>\n<h3 id=\"澳大利亚\">38.4 澳大利亚</h3>\n<h3 id=\"南非\">38.5 南非</h3>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl6p7t1f70001142p0a3f54zh","category_id":"cl6p7t1fb0003142pepxm0lu6","_id":"cl6p7t1fq000w142pb4ajgb2z"},{"post_id":"cl6p7t1f70001142p0a3f54zh","category_id":"cl6p7t1fm000m142pbkb05jlc","_id":"cl6p7t1fr0010142pb5udec52"},{"post_id":"cl6p7t1ga002v142p6sorc1og","category_id":"cl6p7t1fb0003142pepxm0lu6","_id":"cl6p7t1gc0034142p5szc72b2"},{"post_id":"cl6p7t1ga002v142p6sorc1og","category_id":"cl6p7t1fm000m142pbkb05jlc","_id":"cl6p7t1gc0036142p9kydfzwp"},{"post_id":"cl6p7t1fq000y142pg2oibxzm","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gd003i142p13bsed4w"},{"post_id":"cl6p7t1fq000y142pg2oibxzm","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gd003k142pa1lih0mx"},{"post_id":"cl6p7t1fq000y142pg2oibxzm","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1ge003o142pbf2o3v1f"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1ge003q142p8mkj24p3"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gf003u142p4wjk2tvc"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gf003w142p95kldzp9"},{"post_id":"cl6p7t1fr0012142pb2f447tz","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gf003z142p68i0a7dx"},{"post_id":"cl6p7t1fr0012142pb2f447tz","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gf0042142paaoc66ti"},{"post_id":"cl6p7t1fr0012142pb2f447tz","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gg0045142p50z0f4si"},{"post_id":"cl6p7t1fs0015142pheqmdiox","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gg0048142p5de3halg"},{"post_id":"cl6p7t1fs0015142pheqmdiox","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gg004a142pgoclgxcy"},{"post_id":"cl6p7t1fs0015142pheqmdiox","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gh004c142p9xgzhn42"},{"post_id":"cl6p7t1f90002142p1k2iedks","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gh004e142p9uwad380"},{"post_id":"cl6p7t1f90002142p1k2iedks","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gh004g142pcpehhol2"},{"post_id":"cl6p7t1f90002142p1k2iedks","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gi004j142peq80gbyz"},{"post_id":"cl6p7t1fu0018142p3643fh9y","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gi004m142pduj56nyn"},{"post_id":"cl6p7t1fu0018142p3643fh9y","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gi004p142p2uai904t"},{"post_id":"cl6p7t1fu0018142p3643fh9y","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gj004s142ph132cjdd"},{"post_id":"cl6p7t1fv001b142p7vvjc83p","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gj004v142p9whohlbg"},{"post_id":"cl6p7t1fv001b142p7vvjc83p","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gj004y142p51oh3i2k"},{"post_id":"cl6p7t1fv001b142p7vvjc83p","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gk0051142pfbnre63l"},{"post_id":"cl6p7t1fg000b142p5lnucq4n","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gk0054142pgsu75o3n"},{"post_id":"cl6p7t1fg000b142p5lnucq4n","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gk0057142pcj3i8tim"},{"post_id":"cl6p7t1fg000b142p5lnucq4n","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gl0059142pd0vc5xmg"},{"post_id":"cl6p7t1fw001e142peby5at6x","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gl005d142p0jf39vx2"},{"post_id":"cl6p7t1fw001e142peby5at6x","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gm005f142pfmcnfsz8"},{"post_id":"cl6p7t1fw001e142peby5at6x","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gm005j142p5vk67528"},{"post_id":"cl6p7t1fx001h142p6la62cyr","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gm005l142phgym7izj"},{"post_id":"cl6p7t1fx001h142p6la62cyr","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gn005p142pgvwsa0rn"},{"post_id":"cl6p7t1fx001h142p6la62cyr","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gn005r142p5akm4wz9"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1go005v142pd5if608x"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1go005x142pgoe22ou9"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gp0061142p3xwn2xo8"},{"post_id":"cl6p7t1fy001k142p53ou14oe","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gq0063142pdf5g2t38"},{"post_id":"cl6p7t1fy001k142p53ou14oe","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gr0067142p12yd8rd4"},{"post_id":"cl6p7t1fy001k142p53ou14oe","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gr0069142p731ibnz2"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gs006d142p1g1j598a"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gs006f142p1zdmd385"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gs006i142pdgj6c449"},{"post_id":"cl6p7t1fc0005142pfknr6b2u","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gu006k142p8qbg0bi5"},{"post_id":"cl6p7t1fc0005142pfknr6b2u","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gu006o142p2rxq9zan"},{"post_id":"cl6p7t1fc0005142pfknr6b2u","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gv006q142p8m171zzj"},{"post_id":"cl6p7t1fz001q142pgx965qz2","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gv006u142pclqe4s17"},{"post_id":"cl6p7t1fz001q142pgx965qz2","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gw006w142pbcrp9cn5"},{"post_id":"cl6p7t1fz001q142pgx965qz2","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gw006z142p6yqmav34"},{"post_id":"cl6p7t1g0001t142p4jo1ar80","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gw0072142p2wjda2ik"},{"post_id":"cl6p7t1g0001t142p4jo1ar80","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gx0075142peo810qaf"},{"post_id":"cl6p7t1g0001t142p4jo1ar80","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gx0078142p88c43w16"},{"post_id":"cl6p7t1fj000g142p4gvo5k9v","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gx007b142p7dnd8qcp"},{"post_id":"cl6p7t1fj000g142p4gvo5k9v","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gy007e142p4thj08ky"},{"post_id":"cl6p7t1fj000g142p4gvo5k9v","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gy007h142p9jce52zz"},{"post_id":"cl6p7t1g1001w142pb9jicoy4","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1gz007k142pawen011r"},{"post_id":"cl6p7t1g1001w142pb9jicoy4","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1gz007n142p429p1l4t"},{"post_id":"cl6p7t1g1001w142pb9jicoy4","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1gz007q142par117q51"},{"post_id":"cl6p7t1g2001z142p27yi5spo","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h0007t142ph63fhou0"},{"post_id":"cl6p7t1g2001z142p27yi5spo","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h0007w142pf6j8edc9"},{"post_id":"cl6p7t1g2001z142p27yi5spo","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h0007z142p9fkd06m9"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h10082142p5aoy7myz"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h10085142p2vlv5pn0"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h20088142phuqr5lzb"},{"post_id":"cl6p7t1g30022142p44aodmro","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h2008b142p5r4w1wym"},{"post_id":"cl6p7t1g30022142p44aodmro","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h3008e142p2zg3gilt"},{"post_id":"cl6p7t1g30022142p44aodmro","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h3008h142p7l8o7xb8"},{"post_id":"cl6p7t1g30025142p5z4na6d7","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h3008k142p01c3e1nb"},{"post_id":"cl6p7t1g30025142p5z4na6d7","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h4008n142pez2zfc19"},{"post_id":"cl6p7t1g30025142p5z4na6d7","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h4008q142pfsep87oq"},{"post_id":"cl6p7t1fd0006142pfo9l39uz","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h4008t142p1xvca7tx"},{"post_id":"cl6p7t1fd0006142pfo9l39uz","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h5008v142pbmu31l0o"},{"post_id":"cl6p7t1fd0006142pfo9l39uz","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h5008z142p13y55f2s"},{"post_id":"cl6p7t1g40028142pe5zzaf85","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h50091142pddfhhz30"},{"post_id":"cl6p7t1g40028142pe5zzaf85","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h60093142peh1zadmj"},{"post_id":"cl6p7t1g40028142pe5zzaf85","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h60095142p545b2tf6"},{"post_id":"cl6p7t1g5002b142p12p6hauh","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h60097142p9nvnb77p"},{"post_id":"cl6p7t1g5002b142p12p6hauh","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h60099142p11fd9w19"},{"post_id":"cl6p7t1g5002b142p12p6hauh","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h6009b142pf0060zaj"},{"post_id":"cl6p7t1fm000l142p3box2n1d","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h6009d142p0lw3fl30"},{"post_id":"cl6p7t1fm000l142p3box2n1d","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h6009f142p12zdb4tm"},{"post_id":"cl6p7t1fm000l142p3box2n1d","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h6009h142pdzs7hcyr"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h6009j142pa8ro84mc"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h6009l142pgr3vd6rc"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h6009n142pam6ubao1"},{"post_id":"cl6p7t1g6002h142p3h33bvl1","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h6009o142p99lb97tw"},{"post_id":"cl6p7t1g6002h142p3h33bvl1","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h6009p142p7ersdlw9"},{"post_id":"cl6p7t1g6002h142p3h33bvl1","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h6009q142p0u6c0qhw"},{"post_id":"cl6p7t1fn000o142p7ce4035g","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h6009r142pd6ubax2w"},{"post_id":"cl6p7t1fn000o142p7ce4035g","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h7009s142p8fb097nb"},{"post_id":"cl6p7t1fn000o142p7ce4035g","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h7009t142pfm5a1ssw"},{"post_id":"cl6p7t1g7002k142phd9ibjp1","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h7009u142pc5pvfa0t"},{"post_id":"cl6p7t1g7002k142phd9ibjp1","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h7009v142p8rjy99kb"},{"post_id":"cl6p7t1g7002k142phd9ibjp1","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h7009w142pgykf9gzg"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h7009x142pff3kbqn1"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h7009y142p5n05538b"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h7009z142pho25ayoa"},{"post_id":"cl6p7t1fn000p142p3nhzc2c9","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h700a0142pc3fi5igb"},{"post_id":"cl6p7t1fn000p142p3nhzc2c9","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h700a1142p7ccu4eo2"},{"post_id":"cl6p7t1fn000p142p3nhzc2c9","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h700a2142p8gu6g42d"},{"post_id":"cl6p7t1g8002p142p4wqc4b3a","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h700a3142p0sgj41qs"},{"post_id":"cl6p7t1g8002p142p4wqc4b3a","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h700a4142p6rn3dqgg"},{"post_id":"cl6p7t1g8002p142p4wqc4b3a","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h700a5142pfstk5srz"},{"post_id":"cl6p7t1g9002t142phpivdjkm","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h700a6142p2bcvd63e"},{"post_id":"cl6p7t1g9002t142phpivdjkm","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h700a7142pbl7aafcd"},{"post_id":"cl6p7t1g9002t142phpivdjkm","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h700a8142p5och5s55"},{"post_id":"cl6p7t1fo000r142p5vzmgi25","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h700a9142p60l0e3z5"},{"post_id":"cl6p7t1fo000r142p5vzmgi25","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h700aa142p5pqm7j5e"},{"post_id":"cl6p7t1fo000r142p5vzmgi25","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h700ab142phvgtfou1"},{"post_id":"cl6p7t1fe0007142pclulf23e","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h700ac142pd5fe4pfd"},{"post_id":"cl6p7t1fe0007142pclulf23e","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h700ad142pfr4j0myq"},{"post_id":"cl6p7t1fe0007142pclulf23e","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h700ae142p8uw269g8"},{"post_id":"cl6p7t1fp000u142p7lh357qm","category_id":"cl6p7t1ff0008142pebyn8cgn","_id":"cl6p7t1h700af142p4cad25yx"},{"post_id":"cl6p7t1fp000u142p7lh357qm","category_id":"cl6p7t1fq000v142p91vk9g51","_id":"cl6p7t1h800ag142p12nva293"},{"post_id":"cl6p7t1fp000u142p7lh357qm","category_id":"cl6p7t1gc0038142pcbfpbk3s","_id":"cl6p7t1h800ah142p8jryg17y"},{"post_id":"cl6p7t1hb00aj142pde627dsw","category_id":"cl6p7t1hc00an142pbf36hx6j","_id":"cl6p7t1hd00as142pe7x55oof"},{"post_id":"cl6p7t1ha00ai142pf1yjdths","category_id":"cl6p7t1hb00ak142pdqx819zk","_id":"cl6p7t1he00az142pcpuf759i"},{"post_id":"cl6p7t1ha00ai142pf1yjdths","category_id":"cl6p7t1hd00ar142p7mp4hwqs","_id":"cl6p7t1he00b1142p5fd45qqg"},{"post_id":"cl6p7t1hb00am142payfr9ruf","category_id":"cl6p7t1hb00ak142pdqx819zk","_id":"cl6p7t1he00b2142p06mncoy2"},{"post_id":"cl6p7t1hb00am142payfr9ruf","category_id":"cl6p7t1hd00ar142p7mp4hwqs","_id":"cl6p7t1he00b4142pabe1bgb4"}],"PostTag":[{"post_id":"cl6p7t1f70001142p0a3f54zh","tag_id":"cl6p7t1fc0004142pa77d0xlu","_id":"cl6p7t1fj000f142pfsyc60hi"},{"post_id":"cl6p7t1f70001142p0a3f54zh","tag_id":"cl6p7t1ff0009142p94xwfa66","_id":"cl6p7t1fk000h142p0j2te7p7"},{"post_id":"cl6p7t1f90002142p1k2iedks","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1fp000t142pfmjzduix"},{"post_id":"cl6p7t1f90002142p1k2iedks","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1fq000x142p3rz9fxgc"},{"post_id":"cl6p7t1f90002142p1k2iedks","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1fr0011142p8pcp5jof"},{"post_id":"cl6p7t1fp000u142p7lh357qm","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1fs0014142pf7w9d85s"},{"post_id":"cl6p7t1fp000u142p7lh357qm","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1fu0017142p75an94zp"},{"post_id":"cl6p7t1fr0012142pb2f447tz","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1fv001a142pcrafh8yd"},{"post_id":"cl6p7t1fr0012142pb2f447tz","tag_id":"cl6p7t1fq000z142p6vuc2zx7","_id":"cl6p7t1fw001d142pcc34fvy6"},{"post_id":"cl6p7t1fs0015142pheqmdiox","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1fx001g142pbk1xdqq3"},{"post_id":"cl6p7t1fs0015142pheqmdiox","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1fy001j142pbwshazq0"},{"post_id":"cl6p7t1fc0005142pfknr6b2u","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1fy001m142p518a4pll"},{"post_id":"cl6p7t1fc0005142pfknr6b2u","tag_id":"cl6p7t1fq000z142p6vuc2zx7","_id":"cl6p7t1fz001p142p5g9z6ilh"},{"post_id":"cl6p7t1fc0005142pfknr6b2u","tag_id":"cl6p7t1fs0016142p392xakn3","_id":"cl6p7t1g0001s142pa96q2fn8"},{"post_id":"cl6p7t1fv001b142p7vvjc83p","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1g1001v142pg5pd77jn"},{"post_id":"cl6p7t1fv001b142p7vvjc83p","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1g2001y142p66cq4hlf"},{"post_id":"cl6p7t1fd0006142pfo9l39uz","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1g20021142pdnyj3thg"},{"post_id":"cl6p7t1fd0006142pfo9l39uz","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1g30024142p97i4dr9h"},{"post_id":"cl6p7t1fd0006142pfo9l39uz","tag_id":"cl6p7t1fz001o142pab0d909y","_id":"cl6p7t1g40027142pfhd12zy1"},{"post_id":"cl6p7t1g0001t142p4jo1ar80","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1g5002a142pefixdurt"},{"post_id":"cl6p7t1g0001t142p4jo1ar80","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1g6002d142p61r7hixv"},{"post_id":"cl6p7t1g2001z142p27yi5spo","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1g6002g142p2dag3xar"},{"post_id":"cl6p7t1g2001z142p27yi5spo","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1g7002j142pa8iiafqm"},{"post_id":"cl6p7t1g30022142p44aodmro","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1g8002m142pgcwr72ju"},{"post_id":"cl6p7t1g30022142p44aodmro","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1g8002o142parhn9yz8"},{"post_id":"cl6p7t1fe0007142pclulf23e","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1g9002s142pcgzk4jzv"},{"post_id":"cl6p7t1fe0007142pclulf23e","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1ga002u142pfhwp9ikk"},{"post_id":"cl6p7t1g7002k142phd9ibjp1","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1ga002y142pbos398jz"},{"post_id":"cl6p7t1g7002k142phd9ibjp1","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1gb0030142p37rjhenw"},{"post_id":"cl6p7t1g8002p142p4wqc4b3a","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gc0033142p2xgy6id4"},{"post_id":"cl6p7t1g8002p142p4wqc4b3a","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1gc0035142p4ywg0vul"},{"post_id":"cl6p7t1g9002t142phpivdjkm","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gc0039142phtxu6n46"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gc003a142ph16m8myq"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1gd003c142pa85j90bo"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","tag_id":"cl6p7t1g7002i142p6rzf57sk","_id":"cl6p7t1gd003e142p7o8na63b"},{"post_id":"cl6p7t1ff000a142pb1sb83qm","tag_id":"cl6p7t1g9002q142pgb4z0lne","_id":"cl6p7t1gd003g142p94wo1fko"},{"post_id":"cl6p7t1fg000b142p5lnucq4n","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gd003j142pakjkfbvm"},{"post_id":"cl6p7t1fg000b142p5lnucq4n","tag_id":"cl6p7t1fz001o142pab0d909y","_id":"cl6p7t1ge003m142p7ag93ybz"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1ge003p142pd1q40c2q"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","tag_id":"cl6p7t1gc0037142p0zgu2h0f","_id":"cl6p7t1ge003s142pdz329152"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","tag_id":"cl6p7t1g7002i142p6rzf57sk","_id":"cl6p7t1gf003v142p9wl15sse"},{"post_id":"cl6p7t1fi000e142p4ucf0v1h","tag_id":"cl6p7t1gd003f142pewju9ll8","_id":"cl6p7t1gf003x142pfg36fbfz"},{"post_id":"cl6p7t1fj000g142p4gvo5k9v","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gf0041142p6ue181zl"},{"post_id":"cl6p7t1fj000g142p4gvo5k9v","tag_id":"cl6p7t1fq000z142p6vuc2zx7","_id":"cl6p7t1gg0043142p9xco3cry"},{"post_id":"cl6p7t1fj000g142p4gvo5k9v","tag_id":"cl6p7t1ge003r142pavmrcrkg","_id":"cl6p7t1gg0047142p3cpggg7m"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gh004h142phrgb2pgg"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","tag_id":"cl6p7t1fs0016142p392xakn3","_id":"cl6p7t1gi004k142pgwpc55a6"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","tag_id":"cl6p7t1gg0046142p0jnx8xxc","_id":"cl6p7t1gi004n142pdebpc4hu"},{"post_id":"cl6p7t1fl000k142p82ig1fhp","tag_id":"cl6p7t1gg004b142p030o1iqg","_id":"cl6p7t1gi004q142p0hf320xf"},{"post_id":"cl6p7t1fm000l142p3box2n1d","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gj004t142pdx0naag9"},{"post_id":"cl6p7t1fm000l142p3box2n1d","tag_id":"cl6p7t1g9002q142pgb4z0lne","_id":"cl6p7t1gj004w142p2fb49no5"},{"post_id":"cl6p7t1fm000l142p3box2n1d","tag_id":"cl6p7t1fz001o142pab0d909y","_id":"cl6p7t1gk004z142pdfsm43ee"},{"post_id":"cl6p7t1fm000l142p3box2n1d","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1gk0052142p1ccc25fe"},{"post_id":"cl6p7t1fn000o142p7ce4035g","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gk0055142pcwuy8b92"},{"post_id":"cl6p7t1fn000o142p7ce4035g","tag_id":"cl6p7t1fz001o142pab0d909y","_id":"cl6p7t1gk0058142p48yqel8n"},{"post_id":"cl6p7t1fn000p142p3nhzc2c9","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gl005b142p56x46aob"},{"post_id":"cl6p7t1fn000p142p3nhzc2c9","tag_id":"cl6p7t1gj004x142p5e4k2yne","_id":"cl6p7t1gl005e142p3e1l0hxz"},{"post_id":"cl6p7t1fn000p142p3nhzc2c9","tag_id":"cl6p7t1gk0053142p8bzj9lwt","_id":"cl6p7t1gm005h142phswy49db"},{"post_id":"cl6p7t1fo000r142p5vzmgi25","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gm005k142p005q4jdz"},{"post_id":"cl6p7t1fo000r142p5vzmgi25","tag_id":"cl6p7t1gl005a142p7q405enm","_id":"cl6p7t1gn005n142pcbh88r5w"},{"post_id":"cl6p7t1fq000y142pg2oibxzm","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gn005q142p6158gx2y"},{"post_id":"cl6p7t1fq000y142pg2oibxzm","tag_id":"cl6p7t1fs0016142p392xakn3","_id":"cl6p7t1go005t142p4sp50cs4"},{"post_id":"cl6p7t1fq000y142pg2oibxzm","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1go005w142p8hjt29le"},{"post_id":"cl6p7t1fu0018142p3643fh9y","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1go005z142pa5ox7qei"},{"post_id":"cl6p7t1fu0018142p3643fh9y","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1gq0062142p7b9cdvkq"},{"post_id":"cl6p7t1fu0018142p3643fh9y","tag_id":"cl6p7t1gl005a142p7q405enm","_id":"cl6p7t1gr0065142p58tf7vzz"},{"post_id":"cl6p7t1fw001e142peby5at6x","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gr0068142pa0ibba28"},{"post_id":"cl6p7t1fw001e142peby5at6x","tag_id":"cl6p7t1ge003r142pavmrcrkg","_id":"cl6p7t1gs006b142pgsi2frfr"},{"post_id":"cl6p7t1fw001e142peby5at6x","tag_id":"cl6p7t1go005y142p41nz4x66","_id":"cl6p7t1gs006e142pebkbh8hm"},{"post_id":"cl6p7t1fx001h142p6la62cyr","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gu006j142p7sqz1u2t"},{"post_id":"cl6p7t1fx001h142p6la62cyr","tag_id":"cl6p7t1go005y142p41nz4x66","_id":"cl6p7t1gu006l142p3m9e44j6"},{"post_id":"cl6p7t1fx001h142p6la62cyr","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1gv006p142p7j905u02"},{"post_id":"cl6p7t1fx001h142p6la62cyr","tag_id":"cl6p7t1gr006a142pawar4874","_id":"cl6p7t1gv006r142pg9jzcy3w"},{"post_id":"cl6p7t1fy001k142p53ou14oe","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gw006v142pgs1h02dz"},{"post_id":"cl6p7t1fy001k142p53ou14oe","tag_id":"cl6p7t1g7002i142p6rzf57sk","_id":"cl6p7t1gw006x142p2d2d39e9"},{"post_id":"cl6p7t1fy001k142p53ou14oe","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1gw0071142p6rj9gttc"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gx0073142p2sdt2kwt"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1gx0077142p1u245diz"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1gx0079142p67ppghkn"},{"post_id":"cl6p7t1fy001n142p8ozc8f73","tag_id":"cl6p7t1go005y142p41nz4x66","_id":"cl6p7t1gy007d142p0wzwh34u"},{"post_id":"cl6p7t1fz001q142pgx965qz2","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gy007f142p108aglty"},{"post_id":"cl6p7t1fz001q142pgx965qz2","tag_id":"cl6p7t1gv006s142p2rx230sr","_id":"cl6p7t1gz007j142pghi45y4g"},{"post_id":"cl6p7t1fz001q142pgx965qz2","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1gz007l142p1jpy6t9w"},{"post_id":"cl6p7t1fz001q142pgx965qz2","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1gz007p142p9o8k2kea"},{"post_id":"cl6p7t1g1001w142pb9jicoy4","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1gz007r142p2ae884m2"},{"post_id":"cl6p7t1g1001w142pb9jicoy4","tag_id":"cl6p7t1g7002i142p6rzf57sk","_id":"cl6p7t1h0007v142parn89wxh"},{"post_id":"cl6p7t1g30025142p5z4na6d7","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1h0007x142p9cvugx79"},{"post_id":"cl6p7t1g30025142p5z4na6d7","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1h10081142pd5bsgkuw"},{"post_id":"cl6p7t1g30025142p5z4na6d7","tag_id":"cl6p7t1gk0053142p8bzj9lwt","_id":"cl6p7t1h10083142p405g9ph2"},{"post_id":"cl6p7t1g40028142pe5zzaf85","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1h10087142p3xjrb3jn"},{"post_id":"cl6p7t1g40028142pe5zzaf85","tag_id":"cl6p7t1gx007c142p7kbt036h","_id":"cl6p7t1h20089142pgjaycss3"},{"post_id":"cl6p7t1g5002b142p12p6hauh","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1h2008d142p2uamf0lo"},{"post_id":"cl6p7t1g5002b142p12p6hauh","tag_id":"cl6p7t1gy007i142pgrcr5ows","_id":"cl6p7t1h3008f142pfvp10vi3"},{"post_id":"cl6p7t1g5002b142p12p6hauh","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1h3008j142p7ba215gd"},{"post_id":"cl6p7t1g5002b142p12p6hauh","tag_id":"cl6p7t1gx007c142p7kbt036h","_id":"cl6p7t1h4008l142p7pgcc1xu"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1h4008o142p9g07hhoc"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","tag_id":"cl6p7t1gy007i142pgrcr5ows","_id":"cl6p7t1h4008r142pdxxf3ge8"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1h5008u142p8k0yaywd"},{"post_id":"cl6p7t1g6002e142p4tdr3zb8","tag_id":"cl6p7t1gx007c142p7kbt036h","_id":"cl6p7t1h5008x142p2bsu49zd"},{"post_id":"cl6p7t1g6002h142p3h33bvl1","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1h50090142p07d6fysd"},{"post_id":"cl6p7t1g6002h142p3h33bvl1","tag_id":"cl6p7t1gy007i142pgrcr5ows","_id":"cl6p7t1h60092142pbqykbb6d"},{"post_id":"cl6p7t1g6002h142p3h33bvl1","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1h60094142p4kh7f1re"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","tag_id":"cl6p7t1fh000d142p6kptbzuy","_id":"cl6p7t1h60096142pgup86xb7"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","tag_id":"cl6p7t1fl000j142pgf6dggvv","_id":"cl6p7t1h60098142pel7537bq"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","tag_id":"cl6p7t1fn000n142pcssy7lfy","_id":"cl6p7t1h6009a142pc80a8ql6"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","tag_id":"cl6p7t1gl005a142p7q405enm","_id":"cl6p7t1h6009c142pbl4u9wjs"},{"post_id":"cl6p7t1g8002n142p4l8k3g03","tag_id":"cl6p7t1fz001o142pab0d909y","_id":"cl6p7t1h6009e142pcc7jej6g"},{"post_id":"cl6p7t1ga002v142p6sorc1og","tag_id":"cl6p7t1h3008i142p7xdo9k6s","_id":"cl6p7t1h6009g142p323waljt"},{"post_id":"cl6p7t1ga002v142p6sorc1og","tag_id":"cl6p7t1fc0004142pa77d0xlu","_id":"cl6p7t1h6009i142p58zh28u7"},{"post_id":"cl6p7t1ga002v142p6sorc1og","tag_id":"cl6p7t1h4008p142p4trrb2nm","_id":"cl6p7t1h6009k142p6vbz3ndp"},{"post_id":"cl6p7t1ga002v142p6sorc1og","tag_id":"cl6p7t1h5008w142pbdo238o9","_id":"cl6p7t1h6009m142pg1hf9kza"},{"post_id":"cl6p7t1ha00ai142pf1yjdths","tag_id":"cl6p7t1hb00al142pfolyhrjj","_id":"cl6p7t1hd00au142p5hm4f4i6"},{"post_id":"cl6p7t1ha00ai142pf1yjdths","tag_id":"cl6p7t1hc00ao142pgnlt8iuq","_id":"cl6p7t1hd00av142p5y3g77xl"},{"post_id":"cl6p7t1ha00ai142pf1yjdths","tag_id":"cl6p7t1hc00aq142pa2uydk3u","_id":"cl6p7t1he00ay142p1tozb34m"},{"post_id":"cl6p7t1hb00aj142pde627dsw","tag_id":"cl6p7t1hd00at142p4weha6ly","_id":"cl6p7t1he00b5142pa0bpfwna"},{"post_id":"cl6p7t1hb00aj142pde627dsw","tag_id":"cl6p7t1hd00ax142pea55e5sc","_id":"cl6p7t1he00b6142p03w38307"},{"post_id":"cl6p7t1hb00aj142pde627dsw","tag_id":"cl6p7t1he00b0142p3tm297dw","_id":"cl6p7t1he00b8142pdbffaczj"},{"post_id":"cl6p7t1hb00am142payfr9ruf","tag_id":"cl6p7t1hb00al142pfolyhrjj","_id":"cl6p7t1hf00ba142p5y8qet7y"},{"post_id":"cl6p7t1hb00am142payfr9ruf","tag_id":"cl6p7t1he00b7142p03331zvq","_id":"cl6p7t1hf00bb142p1yu4bnm2"},{"post_id":"cl6p7t1hb00am142payfr9ruf","tag_id":"cl6p7t1hf00b9142p771fc062","_id":"cl6p7t1hf00bc142p0o9ceqyu"}],"Tag":[{"name":"mysql","_id":"cl6p7t1fc0004142pa77d0xlu"},{"name":"sololearn","_id":"cl6p7t1ff0009142p94xwfa66"},{"name":"python","_id":"cl6p7t1fh000d142p6kptbzuy"},{"name":"hash","_id":"cl6p7t1fl000j142pgf6dggvv"},{"name":"point","_id":"cl6p7t1fn000n142pcssy7lfy"},{"name":"stack","_id":"cl6p7t1fq000z142p6vuc2zx7"},{"name":"linked list","_id":"cl6p7t1fs0016142p392xakn3"},{"name":"string","_id":"cl6p7t1fz001o142pab0d909y"},{"name":"binary search","_id":"cl6p7t1g7002i142p6rzf57sk"},{"name":"dp","_id":"cl6p7t1g9002q142pgb4z0lne"},{"name":"loop","_id":"cl6p7t1gc0037142p0zgu2h0f"},{"name":"Newton's method","_id":"cl6p7t1gd003f142pewju9ll8"},{"name":"recursion","_id":"cl6p7t1ge003r142pavmrcrkg"},{"name":"array","_id":"cl6p7t1gg0046142p0jnx8xxc"},{"name":"binary tree","_id":"cl6p7t1gg004b142p030o1iqg"},{"name":"sql","_id":"cl6p7t1gj004x142p5e4k2yne"},{"name":"ascii","_id":"cl6p7t1gk0053142p8bzj9lwt"},{"name":"bit","_id":"cl6p7t1gl005a142p7q405enm"},{"name":"math","_id":"cl6p7t1go005y142p41nz4x66"},{"name":"sort","_id":"cl6p7t1gr006a142pawar4874"},{"name":"bubble","_id":"cl6p7t1gv006s142p2rx230sr"},{"name":"enumerate","_id":"cl6p7t1gx007c142p7kbt036h"},{"name":"greedy","_id":"cl6p7t1gy007i142pgrcr5ows"},{"name":"ssh tunnel","_id":"cl6p7t1h3008i142p7xdo9k6s"},{"name":"powerbi","_id":"cl6p7t1h4008p142p4trrb2nm"},{"name":"tableau","_id":"cl6p7t1h5008w142pbdo238o9"},{"name":"credit","_id":"cl6p7t1hb00al142pfolyhrjj"},{"name":"decision","_id":"cl6p7t1hc00ao142pgnlt8iuq"},{"name":"economics","_id":"cl6p7t1hc00aq142pa2uydk3u"},{"name":"management","_id":"cl6p7t1hd00at142p4weha6ly"},{"name":"develop","_id":"cl6p7t1hd00ax142pea55e5sc"},{"name":"scrum","_id":"cl6p7t1he00b0142p3tm297dw"},{"name":"scorecard","_id":"cl6p7t1he00b7142p03331zvq"},{"name":"risk control","_id":"cl6p7t1hf00b9142p771fc062"}]}}
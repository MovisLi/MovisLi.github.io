

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#414142">
  <meta name="author" content="MovisLi">
  <meta name="keywords" content="ComputerScience, DataScience, Economics&amp;Finance, Management">
  
    <meta name="description" content="基础 WEB 基础    请求方法 说明     GET 请求 URL 的网页信息，并返回实体数据。一般用于查询数据   POST 向 URL 提交数据进行处理请求。比如提交表单或是上传文件   PUT 向 URL 上传数据内容   DELETE 向 URL 发送删除资源请求   HEAD 与 GET 请求类似，只返回响应头   CON">
<meta property="og:type" content="article">
<meta property="og:title" content="FastAPI">
<meta property="og:url" content="https://movisli.github.io/2023/06/20/FastAPI/index.html">
<meta property="og:site_name" content="movis">
<meta property="og:description" content="基础 WEB 基础    请求方法 说明     GET 请求 URL 的网页信息，并返回实体数据。一般用于查询数据   POST 向 URL 提交数据进行处理请求。比如提交表单或是上传文件   PUT 向 URL 上传数据内容   DELETE 向 URL 发送删除资源请求   HEAD 与 GET 请求类似，只返回响应头   CON">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-06-19T21:57:22.000Z">
<meta property="article:modified_time" content="2024-06-07T08:32:58.968Z">
<meta property="article:author" content="MovisLi">
<meta property="article:tag" content="python">
<meta property="article:tag" content="fastapi">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>FastAPI - movis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"movisli.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Movis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="FastAPI"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        MovisLi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-20 05:57" pubdate>
          June 20, 2023 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          33k words
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">FastAPI</h1>
            
            <div class="markdown-body">
              
              <h1 id="基础">基础</h1>
<h2 id="web-基础">WEB 基础</h2>
<table>
<thead>
<tr class="header">
<th>请求方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GET</td>
<td>请求 URL 的网页信息，并返回实体数据。一般用于查询数据</td>
</tr>
<tr class="even">
<td>POST</td>
<td>向 URL 提交数据进行处理请求。比如提交表单或是上传文件</td>
</tr>
<tr class="odd">
<td>PUT</td>
<td>向 URL 上传数据内容</td>
</tr>
<tr class="even">
<td>DELETE</td>
<td>向 URL 发送删除资源请求</td>
</tr>
<tr class="odd">
<td>HEAD</td>
<td>与 GET 请求类似，只返回响应头</td>
</tr>
<tr class="even">
<td>CONNECT</td>
<td>HTTP/1.1 预留</td>
</tr>
<tr class="odd">
<td>OPTIONS</td>
<td>获取服务器特定资源的 HTML 请求方法</td>
</tr>
<tr class="even">
<td>TRACE</td>
<td>回复并显示服务器收到的请求</td>
</tr>
<tr class="odd">
<td>PATCH</td>
<td>对 PUT 方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody>
</table>
<p>URL （ Uniform Resource
Locator，资源定位符）代表一个网站上资源的详细地址。完整的 URL
由以下部分依序组成：</p>
<ol type="1">
<li>协议，如 HTTPS 协议。</li>
<li>主机名，可能是域名，如 <code>www.google.com</code> ，也可能是 IP
地址加端口号，如 <code>192.168.1.1:80</code> 。</li>
<li>资源相对路径，指网站上资源相对的地址，可能还带有参数。</li>
</ol>
<p>HTTP 请求与响应详细实现步骤如下：</p>
<ol type="1">
<li>客户端 TCP 连接到 Web 服务器。</li>
<li>客户端发送 HTTP 请求。</li>
<li>Web 服务器接受请求并返回 HTTP 响应。</li>
<li>释放 TCP 连接。</li>
<li>客户端解析响应数据。</li>
</ol>
<p>HTTP 请求大致组成如下：</p>
<ul>
<li>请求行（请求方法，URL，协议版本）</li>
<li>请求头</li>
<li>空行</li>
<li>请求数据</li>
</ul>
<p>HTTP 响应大致组成如下：</p>
<ul>
<li>状态行（协议版本，状态码，状态码描述）</li>
<li>响应头</li>
<li>空行</li>
<li>响应收据</li>
</ul>
<table>
<thead>
<tr class="header">
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>不带有响应对象的业务数据，需要请求后执行后续相关操作</td>
</tr>
<tr class="even">
<td>200</td>
<td>成功</td>
</tr>
<tr class="odd">
<td>201</td>
<td>也是成功，一般用于表示在数据库中创建了一条新的记录</td>
</tr>
<tr class="even">
<td>204</td>
<td>提示客户端服务端成功处理，但没有返回内容</td>
</tr>
<tr class="odd">
<td>300</td>
<td>重定向</td>
</tr>
<tr class="even">
<td>400</td>
<td>客户端异常</td>
</tr>
<tr class="odd">
<td>500</td>
<td>服务器异常</td>
</tr>
</tbody>
</table>
<h2 id="fastapi-框架组成">FastAPI 框架组成</h2>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202305120725715.png" srcset="/img/loading.gif" lazyload /></p>
<p>FastAPI 功能建立在 Python 类型提示（3.7, 3.9, 3.10
可能写法不一样）、Pydantic 框架、 Starlette 框架基础上。</p>
<h3 id="python-类型提示">Python 类型提示</h3>
<h4 id="使用方式">使用方式</h4>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">data: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    res: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>(data)
    <span class="hljs-keyword">return</span> res</code></pre></div>
<p>变量或参数后面使用冒号指定类型，不过运行时没用，也是防君子不防小人的一种体现。</p>
<h4 id="基础数据类型">基础数据类型</h4>
<ul>
<li>int - 整型</li>
<li>float - 浮点型</li>
<li>str - 字符串型</li>
<li>bool - 逻辑型</li>
<li>bytes - 字节型</li>
</ul>
<h4 id="泛型">泛型</h4>
<ul>
<li><p>list - 列表泛型</p></li>
<li><p>tuple - 元组泛型</p></li>
<li><p>set - 集合泛型</p></li>
<li><p>dict - 字典泛型</p></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span>
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime

<span class="hljs-comment"># 3.7</span>
my_list: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = []
timestamp: <span class="hljs-type">Optional</span>[datetime] = <span class="hljs-literal">None</span>

<span class="hljs-comment"># 3.9</span>
my_list: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []
timestamp: <span class="hljs-type">Optional</span>[datetime] = <span class="hljs-literal">None</span>

<span class="hljs-comment"># 3.10</span>
my_list: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []
timestamp: datetime | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span></code></pre></div>
<h4 id="自定义类">自定义类</h4>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>):
        self.name = name


<span class="hljs-comment"># output: movis</span>
<span class="hljs-built_in">print</span>(Person(<span class="hljs-string">&#x27;movis&#x27;</span>).name)</code></pre></div>
<h3 id="pydantic-框架">Pydantic 框架</h3>
<p><a target="_blank" rel="noopener" href="https://docs.pydantic.dev/latest/">Pydantic</a> 是一套基于
Python 类型提示的数据模型定义及验证的框架。</p>
<p>这个框架在<strong>运行时</strong>强制执行类型提示。</p>
<h3 id="starlette-框架">Starlette 框架</h3>
<p>Starlette 是一个轻量级高性能的异步服务网关接口框架（ASGI）。</p>
<h1 id="请求">请求</h1>
<ol type="1">
<li>用户向浏览器提交请求数据。</li>
<li>浏览器封装请求数据冰箱 Web 服务器提交。</li>
<li>Web 服务器处理请求数据。</li>
</ol>
<h2 id="路径参数">路径参数</h2>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file_path</span>(<span class="hljs-params">file_name: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-built_in">print</span>(file_name)
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div>
<p>写在 <code>get</code> 请求路径里的 <code>&#123;file_name&#125;</code>
这部分就是路径参数，可以定义类型，有类型路径参数的数据会有验证。</p>
<h3 id="路由访问顺序">路由访问顺序</h3>
<p>与代码里路由顺序有关，具体为从上到下。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/test&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test_file</span>():
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: <span class="hljs-string">&#x27;this is test&#x27;</span>&#125;


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file_path</span>(<span class="hljs-params">file_name: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-built_in">print</span>(file_name)
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div>
<p>如上代码的访问顺序是如果 <code>/file/test</code> 会执行
<code>read_test_file()</code> 而不是 <code>read_csv_file_path()</code>
。</p>
<h3 id="枚举的应用">枚举的应用</h3>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FileEnum</span>(<span class="hljs-title class_ inherited__">Enum</span>):
    file1 = <span class="hljs-string">&quot;file_one&quot;</span>
    file2 = <span class="hljs-string">&quot;file_two&quot;</span>


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_file_path</span>(<span class="hljs-params">file_name: FileEnum</span>):
    <span class="hljs-built_in">print</span>(file_name)
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div>
<h3 id="路径参数类">路径参数类</h3>
<p>当想要给路径参数添加约束条件时（校验路径参数）可以使用
<code>Path</code> 这个查询参数类。这样代码更加规范。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Path

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#123;item_id&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">..., gt=<span class="hljs-number">3</span></span>)</span>):
    <span class="hljs-keyword">return</span> item_id</code></pre></div>
<p>这样可以指定，<code>item_id</code> 必传并且必须大于 3 。</p>
<p>具体用法可以看 <a
target="_blank" rel="noopener" href="https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/">Path
Parameters and Numeric Validations - FastAPI</a> 。</p>
<h2 id="查询参数">查询参数</h2>
<p>指 <code>path?p1=v1&amp;p2=v2</code> 这种形式。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_file_path</span>(<span class="hljs-params">file_name: FileEnum, q: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;path parameter:&#x27;</span>, file_name)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;query parameter&#x27;</span>, q)
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div>
<p>在这个示例中，<code>file_name</code> 是路径参数，<code>q</code>
这是查询参数，可以看到没有出现在 <code>app.get</code> 后的路径里。</p>
<p>那么请求 <code>URL</code> 是 <code>xxx/file/file_one?q=v</code>
这种形式。</p>
<p>如果 <code>read_csv_file_path</code> 这个函数声明里写了
<code>q</code>
的默认值，那么这个查询参数就是一个可选的查询参数，否则就是必选查询参数。将这个示例改写为可选查询参数为：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_file_path</span>(<span class="hljs-params">file_name: FileEnum, q: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
<span class="hljs-comment"># 其实 q: str = None 这样写也可以</span></code></pre></div>
<h3 id="参数类型转换">参数类型转换</h3>
<p>通过 <code>URL</code>
传递的查询参数，参数值的原始类型是字符串，如果这个函数定义的是
<code>int</code> 或者是 <code>bool</code> 那么 FastAPI
会验证参数并转换为对应的类型。</p>
<p>其中 <code>bool</code> 类型可以将如下字符串转义为 <code>True</code>
或者 <code>False</code> ：</p>
<ul>
<li>True
<ul>
<li><code>q=True</code> , <code>q=true</code> , <code>q=1</code> ,
<code>q=yes</code> ，注意这里 1 这个值是可以的，123 这种是不行的。</li>
</ul></li>
<li>False
<ul>
<li><code>q=False</code> , <code>q=false</code> , <code>q=0</code> ,
<code>q=no</code></li>
</ul></li>
</ul>
<p>对于多路径参数和多查询参数的情况，路径参数的顺序必须是正确的，查询参数的顺序可以随意调换。</p>
<h3 id="查询参数类">查询参数类</h3>
<p>当想要给查询参数添加约束条件时（校验查询参数）可以使用
<code>Query</code> 这个查询参数类。这样代码更加规范。</p>
<p>比如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Query

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">q: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Query(<span class="hljs-params"><span class="hljs-literal">None</span>, min_length=<span class="hljs-number">3</span></span>)</span>):
    <span class="hljs-keyword">return</span> q</code></pre></div>
<p>具体用法可以看 <a
target="_blank" rel="noopener" href="https://fastapi.tiangolo.com/tutorial/query-params-str-validations/">Query
Parameters and String Validations - FastAPI</a> 。</p>
<h2 id="请求体">请求体</h2>
<p>客户端发送给服务端的受数据模型约束的请求数据称为请求体（ Request Body
），默认是 JSON 形式，<strong>请求体不能使用 <code>GET</code>
方法</strong>，需要使用 <code>POST</code> 、<code>PUT</code>
、<code>DELETE</code> 、<code>PATCH</code> 方法之一。</p>
<h3 id="对象请求体">对象请求体</h3>
<p>在 FastAPI 中，所有请求体实现对象，通过创建类继承 Pydantic 的
BaseModel 类实现定义。</p>
<p>假设我需要一个路径为 <code>/items/</code> 的接口，请求体格式为：</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    name<span class="hljs-punctuation">:</span> &#x27;xxx&#x27;<span class="hljs-punctuation">,</span>
    num<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>
<p>这两个参数并将其返回给客户端，那么写法为：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>
    num: <span class="hljs-built_in">int</span>


<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">created_item</span>(<span class="hljs-params">item: Item</span>):
    <span class="hljs-keyword">return</span> item</code></pre></div>
<p>值得注意的是，由于 <code>Item</code> 类已经定义了数据类型，比如
<code>num</code> 为 <code>int</code> ，假设 <code>num</code>
没传数字是会报错的。</p>
<h3 id="常规数据类型请求体">常规数据类型请求体</h3>
<p>上面定义了继承 Pydantic 的 <code>schema</code>
类，因为请求体里是个对象，但是请求体也可能不是个对象，是基础数据类型，可以这样写：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Body

<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">created_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">str</span> = Body(<span class="hljs-params"></span>)</span>):
    <span class="hljs-keyword">return</span> item</code></pre></div>
<p>这里主要体现了和查询参数的区别，如果不写这个 <code>Body</code>
，很显然这个 <code>item</code> 就是个查询参数。</p>
<h3 id="表单和文件">表单和文件</h3>
<p>表单和文件实际上也是在请求体中传给服务端的，都依赖第三方库
<code>python-multipart</code> 。</p>
<p>表单比较常见的应用就是登录时的提交。</p>
<p>写法为：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/login/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>):
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;username&#x27;</span>: username, <span class="hljs-string">&#x27;password&#x27;</span>: password&#125;</code></pre></div>
<p>官网教程有用过 <code>username: Annotated[str, Form()]</code>
这种写法， 这样的话 <code>username</code>
就不再是请求体里的内容而是查询参数。</p>
<p>从上面可以看到，其实请求体实质上是以一个对象的方式传递的，包括自定义继承
<code>Pydantic</code> 的 <code>BaseModel</code>
的对象，<code>Body</code> 对象，<code>Form</code> 对象。</p>
<p>上传文件也是用类似的方式，即 <code>File</code>
对象。这里有两种方式接收文件。</p>
<p>第一种的参数类型为 bytes，用来接收 HTTP 上传的文件流。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/upload/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: <span class="hljs-built_in">bytes</span> = File(<span class="hljs-params"></span>)</span>):
    <span class="hljs-keyword">return</span> file[:<span class="hljs-number">20</span>]</code></pre></div>
<p>第二种的参数类型为 UploadFile
，这种情况下，当内存中的数据尺寸超过最大限制后，会将部分数据存储在磁盘中。这种方式比较适合处理大文件，比如图片，视频等。还可以获得文件名。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> File, UploadFile

<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/upload/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: UploadFile = File(<span class="hljs-params"></span>)</span>):
    <span class="hljs-keyword">return</span> file.filename</code></pre></div>
<h2 id="cookie-参数">Cookie 参数</h2>
<p>HTTP Cookie
是服务器发送到客户端并保存在本地的一小块数据，一般用来记录用户登录状态和浏览器行为。在
FastAPI 中可以通过 <code>Cookie</code> 参数处理 <code>Cookie</code>
。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Cookie

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">c: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Cookie(<span class="hljs-params"><span class="hljs-literal">None</span></span>)</span>):
    <span class="hljs-keyword">return</span> c</code></pre></div>
<p>然后需要在浏览器设置 <code>Cookie</code> ：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081045370.png" srcset="/img/loading.gif" lazyload /></p>
<p>返回内容如下：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081046482.png" srcset="/img/loading.gif" lazyload /></p>
<p>URL 里是没有传 Cookie 的信息的。</p>
<p>具体可以见 <a
target="_blank" rel="noopener" href="https://fastapi.tiangolo.com/tutorial/cookie-params/">Cookie
Parameters - FastAPI</a> 与 <a
target="_blank" rel="noopener" href="https://www.starlette.io/responses/#set-cookie">Responses - Set
Cookie - Starlette</a>。</p>
<h2 id="请求头">请求头</h2>
<p>在 FastAPI 中可以通过 <code>Header</code>
参数处理请求头（响应头其实也可以）。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Header

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">user_agent: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Header(<span class="hljs-params"></span>)</span>):
    <span class="hljs-keyword">return</span> user_agent</code></pre></div>
<p>这样就可以拿到 <code>User-Agent</code> 。</p>
<p>具体可以见 <a
target="_blank" rel="noopener" href="https://fastapi.tiangolo.com/tutorial/header-params/">Header
Parameters - FastAPI</a> 。</p>
<h2 id="请求类">请求类</h2>
<p>在某些情况下，不需要对数据进行校验和转换，可以使用 FastAPI 中的
<code>Request</code> 类。</p>
<p>比如需要返回客户端的 IP ：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Request

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):
    <span class="hljs-keyword">return</span> request.client.host</code></pre></div>
<h1 id="响应">响应</h1>
<ol type="1">
<li>Web 服务器解析请求数据。</li>
<li>数据逻辑处理。</li>
<li>服务器将响应数据发送回浏览器。</li>
<li>浏览器渲染响应数据。</li>
</ol>
<h2 id="响应模型">响应模型</h2>
<p>在请求中，请求体中的数据以数据模型形式传递给服务端，好处是可以自动做数据验证。在响应中其实也有同样的方式传递给客户端。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIn</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>
    password: <span class="hljs-built_in">str</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserOut</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>


<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/signup/&#x27;</span>, response_model=UserOut</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_customer</span>(<span class="hljs-params">user: UserIn</span>):
    <span class="hljs-keyword">return</span> user</code></pre></div>
<p>只需要在 <code>app.post</code> 或者 <code>app.get</code>
装饰器中添加参数 <code>response_model = YOUR_SCHEMA</code>
就可以了。</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080709699.png" srcset="/img/loading.gif" lazyload /></p>
<p>当然，请求模型和响应模型可以是同一个模型。</p>
<p>在上述例子中，可以通过继承的方式简化数据模型的定义（比如
<code>UserIn</code> 和 <code>UserOut</code> 继承同一个基类
<code>UserBase</code> ），也可以通过<code>reponse_model</code> 使用
<code>typing</code> 里的 <code>Union</code>
使用多种响应模型，按顺序匹配直至匹配为止。</p>
<p>一般来讲，数据模型可以分为三类，请求数据模型，响应数据模型，业务数据模型（跟数据库有关）。</p>
<h2 id="响应类">响应类</h2>
<p>路径操作函数在返回响应数据时，可以返回基础数据类型、泛型、数据模型的数据，FastAPI
会将不同类型的数据都转换成兼容 JSON
格式的字符串，再通过响应对象返回给客户端。除此之外，也可以再路径操作函数中直接使用
FastAPI 的内置响应类，返回特殊类型的数据，比如
XML、HTML、文件等。具体响应类型如下：</p>
<h3 id="纯文本响应">纯文本响应</h3>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> PlainTextResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=PlainTextResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Response&quot;</span></code></pre></div>
<p>返回的内容为：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080823675.png" srcset="/img/loading.gif" lazyload /></p>
<p>可以看到这里浏览器是没有渲染的。</p>
<h3 id="html-响应">HTML 响应</h3>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=HTMLResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Response&quot;</span></code></pre></div>
<p>返回的内容为：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080824082.png" srcset="/img/loading.gif" lazyload /></p>
<p>可以看到这里浏览器已经渲染了。</p>
<p>可以打开开发者工具观察和上一个的不同，体现在：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080825151.png" srcset="/img/loading.gif" lazyload /></p>
<p>另外，这样写也是可以的：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> HTMLResponse(<span class="hljs-string">&quot;Response&quot;</span>)</code></pre></div>
<h3 id="重定向响应">重定向响应</h3>
<p>HTTP 重定向也是 Web
服务中常见的响应方式，此方式不返回数据，仅返回一个新的 URL
地址，比如百度：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> RedirectResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=RedirectResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> RedirectResponse(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)</code></pre></div>
<p>返回的响应就变成了百度的页面。但是这里更重要的是这个
<code>return</code> 后这个网址要写全，这里写 <code>www.baidu.com</code>
不加协议是不行的。</p>
<h3 id="json-响应">JSON 响应</h3>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> JSONResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=JSONResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> JSONResponse(content=&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;xx&#x27;</span>&#125;, status_code=<span class="hljs-number">404</span>)</code></pre></div>
<p>可以看到 <code>JSONResponse</code> 这个类可以更改
<code>status_code</code> （其实 <code>XXResponse</code>
类都可以），不同公司可能对不同错误要求返回不同 <code>status_code</code>
，这里就可以派上用场。</p>
<h3 id="通用响应">通用响应</h3>
<p>根据自己需要的 <code>media_type</code> 自己写，比如
<code>application/json</code> 或 <code>application/xml</code> 等 :</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> Response

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=Response</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> Response(content=<span class="hljs-string">&#x27;&#123;&quot;1&quot;: &quot;xx&quot;&#125;&#x27;</span>, media_type=<span class="hljs-string">&#x27;application/json&#x27;</span>)</code></pre></div>
<p>其实<strong>剩下的响应都是继承这个响应的</strong>。这里有几个参数可以了解：</p>
<ul>
<li><code>content</code> ：要响应的内容，可以是 <code>str</code> 或者是
<code>bytes</code> 类型。</li>
<li><code>status_code</code> ：HTTP 状态码，<code>int</code> 类型。</li>
<li><code>headers</code> ：响应头，<code>dict</code> 类型。</li>
<li><code>media_type</code> ：媒体类型的文本，<code>str</code>
类型，可以在 IANA 查看 <a
target="_blank" rel="noopener" href="https://www.iana.org/assignments/media-types/media-types.xhtml">Media
Types</a> 。</li>
</ul>
<h3 id="流响应">流响应</h3>
<p>指使用字节流进行传输。字节流响应的内容是二进制格式，这里以
<code>csv</code> 文件举例（可以说明和文件响应的不同之处）。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> StreamingResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=StreamingResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file_like.csv&#x27;</span>, mode=<span class="hljs-string">&#x27;rb&#x27;</span>)
    <span class="hljs-keyword">return</span> StreamingResponse(f, media_type=<span class="hljs-string">&#x27;text/csv&#x27;</span>) <span class="hljs-comment"># 这里需要指定媒体文件类型</span></code></pre></div>
<p>这样下载的文件不会带有文件名的信息。</p>
<h3 id="文件响应">文件响应</h3>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> FileResponse

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=FileResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> FileResponse(<span class="hljs-string">&#x27;file_like.csv&#x27;</span>, media_type=<span class="hljs-string">&#x27;text/csv&#x27;</span>, filename=<span class="hljs-string">&#x27;file_like.csv&#x27;</span>)</code></pre></div>
<p>与流响应相比，文件响应可以接收更多的参数：</p>
<ul>
<li><code>path</code> ：路径，而非文件对象。</li>
<li><code>filename</code> ：文件名，会包含在响应头的
<code>Content-Disposition</code> 中。</li>
</ul>
<p>使用 <code>StreamingResponse</code>
类时，需要先将文件打开，载入文件对象进行返回，文件内容是一次性读取的，如果文件很大，就会占用很大的内存。使用
<code>FileResponse</code> 类时，通过文件路径指定生成了一个
<code>FileRespnse</code>
类实例，文件是异步读取的，会占用更少的内存。所以推荐使用文件响应。</p>
<h2 id="自定义-cookie">自定义 Cookie</h2>
<p>服务器设置 Cookie 的方式是先创建响应实例，再调用响应实例的
<code>set_cookie</code> 方法。</p>
<p>比如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):
    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;)
    response.set_cookie(key=<span class="hljs-string">&#x27;used_id&#x27;</span>, value=<span class="hljs-string">&#x27;123&#x27;</span>)
    <span class="hljs-keyword">return</span> response</code></pre></div>
<p>调用后可以看到，在浏览器已经返回 <code>cookie</code> ：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081222439.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="响应头">响应头</h2>
<p>和自定义 Cookie 类似，如果想自定义响应头，需要在实例化
<code>Response</code> 类时传入 <code>header</code> 这个参数，如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):
    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Test Server&#x27;</span>&#125;)
    <span class="hljs-keyword">return</span> response</code></pre></div>
<p>可以看到：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081225963.png" srcset="/img/loading.gif" lazyload /></p>
<p>在设置响应头时，有三个规定：</p>
<ol type="1">
<li>设置服务器内置的 Header 的名称可以直接设置，比如这里的
<code>User-Agent</code> 。</li>
<li>设置自定义的 Header 的名称要以 <strong><code>X-</code></strong>
开头。</li>
<li>自定义 Header 的名称和内容都不要包含下划线 <code>_</code>
，因为很多服务器会默认过滤下划线。</li>
</ol>
<h2 id="响应码">响应码</h2>
<p>自定义响应状态码可以在实例化 <code>Response</code>
类时传入，比如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):
    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, status_code=<span class="hljs-number">203</span>)
    <span class="hljs-keyword">return</span> response</code></pre></div>
<p>当然可以通过导入 <code>status</code>
这个模块，在写代码时能更清楚想向客户端传递什么信息，比如上述改写成：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> status

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):
    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, status_code=status.HTTP_203_NON_AUTHORITATIVE_INFORMATION)
    <span class="hljs-keyword">return</span> response</code></pre></div>
<p>两者效果都如下：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081237061.png" srcset="/img/loading.gif" lazyload /></p>
<h1 id="异常处理">异常处理</h1>
<p>FastAPI
提供了异常处理机制，是为了对异常信息的抛出和处理进行统一管理，增加代码可读性。</p>
<h2 id="httpexception">HTTPException</h2>
<p>使用 <code>raise</code> 关键字抛出 <code>HTTPException</code>
异常，如下：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> HTTPException

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#123;item_id&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span></span>):
    <span class="hljs-keyword">if</span> item_id == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">&#x27;Error item_id&#x27;</span>)
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;item_id&#x27;</span>: item_id&#125;</code></pre></div>
<p>当路径参数中的 <code>item_id</code> 为 3
时，客户端会收到一条如下的响应：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120506790.png" srcset="/img/loading.gif" lazyload /></p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120506339.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="全局异常管理器">全局异常管理器</h2>
<p>用 <code>HTTPException</code>
的方式抛出异常，在大型项目中不太方便管理。为了实现逻辑处理与异常处理的分离，FastAPI
提供了一种全局异常处理器的方式。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span>(<span class="hljs-title class_ inherited__">Exception</span>): <span class="hljs-comment"># 定义异常类</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.name = name


<span class="hljs-meta">@app.exception_handler(<span class="hljs-params">TestException</span>) </span><span class="hljs-comment"># 注册全局异常管理器</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_handler</span>(<span class="hljs-params">request: Request, exc: TestException</span>): <span class="hljs-comment"># 定义异常处理函数</span>
    <span class="hljs-keyword">return</span> JSONResponse(status_code=<span class="hljs-number">404</span>, content=&#123;<span class="hljs-string">&#x27;detail&#x27;</span>: <span class="hljs-string">&#x27;Error item_id.&#x27;</span>&#125;)


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#123;item_id&#125;&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span></span>):
    <span class="hljs-keyword">if</span> item_id == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">raise</span> TestException(<span class="hljs-built_in">str</span>(item_id))
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;item_id&#x27;</span>: item_id&#125;</code></pre></div>
<p>通过这种写法，得到的效果和上面 <code>HTTPException</code>
的方式是一样的。但是异常处理这部分，也就是
<code>test_exception_handler</code>
这个函数已经和逻辑处理分离开，而且异常信息的格式也可以自定义，比如不用
<code>JSONResponse</code> 而改用 <code>PlainTextResponse</code>
就可以返回一段文本而不是 json 格式的数据。</p>
<h2 id="requestvalidationerror">RequestValidationError</h2>
<p>这里主要是 <code>RequestValidationError</code>
，与前面请求模型里的数据格式验证相对应，当数据格式验证失败时，也可以采取自定义的方式返回错误信息。上面这个例子，如果不自定义，当数据格式验证错误时：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120555362.png" srcset="/img/loading.gif" lazyload /></p>
<p>在某些时候需要自定义这个信息，比如在公司里可能需要约定正确和错误的格式，这时就可以自定义：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.exception_handler(<span class="hljs-params">RequestValidationError</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">validation_exception_handler</span>(<span class="hljs-params">request: Request, exc: Exception</span>):
    <span class="hljs-keyword">return</span> JSONResponse(status_code=<span class="hljs-number">200</span>, content=&#123;<span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;-2&quot;</span>&#125;)</code></pre></div>
<p>这样的话当数据格式验证错误时，返回的 <code>Status Code</code> 仍然是
200，而错误信息变成了：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120558009.png" srcset="/img/loading.gif" lazyload /></p>
<h1 id="中间件">中间件</h1>
<p>FastAPI
中间件实际上是服务端的一种函数，在每个请求处理之前被调用，又在每个响应返回给客户端之前被调用。（也就是函数内部不再需要自己调用）</p>
<h2 id="自定义中间件">自定义中间件</h2>
<p>如下是一个在 <code>header</code> 里添加 <code>X-Process-Time</code>
的中间件：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.middleware(<span class="hljs-params"><span class="hljs-string">&#x27;http&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_process_time_header</span>(<span class="hljs-params">request: Request, call_next</span>):
    start_time = time.time()
    response = <span class="hljs-keyword">await</span> call_next(request)
    end_time = time.time()
    response.headers[<span class="hljs-string">&#x27;X-Process-Time&#x27;</span>] = <span class="hljs-built_in">str</span>(end_time - start_time)
    <span class="hljs-keyword">return</span> response</code></pre></div>
<p>这样在给服务端发请求时：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120636748.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="corsmiddleware">CORSMiddleware</h2>
<p>针对前后端分离的软件项目开发方式，有一种称为 CORS （ Cross-Origin
Resource Sharing
，跨域资源共享）的机制，用于<strong>保护后端服务的安全</strong>。</p>
<p>这里所说的 <strong>域</strong> 指 HTTP
协议、主机名、端口的组合。多见于前端访问后端接口访问不通。</p>
<p>针对这种情况，我们可以如下操作：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.cors <span class="hljs-keyword">import</span> CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[<span class="hljs-string">&#x27;http://localhost:9000&#x27;</span>], <span class="hljs-comment"># 这里写前端访问的网址</span>
    allow_credentials=<span class="hljs-literal">True</span>,
    allow_methods=[<span class="hljs-string">&#x27;*&#x27;</span>],
    allow_headers=[<span class="hljs-string">&#x27;*&#x27;</span>],
)</code></pre></div>
<p>以下是 CORSMiddleware 的配置说明：</p>
<ul>
<li><code>allow_origins</code> ：允许跨域请求的源域列表，使用
<code>['*']</code> 代表允许任何源。</li>
<li><code>allow_origin_regex</code>
：使用正则表达式匹配的源允许跨域请求。</li>
<li><code>allow_methods</code> ：允许跨域请求的 HTTP 方法列表，默认为
<code>['GET']</code> ，可以使用 <code>['*']</code>
来允许所有标准方法。</li>
<li><code>allow_headers</code> ：允许跨域请求的 HTTP
请求头列表，默认为空，可以使用 <code>[*]</code> 来允许所有请求头。</li>
<li><code>allow_credentials</code> ：是否支持跨域请求用 cookies，默认
<code>False</code> 不支持。如果设置为 <code>True</code> ，则
<code>allow_origins</code> 不能为 <code>['*']</code> 。</li>
<li><code>expose_headers</code>
：指示可以被浏览器访问的响应信息头，默认为 <code>[]</code> 。</li>
<li><code>max_age</code> ：设定浏览器缓存 CORS
响应的最长事件，单位是秒，默认值为 600 。</li>
</ul>
<p>在不配置 CORSMiddleware 时，不允许任何跨域的访问。</p>
<h2 id="httpsredirectmiddleware">HTTPSRedirectMiddleware</h2>
<p>HTTPS 的全称为 Hyper Text Transfer Protocol over Secure Socket
Layer，通过安全套接字层的超文本传输协议，在 HTTP 上加入了 SSL 。</p>
<p>该中间件的作用是约束传入的请求地址必须是 HTTPS 开头，对于任何传入的以
HTTP 开头的请求地址，都将被重定向到 HTTPS 开头的地址上。</p>
<p>代码只需要一行：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.httpsredirect <span class="hljs-keyword">import</span> HTTPSRedirectMiddleware

app.add_middleware(HTTPSRedirectMiddleware)</code></pre></div>
<h2 id="trustedhostmiddleware">TrustedHostMiddleware</h2>
<p>这个中间件用来设置域名访问白名单，和 <code>CORSMiddleware</code>
类似：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.trustedhost <span class="hljs-keyword">import</span> TrustedHostMiddleware

app.add_middleware(TrustedHostMiddleware, allowed_hosts=[<span class="hljs-string">&#x27;baidu.com&#x27;</span>])</code></pre></div>
<p>这样设置后，只允许域名为 <code>baidu.com</code>
的主机访问，比如本地的 <code>127.0.0.1</code>
并不在白名单里，如果访问就会：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306121020121.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="gzipmiddleware">GZipMiddleware</h2>
<p>这个一个请求头有 <code>Accept-Encoding:GZip</code>
时，对响应数据进行压缩，再发送给客户端，客户端拿到响应，先解压缩的中间件，使用方法也很简单：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.gzip <span class="hljs-keyword">import</span> GZipMiddleware

app.add_middleware(GZipMiddleware, minimum_size=<span class="hljs-number">1000</span>)</code></pre></div>
<p>总的来说，中间件类似于一种通信预处理小工具，可以实现一些基础功能，避免重复造轮子，让开发者更专注于业务逻辑，更多可以看
<a target="_blank" rel="noopener" href="https://www.starlette.io/middleware/">Middleware -
Starlette</a> 。</p>
<h1 id="依赖注入">依赖注入</h1>
<p>依赖注入是指本来接收各种参数构造一个对象，现在只接收一个参数——已经实例化的对象，这样的话就不用关心这个对象的创建，销毁等问题。</p>
<h2 id="函数依赖注入">函数依赖注入</h2>
<p>假设有一个功能是返回参数名，这个功能很多接口都会用，那么我们就可以采用依赖注入的方式减少代码量，比如定义一个依赖函数返回参数名，然后在要用这个功能的接口里都指定依赖：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
	<span class="hljs-string">&quot;&quot;&quot; 定义依赖函数 &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> item


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> user

<span class="hljs-comment"># @app.get(&#x27;/items/&#x27;)</span>
<span class="hljs-comment"># async def read_item(name: Optional[str]):</span>
<span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name&#125;</span>


<span class="hljs-comment"># @app.get(&#x27;/users/&#x27;)</span>
<span class="hljs-comment"># async def read_user(name: Optional[str]):</span>
<span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name&#125;</span></code></pre></div>
<p>这里的这个 <code>depend_func</code>
就是依赖函数，而下面所注释的部分则是不使用依赖注入方式的接口。假设我现在一个新需求，返回
<code>name</code>
时还需要返回当前时间，对于依赖注入的方式，只需要修改依赖函数：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
	<span class="hljs-string">&quot;&quot;&quot; 定义依赖函数 &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name, <span class="hljs-string">&#x27;time&#x27;</span>:time.time()&#125;</code></pre></div>
<p>而对于不是依赖注入的方式则需要去两个接口里分别修改：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># @app.get(&#x27;/items/&#x27;)</span>
<span class="hljs-comment"># async def read_item(name: Optional[str]):</span>
<span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name, &#x27;time&#x27;:time.time()&#125;</span>


<span class="hljs-comment"># @app.get(&#x27;/users/&#x27;)</span>
<span class="hljs-comment"># async def read_user(name: Optional[str]):</span>
<span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name, &#x27;time&#x27;:time.time()&#125;</span></code></pre></div>
<p>这里共享代码逻辑的好处就体现出来了。</p>
<h2 id="类依赖注入">类依赖注入</h2>
<p>同样的方式可以将依赖函数封装成一个参数类，增加了代码的可读性。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DependClass</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.name = name


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">DependClass</span>)</span>):
    <span class="hljs-keyword">return</span> item


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">DependClass</span>)</span>):
    <span class="hljs-keyword">return</span> user</code></pre></div>
<h2 id="依赖注入的嵌套">依赖注入的嵌套</h2>
<p>像<a
href="##函数依赖注入">函数依赖注入</a>说到的时间功能，可以如下写：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func2</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func2</span>), need_time: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span></span>):
    <span class="hljs-keyword">if</span> need_time:
        <span class="hljs-keyword">return</span> &#123;**name, <span class="hljs-string">&#x27;time&#x27;</span>: time.time()&#125;
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> name


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> item


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> user</code></pre></div>
<p>这里 <code>read_item</code> 和 <code>read_user</code> 依赖了
<code>depend_func</code> ，而 <code>depend_func</code> 又依赖了
<code>depend_func2</code> ，可以看到返回参数名的逻辑其实并不是在
<code>depend_func</code> 里完成的，而是在 <code>depend_func2</code>
里完成的。</p>
<p>当程序用到的多个依赖项都依赖于某一个共同的子依赖项时，FastAPI
默认会在第一次执行这个子依赖项时，将其执行结果放在缓存中，以保证对路径操作函数的单次请求，无论定义了多少子依赖项，这个共同的子依赖项只会执行一次。如果不想将其结果放入缓存，可以把
<code>use_cache</code> 参数设置为 <code>False</code> 。</p>
<p>如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func, use_cache=<span class="hljs-literal">False</span></span>)</span>):
    <span class="hljs-keyword">return</span> item</code></pre></div>
<h2 id="装饰器中使用依赖注入">装饰器中使用依赖注入</h2>
<p>假设 <code>read_item</code> 和 <code>read_user</code> 在传入
<code>is_test='test'</code> 时都会抛出异常，而不需要
<code>is_test</code> 的返回值，那么这个依赖可以放在装饰器中，就像：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;定义依赖函数，请求参数依赖&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func_test</span>(<span class="hljs-params">is_test: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;定义依赖函数，装饰器中的依赖&quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> is_test == <span class="hljs-string">&#x27;test&#x27;</span>:
        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&#x27;This is the test&#x27;</span>)


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span>, dependencies=[Depends(<span class="hljs-params">depend_func_test</span>)]</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> item


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span>, dependencies=[Depends(<span class="hljs-params">depend_func_test</span>)]</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> user</code></pre></div>
<p>或者放到实例化 <code>FastAPI()</code> 对象中的
<code>dependencies</code> 参数中，也是一样的效果。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func_test</span>(<span class="hljs-params">is_test: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> is_test == <span class="hljs-string">&#x27;test&#x27;</span>:
        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&#x27;This is the test&#x27;</span>)


app = FastAPI(dependencies=[Depends(depend_func_test)])


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> item


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">return</span> user</code></pre></div>
<h2 id="依赖项中的-yield">依赖项中的 yield</h2>
<p>FastAPI 支持再依赖函数中使用 yield 替代
return，这样做的目的是在<strong>路径操作函数</strong>执行完成后，再执行一些其他操作。比较典型的应用场景是文件的读写，数据库会话连接。在
FastAPI 官方教程中 <a
target="_blank" rel="noopener" href="https://fastapi.tiangolo.com/tutorial/sql-databases/">SQL
(Relational) Databases - FastAPI</a> 里，有这样一段代码：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Dependency</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():
    db = SessionLocal()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> db
    <span class="hljs-keyword">finally</span>:
        db.close()	<span class="hljs-comment"># yield 的意义</span></code></pre></div>
<p>这里这个 <code>get_db</code>
实际上是一个依赖项，可能在路径操作函数中会依赖它。</p>
<p><strong>假设我们不在路径操作函数中依赖它，而在普通函数中依赖它，那么依赖它这个普通函数必须被路径操作函数依赖。简而言之就是依赖链顶端必须是
路径操作函数（否则会报错）。</strong></p>
<p>这样是可以的：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):
    <span class="hljs-keyword">return</span> db

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">pass</span></code></pre></div>
<p>这样却不可以：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):
    <span class="hljs-keyword">return</span> db

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">depend_func</span>)</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">或者是</span>
<span class="hljs-string">&quot;&quot;&quot;</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):
    <span class="hljs-keyword">pass</span></code></pre></div>
<p>因为这时 <code>read_test</code> 已经变为一个普通函数，如果想在
<code>read_test</code> 里使用 <code>get_db</code>
这个生成器，那么就要像使用生成器一样使用它：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = <span class="hljs-built_in">next</span>(<span class="hljs-params">get_db(<span class="hljs-params"></span>)</span>)</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">或者是</span>
<span class="hljs-string">&quot;&quot;&quot;</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>():
    <span class="hljs-keyword">for</span> db <span class="hljs-keyword">in</span> get_db():
    	<span class="hljs-keyword">pass</span></code></pre></div>
<h2 id="依赖类的可调用实例">依赖类的可调用实例</h2>
<p>依赖类本身是可调用的，但是如果想让类的实例也可调用，那么需要实现
<code>__call__</code> 这个方法：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DependClass</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.name = name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, q: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">if</span> q:
            <span class="hljs-keyword">return</span> self.name <span class="hljs-keyword">in</span> q
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">is_dog: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">DependClass(<span class="hljs-params"><span class="hljs-string">&#x27;dog&#x27;</span></span>)</span>), is_cat: <span class="hljs-built_in">bool</span> = Depends(<span class="hljs-params">DependClass(<span class="hljs-params"><span class="hljs-string">&#x27;cat&#x27;</span></span>)</span>)</span>):
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;is_dog&#x27;</span>: is_dog, <span class="hljs-string">&#x27;is_cat&#x27;</span>: is_cat&#125;</code></pre></div>
<p>结果如下：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306200447727.png" srcset="/img/loading.gif" lazyload /></p>
<h1 id="数据库操作">数据库操作</h1>
<h2 id="sqlalchemy">SQLAlchemy</h2>
<p>SQLAlchemy 是一个 ORM（ Object Relationship Mapping
，对象关系映射）工具，作用就是像操作对象一样（因为这样比较符合习惯）与数据库交互。在我另一篇文章
《SQLModel》 中那个框架其实就是基于 SQLAlchemy。</p>
<h2 id="连接-mysql">连接 MySQL</h2>
<p>像 PostgreSQL，SQLite 这些关系型数据库其实和 Mysql 差不多，这里以
Mysql 举例，主要是完成以下几件事情：</p>
<h3 id="连接数据库">连接数据库</h3>
<p>一般放在 <code>database.py</code>
文件中，代码一般就是负责建立连接：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine
<span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker
<span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base

SQLALCHEMY_DATABASE_URL = <span class="hljs-string">&quot;mysql://username:password@ipaddress:port/databse&quot;</span>

engine = create_engine(SQLALCHEMY_DATABASE_URL)

SessionLocal = sessionmaker(autocommit=<span class="hljs-literal">False</span>, bind=engine)

Base = declarative_base()</code></pre></div>
<ol type="1">
<li><p>定义连接地址与驱动</p>
<ul>
<li><p>```python SQLALCHEMY_DATABASE_URL =
"mysql://username:password@ipaddress:port/databse"
<div class="code-wrapper"><pre><code class="hljs markdown">
<span class="hljs-bullet">   -</span> 当然其实连接 MySQL 的驱动有很多种，比如 <span class="hljs-code">`mysqldb`</span> ，<span class="hljs-code">`pymysql`</span> 等等。这里可以用 <span class="hljs-code">```mysql+mysqldb://username:password@ipaddress:port/databse``` </span>这样的方式去选择。

<span class="hljs-bullet">   -</span> 另外，如果使用 SSH 的方式那么这一步可能还要复杂一点，原理就是首先要创建 SSH 连接，然后这里的 IP 与端口填写 SSH 映射的。

<span class="hljs-bullet">2.</span> 创建连接引擎

<span class="hljs-bullet">   -</span> <span class="hljs-code">```python</span>
<span class="hljs-code">     engine = create_engine(SQLALCHEMY_DATABASE_URL)</span></code></pre></div></p></li>
<li><p>熟悉 pandas 的应该知道这里这个引擎就是 <code>pd.read_sql()</code>
这个方法中需要的引擎。</p></li>
</ul></li>
<li><p>创建本地会话</p>
<ul>
<li>```python SessionLocal = sessionmaker(autocommit=False, bind=engine)
<div class="code-wrapper"><pre><code class="hljs autohotkey">
<span class="hljs-number">4</span>. 创建数据模型基类

   - ```python
     Base = declarative_base()</code></pre></div></li>
</ul></li>
</ol>
<p>一般 <code>database.py</code> 就放这些内容。</p>
<h3 id="创建-orm-数据模型">创建 ORM 数据模型</h3>
<p>数据模型一般写在 <code>models.py</code>
文件中，每个类其实就是数据库的一张表。</p>
<p>比如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Integer, String

<span class="hljs-keyword">from</span> .database <span class="hljs-keyword">import</span> Base <span class="hljs-comment"># 刚刚创建的 Base</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemModel</span>(<span class="hljs-title class_ inherited__">Base</span>):
    __tablename__ = <span class="hljs-string">&quot;item&quot;</span>
    
    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)
    name = Column(String)</code></pre></div>
<h3 id="创建-pydantic-数据模型">创建 Pydantic 数据模型</h3>
<p>用 Pydantic 实现的数据模型主要为了实现数据的读写操作，并提供 API
接口文档，一般写在 <code>schemas.py</code> 文件中。</p>
<p>比如：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemSchema</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>
    
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span></code></pre></div>
<p>在内部类 <code>Config</code> 中配置 <code>orm_mode = True</code>
的作用是让 Pydantic 模型可以从 ORM
模型读取数据，如果不写的话，只能从字典读取数据。</p>
<h3 id="实现-crud-操作">实现 CRUD 操作</h3>
<p>CRUD ：Create 增加，Read 查询，Update 更改，Delete
删除。也就是我们常说的增删改查。</p>
<p>一般写在 <code>crud.py</code> 文件中。</p>
<p>这里要遵循 SQLAlchemy 的方式去实现这几个操作，以单个 C R 为例。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">db: Session, item: ItemSchema</span>):
    db_item = ItemModel(name=item.name)
    
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    
    <span class="hljs-keyword">return</span> db_item

<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">db: Session</span>):
    <span class="hljs-keyword">return</span> db.query(ItemModel).first()</code></pre></div>
<p>具体使用 CRUD
操作的逻辑不写在这里，一般写在请求函数中。具体步骤一般如下：</p>
<ol type="1">
<li><p>导入所需模块。</p></li>
<li><p>```python Base.metadata.create_all(bind=engine)
<div class="code-wrapper"><pre><code class="hljs csharp">
   这段代码的作用是**生成数据库表**，这是 SQLAlchemy 提供的最简洁的方式。

<span class="hljs-number">3.</span> 使用依赖注入的方式将 `SessionLocal` 管理。

   ```<span class="hljs-function">python</span>
<span class="hljs-function">   def <span class="hljs-title">get_db</span>():</span>
<span class="hljs-function">       db</span> = SessionLocal()
       <span class="hljs-keyword">try</span>:
           <span class="hljs-keyword">yield</span> db
       <span class="hljs-keyword">finally</span>:
           db.close()</code></pre></div></p></li>
<li><p>根据业务需求定义路径操作函数。</p></li>
</ol>
<h2 id="连接-redis">连接 Redis</h2>
<h3 id="连接数据库-1">连接数据库</h3>
<p>类似关系型数据库，连接 Redis 同样采用依赖注入的方式：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rdb</span>():
    pool = ConnectionPool(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">6379</span>)
    rdb = Redis(connection_pool=pool)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> rdb
    <span class="hljs-keyword">finally</span>:
        rdb.close()</code></pre></div>
<h3 id="增加数据与更改数据">增加数据与更改数据</h3>
<p>增加和更改数据都只需要调用 <code>set</code> 方法就行了：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span>, response_model=Item</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_item</span>(<span class="hljs-params">item: Item, rdb: Redis = Depends(<span class="hljs-params">get_rdb</span>)</span>):
    rdb.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;test&#x27;</span>, json.dumps(item.<span class="hljs-built_in">dict</span>()))
    <span class="hljs-keyword">return</span> item</code></pre></div>
<h3 id="查询数据">查询数据</h3>
<p>查询数据需要调用 <code>get</code> 方法：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span>, response_model=Item</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_item</span>(<span class="hljs-params">rdb: Redis = Depends(<span class="hljs-params">get_rdb</span>)</span>):
    item = rdb.get(<span class="hljs-string">&#x27;test&#x27;</span>)
    <span class="hljs-keyword">return</span> json.loads(item)</code></pre></div>
<h3 id="删除数据">删除数据</h3>
<p>删除数据需要调用 <code>delete</code> 方法：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_item</span>(<span class="hljs-params">rdb: Redis = Depends(<span class="hljs-params">get_rdb</span>)</span>):
    rdb.delete(<span class="hljs-string">&#x27;test&#x27;</span>)</code></pre></div>
<h1 id="安全">安全</h1>
<h2 id="安全机制">安全机制</h2>
<h3 id="oauth-2-令牌授权安全机制">OAuth 2 令牌授权安全机制</h3>
<p>OAuth 2
是一个关于令牌授权的开放网络规范，主要特点是在资源使用者与资源提供者之间，建立一个认证服务器。流程如下：</p>
<ol type="1">
<li>资源使用者向资源提供者发起认证请求</li>
<li>资源提供者同意给予资源使用者授权</li>
<li>资源使用者使用上一步获得的授权，向认证服务器申请令牌</li>
<li>认证服务器对资源使用者进行认证成功后，向资源使用者发放<em>令牌</em></li>
<li>资源使用者借助令牌向资源服务器申请使用资源</li>
<li>资源服务器确认令牌正确后，向资源使用者开放受保护的资源</li>
</ol>
<p>其中最关键的是资源提供者如何给资源使用者授权，OAuth 2 定义了 4
种授权模式：</p>
<ul>
<li>授权码模式 -
先从资源提供者处申请授权码，根据授权码从认证服务器申请令牌。最常用。</li>
<li>隐藏模式 -
直接在请求种传递令牌，通过链接跳转的方式将令牌传递给另一个资源使用者。适合前端应用服务短期授权。</li>
<li>密码模式 - 资源使用者通过提供用户名合密码的方式申请令牌。适合提供
OAuth 2 认证的自身平台。</li>
<li>客户端凭证模式 - 通过交换凭证（应用
ID，应用密钥）的方式，获取认证信息和令牌。适合后端应用服务之间的授权。</li>
</ul>
<h3 id="openid-connect">OpenID Connect</h3>
<p>OpenID Connect 是一种基于 OAuth 2 的规范，是建立在 OAuth 2
协议上的一个简单的身份标识层，也就是说比起 OAuth 2
的<strong>访问令牌</strong>多了一个<strong>身份标识令牌</strong>。</p>
<h3 id="openapi">OpenAPI</h3>
<p>OpenAPI 是一套用于构建 API 的开放规范。在 OpenAPI
规范中，关于安全模式的类型有以下几种：</p>
<ul>
<li>APIKey - 用来通过查询参数、Header 参数、Cookie 参数传递密钥。</li>
<li>HTTP - 使用标准 HTTP 身份认证系统，包含三种类型：
<ol type="1">
<li>使用 Authorization 请求头，并且包含以 Bearer 开头的加密令牌。</li>
<li>使用 HTTP 标准身份认证。</li>
<li>使用 HTTP 摘要身份认证。</li>
</ol></li>
<li>OAuth 2 - 使用 OAuth 2 规范中定义的 4 种授权模式。</li>
<li>OpenID Connect - 使用 OpenID Connect 规范进行认证。</li>
</ul>
<p>FastAPI 基于 OpenAPI 规范构建了自动交互式文档。</p>
<h2 id="基于-oauth-2-的安全机制">基于 OAuth 2 的安全机制</h2>
<h3 id="jwt-token-bearer">JWT Token &amp; Bearer</h3>
<p>JWT（Json Web Tokens）是一种安全标准，将 JSON
对象编入一个没有空格的长字符串中。</p>
<p>我们这里使用 <code>python-jose</code> 包实现。</p>
<p>在没有 Token 认证时，我们用于记录一个用户可能会用到以下函数：</p>
<ul>
<li><code>get_db</code> - 依赖函数，用于 FastAPI
和数据库有交互时连接的建立。</li>
<li><code>create_user</code> - 新建一个用户。</li>
<li><code>get_user</code> - 查询一个用户。</li>
</ul>
<p>这时我们遇到一个问题，就是其实我们并不知道当前用户是谁。当我们需要提供差异化服务时，我们就做不到。因此，我们需要对每个用户进行一个身份认证。思路如下：</p>
<ul>
<li>创建一个工具函数用于 hash
用户的密码，也就是加盐。那么由于密码已经加盐，我们就需要再创建一个工具函数用于校验接收的密码是否与存储的
hash value
匹配。这两个函数是为了认证并返回用户，具体的功能还需要一个工具函数实现。这一步统称为密码加盐相关处理。</li>
<li>配置 JWT 令牌签名，包括算法、令牌过期时间。创建一个工具函数用于生成
token 的编码与解码。</li>
<li>在业务相关模块用到上面 2 个模块实现业务逻辑。</li>
</ul>
<h4 id="密码-hash-相关">密码 Hash 相关</h4>
<p>密码加盐指存储密码散列形式而不是明文，这样做提高了密码的安全性。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session
<span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext

_pwd_context = CryptContext(schemes=[<span class="hljs-string">&#x27;bcrypt&#x27;</span>], deprecated=<span class="hljs-string">&#x27;auto&#x27;</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_password</span>(<span class="hljs-params">plain_password: <span class="hljs-built_in">str</span>, hashed_password: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> _pwd_context.verify(plain_password, hashed_password)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_password_hash</span>(<span class="hljs-params">password</span>):
    <span class="hljs-keyword">return</span> _pwd_context.<span class="hljs-built_in">hash</span>(password)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate_user</span>(<span class="hljs-params">db: Session, username: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>):
    user = read_user(db=db, username=username)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> verify_password(password, user.hashed_password):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> user</code></pre></div>
<p>用 <code>passlib</code> 包可以实现密码加盐与校验密码。</p>
<ul>
<li><code>get_password_hash</code> - 实现了对来自用户的密码进行 hash
处理。</li>
<li><code>verify_password</code> -
实现了验证收到的密码是否与存储的哈希值相符。</li>
<li><code>authenticate_user</code> - 认证并返回用户，可以看到这里是根据
<code>username</code> 与 <code>password</code> 查询。</li>
</ul>
<h4 id="jwt-相关">JWT 相关</h4>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta
<span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwt

SECRET_KEY = <span class="hljs-string">&quot;b8f7673c0929ee8fa7e9974ba7fbd3e999f2a526189dab012258381c4a044dd7&quot;</span>
ALGORITHM = <span class="hljs-string">&quot;HS256&quot;</span>
ACCESS_TOKEN_EXPIRE_MINUTES = <span class="hljs-number">5</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_token</span>(<span class="hljs-params">data: <span class="hljs-built_in">dict</span></span>):
    to_encode = data.copy()
    expries_delta = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    expire = datetime.utcnow() + expries_delta
    to_encode.update(&#123;<span class="hljs-string">&#x27;exp&#x27;</span>: expire&#125;)
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    <span class="hljs-keyword">return</span> encoded_jwt


<span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_token</span>(<span class="hljs-params">token: <span class="hljs-built_in">str</span></span>):
    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    <span class="hljs-keyword">return</span> payload.get(<span class="hljs-string">&#x27;username&#x27;</span>)</code></pre></div>
<ul>
<li><p><code>create_token</code> -
这里我们可以看到，生成令牌的逻辑其实就是 <code>jwt.encode</code>
一个函数，为了设置过期时间，这里需要将一个 <code>datetime</code>
对象（过期的时间点，这里实现方式是当前时间 <code>datetime</code>
对象加上时间偏移 <code>timedelta</code> 对象）作为 value 传入到名为
<code>exp</code> 的 key 中。然后 <code>jwt.encode</code>
会返回一个长字符串，也就是令牌。官方文档的方式是把过期时间作为函数参数传入，这样也不错。</p>
<p>这里需要注意的是，由于时区问题的存在，<code>jose</code>
源码里有一段：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> time_claim <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;exp&quot;</span>, <span class="hljs-string">&quot;iat&quot;</span>, <span class="hljs-string">&quot;nbf&quot;</span>]:
    <span class="hljs-comment"># Convert datetime to a intDate value in known time-format claims</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(claims.get(time_claim), datetime):
        claims[time_claim] = timegm(claims[time_claim].utctimetuple())</code></pre></div>
<p>很显然这个包是把这个 <code>datetime</code> 对象当作 <code>utc</code>
时间来处理，所以我们在生成时间的时候一定要用
<code>datetime.utcnow()</code> 而不是 <code>datetime.now()</code>
。</p></li>
<li><p><code>extract_token</code> -
令牌的解码很简单，直接调用即可，<code>jose</code> 源码里有一个函数叫
<code>_validate_exp</code>
是来验证令牌是否过期的，如果过期就会抛出异常，所以我们在这里不需要自己处理令牌过期问题。</p></li>
</ul>
<h4 id="业务逻辑相关">业务逻辑相关</h4>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    access_token: <span class="hljs-built_in">str</span>
    token_type: <span class="hljs-built_in">str</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBase</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    username: <span class="hljs-built_in">str</span>
    email: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    full_name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span></code></pre></div>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.security <span class="hljs-keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm
<span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> JWTError
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="hljs-string">&quot;login&quot;</span>)

<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/login/&#x27;</span>, response_model=schemas.Token</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">form: OAuth2PasswordRequestForm = Depends(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):
    user = services.authenticate_user(db, form.username, form.password)

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:
        <span class="hljs-keyword">raise</span> HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=<span class="hljs-string">&#x27;Username or password is invalid.&#x27;</span>)
    access_token = services.create_token(data=&#123;<span class="hljs-string">&#x27;username&#x27;</span>: user.username&#125;)

    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;access_token&#x27;</span>: access_token, <span class="hljs-string">&#x27;token_type&#x27;</span>: <span class="hljs-string">&#x27;bearer&#x27;</span>&#125;

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&#x27;</span>, response_model=schemas.User</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_current_user</span>(<span class="hljs-params">token: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">oauth2_scheme</span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):
    invalid_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                      detail=<span class="hljs-string">&#x27;Username or password is invalid.&#x27;</span>)
    <span class="hljs-keyword">try</span>:
        username: <span class="hljs-built_in">str</span> = services.extract_token(token)
        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> invalid_exception
    <span class="hljs-keyword">except</span> JWTError:
        <span class="hljs-keyword">raise</span> invalid_exception
    user = services.read_user(db, username=username)
    <span class="hljs-keyword">if</span> user <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">raise</span> invalid_exception
    <span class="hljs-keyword">return</span> user</code></pre></div>
<p>这里有两个接口，<code>login</code> 和 <code>get_current_user</code>
：</p>
<ul>
<li><code>login</code> -
业务逻辑是，首先校验用户名和密码（登陆），校验成功后发放令牌。</li>
<li><code>get_current_user</code> -
从令牌里拿到用户名，根据用户名去数据库查询用户相关信息。</li>
</ul>
<h1 id="异步">异步</h1>
<p>理解异步需要先理解几个概念：</p>
<h2 id="进程与线程">进程与线程</h2>
<ul>
<li>进程 / Process -
进程是计算机<strong>资源分配和调度</strong>的最小单位。所以不同进程之间的数据是不共享的，需要通过网络通信比如
TCP/IP 端口通信实现资源共享。</li>
<li>线程 / Thread -
线程是计算机<strong>运算调度</strong>的最小单位。所以不同线程之间的数据是有可能共享的（处在同一个进程时），此时通过共享内存可实现线程间的通信。</li>
</ul>
<h2 id="阻塞与非阻塞">阻塞与非阻塞</h2>
<ul>
<li>阻塞 / Blocking -
阻塞是指一个线程所访问的资源被其他线程占用时，需要等待其他线程完成操作，<strong>在等待期间该线程自身无法继续其他操作</strong>，常见的阻塞有：网络
I/O 、磁盘 I/O 、用户输入阻塞。</li>
<li>非阻塞 / Non-Blocking -
非阻塞是指线程在等待其他线程过程中，自身不被阻塞，<strong>等待期间可以执行其他操作</strong>。</li>
</ul>
<h2 id="同步与异步">同步与异步</h2>
<ul>
<li>同步 / Synchronous -
同步是指为了完成某个操作，多个线程必须按照特定的通信方式协调一致，<strong>按顺序执行，前面的执行完了，后面才能执行</strong>。</li>
<li>异步 / Asynchronous -
异步是指为了完成某个操作，无需特定的通信方式协调也可完成任务的方式。</li>
</ul>
<p>这里提到的通信方式，通常有：</p>
<ul>
<li>信号量 - 用于控制并发的数量。比如某个网站一秒内只能接收本机 500
次访问，那么为了避免网站服务器压力过大，可以在客户端使用信号量做控制。</li>
<li>锁 -
确保并发时数据安全。比如两个线程一起访问一个数，逻辑都为如果此数为奇数，则加一否则不变。当一个数原本是奇数时，两个线程同时访问（或者说一个线程访问时另外个线程正在加一，但还没加上去），最后结果是奇数，这种就是数据不安全。可以通过在线程访问时加一个锁，等访问完毕加一完毕释放此锁达保证数据安全。</li>
<li>同步队列 - 一个自带锁的队列。</li>
</ul>
<h2 id="并发与并行">并发与并行</h2>
<ul>
<li>并发 / Concurrency - 看起来同时执行。</li>
<li>并行 / Parallelism - 实际上同时执行。</li>
</ul>
<h2 id="gil">GIL</h2>
<p>Python
是一种动态解释型语言。动态指值的类型是在运行时确定，解释指不需要编译直接运行。运行
<code>.py</code> 文件的代码需要一个 Python 解释器。</p>
<p>GIL 全称 Global Interpreter Lock
，全局解释器锁，是一种全局互斥锁。作用是每个线程在执行的过程中都需要先获取
GIL ，保证同一时刻只有一个线程能控制 Python
解释器。好处显然是保证了数据的线程安全，坏处就是效率比较低，没有充分运用
CPU 多核的优势。</p>
<p>但是值得注意的是，并不是有了 GIL 就没有多线程这一说了，比如网络 I/O
的典型应用爬虫一样可以多线程执行。另外，协程的出现很好的解决了性能损失的问题。</p>
<h2 id="协程-coroutine">协程 / Coroutine</h2>
<p>协程成为微线程，是一种用户态的轻量级线程，也就是操作系统是没有协程这个概念的，是用户自己在用类似多线程的方式进行任务的切换以实现并发目的。</p>
<p>Python 中有一个库叫 <code>Asyncio</code>
，要使用这个库要理解几个概念以及用法。因为我本人主要是从事数据方面的工作，时常用到
<code>jupyter notebook</code> ，在那里面想正常使用需要：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nest_asyncio

nest_asyncio.apply()</code></pre></div>
<h3 id="事件循环">事件循环</h3>
<p>事件循环时每个异步应用的核心，用于管理异步任务和回调、执行网络 I/O
操作，以及运行子线程等等。大概类似于一个包含很多任务的循环队列。</p>
<div class="code-wrapper"><pre><code class="hljs python">loop = asyncio.get_event_loop()</code></pre></div>
<p>事件循环可以这样拿到。</p>
<h3 id="协程">协程</h3>
<p>协程本质上是一个函数，特点是在代码块中可以将执行权交给其他协程。当调用协程函数时，不会立即执行，而是返回一个协程对象。需要将协程对象注册到事件循环当中，由事件循环负责调用。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>, time.time())
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>, time.time())


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">await</span> test()
    <span class="hljs-keyword">await</span> test()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:
    asyncio.run(main())</code></pre></div>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306261339057.png" srcset="/img/loading.gif" lazyload /></p>
<p>这里可以看到实际上，这两个协程并没有并发执行。那么如果要让他们并发执行，则需要任务。</p>
<h3 id="任务">任务</h3>
<p>在事件循环中，使用 Task 对象运行协程，Task
对象可以说是顾名思义，就是一个任务，比如刚刚那个 <code>test</code>
协程如果想并发执行，可以：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>, time.time())
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>, time.time())


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    task1 = asyncio.create_task(test())
    task2 = asyncio.create_task(test())

    <span class="hljs-keyword">await</span> task1
    <span class="hljs-keyword">await</span> task2


asyncio.run(main())</code></pre></div>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306261340442.png" srcset="/img/loading.gif" lazyload /></p>
<p>可以看到用 <code>asyncio.create_task()</code> 可以创建 Task
对象。也可以先去拿到事件循环 <code>event_loop</code> ，再用
<code>loop.create_task()</code> 创建 Task 对象。</p>
<p>有时遇到多个任务我们可以往 <code>list</code> 里添加 <code>task</code>
，然后用 <code>asyncio.wait(task_list)</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>, time.time())
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>, time.time())


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    task_list = []
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):
        task_list.append(asyncio.create_task(test()))

    <span class="hljs-keyword">await</span> asyncio.wait(task_list)


asyncio.run(main())</code></pre></div>
<h3 id="future">Future</h3>
<p>一个 Future
对象代表一个异步操作的最终结果，是一个比较底层的东西。</p>
<p>关于异步这块，我个人觉得有必要直接读官方的文档：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html">Coroutines
and Tasks — Python 3.11.4 documentation</a></li>
<li><a
target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-future.html">Futures —
Python 3.11.4 documentation</a></li>
</ul>
<h1 id="应用管理">应用管理</h1>
<h2 id="配置项管理">配置项管理</h2>
<h3 id="环境变量">环境变量</h3>
<p>在 Windows 系统中设置环境变量和打印环境变量如下所示：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270435936.png" srcset="/img/loading.gif" lazyload /></p>
<p>但是这样做似乎并没有保存，如果想要保存，可以从 <em>我的电脑 - 属性 -
高级系统设置 - 高级 - 环境变量</em>
这里去设置环境变量，举个例子，假设安装了 JAVA ，很有可能配置了名为
<code>JAVA_HOME</code> 的环境变量。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> os.getenv(<span class="hljs-string">&#x27;JAVA_HOME&#x27;</span>)</code></pre></div>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270505462.png" srcset="/img/loading.gif" lazyload /></p>
<p>有时为了安全性考虑，可能会把密钥存储在环境变量中。</p>
<h3 id="配置">配置</h3>
<p>在 Pydantic 中，前面已经使用了 <code>BaseModel</code>
作为数据类的基类，另外还有一个 <code>BaseSettings</code>
可以用作配置。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseSettings


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>(<span class="hljs-title class_ inherited__">BaseSettings</span>):
    verson: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;0.1.0a&#x27;</span>


settings = Settings()
app = FastAPI()


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: settings.verson&#125;</code></pre></div>
<p>作为一个类，每次在使用的时候需要实例化。</p>
<h2 id="应用事件处理">应用事件处理</h2>
<h3 id="程序启动事件">程序启动事件</h3>
<p>有参装饰器 <code>app.on_event()</code> 传入参数 <code>startup</code>
即可。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;startup&quot;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_log</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FastAPI start&#x27;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;=&#x27;</span>))</code></pre></div>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270519403.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="程序停止事件">程序停止事件</h3>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;shutdown&quot;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">end_log</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FastAPI shutdown&#x27;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;=&#x27;</span>))</code></pre></div>
<p>当 FastAPI
应用程序被停止时，会执行所有停止事件。但与启动事件不同，如果停止事件执行失败，不会影响应用程序的关闭过程。所以，尽量不要在停止事件中写入耗时或者是特别重要的操作。</p>
<h2 id="应用挂载">应用挂载</h2>
<p>FastAPI 提供了一种方式，可以用一个主应用管理各个子应用，这个过程称为
<strong>挂载</strong> 。挂载可以通过 <code>app.mount()</code> 实现。</p>
<div class="code-wrapper"><pre><code class="hljs python">app = FastAPI()

test1_app = FastAPI()
test2_app = FastAPI()

app.mount(<span class="hljs-string">&#x27;/test1&#x27;</span>, test1_app)
app.mount(<span class="hljs-string">&#x27;/test2&#x27;</span>, test2_app)


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-string">&#x27;main app&#x27;</span>&#125;


<span class="hljs-meta">@test1_app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-string">&#x27;test1 app&#x27;</span>&#125;


<span class="hljs-meta">@test2_app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-string">&#x27;test2 app&#x27;</span>&#125;</code></pre></div>
<p>然后这三个接口的访问方式及结果为：</p>
<p>主接口：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270528429.png" srcset="/img/loading.gif" lazyload /></p>
<p>test1 接口：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270529686.png" srcset="/img/loading.gif" lazyload /></p>
<p>test2 接口：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270530840.png" srcset="/img/loading.gif" lazyload /></p>
<p>当挂载对象是外部应用，比如 Flask 应用时，可以使用
<code>WSGIMiddleware</code> 中间件：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> fastapi.middleware.wsgi <span class="hljs-keyword">import</span> WSGIMiddleware

<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask

app = FastAPI()
flaskapp = Flask(__name__)

app.mount(<span class="hljs-string">&#x27;/flask&#x27;</span>, WSGIMiddleware(flaskapp))</code></pre></div>
<h2 id="路由管理">路由管理</h2>
<p>在真实的应用程序中，会有几十个甚至上百个路由，如果都放在
<code>main.py</code> 中，那么主文件会非常复杂，可以使用
<code>APIRouter</code> 这个路由类抽离出来。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, APIRouter

app = FastAPI()

openapi = APIRouter(
    prefix=<span class="hljs-string">&#x27;/openapi&#x27;</span>,
    tags=[<span class="hljs-string">&#x27;openapi&#x27;</span>],
    dependencies=[],
    responses=&#123;<span class="hljs-number">404</span>: &#123;
        <span class="hljs-string">&#x27;detail&#x27;</span>: <span class="hljs-string">&#x27;Not Found&#x27;</span>
    &#125;&#125;,
)


<span class="hljs-meta">@openapi.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;


app.include_router(openapi)</code></pre></div>
<p>可以看到，这样 <code>/openapi/</code> 这个接口就被分离出来了。</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270547196.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="目录结构管理">目录结构管理</h2>
<p>在实际项目中，一般由团队成员共同讨论决定目录结构，也没有说哪种方式就是最好的。</p>
<p>这里可以参考一下 FastAPI 这个框架作者给的一个全栈项目 <a
target="_blank" rel="noopener" href="https://github.com/tiangolo/full-stack-fastapi-postgresql">Full
Stack FastAPI and PostgreSQL - Base Project Generator</a>
中后端部分的目录结构。</p>
<ul>
<li>app
<ul>
<li><code>main.py</code> - 主文件</li>
<li>api
<ul>
<li>routers - Router</li>
<li>errors - Error</li>
<li>dependencies - 依赖</li>
</ul></li>
<li>core
<ul>
<li>setting - 综合设置</li>
<li>database - 数据库相关设置</li>
<li>security - 安全设置</li>
</ul></li>
<li>services - 业务逻辑</li>
<li>crud - 数据库的各种操作</li>
<li>models - 数据库模型</li>
<li>schemas - 数据模型</li>
</ul></li>
</ul>
<h1 id="模板">模板</h1>
<p>FastAPI
是一个服务器端框架，主要用于提供服务器端的数据接口，但在某些场景下，仍然需要使用传统的页面模板技术，提供
Web 界面（前后端不分离）。</p>
<p>接口函数的主要作用是处理业务逻辑返回响应。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。使用模板后，由模板负责渲染表现内容，后端接口负责处理业务逻辑。</p>
<p>模板仅仅是文本文件。它可以生成任何基于文本的格式（ HTML 、 XML 、 CSV
、 LaTex 等等）。 它并没有特定的扩展名， <code>.html</code> 或
<code>.xml</code> 都是可以的。</p>
<p>这里介绍一下 Jinja2 这个模板的使用。详情可参考 <a
target="_blank" rel="noopener" href="https://jinja.palletsprojects.com/en/3.1.x/templates/">Template
Designer Documentation — Jinja Documentation (3.1.x)</a>
这份官方文档。</p>
<h2 id="注释">注释</h2>
<div class="code-wrapper"><pre><code class="hljs clean">&#123;# 注释 #&#125;</code></pre></div>
<h2 id="变量">变量</h2>
<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">变量名</span> &#125;&#125;</span></code></pre></div>
<p>最终在文件或网页中，这里可以直接得到变量值。</p>
<h2 id="转义">转义</h2>
<div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">raw</span> %&#125;</span><span class="language-xml"></span>
<span class="language-xml">	这部分不会被转义</span>
<span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endraw</span> %&#125;</span></code></pre></div>
<h2 id="循环">循环</h2>
<div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> list %&#125;</span><span class="language-xml"></span>
<span class="language-xml">	</span><span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span><span class="language-xml"></span>
<span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span></code></pre></div>
<h2 id="条件-if">条件 IF</h2>
<div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> item is not None %&#125;</span><span class="language-xml"></span>
<span class="language-xml">	</span><span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span><span class="language-xml"></span>
<span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span></code></pre></div>
<h2 id="作用域with">作用域With</h2>
<div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">with</span></span> name = test %&#125;</span><span class="language-xml"></span>
<span class="language-xml">	</span><span class="hljs-template-variable">&#123;&#123; name &#125;&#125;</span><span class="language-xml"></span>
<span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endwith</span></span> %&#125;</span></code></pre></div>
<h2 id="fastapi-应用-jinja2">FastAPI 应用 Jinja2</h2>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request
<span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse
<span class="hljs-keyword">from</span> fastapi.templating <span class="hljs-keyword">import</span> Jinja2Templates

app = FastAPI()

templates = Jinja2Templates(directory=<span class="hljs-string">&#x27;templates&#x27;</span>)


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=HTMLResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request: Request, input_str: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Hello World !&#x27;</span></span>):
    <span class="hljs-keyword">return</span> templates.TemplateResponse(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;request&#x27;</span>: request, <span class="hljs-string">&#x27;input_str&#x27;</span>: input_str&#125;)</code></pre></div>
<p>后端代码如上所示，不难看出，当用户请求 <code>index</code>
这个接口的时候，接口返回的数据是 <code>request</code> 和
<code>input_str</code> ，到 <code>index.html</code>
这个文件中，那么再来看下这个前端文件的具体内容：</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&#123;&#123; request &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; input_str &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>
<p>这里这个 <code>request</code> 和 <code>input_str</code>
其实就是接口给的，最终效果如下：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270743752.png" srcset="/img/loading.gif" lazyload /></p>
<p>我们可以用 <code>StaticFiles</code> 挂载静态资源比如 CSS
文件，例如：</p>
<p>后端 <code>main.py</code> ：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request
<span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse
<span class="hljs-keyword">from</span> fastapi.templating <span class="hljs-keyword">import</span> Jinja2Templates
<span class="hljs-keyword">from</span> fastapi.staticfiles <span class="hljs-keyword">import</span> StaticFiles

app = FastAPI()
app.mount(<span class="hljs-string">&#x27;/static&#x27;</span>, StaticFiles(directory=<span class="hljs-string">&#x27;static&#x27;</span>), name=<span class="hljs-string">&#x27;static&#x27;</span>)
templates = Jinja2Templates(directory=<span class="hljs-string">&#x27;templates&#x27;</span>)


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=HTMLResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request: Request, input_str: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Hello World !&#x27;</span></span>):
    <span class="hljs-keyword">return</span> templates.TemplateResponse(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;request&#x27;</span>: request, <span class="hljs-string">&#x27;input_str&#x27;</span>: input_str&#125;)</code></pre></div>
<p>HTML 文件 <code>templates/index.html</code> ：</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&#123;&#123; request &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, path=&#x27;/style.css&#x27;) &#125;&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; input_str &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>
<p>CSS 文件 <code>static/style.css</code> ：</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;
    <span class="hljs-attribute">font-style</span>: italic;
    <span class="hljs-attribute">text-align</span>: center;
&#125;</code></pre></div>
<p>最终可以得到效果：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270752899.png" srcset="/img/loading.gif" lazyload /></p>
<h1 id="测试">测试</h1>
<h1 id="部署">部署</h1>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ComputerScience/" class="category-chain-item">ComputerScience</a>
  
  
    <span>></span>
    
  <a href="/categories/ComputerScience/Python/" class="category-chain-item">Python</a>
  
  
    <span>></span>
    
  <a href="/categories/ComputerScience/Python/Backend/" class="category-chain-item">Backend</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/python/">#python</a>
      
        <a href="/tags/fastapi/">#fastapi</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>FastAPI</div>
      <div>https://movisli.github.io/2023/06/20/FastAPI/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>MovisLi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 20, 2023</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/28/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/" title="《消费信用模型：定价、利润与组合》 - 读书笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《消费信用模型：定价、利润与组合》 - 读书笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/16/matplotlib%E4%B8%8Eseaborn/" title="matplotlib&amp;seaborn 包的学习">
                        <span class="hidden-mobile">matplotlib&amp;seaborn 包的学习</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://unpkg.com/mathjax@3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>

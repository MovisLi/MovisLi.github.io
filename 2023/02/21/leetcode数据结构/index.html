

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#414142">
  <meta name="author" content="MovisLi">
  <meta name="keywords" content="ComputerScience, DataScience, Economics&amp;Finance, Management">
  
    <meta name="description" content="数据结构入门 数组 217. 存在重复元素 简单 set 来判断是否有元素重复。 class Solution:     def containsDuplicate(self, nums: List[int]) -&gt; bool:         hashset &#x3D; set(&amp;#x27;&amp;#x27;)         for i in nums:             if i no">
<meta property="og:type" content="article">
<meta property="og:title" content="「数据结构」 - 学习计划">
<meta property="og:url" content="https://movisli.github.io/2023/02/21/leetcode%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="movis">
<meta property="og:description" content="数据结构入门 数组 217. 存在重复元素 简单 set 来判断是否有元素重复。 class Solution:     def containsDuplicate(self, nums: List[int]) -&gt; bool:         hashset &#x3D; set(&amp;#x27;&amp;#x27;)         for i in nums:             if i no">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-21T15:33:41.000Z">
<meta property="article:modified_time" content="2024-06-07T08:32:58.968Z">
<meta property="article:author" content="MovisLi">
<meta property="article:tag" content="python">
<meta property="article:tag" content="stack">
<meta property="article:tag" content="linked list">
<meta property="article:tag" content="array">
<meta property="article:tag" content="tree">
<meta property="article:tag" content="queue">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>「数据结构」 - 学习计划 - movis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"movisli.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Movis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="「数据结构」 - 学习计划"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        MovisLi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-21 23:33" pubdate>
          February 21, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          45k words
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">「数据结构」 - 学习计划</h1>
            
            <div class="markdown-body">
              
              <h1 id="数据结构入门">数据结构入门</h1>
<h2 id="数组">数组</h2>
<h3 id="存在重复元素">217. 存在重复元素</h3>
<p>简单 set 来判断是否有元素重复。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                hashset.add(i)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="最大子数组和">53. 最大子数组和</h3>
<p>首先数组限定了必有至少 1 个元素，那么我们可以假设最大子数和
<code>max_sum</code> 等于数组第 1 个元素。</p>
<p>这时我们思考，假如数组中有一段是最大子数和，那么其左右肯定是 0 或者比
0 小的子数和，所以我们可以定义一个 <code>temp_sum</code> ，初始化为 0
，遍历子数并累加，当它小于 0 时，把它置 0
（代表从这开始不加了），当它大于 <code>max_sum</code>
时，<code>max_sum = temp_sum</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        max_sum = nums[<span class="hljs-number">0</span>]
        temp_sum = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            temp_sum += i
            <span class="hljs-keyword">if</span> temp_sum &gt; max_sum:
                max_sum = temp_sum
            <span class="hljs-keyword">if</span> temp_sum &lt; <span class="hljs-number">0</span>:
                temp_sum = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> max_sum</code></pre></div>
<h3 id="两数之和">1. 两数之和</h3>
<p>可以建立一个 <code>dict</code>
来记录数组遍历过的值和它的下标，这样每次遍历到一个数时，看一下
<code>target-x</code> 是否在 <code>dict</code>
里就可以找到之前出现的数和这个数的和等于 <code>target</code> 的。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):
            temp = target - v
            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">in</span> hashmap:
                <span class="hljs-keyword">return</span> [hashmap[temp], i]
            <span class="hljs-keyword">else</span>:
                hashmap[v] = i
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="合并两个有序数组">88. 合并两个有序数组</h3>
<p>这道题需要反着来，从 <code>nums1</code>
后面开始放数，优先放大的数，这个不是很容易想到。放的过程中有 4
种情况：</p>
<table>

<thead>
<tr class="header">
<th>Situation</th>
<th>Operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>两数组都没放完 <code>nums2</code> 的大</td>
<td>放 <code>nums2</code> 的数， <code>nums2</code> 的指针左移。</td>
</tr>
<tr class="even">
<td>两数组都没放完 <code>nums1</code> 的大</td>
<td>放 <code>nums1</code> 的数， <code>nums1</code> 的指针左移。</td>
</tr>
<tr class="odd">
<td><code>nums1</code> 的数放完了</td>
<td>放 <code>nums2</code> 的数， <code>nums2</code> 的指针左移。</td>
</tr>
<tr class="even">
<td><code>nums2</code> 的数放完了</td>
<td>不用放 <code>nums1</code> 的数了因为本来就在里面，跳出循环。</td>
</tr>
</tbody>
</table>
<p>所以其实跳出循环的条件就是 <code>nums2</code>
的数放完了，剩下的情况里只有两数组都没放完 <code>nums1</code>
的大这种情况需要放 <code>nums1</code> 的数，因此：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">while</span> n &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> m&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums1[m-<span class="hljs-number">1</span>] &gt; nums2[n-<span class="hljs-number">1</span>]:
                nums1[m+n-<span class="hljs-number">1</span>] = nums1[m-<span class="hljs-number">1</span>]
                m -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                nums1[m+n-<span class="hljs-number">1</span>] = nums2[n-<span class="hljs-number">1</span>]
                n -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="两个数组的交集-ii">350. 两个数组的交集 II</h3>
<p>用两个 <code>dict</code>
分别计数数组中每个数出现的次数，然后遍历其中一个 <code>dict</code>
，如果数满足两个 <code>dict</code> 里 <code>key</code> 都有取
<code>value</code> 的最小值，然后将 <code>value</code> 个
<code>key</code> 加入结果。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersect</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        counter1 = &#123;&#125;
        counter2 = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> counter1:
                counter1[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                counter1[i] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> counter2:
                counter2[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                counter2[i] += <span class="hljs-number">1</span>
        res = []
        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> counter1.items():
            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> counter2:
                t = <span class="hljs-built_in">min</span>(v, counter2[k])
                res += [k]*t
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h3>
<p>动态规划的入门题，卖是建立在买的基础上的。在找到买入更低点时更新最大利润直到找到下个买入最低点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        price_min = <span class="hljs-number">1e5</span>
        profit_max = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:
            <span class="hljs-keyword">if</span> i &lt; price_min:
                price_min = i
            <span class="hljs-keyword">if</span> i-price_min &gt; profit_max:
                profit_max = i-price_min
        <span class="hljs-keyword">return</span> profit_max</code></pre></div>
<h3 id="重塑矩阵">566. 重塑矩阵</h3>
<p>比较直观的解法，假设有一个点 <code>(a,b)</code> 在源矩阵
<code>m*n</code> 里面，如果源矩阵用一维数组表示，那么它的位置就是
<code>b+a*n</code> ，对于一个新矩阵 <code>r*c</code> 来讲，它对应
<code>r</code> 的位置就应该是 <code>((b+a*n)//c, (b+a*n)%c)</code>
这个点：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        m = <span class="hljs-built_in">len</span>(mat)
        <span class="hljs-keyword">if</span> m*n != r*c:
            <span class="hljs-keyword">return</span> mat
        res = [[<span class="hljs-number">0</span>]*c <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r)]
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                res[(col+row*n)//c][(col+row*n)%c] = mat[row][col]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>这里我们用了两层循环，其实如果用一维数组做循环也可以，重点变成双方都找
<code>(loc//column, loc%column)</code> 的位置了：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])
        m = <span class="hljs-built_in">len</span>(mat)
        <span class="hljs-keyword">if</span> m*n != r*c:
            <span class="hljs-keyword">return</span> mat
        res = [[<span class="hljs-number">0</span>]*c <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r)]
        <span class="hljs-keyword">for</span> loc <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m*n):
                res[loc//c][loc%c] = mat[loc//n][loc%n]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="杨辉三角">118. 杨辉三角</h3>
<p>又是一道考察多维数组的题，我们可以模拟题目描述中的动画：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = [[<span class="hljs-number">1</span>]]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows-<span class="hljs-number">1</span>):
            temp = [<span class="hljs-number">1</span>]
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res[-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>):
                temp.append(res[-<span class="hljs-number">1</span>][k]+res[-<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>])
            temp += [<span class="hljs-number">1</span>]
            res.append(temp)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>然后我们也可以想象下这个假如是个二维数组坐标系：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>col</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>row</strong></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>1</td>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>1</td>
<td>4</td>
<td>6</td>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>在 <code>row-col</code> 坐标系上非行首行尾点 <code>(a,b)</code>
其实等于 <code>(a-1, b-1)+(a-1, b)</code> ：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = [[<span class="hljs-number">1</span>]*(row+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows)]
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, numRows):
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, row):
                res[row][col] = res[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>]+res[row-<span class="hljs-number">1</span>][col]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="有效的数独">36. 有效的数独</h3>
<p>我们首先遍历一遍数独，得到一个每个数的存储信息的 <code>dict</code>
：</p>
<ul>
<li><code>dict</code> 的 <code>key</code> - 存放每个数，除了
<code>'.'</code> 这个代表空白的值。</li>
<li><code>dict</code> 的 <code>value</code> - 存放一个 <code>list</code>
，这个 <code>list</code> 里存放的是
<code>(row_index, col_index, block_index)</code> 的 <code>tuple</code>
用来记录这个数的位置信息。</li>
</ul>
<p>得到信息后对字典每个 <code>value</code> 进行判断，需要当前
<code>list</code> 里的 <code>row_index</code> ， <code>col_index</code>
， <code>block_index</code>
都不相同，任意一个相同时返回错误，否则返回正确。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        num_loc = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):
                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:
                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_loc:
                        num_loc[board[i][j]] = [(i,j,((i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>)))]
                    <span class="hljs-keyword">else</span>:
                        num_loc[board[i][j]].append((i,j,((i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>))))
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> num_loc.values():
            row_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
            col_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
            block_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> v:
                <span class="hljs-keyword">if</span> i[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> row_set:
                    row_set.add(i[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> col_set:
                    col_set.add(i[<span class="hljs-number">1</span>])
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-keyword">if</span> i[<span class="hljs-number">2</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> block_set:
                    block_set.add(i[<span class="hljs-number">2</span>])
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<p>然后就可以发现上面的逻辑可以优化，上述逻辑是先放后比，边放边比会更快。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        row_record = [<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]
        col_record = [<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]
        block_record = [<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):
                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:
                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">in</span> row_record[i]:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">in</span> col_record[j]:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">in</span> block_record[(i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>)]:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                    row_record[i].add(board[i][j])
                    col_record[j].add(board[i][j])
                    block_record[(i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>)].add(board[i][j])
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h3 id="矩阵置零">73. 矩阵置零</h3>
<p>和上面这道题思路比较像，先统计一下 0 的位置信息，再修改。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:
        row_record = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        col_record = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        m = <span class="hljs-built_in">len</span>(matrix)
        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:
                    row_record.add(i)
                    col_record.add(j)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> row_record:
                matrix[i][:] = [<span class="hljs-number">0</span>]*n
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> col_record:
                    matrix[i][j] = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h2 id="字符串">字符串</h2>
<h3 id="字符串中的第一个唯一字符">387. 字符串中的第一个唯一字符</h3>
<p><code>dict</code> 存储频次。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                hashmap[i] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):
            <span class="hljs-keyword">if</span> hashmap[v] == <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> i
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>
<p><code>dict</code> 存储唯一元素的下标，否则存储 -1。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):
            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[v] = i
            <span class="hljs-keyword">else</span>:
                hashmap[v] = -<span class="hljs-number">1</span>
        res = <span class="hljs-built_in">len</span>(s)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hashmap.values():
            <span class="hljs-keyword">if</span> i != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i &lt; res:
                res = i
        <span class="hljs-keyword">if</span> res == <span class="hljs-built_in">len</span>(s):
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="赎金信">383. 赎金信</h3>
<p>用 <code>dict</code> 做一个简单的计数，再判断。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote: <span class="hljs-built_in">str</span>, magazine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        magazine_dict = &#123;&#125;
        ransomNote_dict = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> magazine:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> magazine_dict:
                magazine_dict[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                magazine_dict[i] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ransomNote:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ransomNote_dict:
                ransomNote_dict[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                ransomNote_dict[i] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> ransomNote_dict.items():
            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> magazine_dict:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> v &gt; magazine_dict[k]:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h3 id="有效的字母异位词">242. 有效的字母异位词</h3>
<p>用 <code>dict</code> 做一个简单的计数统计，再判断。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                hashmap[i] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">else</span>:
                hashmap[i] -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> hashmap.values():
            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h2 id="链表">链表</h2>
<h3 id="环形链表">141. 环形链表</h3>
<p>快慢双指针能否相遇的问题，如果相遇了就是有环，没有相遇就是没有环。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        fast = slow = head
        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:
            slow = slow.<span class="hljs-built_in">next</span>
            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> fast == slow:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="合并两个有序链表">21. 合并两个有序链表</h3>
<p>迭代，链表的修改需要找到待插入节点的上一个节点，因此，我们需要定义一个
<code>pre</code> 节点方便修改，同时为了方便返回结果，我们还需要一个
<code>dummy</code> 节点用于记录一开始的位置。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        pre = dummy
        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:
            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:
                pre.<span class="hljs-built_in">next</span> = list1
                list1 = list1.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                pre.<span class="hljs-built_in">next</span> = list2
                list2 = list2.<span class="hljs-built_in">next</span>
            pre = pre.<span class="hljs-built_in">next</span>
        pre.<span class="hljs-built_in">next</span> = list2 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> list1
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> list2
        <span class="hljs-keyword">elif</span> list2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> list1
        <span class="hljs-keyword">elif</span> list1.val &lt;= list2.val:
            list1.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1.<span class="hljs-built_in">next</span>, list2)
            <span class="hljs-keyword">return</span> list1
        <span class="hljs-keyword">else</span>:
            list2.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="hljs-built_in">next</span>)
            <span class="hljs-keyword">return</span> list2</code></pre></div>
<h3 id="移除链表元素">203. 移除链表元素</h3>
<p>迭代，同样一个 <code>pre</code> 节点方便删元素，一个
<code>dummy</code> 节点方便返回头指针。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        pre = dummy
        <span class="hljs-keyword">while</span> head:
            <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.val == val:
                head = head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> head:
                pre.<span class="hljs-built_in">next</span> = head
                head = head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                pre.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
            pre = pre.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>虽然过了，但是我仔细一看上面的代码其实逻辑有问题，最外层的
<code>while head</code> 根本不应该写成循环，因为推动循环变化的是
<code>pre</code> 这个点，优化一下：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode(<span class="hljs-number">0</span>, head)
        pre = dummy
        <span class="hljs-keyword">while</span> pre.<span class="hljs-built_in">next</span>:
            <span class="hljs-keyword">if</span> pre.<span class="hljs-built_in">next</span>.val != val:
                pre = pre.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                pre.<span class="hljs-built_in">next</span> = pre.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>递归。这里也注意递归条件。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> head
        head.<span class="hljs-built_in">next</span> = self.removeElements(head.<span class="hljs-built_in">next</span>, val)
        <span class="hljs-keyword">return</span> head <span class="hljs-keyword">if</span> head.val != val <span class="hljs-keyword">else</span> head.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="反转链表">206. 反转链表</h3>
<p>用栈进行反转。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        stack = []
        <span class="hljs-keyword">while</span> head:
            stack.append(head.val)
            head = head.<span class="hljs-built_in">next</span>
        dummy = ListNode()
        node = dummy
        <span class="hljs-keyword">while</span> stack:
            node.<span class="hljs-built_in">next</span> = ListNode(stack.pop())
            node = node.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>但是这个都把值提出来了，不太正规。</p>
<p>我们可以使用双指针迭代，一个指针在前一个指针在后，遍历链表时修改指针的方向。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        pre = <span class="hljs-literal">None</span>
        cur = head
        <span class="hljs-keyword">while</span> cur:
            temp = cur.<span class="hljs-built_in">next</span>
            cur.<span class="hljs-built_in">next</span> = pre
            pre = cur
            cur = temp
        <span class="hljs-keyword">return</span> pre</code></pre></div>
<p>还可以用递归，其中递归是参考的 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">206.
反转链表 - 力扣（Leetcode）</a> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> head
        cur = self.reverseList(head.<span class="hljs-built_in">next</span>)
        head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head
        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">return</span> cur</code></pre></div>
<h3 id="删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h3>
<p>可以使用 <code>set</code> 只保留重复元素。</p>
<div class="code-wrapper"><pre><code class="hljs python">hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
dummy = ListNode()
pre = dummy
<span class="hljs-keyword">while</span> head:
    <span class="hljs-keyword">if</span> head.val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
        hashset.add(head.val)
        pre.<span class="hljs-built_in">next</span> = head
        pre = pre.<span class="hljs-built_in">next</span>
    head = head.<span class="hljs-built_in">next</span>
pre.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
<span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>不过，因为这道题是已经排序的链表，也就是说重复元素都是连着出现的，所以也可以这样，根据下一个元素是否重复来决定是移动指针还是插值：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> head
        node = head
        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:
            <span class="hljs-keyword">if</span> node.val == node.<span class="hljs-built_in">next</span>.val:
                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                node = node.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> head</code></pre></div>
<h2 id="栈-队列">栈 / 队列</h2>
<h3 id="有效的括号">20. 有效的括号</h3>
<p>用栈处理，左符号进栈右符号出栈匹配，出现任何错误或者最后栈非空都是
<code>False</code> ，否则是 <code>True</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        stack = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            match i:
                case <span class="hljs-string">&#x27;(&#x27;</span>: stack.append(i)
                case <span class="hljs-string">&#x27;)&#x27;</span>: 
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                case <span class="hljs-string">&#x27;&#123;&#x27;</span>: stack.append(i)
                case <span class="hljs-string">&#x27;&#125;&#x27;</span>:
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                case <span class="hljs-string">&#x27;[&#x27;</span>: stack.append(i)
                case <span class="hljs-string">&#x27;]&#x27;</span>:
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack</code></pre></div>
<h3 id="用栈实现队列">232. 用栈实现队列</h3>
<p>我的做法是有两个栈分别叫 <code>stack_in</code> 和
<code>stack_out</code> ，<code>stack_in</code>
负责用于转换数据的顺序（因为队列和栈顺序是反着的），<code>stack_out</code>
存着正确的出队，查看队顶，查看队空的顺序。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.stack_in = []
        self.stack_out = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">while</span> self.stack_out:
            self.stack_in.append(self.stack_out.pop())
        self.stack_in.append(x)
        <span class="hljs-keyword">while</span> self.stack_in:
            self.stack_out.append(self.stack_in.pop())

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> self.stack_out.pop()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> self.stack_out[-<span class="hljs-number">1</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack_out) == <span class="hljs-number">0</span></code></pre></div>
<h2 id="树">树</h2>
<h3 id="二叉树的前序遍历">144. 二叉树的前序遍历</h3>
<p>二叉树的遍历顺序（前中后）指的是根节点遍历是在前中后哪个位置，比如这道题，前序，根节点在前。</p>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> res

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">NLR</span>(<span class="hljs-params">node:<span class="hljs-type">Optional</span>[TreeNode]</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            res.append(node.val)
            NLR(node.left)
            NLR(node.right)
            
        NLR(root)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>非递归，类似深度优先搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> res
        stack = [root]
        <span class="hljs-keyword">while</span> stack:
            node = stack.pop()
            res.append(node.val)
            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)
            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="二叉树的中序遍历">94. 二叉树的中序遍历</h3>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> res

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node:<span class="hljs-type">Optional</span>[TreeNode]</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            LNR(node.left)
            res.append(node.val)
            LNR(node.right)
        
        LNR(root)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>非递归的方式，我们可以看上面递归的方法，其实在打印之前，是不对右节点进行处理的，也就是说是针对每一次循环都是先处理左节点到打印，想明白这件事，我们对栈的变化情况其实心里就有数了。</p>
<p>值得注意的是这个中序遍历其实用的是指针去遍历，而不是用栈遍历。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> res
        stack = []
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:
            <span class="hljs-keyword">while</span> root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            res.append(root.val)
            root = root.right
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="二叉树的后序遍历">145. 二叉树的后序遍历</h3>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> res

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LRN</span>(<span class="hljs-params">node:<span class="hljs-type">Optional</span>[TreeNode]</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            LRN(node.left)
            LRN(node.right)
            res.append(node.val)

        LRN(root)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>这个有点骚，已知前序遍历是 NLR，后续遍历是
LRN，我们可以将前序遍历魔改一下成为，NRL，再反转一下结果就变成了
LRN。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        res = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> res
        stack = [root]
        <span class="hljs-keyword">while</span> stack:
            node = stack.pop()
            res.append(node.val)
            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)
            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)
        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="二叉树的层序遍历">102. 二叉树的层序遍历</h3>
<p>经典广度优先搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> []
        queue = collections.deque()
        res = []
        queue.append(root)
        <span class="hljs-keyword">while</span> queue:
            temp = []
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.popleft()
                temp.append(node.val)
                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
            res.append(temp)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="二叉树的最大深度">104. 二叉树的最大深度</h3>
<p>昨天刚在编程能力学习计划里做了。递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))+<span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div>
<p>广度优先搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        res = <span class="hljs-number">0</span>
        queue = collections.deque()
        queue.append(root)
        <span class="hljs-keyword">while</span> queue:
            res += <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.popleft()
                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="对称二叉树">101. 对称二叉树</h3>
<p>我们可以用二叉树层次遍历的思想进行广度优先搜索。每一层都必须是对称的否则直接不是对称二叉树。同时为了处理空节点的情况，即使空节点也要添加值
<code>None</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        queue = collections.deque()
        queue.append(root)
        <span class="hljs-keyword">while</span> queue:
            temp = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.popleft()
                <span class="hljs-keyword">if</span> node.left:
                    temp.append(node.left.val)
                    queue.append(node.left)
                <span class="hljs-keyword">else</span>:
                    temp.append(<span class="hljs-literal">None</span>)
                <span class="hljs-keyword">if</span> node.right:
                    temp.append(node.right.val)
                    queue.append(node.right)
                <span class="hljs-keyword">else</span>:
                    temp.append(<span class="hljs-literal">None</span>)
            <span class="hljs-keyword">if</span> temp != temp[::-<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<p>递归，这里主要考虑终止递归的条件：</p>
<ul>
<li>左节点和右节点都为空 - 对称，返回 <code>True</code> 。</li>
<li>左右节点空了一个 - 非对称，返回 <code>False</code> 。</li>
<li>左右节点都非空但值不相等 - 非对称，返回 <code>False</code> 。</li>
<li>左右节点都非空且值相等 -
需要递归比较（左节点的左子节点，右节点的右子节点）和（左节点的右子节点，右节点的左子节点）。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">left, right</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">or</span> right):
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">and</span> right):
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> left.val != right.val:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">return</span> DFS(left.left, right.right) <span class="hljs-keyword">and</span> DFS(left.right, right.left)
        <span class="hljs-keyword">return</span> DFS(root.left, root.right)</code></pre></div>
<h3 id="翻转二叉树">226. 翻转二叉树</h3>
<p>递归翻转。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>层次反转，广度优先搜索的思想：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        queue = collections.deque()
        queue.append(root)
        <span class="hljs-keyword">while</span> queue:
            node = queue.popleft()
            node.left, node.right = node.right, node.left
            <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
            <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>深度优先搜索的思想：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        stack = [root]
        <span class="hljs-keyword">while</span> stack:
            node = stack.pop()
            node.left, node.right = node.right, node.left
            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)
            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<h3 id="路径总和">112. 路径总和</h3>
<p>深度优先搜索，非递归方法。实质上就是每次往栈里填节点的时候填上当前路径的和，当节点为叶子节点的时候可以看一下路径和是否等于目标值。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        stack = [(root, root.val)]
        <span class="hljs-keyword">while</span> stack:
            node, temp = stack.pop()
            <span class="hljs-keyword">if</span> node.right: stack.append((node.right, temp+node.right.val))
            <span class="hljs-keyword">if</span> node.left: stack.append((node.left, temp+node.left.val))
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">and</span> temp == targetSum:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>广度优先搜索也能解决。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        queue = collections.deque()
        queue.append((root, root.val))
        <span class="hljs-keyword">while</span> queue:
            node, temp = queue.popleft()
            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, temp+node.right.val))
            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, temp+node.left.val))
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">and</span> temp == targetSum:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>递归，递归似乎比上面两种快很多。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">and</span> root.right:
            <span class="hljs-keyword">return</span> self.hasPathSum(root.left, targetSum-root.val) <span class="hljs-keyword">or</span> self.hasPathSum(root.right, targetSum-root.val)
        <span class="hljs-keyword">if</span> root.left:
            <span class="hljs-keyword">return</span> self.hasPathSum(root.left, targetSum-root.val)
        <span class="hljs-keyword">if</span> root.right:
            <span class="hljs-keyword">return</span> self.hasPathSum(root.right, targetSum-root.val)
        <span class="hljs-keyword">return</span> root.val == targetSum</code></pre></div>
<h3 id="二叉搜索树中的搜索">700. 二叉搜索树中的搜索</h3>
<p>二叉搜索树的重要特征就是左子树的所有值 &lt;= 根节点的值 &lt;=
右子树的所有值，因此我们可以通过值的比较快速定位到目标值的节点。</p>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> root.val == val:
            <span class="hljs-keyword">return</span> root
        <span class="hljs-keyword">if</span> root.val &lt; val <span class="hljs-keyword">and</span> root.right:
            <span class="hljs-keyword">return</span> self.searchBST(root.right, val)
        <span class="hljs-keyword">if</span> root.val &gt; val <span class="hljs-keyword">and</span> root.left:
            <span class="hljs-keyword">return</span> self.searchBST(root.left, val)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>非递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">while</span> root:
            <span class="hljs-keyword">if</span> root.val == val:
                <span class="hljs-keyword">return</span> root
            <span class="hljs-keyword">elif</span> root.val &lt; val:
                root = root.right
            <span class="hljs-keyword">elif</span> root.val &gt; val:
                root = root.left
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="二叉搜索树中的插入操作">701. 二叉搜索树中的插入操作</h3>
<p>在不考虑树的深度的情况下插入新节点到二叉搜索树中还是非常容易的，与上题相似。</p>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> TreeNode(val)
        <span class="hljs-keyword">if</span> root.val &gt; val:
            <span class="hljs-keyword">if</span> root.left:
                root.left = self.insertIntoBST(root.left, val)
            <span class="hljs-keyword">else</span>:
                root.left = TreeNode(val)
        <span class="hljs-keyword">if</span> root.val &lt; val:
            <span class="hljs-keyword">if</span> root.right:
                root.right = self.insertIntoBST(root.right, val)
            <span class="hljs-keyword">else</span>:
                root.right = TreeNode(val)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>非递归，在循环里插入：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> TreeNode(val)
        dummy = root
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">if</span> root.val &gt; val:
                <span class="hljs-keyword">if</span> root.left:
                    root = root.left
                <span class="hljs-keyword">else</span>:
                    root.left = TreeNode(val)
                    <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">elif</span> root.val &lt; val:
                <span class="hljs-keyword">if</span> root.right:
                    root = root.right
                <span class="hljs-keyword">else</span>:
                    root.right = TreeNode(val)
                    <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> dummy</code></pre></div>
<p>非递归，在循环外插入：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> TreeNode(val)
        dummy = root
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">if</span> root.val &gt; val <span class="hljs-keyword">and</span> root.left:
                root = root.left
            <span class="hljs-keyword">elif</span> root.val &lt; val <span class="hljs-keyword">and</span> root.right:
                root = root.right
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> root.val &gt; val:
            root.left = TreeNode(val)
        <span class="hljs-keyword">else</span>:
            root.right = TreeNode(val)
        <span class="hljs-keyword">return</span> dummy</code></pre></div>
<h3 id="验证二叉搜索树">98. 验证二叉搜索树</h3>
<p>自定义一个递归方法去设置上下限。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">DST</span>(<span class="hljs-params">root, min_val, max_val</span>):
            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">and</span> root.right:
                <span class="hljs-keyword">if</span> min_val &lt; root.left.val &lt; root.val &lt; root.right.val &lt; max_val:
                    <span class="hljs-keyword">return</span> DST(root.left, min_val, root.val) <span class="hljs-keyword">and</span> DST(root.right, root.val, max_val)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> root.left:
                <span class="hljs-keyword">if</span> min_val &lt; root.left.val &lt; root.val &lt; max_val:
                    <span class="hljs-keyword">return</span> DST(root.left, min_val, root.val)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> root.right:
                <span class="hljs-keyword">if</span> min_val &lt; root.val &lt; root.right.val &lt; max_val:
                    <span class="hljs-keyword">return</span> DST(root.right, root.val, max_val)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> DST(root, -<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span>)</code></pre></div>
<p>也可以中序遍历完了再做比较。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        res = []
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            LNR(node.left)
            res.append(node.val)
            LNR(node.right)
        LNR(root)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> res[i] &gt;= res[i+<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<p>对于中序遍历来讲，可以边遍历边比较会更快。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        pre = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)
        stack = []
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:
            <span class="hljs-keyword">while</span> root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            <span class="hljs-keyword">if</span> root.val &lt;= pre:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            pre = root.val
            root = root.right
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h3 id="两数之和-iv---输入二叉搜索树">653. 两数之和 IV -
输入二叉搜索树</h3>
<p>我们可以用 hash 加遍历树的方式来寻找有无两数之和。非递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTarget</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        stack = [root]
        <span class="hljs-keyword">while</span> stack:
            node = stack.pop()
            <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">in</span> hashset:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            hashset.add(k-node.val)
            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)
            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTarget</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">node</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">in</span> hashset:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            hashset.add(k-node.val)
            <span class="hljs-keyword">return</span> DFS(node.left) <span class="hljs-keyword">or</span> DFS(node.right) 
        <span class="hljs-keyword">return</span> DFS(root)</code></pre></div>
<h3 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h3>
<p>上道题感觉其实与二叉搜索树没什么关系，这道是真有。</p>
<p>我们先不管这个二叉搜索树的性质，使用树的层次遍历并开一个祖先列表，将一个节点所有祖先都放入列表中，直到找到
<code>p</code> ， <code>q</code>
两个节点然后再从后往前去比较两个祖先列表。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:
        queue = collections.deque()
        queue.append((root,[root]))
        p_ancestors = <span class="hljs-literal">None</span>
        q_ancestors = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> queue:
            node, ancestors = queue.pop()
            <span class="hljs-keyword">if</span> node == p:
                p_ancestors = ancestors
            <span class="hljs-keyword">if</span> node == q:
                q_ancestors = ancestors
            <span class="hljs-keyword">if</span> p_ancestors <span class="hljs-keyword">and</span> q_ancestors:
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, ancestors+[node.left]))
            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, ancestors+[node.right]))
        <span class="hljs-keyword">for</span> p_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(p_ancestors):
            <span class="hljs-keyword">for</span> q_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(q_ancestors):
                <span class="hljs-keyword">if</span> p_ancestor == q_ancestor:
                    <span class="hljs-keyword">return</span> p_ancestor
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>这个效率确实低了很多。</p>
<p>我们可以利用二叉搜索树的性质，如果两个节点的值都比某个节点值大，这两个节点都应该在这个节点右边。如果两个节点值都比某个节点值小，这两个节点都应该在某个节点左边。否则这个节点就是两个节点的最近公共祖先。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:
        <span class="hljs-keyword">if</span> p.val &lt; root.val <span class="hljs-keyword">and</span> q.val &lt; root.val:
            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.left, p, q)
        <span class="hljs-keyword">if</span> p.val &gt; root.val <span class="hljs-keyword">and</span> q.val &gt; root.val:
            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.right, p, q)
        <span class="hljs-keyword">return</span> root</code></pre></div>
<h1 id="数据结构基础">数据结构基础</h1>
<h2 id="数组-1">数组</h2>
<h3 id="只出现一次的数字">136. 只出现一次的数字</h3>
<p>异或运算的性质。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y:x^y, nums)</code></pre></div>
<h3 id="多数元素">169. 多数元素</h3>
<p>对元素计数，找出大于 <code>len(nums)//2</code> 的元素。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        nums_len_half = <span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>
        counter = collections.Counter(nums)
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> counter:
            <span class="hljs-keyword">if</span> counter[k] &gt; nums_len_half:
                <span class="hljs-keyword">return</span> k
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="三数之和">15. 三数之和</h3>
<p>强行三数之和转两数之和（ hash ）+ 去重。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums, target, begin_index</span>):
            hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
            res = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(begin_index, <span class="hljs-built_in">len</span>(nums)):
                temp = target-nums[i]
                <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">in</span> hashset:
                    res.append([nums[i],temp])
                <span class="hljs-keyword">else</span>:
                    hashset.add(nums[i])
            <span class="hljs-keyword">return</span> res
        
        res = []
        zero = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):
            two = twoSum(nums, -v, i+<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(two) != <span class="hljs-number">0</span>:
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> two:
                    <span class="hljs-keyword">if</span> v==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>:
                        zero = <span class="hljs-literal">True</span>
                        <span class="hljs-keyword">continue</span>
                    flag = <span class="hljs-literal">True</span>
                    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:
                        <span class="hljs-keyword">if</span> v <span class="hljs-keyword">in</span> r <span class="hljs-keyword">and</span> j[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> r <span class="hljs-keyword">and</span> j[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> r:
                            flag = <span class="hljs-literal">False</span>
                    <span class="hljs-keyword">if</span> flag:
                        res.append([v]+j)
        <span class="hljs-keyword">if</span> zero:
            res.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>太慢了，我甚至怀疑不是 Python 都过不了测试用例：</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212260937219.png" srcset="/img/loading.gif" lazyload /></p>
<p>双指针法，见注释。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        nums = <span class="hljs-built_in">sorted</span>(nums)	<span class="hljs-comment"># 靠排序达到去重效果</span>
        nums_len = <span class="hljs-built_in">len</span>(nums)
        res = []
        <span class="hljs-keyword">if</span> nums_len &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums[-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> res
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len-<span class="hljs-number">2</span>):	<span class="hljs-comment"># 寻找元素 a</span>
            <span class="hljs-keyword">if</span> nums[i]&gt;<span class="hljs-number">0</span>:	<span class="hljs-comment"># 剪枝</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:	<span class="hljs-comment"># 对元素 a 去重</span>
                <span class="hljs-keyword">continue</span>
            left = i+<span class="hljs-number">1</span>			<span class="hljs-comment"># 寻找元素 b</span>
            right = nums_len-<span class="hljs-number">1</span>	<span class="hljs-comment"># 寻找元素 c</span>
            <span class="hljs-keyword">while</span> left&lt;right:
                temp_sum = nums[i]+nums[left]+nums[right]	<span class="hljs-comment"># 这里和下面的 if-elif-else 语句都在寻找三数之和为 0</span>
                <span class="hljs-keyword">if</span> temp_sum &gt; <span class="hljs-number">0</span>:
                    right -= <span class="hljs-number">1</span>
                <span class="hljs-keyword">elif</span> temp_sum &lt; <span class="hljs-number">0</span>:
                    left += <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    res.append([nums[i], nums[left], nums[right]])
                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[left] == nums[left+<span class="hljs-number">1</span>]: left += <span class="hljs-number">1</span>		<span class="hljs-comment"># 对元素 b 去重</span>
                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[right] == nums[right-<span class="hljs-number">1</span>]: right -= <span class="hljs-number">1</span>	<span class="hljs-comment"># 对元素 c 去重</span>
                    left += <span class="hljs-number">1</span>
                    right -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="颜色分类">75. 颜色分类</h3>
<p>这道题是一道盲点问题，其实不需要排序，只需要统计，统计完之后根据统计结果直接替换就行了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortColors</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:
        counter = collections.Counter(nums)
        index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter[i]):
                nums[index] = i
                index += <span class="hljs-number">1</span></code></pre></div>
<h3 id="合并区间">56. 合并区间</h3>
<p>暴力法，用一个 <code>record</code>
数组记录有数的位置，这种思路的问题在于要处理 <code>[1,1], [2,2]</code>
与 <code>[1,2], [2,2]</code> 的区别，因为在 <code>record</code>
数组上的记录都是 <code>record[1]=1, record[2]=1</code>
。这里采取的方式是将 <code>record</code> 数组扩大两倍，这样
<code>[1,1], [2,2]</code> 就表现为 <code>record[2]=1, record[4]=1</code>
，而 <code>[1,2], [2,2]</code> 则表现为
<code>record[2]=1, record[3]=1, record[4]=1</code> ，得以区分。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = []
        record = [<span class="hljs-number">0</span>] * <span class="hljs-number">20002</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>, i[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>):
                record[j] = <span class="hljs-number">1</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i&lt;=<span class="hljs-number">20001</span>:
            <span class="hljs-keyword">if</span> record[i] == <span class="hljs-number">0</span>:
                i += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                pre = i+<span class="hljs-number">1</span>
                <span class="hljs-keyword">while</span> pre&lt;=<span class="hljs-number">20001</span> <span class="hljs-keyword">and</span> record[pre]:
                    pre += <span class="hljs-number">1</span>
                res.append([i//<span class="hljs-number">2</span>, pre//<span class="hljs-number">2</span>])
                i = pre
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>贪心。首先需要将 <code>intervals</code> 数组按 <code>i[0]</code>
排序，排序之后进行遍历，这时会有两种情况：</p>
<ul>
<li>当前遍历的 <code>t[0]</code> 大于结果数组 <code>res</code> 最后一个
<code>i[1]</code> 的值，代表从现在开始就不连续了，直接将 <code>t</code>
加入结果数组。</li>
<li>当前遍历的 <code>t[0]</code> 小于等于结果数组 <code>res</code>
最后一个 <code>i[1]</code> 的值，也就是连续，这时候应该对
<code>res[-1]</code> 和 <code>t</code>
取并集，不过由于已经排了序，所以其实就是 <code>res[-1][1]</code>
右边边界取 <code>t[1]</code> 和 <code>res[-1][1]</code> 的更大值。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        arr_sort = <span class="hljs-built_in">sorted</span>(intervals, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
        res = [arr_sort[<span class="hljs-number">0</span>]]
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> arr_sort:
            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>]&gt;res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:
                res.append(t)
            <span class="hljs-keyword">else</span>:
                res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], t[<span class="hljs-number">1</span>])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="设计哈希映射">706. 设计哈希映射</h3>
<p>调用 <code>dict</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.hashmap = &#123;&#125;

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.hashmap[key] = value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.hashmap:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.hashmap[key]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.hashmap:
            <span class="hljs-keyword">del</span> self.hashmap[key]</code></pre></div>
<h3 id="杨辉三角-ii">119. 杨辉三角 II</h3>
<p>与构建杨辉三角很类似，直接沿用构建杨辉三角的思路，取结果数组里最后一行的数组就行了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRow</span>(<span class="hljs-params">self, rowIndex: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        <span class="hljs-keyword">if</span> rowIndex == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>]
        res = [[<span class="hljs-number">1</span>]*(row+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rowIndex+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, rowIndex+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, row):
                res[row][col] = res[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>]+res[row-<span class="hljs-number">1</span>][col]
        <span class="hljs-keyword">return</span> res[-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="旋转图像">48. 旋转图像</h3>
<p>先沿右对角线做一次轴对称，再沿中线做一次轴对称。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:
        n = <span class="hljs-built_in">len</span>(matrix)
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):
            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, c):
                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            matrix[r][:] = matrix[r][::-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="螺旋矩阵-ii">59. 螺旋矩阵 II</h3>
<p>模拟过程：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateMatrix</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        res = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        direction = (<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>)
        direct = [<span class="hljs-string">&#x27;r&#x27;</span>]*(n-<span class="hljs-number">1</span>) + [<span class="hljs-string">&#x27;b&#x27;</span>]*(n-<span class="hljs-number">1</span>) + [<span class="hljs-string">&#x27;l&#x27;</span>]*(n-<span class="hljs-number">1</span>)
        index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):
                direct += direction[index]*(n-<span class="hljs-number">2</span>)
                index = (index+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>
            n -= <span class="hljs-number">1</span>
        count = <span class="hljs-number">2</span>
        r = <span class="hljs-number">0</span>
        c = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> direct:
            match d:
                case <span class="hljs-string">&#x27;r&#x27;</span>:
                    c += <span class="hljs-number">1</span>
                case <span class="hljs-string">&#x27;b&#x27;</span>:
                    r += <span class="hljs-number">1</span>
                case <span class="hljs-string">&#x27;l&#x27;</span>:
                    c -= <span class="hljs-number">1</span>
                case <span class="hljs-string">&#x27;t&#x27;</span>:
                    r -= <span class="hljs-number">1</span>
            res[r][c] = count
            count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="搜索二维矩阵-ii">240. 搜索二维矩阵 II</h3>
<p>直接使用暴力法：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        m = <span class="hljs-built_in">len</span>(matrix)
        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                <span class="hljs-keyword">if</span> matrix[i][j] == target:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>？？？打败了 90 % 的人？</p>
<p><img
src="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212291126962.png" srcset="/img/loading.gif" lazyload /></p>
<p>说实话我肯定不能接受。这题肯定跟二分有关系的。</p>
<p>对每一行都使用二分查找搜索。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        m = <span class="hljs-built_in">len</span>(matrix)
        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            l, r = <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> l&lt;=r:
                mid = (l+r) // <span class="hljs-number">2</span>
                <span class="hljs-keyword">if</span> matrix[i][mid] == target:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
                <span class="hljs-keyword">elif</span> matrix[i][mid] &lt; target:
                    l = mid + <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    r = mid - <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<p>从右上角或者左下角开始搜，思路差不多。以右上角开始为例，可以发现向左值都在减小，向下值都在增加，所以可以利用这个性质搜。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        m = <span class="hljs-built_in">len</span>(matrix)
        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])
        i = <span class="hljs-number">0</span>
        j = n-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> i&lt;m <span class="hljs-keyword">and</span> j&gt;=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">if</span> matrix[i][j] == target:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">elif</span> matrix[i][j] &gt; target:
                j -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="无重叠区间">435. 无重叠区间</h3>
<p>先排序之后用贪心的思想过滤每个区间。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eraseOverlapIntervals</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        intervals = <span class="hljs-built_in">sorted</span>(intervals, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])
        bound = -<span class="hljs-number">1e5</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> intervals:
            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>] &lt; bound:
                res += <span class="hljs-number">1</span>
                bound = <span class="hljs-built_in">min</span>(bound, t[<span class="hljs-number">1</span>])
            <span class="hljs-keyword">else</span>:
                bound = t[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="递增的三元子序列">334. 递增的三元子序列</h3>
<p>首先使用暴力，不幸地超出时间限制了。一看 <code>nums.length</code> 哦
5e5 啊，O(n3) 那肯定 OOT 了。</p>
<p>ok，试了一些基础方法，比如转 <code>hashmap</code>
存下标这样的方式还是没能解这个题。但是能感觉到这个题解的代码是一个动态的过程，但又列不出状态转移方程，那肯定就是贪心了。定义
<code>min_1</code> 记录最小值，定义 <code>min_2</code>
记录第二小值，那么当一个数比目前的第二小值大时显然就得到了解。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increasingTriplet</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        min_1 = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        min_2 = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> i &lt;= min_1:
                min_1 = i
            <span class="hljs-keyword">elif</span> i&lt;= min_2:
                min_2 = i
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="除自身以外数组的乘积">238. 除自身以外数组的乘积</h3>
<p>前缀和问题，分别正序和逆序遍历数组找出当前元素之前的积得到
<code>pre</code> 与 <code>suf</code> 数组，将 <code>suf</code>
反序（因为是逆序遍历的），然后对于结果来说就是当前位置的前缀积与后缀积相乘。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        pre = []
        suf = []
        temp = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            pre.append(temp)
            temp *= i
        temp = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums[::-<span class="hljs-number">1</span>]:
            suf.append(temp)
            temp *= i
        suf[:] = suf[::-<span class="hljs-number">1</span>]
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):
            res.append(pre[i]*suf[i])
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="和为-k-的子数组">560. 和为 K 的子数组</h3>
<p>前缀和 + hashmap 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        pre_sum = [<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            pre_sum.append(pre_sum[-<span class="hljs-number">1</span>]+i)
        hashmap = &#123;<span class="hljs-number">0</span>:<span class="hljs-number">1</span>&#125;
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):
            temp = pre_sum[i+<span class="hljs-number">1</span>]-k
            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">in</span> hashmap:
                res += hashmap[temp]
            <span class="hljs-keyword">if</span> pre_sum[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[pre_sum[i+<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                hashmap[pre_sum[i+<span class="hljs-number">1</span>]] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h2 id="字符串-1">字符串</h2>
<h3 id="字符串相加">415. 字符串相加</h3>
<p>模拟。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addStrings</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        res = <span class="hljs-string">&quot;&quot;</span>
        i, j, carry = <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-number">0</span>:
            n1 = <span class="hljs-built_in">int</span>(num1[i]) <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            n2 = <span class="hljs-built_in">int</span>(num2[j]) <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            temp = n1 + n2 + carry
            carry = temp // <span class="hljs-number">10</span>
            res = <span class="hljs-built_in">str</span>(temp % <span class="hljs-number">10</span>) + res
            i, j = i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span> + res <span class="hljs-keyword">if</span> carry <span class="hljs-keyword">else</span> res</code></pre></div>
<h3 id="最长回文串">409. 最长回文串</h3>
<p>用 <code>dict</code> 去统计每个字符出现的次数，如果是偶数可以直接用
<code>n</code> 个字符构成回文串，如果是奇数则可以用 <code>n-1</code>
个字符来构成，不过这时要标记遇到了奇数，之后如果标记位为真说明遇到了奇数，结果就会加
1 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        res = <span class="hljs-number">0</span>
        hashmap = &#123;&#125;
        flag = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                hashmap[i] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> hashmap.values():
            <span class="hljs-keyword">if</span> value&amp;<span class="hljs-number">1</span>:
                res += value - <span class="hljs-number">1</span>
                flag = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">else</span>:
                res += value
        <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> res</code></pre></div>
<h3 id="单词规律">290. 单词规律</h3>
<p>用 <code>dict</code> 去计数匹配。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        dict_pos = &#123;&#125;
        dict_nag = &#123;&#125;
        lst_ptn = <span class="hljs-built_in">list</span>(pattern)
        lst_s = s.split()
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst_ptn) != <span class="hljs-built_in">len</span>(lst_s):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(lst_ptn, lst_s):
            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_pos:
                dict_pos[k] = v
            dict_nag[v] = k
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_pos) != <span class="hljs-built_in">len</span>(dict_nag):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_pos.items():
            <span class="hljs-keyword">if</span> k != dict_nag[v]:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h3 id="划分字母区间">763. 划分字母区间</h3>
<p>用 <code>dict</code>
去记录每个字母首次出现尾次出现的索引，然后根据首次出现的索引排序，遍历排序后的索引，并记录首次索引和尾次索引。会遇到
3 种情况：</p>
<ul>
<li>遍历的首次索引大于当前记录的尾次出现索引 -
将当前结果添加，更新当前记录的首次索引和尾次索引。</li>
<li>遍历的尾次索引大于当前记录的尾次索引 - 更新当前记录的尾次索引。</li>
<li>遍历的首尾区间被当前记录的索引包含 - 不处理。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionLabels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):
            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[v] = (i, i)
            <span class="hljs-keyword">else</span>:
                start, end = hashmap[v]
                hashmap[v] = (start, i)
        sorted_index = <span class="hljs-built_in">sorted</span>(hashmap.items(), key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])
        res = []
        start = -<span class="hljs-number">1</span>
        end = -<span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sorted_index:
            <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; end:
                res.append(end-start+<span class="hljs-number">1</span>)
                start = i[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]
                end = i[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]
            <span class="hljs-keyword">elif</span> i[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &gt; end:
                end = i[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]
        res.append(end-start+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>:]</code></pre></div>
<h3 id="字母异位词分组">49. 字母异位词分组</h3>
<p>这道题主要考察如何将具有相同特征（字母异位词）作为 <code>dict</code>
的 <code>key</code> ，毕竟如果只是对每个字母做计数得到的子
<code>dict</code> 是不能作为 <code>key</code>
的。因此首先我想到的是计数之后再双循环去处理，不幸地超时了。然后可以将每个单词重新排序后作为
<code>key</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:
            temp = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>([_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> i]))
            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[temp] = [i]
            <span class="hljs-keyword">else</span>:
                hashmap[temp] += [i]
        <span class="hljs-keyword">return</span> [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> hashmap.values()]</code></pre></div>
<p>官解里提到的另一种方法实际也是再找寻合适的 <code>key</code>
，也是不排序直接计数的方法，我最开始也这样想但是没想到。官解这里采用长度为
26 的 <code>list</code>
来记录字母出现的次数，<code>ord(x)-ord('a')</code>
即为对应数组下标，再将 <code>list</code> 转为 <code>tuple</code>
以实现哈希。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:
        hashmap = &#123;&#125;
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> strs:
            temp = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:
                temp[<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>
            temp = <span class="hljs-built_in">tuple</span>(temp)
            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[temp] = [t]
            <span class="hljs-keyword">else</span>:
                hashmap[temp] += [t]
        <span class="hljs-keyword">return</span> [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> hashmap.values()]</code></pre></div>
<h3 id="字符串相乘">43. 字符串相乘</h3>
<p>这题前几天在编程能力计划里做过，不再赘述。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        res = <span class="hljs-number">0</span>
        flag1 = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num1[::-<span class="hljs-number">1</span>]:
            adv = <span class="hljs-number">0</span>
            temp = <span class="hljs-number">0</span>
            flag2 = <span class="hljs-number">1</span>
            i = <span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">48</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> num2[::-<span class="hljs-number">1</span>]:
                j = <span class="hljs-built_in">ord</span>(j)-<span class="hljs-number">48</span>
                mul = (i*j+adv)
                adv = mul//<span class="hljs-number">10</span>
                temp += (mul%<span class="hljs-number">10</span>)*flag2
                flag2 *= <span class="hljs-number">10</span>
            res += (temp+adv*flag2) * flag1
            flag1 *= <span class="hljs-number">10</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(res)</code></pre></div>
<h3 id="重复的dna序列">187. 重复的DNA序列</h3>
<p>用 2 个 <code>set</code>
来记录，一个存放已经出现过的序列，另一个用来存放结果，如果已经出现过，就添加进结果中。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRepeatedDnaSequences</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        res = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):
            temp = s[i:i+<span class="hljs-number">10</span>]
            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                hashset.add(temp)
            <span class="hljs-keyword">else</span>:
                res.add(temp)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(res)</code></pre></div>
<h3 id="最长回文子串">5. 最长回文子串</h3>
<p>暴力，过了。从长到短取序列，如果某个序列是回文串，直接返回他。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        s_len = <span class="hljs-built_in">len</span>(s)
        c_len = s_len
        <span class="hljs-keyword">while</span> c_len &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-c_len+<span class="hljs-number">1</span>):
                temp = s[i:i+c_len]
                <span class="hljs-keyword">if</span> temp == temp[::-<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">return</span> temp
            c_len -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>中心扩散算法，对每个点开始从中心往左右两边扩散直到扩散结果不是回文串。这个算法的难点在于有两种情况，比如
<code>aba</code> 与 <code>abba</code> 这两个字符串，都从第一个
<code>b</code>
开始扩散，很难同时进行处理，所以这里需要假设两种情况扩散的结果，选取最大回文串。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_palindrome</span>(<span class="hljs-params">s, l, r</span>):
            <span class="hljs-keyword">while</span> l&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r&lt;<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[l]==s[r]:
                l -= <span class="hljs-number">1</span>
                r += <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> l,r
        
        s_len = <span class="hljs-built_in">len</span>(s)
        left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):
            l1, r1 = get_palindrome(s, i, i)
            l2, r2 = get_palindrome(s, i, i+<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> r1-l1 &gt; right-left:
                left, right = l1,r1
            <span class="hljs-keyword">if</span> r2-l2 &gt; right-left:
                left, right = l2,r2
        <span class="hljs-keyword">return</span> s[left+<span class="hljs-number">1</span>:right]</code></pre></div>
<p>中心扩散这个算法其实有点动态规划的思想在里面，我之前其实很少遇到二维
dp ，这里用 <code>dp[i][j]</code> 表示字符串 <code>s[i:j]</code>
是否是回文字符串，可以列出如下状态转移方程： <span
class="math display">\[
dp[i][j]=\begin{cases}
dp[i+1][j-1]\&amp;(s[i]==s[j])\ \ \ \ if\ j&gt;i+1\\
s[i]==s[j]\ \ \ \ if\ j=i+1\\
True\ \ \ \ if\ i==j
\end{cases}
\]</span>
但是得注意，这里跟暴力不太一样，是从小往大推，不是从大往小推（否则算
<code>dp[i][j]</code> 时根本不知道 <code>dp[i+1][j-1]</code> ）。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        s_len = <span class="hljs-built_in">len</span>(s)
        dp = [[<span class="hljs-literal">False</span>]*s_len <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):
            dp[i][i] = <span class="hljs-literal">True</span>
        start, max_len = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> c_len <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,s_len+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-c_len+<span class="hljs-number">1</span>):
                j = i+c_len-<span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> s[i] != s[j]:
                    dp[i][j] = <span class="hljs-literal">False</span>
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> j&gt;i+<span class="hljs-number">1</span>:
                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]
                    <span class="hljs-keyword">else</span>:
                        dp[i][j] = <span class="hljs-literal">True</span>
                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> c_len&gt;max_len:
                    start = i
                    max_len = c_len
        <span class="hljs-keyword">return</span> s[start:start+max_len]</code></pre></div>
<p>但是动态规划，这里也不快。</p>
<h2 id="链表-1">链表</h2>
<h3 id="两数相加">2. 两数相加</h3>
<p>一种方式是先把 <code>l1</code> 与 <code>l2</code>
的数都取出来相加之后再根据结果生成新的链表。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        num1 = <span class="hljs-number">0</span>
        digit = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> l1:
            num1 += l1.val*digit
            l1 = l1.<span class="hljs-built_in">next</span>
            digit *= <span class="hljs-number">10</span>
        num2 = <span class="hljs-number">0</span>
        digit = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> l2:
            num2 += l2.val*digit
            l2 = l2.<span class="hljs-built_in">next</span>
            digit *= <span class="hljs-number">10</span>
        res_num = num1+num2
        dummy = ListNode()
        temp = dummy
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(res_num)[::-<span class="hljs-number">1</span>]:
            temp.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">int</span>(i))
            temp = temp.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<p>否则我们需要哨兵节点用于返回最终的链表，并需要前置节点用于将当前数位两数之和结果相加。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        node = dummy
        carry = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:
            temp = carry
            <span class="hljs-keyword">if</span> l1:
                temp += l1.val
                l1 = l1.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> l2:
                temp += l2.val
                l2 = l2.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> temp &gt;= <span class="hljs-number">10</span>:
                temp -= <span class="hljs-number">10</span>
                carry = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                carry = <span class="hljs-number">0</span>
            node.<span class="hljs-built_in">next</span> = ListNode(temp)
            node = node.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">if</span> carry:
            node.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="环形链表-ii">142. 环形链表 II</h3>
<p>用 <code>set</code>
存储每个节点然后遍历链表，如果节点已经存在，那么这个节点就是入环第一个节点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">while</span> head:
            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                hashset.add(head)
                head = head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> head
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>快慢指针，快指针走的步数减去慢指针走的步数一定是环的整数倍。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        fast, slow = head, head
        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:
            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
            slow = slow.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> fast == slow:
                temp = head
                <span class="hljs-keyword">while</span> temp != slow:
                    temp = temp.<span class="hljs-built_in">next</span>
                    slow = slow.<span class="hljs-built_in">next</span>
                <span class="hljs-keyword">return</span> temp
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="相交链表">160. 相交链表</h3>
<p>用 <code>set</code> 存储 <code>headA</code> 的每个节点，然后遍历
<code>headB</code> 看节点是否在 <code>set</code> 中。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        setA = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">while</span> headA:
            setA.add(headA)
            headA = headA.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">while</span> headB:
            <span class="hljs-keyword">if</span> headB <span class="hljs-keyword">in</span> setA:
                <span class="hljs-keyword">return</span> headB
            headB = headB.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>或者用两个 <code>set</code> 存储，在时间效率上有一定的优化。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        setA, setB = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>), <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">while</span> headA <span class="hljs-keyword">or</span> headB:
            <span class="hljs-keyword">if</span> headA:
                <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">in</span> setB: <span class="hljs-keyword">return</span> headA
                setA.add(headA)
                headA = headA.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> headB:
                <span class="hljs-keyword">if</span> headB <span class="hljs-keyword">in</span> setA: <span class="hljs-keyword">return</span> headB
                setB.add(headB)
                headB = headB.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<p>双指针，一个以 <code>headA+headB</code> 顺序遍历，一个以
<code>headB+headA</code> 顺序遍历，相遇的时候就是相交节点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> headA <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> headB:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        nodeA = headA
        nodeB = headB
        <span class="hljs-keyword">while</span> nodeA != nodeB:
            nodeA = headB <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nodeA <span class="hljs-keyword">else</span> nodeA.<span class="hljs-built_in">next</span>
            nodeB = headA <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nodeB <span class="hljs-keyword">else</span> nodeB.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> nodeA</code></pre></div>
<h3 id="删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素
II</h3>
<p>一个哨兵节点用于返回结果链表，另一个用于记录新链表节点。循环遍历
<code>head</code> ，假设 <code>temp</code> 是 <code>head</code>
节点的下个节点：</p>
<ul>
<li>如果 <code>temp</code> 是空节点或者
<code>temp.val != head.val</code> 则将当前 <code>head</code>
节点添加至记录。</li>
<li>否则 <code>head</code> 移到不是重复元素的位置。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        dummy = ListNode()
        node = dummy
        <span class="hljs-keyword">while</span> head:
            temp = head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp <span class="hljs-keyword">or</span> temp.val != head.val:
                node.<span class="hljs-built_in">next</span> = head
                head = head.<span class="hljs-built_in">next</span>
                node = node.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">while</span> temp <span class="hljs-keyword">and</span> temp.val == head.val:
                    temp = temp.<span class="hljs-built_in">next</span>
                head = temp
        node.<span class="hljs-built_in">next</span> = head
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="两两交换链表中的节点">24. 两两交换链表中的节点</h3>
<p>模拟。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:
            <span class="hljs-keyword">return</span> head
        dummy = ListNode()
        node = dummy
        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.<span class="hljs-built_in">next</span>:
            p1 = head
            p2 = head.<span class="hljs-built_in">next</span>
            p1.<span class="hljs-built_in">next</span>, p2.<span class="hljs-built_in">next</span> = p2.<span class="hljs-built_in">next</span>, p1
            node.<span class="hljs-built_in">next</span> = p2
            node = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>
            head = head.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="设计链表">707. 设计链表</h3>
<p><code>list</code> 实现。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>
        self.nums = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.<span class="hljs-built_in">len</span>:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> self.nums[index]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.addAtIndex(<span class="hljs-number">0</span>, val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.addAtIndex(self.<span class="hljs-built_in">len</span>, val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> index &gt; self.<span class="hljs-built_in">len</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        index = <span class="hljs-built_in">max</span>(index, <span class="hljs-number">0</span>)
        self.<span class="hljs-built_in">len</span> += <span class="hljs-number">1</span>
        self.nums.insert(index, val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.<span class="hljs-built_in">len</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        self.<span class="hljs-built_in">len</span> -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">del</span> self.nums[index]</code></pre></div>
<p>单向链表。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span></span>):
        self.val = val
        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.size = <span class="hljs-number">0</span>
        self.head = ListNode(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.size:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        node = self.head
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index+<span class="hljs-number">1</span>):
            node = node.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> node.val

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.addAtIndex(<span class="hljs-number">0</span>, val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.addAtIndex(self.size, val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> index &gt; self.size:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        index = <span class="hljs-built_in">max</span>(index, <span class="hljs-number">0</span>)
        self.size += <span class="hljs-number">1</span>
        node = self.head
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):
            node = node.<span class="hljs-built_in">next</span>
        temp = ListNode(val)
        temp.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>
        node.<span class="hljs-built_in">next</span> = temp

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.size:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        self.size -= <span class="hljs-number">1</span>
        node = self.head
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):
            node = node.<span class="hljs-built_in">next</span>
        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span></code></pre></div>
<h3 id="k-个一组翻转链表">25. K 个一组翻转链表</h3>
<p>用栈可以很轻松的解决，直接每次 <code>k</code>
个节点进栈，然后出栈生成新链表，为了防止节点不够进栈的情况，每次进栈前先记录一下节点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:
        res = ListNode()
        node = res
        stack = []
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            pre = head
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:
                    node.<span class="hljs-built_in">next</span> = pre
                    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span>
                stack.append(head)
                head = head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">while</span> stack:
                temp = stack.pop()
                node.<span class="hljs-built_in">next</span> = temp
                node = node.<span class="hljs-built_in">next</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="重排链表">143. 重排链表</h3>
<p>在编程能力里做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reorderList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-literal">None</span>:
        queue = collections.deque()
        <span class="hljs-keyword">while</span> head:
            queue.append(head)
            head = head.<span class="hljs-built_in">next</span>
        dummy = ListNode()
        node = dummy
        <span class="hljs-keyword">while</span> queue:
            <span class="hljs-keyword">if</span> queue:
                node.<span class="hljs-built_in">next</span> = queue.popleft()
                node = node.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">if</span> queue:
                node.<span class="hljs-built_in">next</span> = queue.pop()
                node = node.<span class="hljs-built_in">next</span>
        node.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
        head = dummy.<span class="hljs-built_in">next</span></code></pre></div>
<h2 id="栈-队列-1">栈 / 队列</h2>
<h3 id="最小栈">155. 最小栈</h3>
<p>最开始读这道题没读懂，后面发现原来这个题既想记录元素入栈的顺序又想记录最小值，那么比较合理的就是采用空间换时间的方法，两个栈，一个正常存数，一个存最小值。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.stack = []
        self.minstack = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> self.minstack:
            _<span class="hljs-built_in">min</span> = self.minstack[-<span class="hljs-number">1</span>]
            _<span class="hljs-built_in">min</span> = <span class="hljs-built_in">min</span>(val, _<span class="hljs-built_in">min</span>)
            self.minstack.append(_<span class="hljs-built_in">min</span>)
            self.stack.append(val)
        <span class="hljs-keyword">else</span>:
            self.minstack.append(val)
            self.stack.append(val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
        self.stack.pop()
        self.minstack.pop()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> self.minstack[-<span class="hljs-number">1</span>]</code></pre></div>
<h3 id="移除无效的括号">1249. 移除无效的括号</h3>
<p>可以采用一个栈来记录有效的括号，遍历字符串时，如果遇到左括号，下标入栈，如果遇到右括号，那么判断是否可出栈，能出则出，不能说明这个右括号是无效的，把下标记录一下。遍历完成后，还在栈里的下标说明这些左括号找不到匹配的右括号，也记录。最后凡是记录的位置不添加到结果里。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minRemoveToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        stack = []
        error = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):
            <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;(&#x27;</span>:
                stack.append(i)
            <span class="hljs-keyword">elif</span> v == <span class="hljs-string">&#x27;)&#x27;</span>:
                <span class="hljs-keyword">if</span> stack:
                    stack.pop()
                <span class="hljs-keyword">else</span>:
                    error.add(i)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:
            error.add(i)
        res = []
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> error:
                res.append(v)
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)</code></pre></div>
<h3 id="找出游戏的获胜者">1823. 找出游戏的获胜者</h3>
<p>可以采用一个队列来模拟实际游戏情况。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheWinner</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        queue = collections.deque()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):
            queue.append(i)
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):
                temp = queue.popleft()
                <span class="hljs-keyword">if</span> i!=k-<span class="hljs-number">1</span>:
                    queue.append(temp)
        <span class="hljs-keyword">return</span> queue.popleft()</code></pre></div>
<p>但是其实我们是知道哪个位置的元素被删的，是 <code>start+k-1</code>
这个位置，所以可以直接删这个元素。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheWinner</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        flag = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>)]
        start = <span class="hljs-number">0</span>
        count = n
        <span class="hljs-keyword">while</span> count != <span class="hljs-number">1</span>:
            index = (start+k-<span class="hljs-number">1</span>)%count
            flag.pop(index)
            start = index
            count -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> flag[<span class="hljs-number">0</span>]</code></pre></div>
<h2 id="树-1">树</h2>
<h3 id="将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h3>
<p>从数组中点开始递归构建二叉平衡树。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_BST</span>(<span class="hljs-params">l, r</span>):
            mid = (l+r) // <span class="hljs-number">2</span>
            node = TreeNode(nums[mid])
            <span class="hljs-keyword">if</span> l&lt;=mid-<span class="hljs-number">1</span>:
                node.left = insert_BST(l,mid-<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> r&gt;=mid+<span class="hljs-number">1</span>:
                node.right = insert_BST(mid+<span class="hljs-number">1</span>,r)
            <span class="hljs-keyword">return</span> node
        
        <span class="hljs-keyword">return</span> insert_BST(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)</code></pre></div>
<h3 id="从前序与中序遍历序列构造二叉树">105.
从前序与中序遍历序列构造二叉树</h3>
<p>二叉树的前序遍历是 <code>NLR</code> ，中序遍历是 <code>LNR</code>
，因此，<code>preorder</code> 的首个元素一定是 <code>root</code>
节点，然后根据 <code>root</code> 在 <code>inorder</code>
中的位置可以区分出左右子树的 <code>inorder</code>
，然后可以根据左右子树的 <code>inorder</code> 数量来找出左右子树的
<code>preorder</code> 。递归构造二叉树。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        node = TreeNode(preorder[<span class="hljs-number">0</span>])
        index_node = inorder.index(preorder[<span class="hljs-number">0</span>])
        left_num = index_node
        node.left = self.buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-number">1</span>+left_num], inorder[:index_node])
        node.right = self.buildTree(preorder[<span class="hljs-number">1</span>+left_num:], inorder[index_node+<span class="hljs-number">1</span>:])
        <span class="hljs-keyword">return</span> node</code></pre></div>
<p>我们可以使用 <code>dict</code>
对于查找根节点进行一个优化，但是就不能像上面那样传新的 <code>list</code>
了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:    
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build</span>(<span class="hljs-params">preorder_left, preorder_right, inorder_left, inorder_right</span>):
            <span class="hljs-keyword">if</span> preorder_left &gt; preorder_right:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            preorder_root = preorder_left
            inorder_root = hashmap[preorder[preorder_root]]
            root = TreeNode(preorder[preorder_root])
            size_left_subtree = inorder_root - inorder_left
            root.left = _build(preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>)           
            root.right = _build(preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right)
            <span class="hljs-keyword">return</span> root

        hashmap=&#123;v:i <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(inorder)&#125;
        <span class="hljs-keyword">return</span> _build(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder)-<span class="hljs-number">1</span>)</code></pre></div>
<h3 id="二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</h3>
<p>简单的层次遍历，根据不同层数添加不同遍历方向的值。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> []
        queue = [root]
        res = []
        count = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> queue:
            temp = []
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.pop(<span class="hljs-number">0</span>)
                temp.append(node.val)
                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
            <span class="hljs-keyword">if</span> count&amp;<span class="hljs-number">1</span>:
                res.append(temp)
            <span class="hljs-keyword">else</span>:
                res.append(temp[::-<span class="hljs-number">1</span>])
            count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="二叉树的右视图">199. 二叉树的右视图</h3>
<p>依然是二叉树的层次遍历，我们在添加节点时从右往左添加并且只将第一个出队的值添加进结果中即可。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> []
        queue = [root]
        res = []
        <span class="hljs-keyword">while</span> queue:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node = queue.pop(<span class="hljs-number">0</span>)
                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:
                    res.append(node.val)
                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)
                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="路径总和-ii">113. 路径总和 II</h3>
<p>带其它信息的搜索，深度优先搜索和广度优先搜索都可以。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> []
        queue = collections.deque()
        res = []
        queue.append((root, [root.val], root.val))
        <span class="hljs-keyword">while</span> queue:
            node, path, path_sum = queue.popleft()
            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, path+[node.left.val], path_sum+node.left.val))
            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, path+[node.right.val], path_sum+node.right.val))
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:
                <span class="hljs-keyword">if</span> path_sum == targetSum:
                    res.append(path)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h3>
<p>在查询并删除某个节点中，可能会遇到以下几种情况。</p>
<ul>
<li>当前节点为空，返回空节点。</li>
<li>当前节点值大于目标值，那么应该去左子树寻找目标节点，相当于对左子树运用同样的函数删一次，因此
<code>root.left = self.deleteNode(root.left, key)</code> 。</li>
<li>当前节点值小于目标值，那么应该去右子树寻找目标节点。</li>
<li>当前节点值等于目标值，也就是找到了。
<ul>
<li>如果没有左子树，那么直接用右子节点覆盖当前节点就行了。</li>
<li>同样如果没有右子树，那么直接用左子节点覆盖当前节点就行了。</li>
<li>如果都有的话，可以将左子树接到右子树的最左节点，然后用右子树覆盖当前节点。</li>
</ul></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">if</span> root.val &gt; key:
            root.left = self.deleteNode(root.left, key)
        <span class="hljs-keyword">elif</span> root.val &lt; key:
            root.right = self.deleteNode(root.right, key)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left: <span class="hljs-keyword">return</span> root.right
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.right: <span class="hljs-keyword">return</span> root.left
            node = root.right
            <span class="hljs-keyword">while</span> node.left:
                node = node.left
            node.left = root.left
            root = root.right
        <span class="hljs-keyword">return</span> root</code></pre></div>
<p>还有一种方法，将二叉搜索树中序遍历，并且如果遇到目标值就跳过。在根据
<code>list</code> 构造二叉搜索树的方法生成新的树。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:
        nums = []
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            LNR(node.left)
            <span class="hljs-keyword">if</span> node.val != key: nums.append(node.val)
            LNR(node.right)
        LNR(root)
        nums_len = <span class="hljs-built_in">len</span>(nums)
        <span class="hljs-keyword">if</span> nums_len == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_BST</span>(<span class="hljs-params">l, r</span>):
            mid = (l+r)//<span class="hljs-number">2</span>
            node = TreeNode(val=nums[mid])
            <span class="hljs-keyword">if</span> l&lt;=mid-<span class="hljs-number">1</span>:
                node.left = insert_BST(l, mid-<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> r&gt;=mid+<span class="hljs-number">1</span>:
                node.right = insert_BST(mid+<span class="hljs-number">1</span>, r)
            <span class="hljs-keyword">return</span> node
        <span class="hljs-keyword">return</span> insert_BST(<span class="hljs-number">0</span>, nums_len-<span class="hljs-number">1</span>)</code></pre></div>
<h3 id="二叉搜索树中第k小的元素">230. 二叉搜索树中第K小的元素</h3>
<p>暴力解法，先将二叉搜索树中序遍历，然后返回第 <code>K</code>
小的元素。递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        nums = []
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            LNR(node.left)
            nums.append(node.val)
            LNR(node.right)
        LNR(root)
        <span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]</code></pre></div>
<p>非递归。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        nums = []
        stack = []
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:
            <span class="hljs-keyword">while</span> root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            nums.append(root.val)
            root = root.right
        <span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]</code></pre></div>
<p>其实在非递归这里可以看出来，只要数组里有 <code>k</code>
个元素就行了，根本不需要遍历完。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        counter = <span class="hljs-number">0</span>
        stack = []
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:
            <span class="hljs-keyword">while</span> root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            counter += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> counter == k: <span class="hljs-keyword">return</span> root.val
            root = root.right
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="二叉搜索树迭代器">173. 二叉搜索树迭代器</h3>
<p>在初始化 <code>__init__</code>
里把二叉搜索树的遍历结果写好，之后就很简单。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):
        nums = []
        stack = []
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:
            <span class="hljs-keyword">while</span> root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            nums.append(root.val)
            root = root.right
        self.index = <span class="hljs-number">0</span>
        self.nums = nums
        self.<span class="hljs-built_in">len</span> = <span class="hljs-built_in">len</span>(nums)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        res = self.nums[self.index]
        self.index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">if</span> self.index&lt;self.<span class="hljs-built_in">len</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>
<h3 id="二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h3>
<p>暴力解法，搜索 <code>p</code> , <code>q</code>
。遍历找出这两个节点，并且记录路径，逆序比较后得到最近公共祖先。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:
        queue = collections.deque()
        queue.append((root,[root]))
        p_ancestors = <span class="hljs-literal">None</span>
        q_ancestors = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> queue:
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):
                node, ancestors = queue.pop()
                <span class="hljs-keyword">if</span> node == p:
                    p_ancestors = ancestors
                <span class="hljs-keyword">if</span> node == q:
                    q_ancestors = ancestors
                <span class="hljs-keyword">if</span> p_ancestors <span class="hljs-keyword">and</span> q_ancestors:
                    <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">if</span> node.left: queue.append((node.left, ancestors+[node.left]))
                <span class="hljs-keyword">if</span> node.right: queue.append((node.right, ancestors+[node.right]))
        <span class="hljs-keyword">for</span> p_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(p_ancestors):
            <span class="hljs-keyword">for</span> q_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(q_ancestors):
                <span class="hljs-keyword">if</span> p_ancestor == q_ancestor:
                    <span class="hljs-keyword">return</span> p_ancestor
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>
<h3 id="二叉树的序列化与反序列化">297. 二叉树的序列化与反序列化</h3>
<p>都可以使用二叉树的遍历去解决。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>
        res = []
        queue = collections.deque()
        queue.append(root)
        <span class="hljs-keyword">while</span> queue:
            node = queue.popleft()
            <span class="hljs-keyword">if</span> node:
                res.append(<span class="hljs-built_in">str</span>(node.val))
                queue.append(node.left)
                queue.append(node.right)
            <span class="hljs-keyword">else</span>:
                res.append(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;,&#x27;</span>.join(res)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        data = data.split(<span class="hljs-string">&#x27;,&#x27;</span>)
        root = TreeNode(data[<span class="hljs-number">0</span>])
        queue = collections.deque()
        queue.append(root)
        i = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> queue:
            node = queue.popleft()
            <span class="hljs-keyword">if</span> data[i] != <span class="hljs-string">&#x27;&#x27;</span>:
                node.left = TreeNode(<span class="hljs-built_in">int</span>(data[i]))
                queue.append(node.left)
            i += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> data[i] != <span class="hljs-string">&#x27;&#x27;</span>:
                node.right = TreeNode(<span class="hljs-built_in">int</span>(data[i]))
                queue.append(node.right)
            i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> root</code></pre></div>
<h2 id="图">图</h2>
<h3 id="找到小镇的法官">997. 找到小镇的法官</h3>
<p>用 <code>dict</code> 记录每个人的信任其人数，用 <code>set</code>
记录信任过别人的人，如果满足信任某个人人数等于 <code>n-1</code>
并且他没有信任的人，他就是法官，否则没有法官。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findJudge</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, trust: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:
        hashmap = &#123;i:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#125;
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">for</span> p,t <span class="hljs-keyword">in</span> trust:
            hashset.add(p)
            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:
                hashmap[t] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                hashmap[t] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> p,count <span class="hljs-keyword">in</span> hashmap.items():
            <span class="hljs-keyword">if</span> count == n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                <span class="hljs-keyword">return</span> p
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>
<h3 id="可以到达所有点的最少点数目">1557.
可以到达所有点的最少点数目</h3>
<p>推演几次可以发现可以到达所有点的最少点其实就是不能由其它点到达的点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findSmallestSetOfVertices</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        hashset = &#123;t <span class="hljs-keyword">for</span> f,t <span class="hljs-keyword">in</span> edges&#125;
        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset]</code></pre></div>
<h3 id="钥匙和房间">841. 钥匙和房间</h3>
<p>这个和上道题不一样的是这道题的图是有可能有环的，因此直接沿用上道题的方法可能不行，可以加一个栈或队列进行图的搜索，搜索结果就是
<code>0</code> 能到达的点。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canVisitAllRooms</span>(<span class="hljs-params">self, rooms: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        queue = collections.deque()
        queue.append(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">while</span> queue:
            node = queue.popleft()
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> rooms[node]:
                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                    queue.append(i)
                    hashset.add(i)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(rooms)):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>
<h2 id="优先队列">优先队列</h2>
<h3 id="数组中的第k个最大元素">215. 数组中的第K个最大元素</h3>
<p>可以调用优先队列 <code>heapq</code> 这个包。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        heapq.heapify(nums)
        res = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-k+<span class="hljs-number">1</span>):
            res = heapq.heappop(nums)
        <span class="hljs-keyword">return</span> res</code></pre></div>
<p>当然实质上排序也是可以的。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>)[k-<span class="hljs-number">1</span>]</code></pre></div>
<p>我这里排序能过，应该是快排，如果我设立一个 <code>k</code>
大小的数组用来存放前 <code>k</code>
大的值，然后用二分法去添加新的比这个数组最小值更大的值的方法，过不了，应该是重构
<code>list</code> 太慢了。</p>
<h3 id="前-k-个高频元素">347. 前 K 个高频元素</h3>
<p>用 <code>dict</code> 进行计数（其实用
<code>collections.Counter</code> 更快），然后根据数量排序就行。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        counter = collections.Counter(nums)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(counter, reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x:counter[x])[:k]</code></pre></div>
<p>或者。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
        counter = collections.Counter(nums).most_common(k)
        <span class="hljs-keyword">return</span> [t[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> counter]</code></pre></div>
<h3 id="根据字符出现频率排序">451. 根据字符出现频率排序</h3>
<p>先对每个字符计数，再根据计数排序，再构建结果字符串。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">frequencySort</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        hashmap = collections.Counter(s)
        feq = <span class="hljs-built_in">sorted</span>(hashmap, key=<span class="hljs-keyword">lambda</span> x:hashmap[x], reverse=<span class="hljs-literal">True</span>)
        res = <span class="hljs-string">&#x27;&#x27;</span>
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> feq:
            res += t*hashmap[t]
        <span class="hljs-keyword">return</span> res</code></pre></div>
<h3 id="最接近原点的-k-个点">973. 最接近原点的 K 个点</h3>
<p>之前做过。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kClosest</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]+x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>])[:k]</code></pre></div>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ComputerScience/" class="category-chain-item">ComputerScience</a>
  
  
    <span>></span>
    
  <a href="/categories/ComputerScience/Algorithm/" class="category-chain-item">Algorithm</a>
  
  
    <span>></span>
    
  <a href="/categories/ComputerScience/Algorithm/LeetCode/" class="category-chain-item">LeetCode</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/python/">#python</a>
      
        <a href="/tags/stack/">#stack</a>
      
        <a href="/tags/linked-list/">#linked list</a>
      
        <a href="/tags/array/">#array</a>
      
        <a href="/tags/tree/">#tree</a>
      
        <a href="/tags/queue/">#queue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>「数据结构」 - 学习计划</div>
      <div>https://movisli.github.io/2023/02/21/leetcode数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>MovisLi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 21, 2023</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/22/Leetcode%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/" title="「编程能力」 - 学习计划">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">「编程能力」 - 学习计划</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/22/leetcodeSQL/" title="「SQL」 - 学习计划">
                        <span class="hidden-mobile">「SQL」 - 学习计划</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://unpkg.com/mathjax@3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>

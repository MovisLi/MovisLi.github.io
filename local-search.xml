<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode 258</title>
    <link href="/2022/06/04/leetcode20220603/"/>
    <url>/2022/06/04/leetcode20220603/</url>
    
    <content type="html"><![CDATA[<h1 id="各位相加">258. 各位相加</h1><p>简单循环，模拟题目中描述的过程逐位相加直到<code>num</code>小于10。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">while</span> num &gt;= <span class="hljs-number">10</span>:            num_str = <span class="hljs-built_in">str</span>(num)            num = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num_str])        <span class="hljs-keyword">return</span> num</code></pre></div><p>但是题目中提到了有<code>O(1)</code>时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：</p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-number">9</span>-&gt;<span class="hljs-number">9</span><span class="hljs-number">99</span>-&gt;<span class="hljs-number">18</span>-&gt;<span class="hljs-number">9</span><span class="hljs-number">999</span>-&gt;<span class="hljs-number">27</span>-&gt;<span class="hljs-number">9</span>...假设<span class="hljs-number">9.</span>..<span class="hljs-number">9</span><span class="hljs-function"><span class="hljs-params">(n位)</span>-&gt;</span><span class="hljs-number">9</span>那么<span class="hljs-number">9.</span>..<span class="hljs-number">9</span><span class="hljs-function"><span class="hljs-params">(n+<span class="hljs-number">1</span>位)</span>-&gt;</span><span class="hljs-number">9</span>(n+<span class="hljs-number">1</span>)=<span class="hljs-number">9</span>*n+<span class="hljs-number">9</span>=<span class="hljs-number">18</span>-&gt;<span class="hljs-number">9</span>所以假设成立</code></pre></div><p>通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：<span class="math display">\[\begin{cases}    result=0,\ when\ n=0 \\    result=9,\ when\ n\%9=0\ and\ n\neq 0 \\    result=n\%9,\ when\ n\%9\neq0\\\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> num==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">9</span> <span class="hljs-keyword">if</span> num%<span class="hljs-number">9</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> num%<span class="hljs-number">9</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>recursion</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再次学习python</title>
    <link href="/2022/06/02/%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0python/"/>
    <url>/2022/06/02/%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0python/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容全部基于<ahref="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程 -廖雪峰的官方网站</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 242</title>
    <link href="/2022/06/01/leetcode20220601/"/>
    <url>/2022/06/01/leetcode20220601/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词">242. 有效的字母异位词</h1><p>排序，比较两个字符串排序后是否相同。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">import</span> operator        <span class="hljs-keyword">return</span> operator.eq(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(s)), <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(t)))</code></pre></div><p>哈希，用<code>dict</code>进行计数。比上一种快。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashmap[i] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《消费信用模型：定价、利润与组合》 - 读书笔记</title>
    <link href="/2022/05/30/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/"/>
    <url>/2022/05/30/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（pricing ）、利润（ profit ）与组合（ portfolio）出发，进行了详细的探讨和论述。</p><p>这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：</p><ul><li><p>贷款机构如何根据违约风险差异化定价。</p></li><li><p>贷款机构如何把违约评分变成利润评分。</p></li><li><p>如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。</p></li></ul><h1 id="消费信用和信用评分简介">1 消费信用和信用评分简介</h1><h2 id="引言消费信用的重要性和影响力">1.1引言：消费信用的重要性和影响力</h2><p>讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。</p><h2 id="违约信用评分的历史背景">1.2 违约信用评分的历史背景</h2><ul><li><p>申请评分 - A卡</p><p>信用评分技术诞生于 20 世纪 50年代，当时的学者认识到用来分类的<strong>统计学方法</strong>可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分-申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。</p><p>这里也提到了最常见的风险是申请者在获得贷款后12个月内出现90天及以上的逾期，<strong>这个只是坏客户定义的一种</strong>。</p><p>根据这样的坏客户定义得到的模型分数，讲究<strong>排序正确</strong>。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。</p></li><li><p>行为评分 - B卡</p><p>行为评分技术诞生于20世纪80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分-贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。</p></li></ul><h2 id="贷款机构的目标">1.3 贷款机构的目标</h2><ul><li><p>银行的目标</p><p>主要目标之一是让贷款带来最多的利润，也就是需要利润率最优。 <spanclass="math display">\[profit\% = \frac{profit}{principal}\]</span>另一个目标是将贷款组合（可以理解为多笔贷款的总额）的风险回报控制在可接受的范围内。</p><p>第三个目标是扩大贷款组合的规模。</p></li><li><p>贷款过程</p><ul><li><p>获得资金</p><p>通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。</p></li><li><p>建立消费贷款组合</p><p>找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。</p></li></ul><blockquote><p>这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。<strong>这里定价指的是定利率而不是额度。</strong></p><p>这里也提到了利润评分重点在于<strong>估计从借款人（ borrower）那里可能获得的现金流</strong>，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。</p></blockquote></li></ul><h2 id="贷款决策的建模工具">1.4 贷款决策的建模工具</h2><p>银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，<strong>本质上都是决策问题</strong>。这里主要介绍了<strong>影响图（influence diagram ）</strong>和<strong>决策树（ decision tree）</strong>两种工具。</p><ul><li><p>影响图</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Influence_diagram">Influencediagram - Wikipedia</a></p></blockquote><p>一张影响图由三类节点（ node ）组成，之间由线（ arc）连接。三类节点是：</p><ul><li>决策（ 用矩形表示 ）</li><li>随机事件（ 用圆圈表示 ）</li><li>结果（ 用菱形表示 ）</li></ul><p>如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y的节点不同时，具有以下三种不同的含义。</p><ul><li>Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。</li><li>Y 是一个随机事件，那么条件概率 <spanclass="math inline">\(P(Y|X)\)</span> 和非条件概率 <spanclass="math inline">\(P(Y)\)</span> 并不相同。</li><li>Y 是一个结果，那么说明该结果受到了 X 的影响。</li></ul></li><li><p>消费信贷中的申请决策影响图</p><figure><img src="https://s2.loli.net/2022/05/31/kNCxmvM7UHplGaT.png"alt="标准消费信贷的影响图" /><figcaption aria-hidden="true">标准消费信贷的影响图</figcaption></figure></li><li><p>决策树</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Decision_tree">Decision tree -Wikipedia</a></p></blockquote><p>决策树中同样有三种类型的节点：</p><ul><li>决策（用矩形表示）</li><li>随机事件（用圆圈表示）</li><li>回报（ pay off ，用每条路径末端的数值表示）</li></ul><p><strong>值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。</strong></p></li><li><p>消费信贷中的申请决策树</p><figure><img src="https://s2.loli.net/2022/05/31/YuiINgPbfxL3jH4.png"alt="标准消费信贷的决策树" /><figcaption aria-hidden="true">标准消费信贷的决策树</figcaption></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>risk control</category>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>credit</tag>
      
      <tag>decision</tag>
      
      <tag>economics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 228 231</title>
    <link href="/2022/05/29/leetcode20220529/"/>
    <url>/2022/05/29/leetcode20220529/</url>
    
    <content type="html"><![CDATA[<h1 id="汇总区间">228. 汇总区间</h1><p>双指针 <code>start</code> 和 <code>end</code>，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []        start = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> start &lt; length:            end = start            <span class="hljs-keyword">while</span> end &lt; length-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (nums[end+<span class="hljs-number">1</span>]-nums[end])==<span class="hljs-number">1</span>:                end += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> start == end:                res.append(<span class="hljs-built_in">str</span>(nums[start]))            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-built_in">str</span>(nums[start])+<span class="hljs-string">&#x27;-&gt;&#x27;</span>+<span class="hljs-built_in">str</span>(nums[end]))            start = end+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="的幂">231. 2 的幂</h1><p>先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c的幂的最大值设为 <span class="math inline">\(x\)</span> ，必有 <spanclass="math inline">\(x\%c=0\)</span>，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是<code>2&lt;&lt;30</code> ，就可以写成如下代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">30</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><p>当然正规军的做法是位运算。首先 2的幂的二进制表示有个规律就是所有位只有一个 1，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2的幂。这里有个小技巧<ahref="https://movisli.github.io/posts/2022/05/19/Solution.html">LeetCode191</a> ，<code>n &amp; (n - 1)</code> 可以将最后一个 1去掉，既然只有一个 1 所以去掉之后就没有了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &amp; (n - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 217 219</title>
    <link href="/2022/05/27/leetcode20220527/"/>
    <url>/2022/05/27/leetcode20220527/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素">217. 存在重复元素</h1><p>简单<code>hash</code>，建立一个<code>set</code>，遍历数组，如果元素不在里面就添加，如果在里面就返回<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="存在重复元素-ii">219. 存在重复元素 II</h1><p>这次涉及到元素还有它的下标，也是简单<code>hash</code>，不过要建立的是<code>dict</code>，<code>dict</code>的<code>key</code>是元素值，<code>dict</code>的<code>value</code>是元素下标。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> n,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[v] = n            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> n-hashmap[v] &lt;= k:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    hashmap[v] = n        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 206</title>
    <link href="/2022/05/26/leetcode20220526/"/>
    <url>/2022/05/26/leetcode20220526/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表">206. 反转链表</h1><p>常见的用栈反转。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:        stack = []        node = head        <span class="hljs-keyword">while</span> node:            stack.append(node.val)            node = node.<span class="hljs-built_in">next</span>        res = ListNode()        node = res        <span class="hljs-keyword">while</span> stack:            node.<span class="hljs-built_in">next</span> = ListNode(stack.pop())            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 203 205</title>
    <link href="/2022/05/25/leetcode20220525/"/>
    <url>/2022/05/25/leetcode20220525/</url>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素">203. 移除链表元素</h1><p>一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:        res = ListNode()        res.<span class="hljs-built_in">next</span> = head        node = res        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>.val == val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div><p>也可以先对头节点进行处理，先保证头节点不是要删除的节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.val == val:            head = head.<span class="hljs-built_in">next</span>        node = head        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>.val == val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h1 id="同构字符串">205. 同构字符串</h1><p>分别建立正向映射关系<code>dict_forward</code>和逆向映射关系<code>dict_backward</code>，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：</p><blockquote><p>"bbbaaaba"</p><p>"aaabbbba"</p></blockquote><p>这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        dict_forward = &#123;&#125;        dict_backward = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_forward:                dict_forward[s[i]] = t[i]            dict_backward[t[i]] = s[i]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_forward) != <span class="hljs-built_in">len</span>(dict_backward):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_forward.items():            <span class="hljs-keyword">if</span> dict_backward[v] != k:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《信用评分工具：自动化信用管理的理论与实践》 - 读书笔记</title>
    <link href="/2022/05/24/%E3%80%8A%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E7%94%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/"/>
    <url>/2022/05/24/%E3%80%8A%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E7%94%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><p>全书共 8 个部分，分别为：</p><ul><li><p>背景设定 -讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔loan做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。</p><blockquote><ol type="1"><li>信用评分及其业务 -什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。</li><li>信用微历史 -关于信用供给、信用评分、征信机构和评级机构的简要历史。</li><li>信用评分原理 - 如何进行信用评分、怎样建立评分卡。</li></ol></blockquote></li><li><p>风险业务 -针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。</p><blockquote><ol start="4" type="1"><li>风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。</li><li>决策科学 -信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。</li><li>企业风险评估 -对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。</li></ol></blockquote></li><li><p>数学和统计 -介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。</p><blockquote><ol start="7" type="1"><li>预测统计 -因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。</li><li>区分度的测量 -用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。</li><li>零碎内容 -描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。</li><li>头脑与机器 -所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。</li></ol></blockquote></li><li><p>数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。</p><blockquote><ol start="11" type="1"><li>数据考虑 -建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。</li><li>数据来源 - 讨论从客户、内部系统和征信机构获取信息。</li><li>评分结构 -关注评分卡的定制和架设、数据整合和不同来源数据的匹配。</li><li>信息共享 -征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。</li><li>数据准备 -开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。</li></ol></blockquote></li><li><p>评分卡开发 -这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把<strong>简单、可解释性强的模型</strong>作为评分卡开发时的选择这个倾向。</p><blockquote><p>Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for PrivateCompanies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.</p></blockquote><p>作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的<code>可行性分析-&gt;需求分析-&gt;总体设计-&gt;详细设计</code>有着异曲同工之妙。作者把开发前大体的步骤划分为如下：</p><ul><li>项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。</li><li>数据收集 - 从数据来源提取大小合适的样本。</li><li>好坏定义 -不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。</li><li>样本分层 -决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）</li><li>确定模型 -开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。</li><li>决策策略 -不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。</li></ul><p>开发的完整流程如下：</p><blockquote><ol start="16" type="1"><li>变量转换 -分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。</li><li>特征选取 -确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。</li><li>样本分层 -是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。</li><li>拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。</li><li>模型校准 -用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。</li><li>检验交付 -用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。</li><li>开发管理 - 评分卡开发的流程管理和安排。</li></ol></blockquote></li><li><p>实施和使用 -遵循<strong>Wiklund提供的框架</strong>，介绍模型部署与模型监控相关内容。</p><blockquote><p>在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。</p><p>Handbook of credit scoring[M]. Global Professional Publishi,2001.</p></blockquote><blockquote><ol start="23" type="1"><li>实施安装 - 绿地开发（ Greenfield Software Development,指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield SoftwareDevelopment,指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。</li><li>管理控制 - 验证审查，保证分数合理有效。</li><li>跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。</li><li>金融财务 - 损失准备金、风险定价和利润率等问题。</li></ol></blockquote></li><li><p>信用风险管理周期 -这里提到风险管理周期可以分为五个阶段，<code>市场营销-&gt;申请审批-&gt;账户管理-&gt;催收-&gt;回收</code>。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。</p><ul><li>分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。</li><li>吸引（ solicitation ） -设计和实施营销活动，吸引潜在客户办理业务。</li><li>获取（ acquisition ） -获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。</li><li>管理（ management ） -对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。</li><li>催收（ collections ） - 重点关注早期的违约和维持客户关系。</li><li>追踪（ tracing ） -尝试联系并找到一些因没有更新住址或联系方式而失联的客户。</li><li>回收（ rehabilitation ） -处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。</li></ul><p>除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。</p><blockquote><ol start="27" type="1"><li>市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。</li><li>申请审批 - 选择客户的操作。</li><li>账户管理 -询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。</li><li>催收回收 - 违约原因和催收流程、催收时机和催收策略。</li><li>欺诈防范 - 趋势、类型和工具。</li></ol></blockquote></li><li><p>监管环境 - 介绍一些对金融机构的监管内容。</p><blockquote><ol start="32" type="1"><li>监管概念 -最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。</li><li>隐私保护 -贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。</li><li>禁止歧视 -涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。</li><li>公平信贷 -确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。</li><li>资本要求 -主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。</li><li>了解客户 -提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。</li><li>国家差异 -对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。</li></ol></blockquote></li></ul><h1 id="第一部分---背景设定">第一部分 - 背景设定</h1><h2 id="第-1-章---信用评分及其业务">第 1 章 - 信用评分及其业务</h2>]]></content>
    
    
    <categories>
      
      <category>risk control</category>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>credit</tag>
      
      <tag>scorecard</tag>
      
      <tag>risk control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 202</title>
    <link href="/2022/05/24/leetcode20220524/"/>
    <url>/2022/05/24/leetcode20220524/</url>
    
    <content type="html"><![CDATA[<h1 id="快乐数">202. 快乐数</h1><p>首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是<code>False</code>，否则就是<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">7</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        res = n        <span class="hljs-keyword">while</span> res&gt;=<span class="hljs-number">10</span>:            temp = <span class="hljs-built_in">str</span>(res)            res = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:                res += <span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> res == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> res == <span class="hljs-number">7</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了<code>hashset</code>，当这次运算结果出现在<code>set</code>里时，说明循环已经开始了，否则我们把这次结果加入<code>set</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = &#123;n&#125;        <span class="hljs-keyword">while</span> n!=<span class="hljs-number">1</span>:            temp = <span class="hljs-built_in">str</span>(n)            n = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:                n += <span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashset.add(n)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 191</title>
    <link href="/2022/05/19/leetcode20220519/"/>
    <url>/2022/05/19/leetcode20220519/</url>
    
    <content type="html"><![CDATA[<h1 id="位1的个数">191. 位1的个数</h1><p>首先来个循环检查每一位是否为1。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        bin_str = <span class="hljs-built_in">bin</span>(n)[<span class="hljs-number">2</span>:]        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> bin_str:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;1&#x27;</span>:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1，python的右移运算符<code>&gt;&gt;</code>就是高位补0，低位舍去。所以移动32次，就可以得到结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += <span class="hljs-number">1</span>            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>但是在位运算里，还有个神奇的做法，可以通过<code>n&amp;(n-1)</code>把二进制中最后一个1改写成0。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += <span class="hljs-number">1</span>            n &amp;= n-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>参考<ahref="https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/">【负雪明烛】详解位运算，附本题躲坑指南- 位1的个数 - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 190</title>
    <link href="/2022/05/18/leetcode20220518/"/>
    <url>/2022/05/18/leetcode20220518/</url>
    
    <content type="html"><![CDATA[<h1 id="颠倒二进制位">190. 颠倒二进制位</h1><p>注意下题目中的32位无符号整数。暴力解：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;0&#x27;</span>*(<span class="hljs-number">32</span>-<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))[<span class="hljs-number">2</span>:]))+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))[<span class="hljs-number">2</span>:])[::-<span class="hljs-number">1</span>], <span class="hljs-number">2</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 168 171 175 181 182 183</title>
    <link href="/2022/05/16/leetcode20220516/"/>
    <url>/2022/05/16/leetcode20220516/</url>
    
    <content type="html"><![CDATA[<h1 id="excel表列名称">168. Excel表列名称</h1><p>此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面<code>temp = (columnNumber-1)%26+1</code>这行代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convertToTitle</span>(<span class="hljs-params">self, columnNumber: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">while</span> columnNumber != <span class="hljs-number">0</span>:            temp = (columnNumber-<span class="hljs-number">1</span>)%<span class="hljs-number">26</span>+<span class="hljs-number">1</span>            res += <span class="hljs-built_in">chr</span>(temp+<span class="hljs-number">64</span>)            columnNumber = (columnNumber-temp)//<span class="hljs-number">26</span>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]</code></pre></div><h1 id="excel-表列序号">171. Excel 表列序号</h1><p>与上题差不多，上题的逆向。本质上还是个进制转换。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">titleToNumber</span>(<span class="hljs-params">self, columnTitle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        n = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> columnTitle[::-<span class="hljs-number">1</span>]:            res += (<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">64</span>)*n            n *= <span class="hljs-number">26</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="组合两个表">175. 组合两个表</h1><p>依题意做一个简单左链接就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTt1.firstName,t1.lastName,t2.city,t2.state FROMPerson t1LEFT JOIN Address t2 ON t1.personId = t2.personId</code></pre></div><h1 id="超过经理收入的员工">181. 超过经理收入的员工</h1><p>表自链接就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTl.NAME AS Employee FROMEmployee lINNER JOIN Employee r ON l.managerId = r.id WHEREl.salary &gt; r.salary</code></pre></div><h1 id="查找重复的电子邮箱">182. 查找重复的电子邮箱</h1><p>自链接</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCTt1.Email FROMPerson t1JOIN Person t2 ON t1.Email = t2.Email AND t1.Id != t2.Id</code></pre></div><p>子表查询</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTEmail FROM( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec WHEREtec.ec &gt; 1</code></pre></div><h1 id="从不订购的客户">183. 从不订购的客户</h1><p>子表查询</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTn.NAME AS Customers FROM( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n WHEREn.id IS NULL</code></pre></div><p>子表查询和<code>NOT IN</code>语句</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTCustomers.Name AS Customers FROMCustomers WHERECustomers.Id NOT IN ( SELECT CustomerId FROM Orders )</code></pre></div><p>右链接</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTa.NAME AS Customers FROMCustomers aLEFT JOIN Orders b ON a.Id = b.CustomerId WHEREb.CustomerId IS NULL</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>sql</tag>
      
      <tag>ascii</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 121 125 136 169</title>
    <link href="/2022/05/15/leetcode20220515/"/>
    <url>/2022/05/15/leetcode20220515/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p>遍历一次数组，更新数组的最小值<code>min_pcp</code>与当前值与数组最小值差的最大值<code>max_pft</code>。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    max_pft = <span class="hljs-number">0</span>    min_pcp = prices[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:      <span class="hljs-keyword">if</span> i &lt; min_pcp:        min_pcp = i        <span class="hljs-keyword">continue</span>      <span class="hljs-keyword">if</span> (i-min_pcp)&gt;max_pft:        max_pft = i-min_pcp    <span class="hljs-keyword">return</span> max_pft</code></pre></div></p><h1 id="验证回文串">125. 验证回文串</h1><p>先进行数据清洗再比较。 <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    washed = <span class="hljs-string">&#x27;&#x27;</span>.join(ch.lower() <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> ch.isalnum())    <span class="hljs-keyword">return</span> washed == washed[::-<span class="hljs-number">1</span>]</code></pre></div></p><h1 id="只出现一次的数字">136. 只出现一次的数字</h1><p>蠢蠢hashset。 <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                res.append(i)                hashset.add(i)            <span class="hljs-keyword">else</span>:                res.remove(i)        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]</code></pre></div>题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x^y, nums)</code></pre></div></p><h1 id="多数元素">169. 多数元素</h1><p>简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        feq = <span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> hashmap.items():            <span class="hljs-keyword">if</span> v &gt; feq:                <span class="hljs-keyword">return</span> k</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>string</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 83 88 94 118 119</title>
    <link href="/2022/05/13/leetcode20220513/"/>
    <url>/2022/05/13/leetcode20220513/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h1><p>基本链表操作。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> head        node = head        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.val == node.<span class="hljs-built_in">next</span>.val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h1 id="合并两个有序数组">88. 合并两个有序数组</h1><p>本题要求<code>inplace</code>，但是我们仍然可以用<code>不inplace</code>的思想做<code>inplace</code>的事情。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-number">0</span>        res = []        <span class="hljs-keyword">while</span> (left+right)&lt;(m+n):            <span class="hljs-keyword">if</span> left&gt;=m:                res.append(nums2[right])                right += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> right&gt;=n:                res.append(nums1[left])                left += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> nums1[left] &lt;= nums2[right]:                res.append(nums1[left])                left += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                res.append(nums2[right])                right += <span class="hljs-number">1</span>        nums1[:]=res</code></pre></div><p>当然我们也可以逆向开始放数，空间复杂度会更低。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        tail = m+n-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> m&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n&gt;=<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> m&lt;<span class="hljs-number">1</span>:                nums1[tail] = nums2[n-<span class="hljs-number">1</span>]                tail -= <span class="hljs-number">1</span>                n -= <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">1</span>:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> nums1[m-<span class="hljs-number">1</span>] &gt;= nums2[n-<span class="hljs-number">1</span>]:                nums1[tail] = nums1[m-<span class="hljs-number">1</span>]                m -= <span class="hljs-number">1</span>                tail -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                nums1[tail] = nums2[n-<span class="hljs-number">1</span>]                n -= <span class="hljs-number">1</span>                tail -= <span class="hljs-number">1</span></code></pre></div><h1 id="二叉树的中序遍历">94. 二叉树的中序遍历</h1><p>递归：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> root:            res.extend(self.inorderTraversal(root.left))            res.append(root.val)            res.extend(self.inorderTraversal(root.right))        <span class="hljs-keyword">return</span> res</code></pre></div><p>非递归：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        node = root        stack = []        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">or</span> stack:            <span class="hljs-keyword">if</span> node:                stack.append(node)                node = node.left            <span class="hljs-keyword">else</span>:                node = stack.pop()                res.append(node.val)                node = node.right        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="杨辉三角">118. 杨辉三角</h1><p>就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]        res = [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]        curRow = <span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> curRow&lt;numRows:            temp = [<span class="hljs-number">1</span>]            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res[curRow-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>):                temp.append(res[curRow-<span class="hljs-number">1</span>][i]+res[curRow-<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>])            temp.append(<span class="hljs-number">1</span>)            res.append(temp)            curRow += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="杨辉三角-ii">119. 杨辉三角 II</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRow</span>(<span class="hljs-params">self, rowIndex: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = [<span class="hljs-number">1</span>]        cal_num = (rowIndex)//<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, cal_num+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            res.append(<span class="hljs-built_in">int</span>(res[i-<span class="hljs-number">1</span>]*(rowIndex-i+<span class="hljs-number">1</span>)/i))        <span class="hljs-keyword">if</span> rowIndex%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cal_num,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):                res.append(res[i])        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cal_num-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):                res.append(res[i])        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>linked list</tag>
      
      <tag>array</tag>
      
      <tag>binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 70</title>
    <link href="/2022/05/11/leetcode20220511/"/>
    <url>/2022/05/11/leetcode20220511/</url>
    
    <content type="html"><![CDATA[<h1 id="爬楼梯">70. 爬楼梯</h1><p>斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        lst = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>):            lst.append(lst[i]+lst[i+<span class="hljs-number">1</span>])        <span class="hljs-keyword">return</span> lst[n]</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 66 67 69</title>
    <link href="/2022/05/10/leetcode20220510/"/>
    <url>/2022/05/10/leetcode20220510/</url>
    
    <content type="html"><![CDATA[<h1 id="加一">66. 加一</h1><p>从后往前加就行了，需要用一个<code>carry flag</code>控制是否进位，加一对末位来说就是进位的，所以当<code>carry flag</code>变为<code>False</code>时，跳出循环。如果循环走完还需进位，则需要在<code>list</code>第0个位置增添个元素1。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plusOne</span>(<span class="hljs-params">self, digits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        carry = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(digits)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> carry:                digits[i] += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> digits[i] &gt;= <span class="hljs-number">10</span>:                    digits[i] %= <span class="hljs-number">10</span>                <span class="hljs-keyword">else</span>:                    carry = <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">if</span> carry:            digits.insert(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> digits</code></pre></div><h1 id="二进制求和">67.二进制求和</h1><p>直接用内置函数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(a,<span class="hljs-number">2</span>)+<span class="hljs-built_in">int</span>(b,<span class="hljs-number">2</span>)))[<span class="hljs-number">2</span>:]</code></pre></div><h1 id="x-的平方根">69. x 的平方根</h1><p>牛顿迭代法：</p><p>为了方便区别问题写为求n的平方根，即 <span class="math display">\[x^2=n\\f(x)=x^2-n\]</span> 相当于求函数<spanclass="math inline">\(f(x)\)</span>的根，关于牛顿迭代的原理参照</p><blockquote><p><ahref="https://www.zhihu.com/question/20690553/answer/146104283">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p></blockquote><p>对<span class="math inline">\(x_0\)</span>点的切线为： <spanclass="math display">\[y = f(x_0)-2x_0(x-x0)\]</span> 令<span class="math inline">\(y=0\)</span>，迭代后的<spanclass="math inline">\(x_1\)</span>点值可算得： <spanclass="math display">\[x_1=x_0-\frac{x_0}{2}+\frac{n}{2x_0}\]</span> 每次迭代的误差为： <span class="math display">\[\varepsilon = |x0-x1|\]</span> 当误差小于0.1时跳出就行了。</p><p><strong>初值不能为0。</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            last = res            res = res - res/<span class="hljs-number">2</span> + x/<span class="hljs-number">2</span>/res            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(last-res) &lt; <span class="hljs-number">1</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(res)</code></pre></div><p>二分查找：</p><p><span class="math inline">\(x\)</span>的平方根整数部分是满足<spanclass="math inline">\(k^2\leq x\)</span>的最大<spanclass="math inline">\(k\)</span>值，所以只要保证这个条件可以进行赋值。经典二分查找代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left, right, res = <span class="hljs-number">0</span>, x, -<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left+right)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid*mid &lt;= x:                res = mid                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                right = mid-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>binary search</tag>
      
      <tag>loop</tag>
      
      <tag>Newton&#39;s method</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 58</title>
    <link href="/2022/05/09/leetcode20220509/"/>
    <url>/2022/05/09/leetcode20220509/</url>
    
    <content type="html"><![CDATA[<h1 id="最后一个单词的长度">58. 最后一个单词的长度</h1><p>反向遍历，用一个<code>flag</code>稍微控制下流程就行了，注意几个<code>if</code>的顺序。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLastWord</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        start = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> s[i] != <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> start:                start = <span class="hljs-literal">True</span>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> start:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> start:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 27 28 35 53</title>
    <link href="/2022/05/07/leetcode20220507/"/>
    <url>/2022/05/07/leetcode20220507/</url>
    
    <content type="html"><![CDATA[<h1 id="移除元素">27. 移除元素</h1><p>双指针，一个指针<code>index</code>控制循环遍历，另一个指针<code>k</code>控制将正确的数填到正确的位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        index = <span class="hljs-number">0</span>        k = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> index&lt;length:            <span class="hljs-keyword">if</span> nums[index] != val:                nums[k] = nums[index]                k+=<span class="hljs-number">1</span>            index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> k</code></pre></div><h1 id="实现strstr">28. 实现strStr()</h1><p>只是用的话，调用python字符串的find函数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> haystack.find(needle)</code></pre></div><p>思路就是逐位比较。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        length = <span class="hljs-built_in">len</span>(needle)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)-length+<span class="hljs-number">1</span>):            j = i            k = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> k&lt;length <span class="hljs-keyword">and</span> haystack[j] == needle[k]:                j += <span class="hljs-number">1</span>                k += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> j-i == length:                <span class="hljs-keyword">return</span> i                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h1 id="搜索插入位置">35. 搜索插入位置</h1><p>时间复杂度<code>O(log n)</code>，经典二分查找。但是这题如果没找到要返回插入的位置，当<span class="math inline">\(left&lt;x&lt;right\)</span>时，很明显该插入的位置是<code>right_index</code>，然后看一下经典二分查找代码，因为没找到的话<code>left</code>还是会加1，所以其实没找到的话<code>left</code>就是<code>right_index</code>，所以没找到返回<code>left</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;=right:            mid = (right+left)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> mid                <span class="hljs-keyword">return</span> left</code></pre></div><h1 id="最大子数组和">53. 最大子数组和</h1><p>动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于<code>nums[0]</code>，然后从左往右遍历，创建一个变量<code>temp_sum</code>用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个<code>temp_sum</code>了。每找出一段<code>temp_sum</code>都与<code>result</code>比较取大的作为新的<code>result</code>。遍历完成后，就可以得到最大的<code>result</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = nums[<span class="hljs-number">0</span>]        temp_sum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            temp_sum += i            <span class="hljs-keyword">if</span> temp_sum &gt; res:                res = temp_sum            <span class="hljs-keyword">if</span> temp_sum &lt; <span class="hljs-number">0</span>:                temp_sum = <span class="hljs-number">0</span>                <span class="hljs-keyword">return</span> res</code></pre></div><blockquote><p>时间复杂度 O(n)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>binary search</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 26</title>
    <link href="/2022/05/06/leetcode20220506/"/>
    <url>/2022/05/06/leetcode20220506/</url>
    
    <content type="html"><![CDATA[<h1 id="删除有序数组中的重复项">26. 删除有序数组中的重复项</h1><p>暴力解法，创建<code>set</code>用于记录出现过的唯一元素，创建<code>drop_lst</code>用于记录要删的位置，删元素的时候注意下<code>python</code>的<code>del</code>会更改后续元素的下标，所以建立一个<code>k</code>辅助找到真正的下标再删。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        drop_lst = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(nums[i])            <span class="hljs-keyword">else</span>:                drop_lst.append(i)        k = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> drop_lst:            <span class="hljs-keyword">del</span> nums[i-k]            k += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(hashset)</code></pre></div><blockquote><p>1068 ms</p></blockquote><p>核心在于前探指针，每次循环时生成一个前探指针<code>next_index</code>找寻下一个不重复的元素的<code>index</code>，用指针<code>k</code>代表下一个不重复元素（假如有）正确的位置，所以在找到正确的<code>next_index</code>后，将其赋值给<code>k</code>就行了，同时将<code>index</code>变为<code>next_index</code>，最后返回<code>k-1</code>因为多算了一次<code>k</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        index = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        k = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> index &lt; length:            next_index = index+<span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> next_index&lt;length:                <span class="hljs-keyword">if</span> nums[next_index] != nums[index]:                    <span class="hljs-keyword">break</span>                next_index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> next_index != length:                nums[k] = nums[next_index]            k += <span class="hljs-number">1</span>            index = next_index        <span class="hljs-keyword">return</span> k-<span class="hljs-number">1</span></code></pre></div><blockquote><p>28 ms</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 13</title>
    <link href="/2022/05/05/leetcode20220505/"/>
    <url>/2022/05/05/leetcode20220505/</url>
    
    <content type="html"><![CDATA[<h1 id="罗马数字转整数">13. 罗马数字转整数</h1><p>比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        s_len = <span class="hljs-built_in">len</span>(s)        index = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> index&lt;s_len:            <span class="hljs-keyword">if</span> s[index] == <span class="hljs-string">&#x27;I&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;V&#x27;</span>:                        res += <span class="hljs-number">4</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;X&#x27;</span>:                        res += <span class="hljs-number">9</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">1</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">1</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;X&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;L&#x27;</span>:                        res += <span class="hljs-number">40</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;C&#x27;</span>:                        res += <span class="hljs-number">90</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">10</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">10</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;C&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;D&#x27;</span>:                        res += <span class="hljs-number">400</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;M&#x27;</span>:                        res += <span class="hljs-number">900</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">100</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">100</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;V&#x27;</span>:                res += <span class="hljs-number">5</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;L&#x27;</span>:                res += <span class="hljs-number">50</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;D&#x27;</span>:                res += <span class="hljs-number">500</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;M&#x27;</span>:                res += <span class="hljs-number">1000</span>                index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 14 20 21</title>
    <link href="/2022/05/04/leetcode20220504/"/>
    <url>/2022/05/04/leetcode20220504/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共前缀">14. 最长公共前缀</h1><p>首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&quot;&quot;</span>        min_len = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:            min_len = <span class="hljs-built_in">min</span>(min_len, <span class="hljs-built_in">len</span>(i))        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_len):            tmp_target = strs[<span class="hljs-number">0</span>][i]            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:                <span class="hljs-keyword">if</span> s[i] != tmp_target:                    <span class="hljs-keyword">return</span> res            res += tmp_target                <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="有效的括号">20. 有效的括号</h1><p>有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回<code>False</code>，二是后括号是否对应出栈的前括号，不对应也返回<code>False</code>。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回<code>False</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;&#123;&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;[&#x27;</span>:                stack.append(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;]&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> stack:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="合并两个有序链表">21. 合并两个有序链表</h1><p>迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        res = ListNode(<span class="hljs-number">0</span>)        tmp = res        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:                tmp.<span class="hljs-built_in">next</span> = list1                tmp = tmp.<span class="hljs-built_in">next</span>                list1 = list1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                tmp.<span class="hljs-built_in">next</span> = list2                tmp = tmp.<span class="hljs-built_in">next</span>                list2 = list2.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> list1:            tmp.<span class="hljs-built_in">next</span> = list1        <span class="hljs-keyword">elif</span> list2:            tmp.<span class="hljs-built_in">next</span> = list2        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1 9</title>
    <link href="/2022/05/03/leetcode20220503/"/>
    <url>/2022/05/03/leetcode20220503/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和">1. 两数之和</h1><p>建立一个<code>dict</code>(map)，遍历一次数组，判断<code>目标值-当前值</code>是否在<code>dict</code>的<code>key</code>里，在就输出对应的<code>value</code>(index)与当前的<code>index</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            temp_target = target - nums[i]            <span class="hljs-keyword">if</span> temp_target <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> [hashmap[temp_target], i]            <span class="hljs-keyword">else</span>:                hashmap[nums[i]] = i        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h1 id="回文数">9. 回文数</h1><p>转字符串判断正序和逆序是否相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(x)[::-<span class="hljs-number">1</span>]==<span class="hljs-built_in">str</span>(x)</code></pre></div><p> 左右指针逐步向中间移动判断每一步是否相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        string = <span class="hljs-built_in">str</span>(x)        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(string)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;right:            <span class="hljs-keyword">if</span> string[left] != string[right]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

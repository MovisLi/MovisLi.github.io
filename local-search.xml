<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python 环境管理</title>
    <link href="/2024/09/03/python%20%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/"/>
    <url>/2024/09/03/python%20%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="pip">pip</h1><h2 id="镜像源">镜像源</h2><h3 id="从镜像源安装包">从镜像源安装包</h3><div class="code-wrapper"><pre><code class="hljs shell">pip install &lt;包名&gt; -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre></div><h1 id="conda">conda</h1><h2 id="版本管理">版本管理</h2><h3 id="查看环境">查看环境</h3><div class="code-wrapper"><pre><code class="hljs shell">conda env list</code></pre></div><p>标了 <code>*</code> 号的代表当前环境。</p><h3 id="创建环境">创建环境</h3><div class="code-wrapper"><pre><code class="hljs shell">conda create -n &lt;环境名&gt;</code></pre></div><p>指定 python 版本：</p><div class="code-wrapper"><pre><code class="hljs shell">conda create -n &lt;环境名&gt; python=&lt;版本号&gt;</code></pre></div><h3 id="删除环境">删除环境</h3><div class="code-wrapper"><pre><code class="hljs shell">conda remove -n &lt;环境名&gt; --all</code></pre></div><h3 id="激活环境">激活环境</h3><div class="code-wrapper"><pre><code class="hljs shell">conda activate &lt;环境名&gt;</code></pre></div><h3 id="退出激活环境">退出激活环境</h3><div class="code-wrapper"><pre><code class="hljs shell">conda deactivate</code></pre></div><h2 id="环境变量管理">环境变量管理</h2><h3 id="查看环境变量">查看环境变量</h3><div class="code-wrapper"><pre><code class="hljs shell">conda env config vars list</code></pre></div><h3 id="设置环境变量">设置环境变量</h3><div class="code-wrapper"><pre><code class="hljs shell">conda env config vars set &lt;变量名&gt;=&lt;变量值&gt;</code></pre></div><h3 id="取消设置环境变量">取消设置环境变量</h3><div class="code-wrapper"><pre><code class="hljs shell">conda env config vars unset &lt;变量名&gt;</code></pre></div><h1 id="poetry">poetry</h1><h3 id="初始化项目">初始化项目</h3><div class="code-wrapper"><pre><code class="hljs shell">poetry init</code></pre></div><h2 id="依赖管理">依赖管理</h2><h3 id="安装包">安装包</h3><h3 id="安装依赖">安装依赖</h3><div class="code-wrapper"><pre><code class="hljs shell">poetry add &lt;包名&gt;</code></pre></div><p>为 <code>dev</code>环境安装包，这个依赖仅用于开发环境中，比如测试工具和代码质量检查工具。</p><div class="code-wrapper"><pre><code class="hljs shell">poetry add &lt;包名&gt; --group dev</code></pre></div><h3 id="更新包">更新包</h3><p>更新项目中的所有依赖到最新的兼容版本，并更新 <code>poetry.lock</code>文件。</p><div class="code-wrapper"><pre><code class="hljs shell">poetry update</code></pre></div><h3 id="删除包和依赖">删除包和依赖</h3><div class="code-wrapper"><pre><code class="hljs shell">poetry remove &lt;包名&gt;</code></pre></div><h3 id="查看包">查看包</h3><div class="code-wrapper"><pre><code class="hljs shell">poetry show</code></pre></div><h2 id="打包与发布">打包与发布</h2><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">构建项目，生成 .tar.gz 和 .whl 格式的分发包。</span>poetry build<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">将构建的包发布到 PyPI 或其他配置的仓库。</span>poetry publish</code></pre></div><h2 id="版本管理-1">版本管理</h2><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示或更新项目的版本号。例如 poetry version patch 自动递增补丁版本号</span>poetry version</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>backtrader</title>
    <link href="/2024/07/25/backtrader/"/>
    <url>/2024/07/25/backtrader/</url>
    
    <content type="html"><![CDATA[<h1 id="summary">Summary</h1><p><a href="https://www.backtrader.com/">Backtrader</a>是一个可同时用于量化交易回测（基于事件）与实盘交易的开源框架。</p><h1 id="控制器">控制器</h1><p>在 Backtrader 中，控制器叫做 <code>Cerebro</code>，是一个调度中心，控制着数据、策略、执行与评估部分。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> backtrader <span class="hljs-keyword">as</span> bt<span class="hljs-comment"># 实例化 Cerebro</span>cerebro = bt.cerebro()<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 获取数据实例</span><span class="hljs-comment"># 将数据添加进控制器中</span>cerebro.adddata(data)<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 编写策略类</span><span class="hljs-comment"># 将策略添加进控制器中</span>cerebro.addstrategy(XXXStrategy)<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 编写头寸类</span><span class="hljs-comment"># 设置交易的头寸</span>cerebro.addsizer(XXXSizer)<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 获取经纪商实例</span><span class="hljs-comment"># 设置交易的经纪商</span><span class="hljs-comment"># 如果不写默认用 BackBroker ，这是一个本地回测用的虚拟券商</span>cerebro.setbroker(xxxbroker)<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 编写评估指标类</span><span class="hljs-comment"># 将评估指标添加进控制器</span>cerebro.addanalyzer(XXX)<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 编写观察器类</span><span class="hljs-comment"># 将观察器添加进控制器，观察器和画图相关</span>cerebro.addobserver(XXX)<span class="hljs-comment"># 运行控制器</span>res = cerebro.run()<span class="hljs-comment"># 画图</span>cerebro.plot()</code></pre></div><p>整个过程的模拟都是由 <code>cerebro</code> 对象去完成的。</p><h1 id="数据">数据</h1><h2 id="datafeeds">DataFeeds</h2><p>在 Backtrader 中， <code>datafeeds</code>是一个用于导入数据的模块，可以将表格数据转化为一个<code>DataSeries</code> 对象。</p><h3 id="dataseries">DataSeries</h3><p><code>DataSeries</code> 是一个表格的形式的类，这个表格由 7列组成：</p><ul><li>datetime - 用于记录一个时段的开始时间。</li><li>open - 此时段的开盘价。</li><li>high - 此时段的最高价。</li><li>low - 此时段的最低价。</li><li>close - 此时段的收盘价。</li><li>volume - 此时段的成交量。</li><li>openinterest - 此时段未平仓的合约量。</li></ul><p>创建 DataFeeds 的方法有很多种，比较常用的就是通过 pandas 的 DataFrame创建。</p><div class="code-wrapper"><pre><code class="hljs python">data = bt.feeds.PandasData(dataname=df)</code></pre></div><p>在创建 <code>DataFeeds</code>的时候，其实不需要保证原始数据里面具有上面提到的 7列。假设出现这种情况，会在 <code>cerebro</code> 运行时报错。</p><h3 id="lineseries-lines">LineSeries &amp; Lines</h3><p>看源码可以发现 <code>DataSeries</code> 类继承了<code>LineSeries</code> 类（可以看作一个没有指定这些列的类），而<code>datetime</code>, <code>open</code>... 这些就是 <code>Lines</code>。</p><p>因此可以理解为 <code>LineSeries</code> 相当于 pandas 中的 DataFrame，而 <code>Lines</code> 则相当于 pandas 中的 Series 。</p><h1 id="策略">策略</h1><h2 id="strategy">Strategy</h2><h3 id="交易策略">交易策略</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleStrategy</span>(bt.Strategy):        params = (        (...,...),    )        <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, txt: <span class="hljs-built_in">str</span>, dt=<span class="hljs-literal">None</span></span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        设定策略打印日志的格式</span><span class="hljs-string">        &quot;&quot;&quot;</span>        dt = dt <span class="hljs-keyword">or</span> self.datas[<span class="hljs-number">0</span>].datetime.date(<span class="hljs-number">0</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;dt.isoformat()&#125;</span>, <span class="hljs-subst">&#123;txt&#125;</span>&quot;</span>)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        初始化属性、计算指标等</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        在开始前调用</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">prenext</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        `nextstart()` 之前策略准备阶段</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextstart</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        `next()` 之前，策略运行的第一个时点</span><span class="hljs-string">        </span><span class="hljs-string">        只运行一次</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        策略正常运行阶段，每根 Bar 都调用</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        策略结束，对应最后一根 Bar 结束</span><span class="hljs-string"></span><span class="hljs-string">        告知系统回测已完成，可以进行策略重置和回测结果整理了</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>       <span class="hljs-comment"># 以下都是设定打印日志的具体内容</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_order</span>(<span class="hljs-params">self, order</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        通知订单信息</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_trade</span>(<span class="hljs-params">self, trade</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        通知交易信息</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_cashvalue</span>(<span class="hljs-params">self, cash, value</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        通知当前资金和总资产</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_fund</span>(<span class="hljs-params">self, cash, value, fundvalue, shares</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        返回当前资金、总资产、基金价值、基金份额</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_store</span>(<span class="hljs-params">self, msg, *args, **kwargs</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        返回供应商发出的信息通知</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_data</span>(<span class="hljs-params">self, data, status, *args, **kwargs</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        返回数据相关的通知</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_timer</span>(<span class="hljs-params">self, timer, when, *args, **kwargs</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        返回定时器的通知</span><span class="hljs-string">        </span><span class="hljs-string">        定时器可以通过函数 `add_time()` 在 `__init__()` 里添加</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span></code></pre></div><p>制定好策略之后，需要将策略添加进 <code>cerebro</code> ：</p><div class="code-wrapper"><pre><code class="hljs python">cerebro.addstrtegy(ExampleStrategy)</code></pre></div><h3 id="交易信号">交易信号</h3><p>除了编写 <code>Strategy</code> 类来编写策略，还可以编写<code>SingalStrategy</code> 类来编写策略。这两者的区别在于<code>SignalStrategy</code> 类<strong>不需要调用交易函数（ buy, sell）</strong>，<code>cerebro</code> 会自动将 <code>SingalStrategy</code>里的信号 <code>signal</code> 转换为交易指令。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 注意这里是继承的 `Indicator`</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleSignal</span>(bt.Indicator):        <span class="hljs-comment"># 声明 xxx 线，交易信号放在 xxx 这个 Lines 上</span>    lines = (<span class="hljs-string">&#x27;signal&#x27;</span>,)    params = (xxx,)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.lines.signal = ...</code></pre></div><p>这里 <code>lines.signal</code> 的取值决定了信号类型：</p><ul><li><code>signal</code> 大于 0 - 对应多头 long 信号</li><li><code>signal</code> 小于 0 - 对应空头 short 信号</li><li><code>signal</code> 等于 0 - 不发指令</li></ul><p>制定好信号后，需要将信号添加进 <code>cerebro</code> ：</p><div class="code-wrapper"><pre><code class="hljs python">cerebro.add_signal(    sigtype = ,<span class="hljs-comment"># 配置触发信号时的交易类型</span>    sigcls = ,<span class="hljs-comment"># 传入交易信号类</span>    ...<span class="hljs-comment"># 传入交易信号参数</span>)</code></pre></div><p>其中可以配置的交易类型有以下等：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 多空开仓信号</span><span class="hljs-comment"># 多头信号会先平仓空头，再开仓多头</span><span class="hljs-comment"># 空头信号会先平仓多头，再开仓空头</span>bt.SIGNAL_LONGSHORT<span class="hljs-comment"># 多头开仓信号</span><span class="hljs-comment"># 多头信号开仓，空头信号平仓</span>bt.SIGNAL_LONG<span class="hljs-comment"># 空头开仓信号</span><span class="hljs-comment"># 空头信号开仓，多头信号平仓</span>bt.SIGNAL_SHORT<span class="hljs-comment"># 多头平仓信号</span><span class="hljs-comment"># 空头信号平仓</span>bt.SIGNAL_LONGEXIT<span class="hljs-comment"># 空头平仓信号</span><span class="hljs-comment"># 多头信号平仓</span>bt.SIGNAL_SHORTEXIT</code></pre></div><p>由于交易信号指标通常只是技术指标之间进行加减得到，在技术指标完全已知的情况下，很容易连续不断地生成交易信号。这里会有两种特殊情况：</p><ul><li>订单累计 -即使已经在市场上，信号也会产生新的订单，进而增加头寸。</li><li>订单并发 - 新订单会并行执行，而不是等待其他订单执行完毕。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 是否允许订单累计发生</span>cerebro.signal_accumulate(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 是否允许订单并发发生</span>cerebro.signal_concurrency(<span class="hljs-literal">True</span>)</code></pre></div><h2 id="indicator">Indicator</h2><h3 id="预计算指标">预计算指标</h3><p>如果想要导入预计算指标，可以通过继承 <code>DataSeries</code>的方式添加 <code>Lines</code> （在数据部分已经提到，一个<code>Lines</code> 对象就是一列，这里相当于添加指标列）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PandasDataExtend</span>(bt.feeds.PandasData):    lines = (        <span class="hljs-string">&#x27;indicator1&#x27;</span>,        <span class="hljs-string">&#x27;indicator2&#x27;</span>,    )        <span class="hljs-comment"># -1 表示自动按列名匹配数据</span>    params = (        (<span class="hljs-string">&#x27;indicator1&#x27;</span>, -<span class="hljs-number">1</span>),        (<span class="hljs-string">&#x27;indicator2&#x27;</span>, -<span class="hljs-number">1</span>),    )    <span class="hljs-comment"># data 是一个 dataframe</span><span class="hljs-comment"># calculate_indicator1, calculate_indicator1 都是计算指标的函数</span>data[<span class="hljs-string">&#x27;indicator1&#x27;</span>] = data.apply(<span class="hljs-keyword">lambda</span> x: calculate_indicator1(x), axis=<span class="hljs-number">1</span>)data[<span class="hljs-string">&#x27;indicator2&#x27;</span>] = data.apply(<span class="hljs-keyword">lambda</span> x: calculate_indicator2(x), axis=<span class="hljs-number">1</span>)datafeed = PandasDataExtend(dataname=data)cerebro.add(datafeed)...</code></pre></div><h3 id="实时计算指标">实时计算指标</h3><h4 id="原生指标">原生指标</h4><p><a href="https://www.backtrader.com/docu/indautoref/">Indicators -Reference - Backtrader</a></p><div class="code-wrapper"><pre><code class="hljs python">bt.indicator.XXX</code></pre></div><h4 id="ta-lib-库指标">TA-lib 库指标</h4><p><a href="https://www.backtrader.com/docu/talibindautoref/">Indicators- ta-lib - Reference - Backtrader</a></p><div class="code-wrapper"><pre><code class="hljs python">bt.talib.XXX</code></pre></div><h4 id="自定义指标">自定义指标</h4><ul><li><code>__init__()</code> - <strong>对整条 <code>Lines</code>进行计算，运算结果也以整条 <code>Lines</code>返回。</strong>也就是说，并不是只有最开始的数据点。</li><li><code>next()</code> - 对数据点进行运算。每个 bar （ DataFeeds的每行）会运行一次。</li><li><code>once()</code> -这个方法只运行一次，但是需要从头到尾循环计算指标。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleIndicator</span>(bt.Indicator):        <span class="hljs-comment"># 指标暂存的数据</span>    lines = (        <span class="hljs-string">&#x27;temp1&#x27;</span>,        <span class="hljs-string">&#x27;temp2&#x27;</span>,    )        <span class="hljs-comment"># 指标的可选参数</span>    params = (        (<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">10</span>),    )        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        可选</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        可选</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">once</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        可选</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-comment"># 画图用的，如果不需要画图可以不设置</span>    plotinfo = ...plotlines = ...</code></pre></div><h2 id="sizer">？Sizer</h2><h2 id="order">Order</h2><h3 id="订单类型">订单类型</h3><ul><li>Order.Market - 市价单。回测时按<strong>下一个 Bar的开盘价</strong>成交。</li><li>Order.Close - 也是市价单。只不过回测时按<strong>下一个 Bar的收盘价</strong>成交。</li><li>Order.Limit - 限价单。对于买方来说，如果下一个 Bar的开盘价更低，以下一个 Bar的开盘价成交；如果开盘价更高，但是订单价格限定在最高最低价之间，那么以订单价格成交；否则不成交。</li><li>Order.Stop -止损单。一旦达到或超过特定的止损价格后，止损单即变为市价单来买或买证券或商品。止损单不担保以特定的价格执行。</li><li>Order.StopLimit -和止损单类似。一旦达到或超过特定价格后启动，不过是以限价单的方式启动。</li><li>Order.StopTrail - 跟踪止损单。一种会自动调整价格的止损单。</li><li>Order.StopTrailLimit -跟踪止损限价单，启动后以限价单的方式执行。</li></ul><h3 id="创建订单">创建订单</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">这里的 self 都是指策略</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># 买入/做多 long</span>self.order = self.buy(data = xxx,<span class="hljs-comment"># 默认为当前策略的第一个数据集 self.datas[0] 创建订单</span>    size = xxx,<span class="hljs-comment"># 默认调用 getsizer() 获取头寸</span>    price = xxx,<span class="hljs-comment"># 适用于限价单，止损单和止损限价单</span>    plimit = xxx,<span class="hljs-comment"># limit price ，仅适用于 StopLimit</span>    exectype = Order.XXX,<span class="hljs-comment"># 订单类型，默认市价单</span>    valid = xxx,<span class="hljs-comment"># 订单有效期，默认撤单前有效</span>    tradeid = xxx,<span class="hljs-comment"># 交易编号</span>)<span class="hljs-comment"># 卖出/做空 short</span>self.order = self.sell(...)<span class="hljs-comment"># 和 buy 参数一样</span><span class="hljs-comment"># 平仓 cover</span>self.order = self.close(...)<span class="hljs-comment"># 和 buy 参数一样</span><span class="hljs-comment"># 目标下单函数</span><span class="hljs-comment"># 按目标数量下单，多退少补</span>self.order = self.order_target_size(target=size)<span class="hljs-comment"># 按目标金额和当前金额的情况决定下单方式</span>self.order = self.order_target_value(target=value)<span class="hljs-comment"># 按当前账户总资产目标百分比下单，多退少补</span>self.order = self.order_target_percent(target=percent)<span class="hljs-comment"># 组合订单</span>self.order = self.buy_bracket()self.order = self.sell_bracket()</code></pre></div><p><code>buy_bracket()</code> 用于long side的交易场景，买入证券后，在价格下跌时，希望通过止损单卖出证券，限制损失；在价格上升时，希望通过限价单卖出证券，及时获利，通过<code>buy_bracket()</code> 可以同时提交上述 3 个订单，而无需繁琐的调用 3次常规交易函数。</p><p><code>sell_bracket()</code> 用于short side的交易场景，卖出证券做空后，在价格上升时，希望通过止损单买入证券，限制损失；在价格下降时，希望通过限价单买入证券，及时获利，<code>sell_bracket()</code>也是一次同时提交上述 3 个订单 。</p><p>只当在主订单执行后，止损单和止盈单才会被激活，而且是同时激活；如果主订单被取消，止盈单和止损单也会被取消；在止盈单和止损单激活之后，如果取消两者中的任意一个，那另外一个也会被取消。</p><h3 id="取消订单">取消订单</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 通过 broker 取消</span>broker.canel(order)</code></pre></div><h3 id="关联订单">关联订单</h3><p>通过在 <code>buy()</code> 或者 <code>sell()</code> 中给<code>oco</code> 参数传入订单实例来实现订单的关联。</p><h3 id="订单状态">订单状态</h3><ul><li>Order.Created - 订单已经被创建。</li><li>Order.Submitted - 订单已经被传递给经纪商。</li><li>Order.Accepted - 订单已经被经纪商接收。</li><li>Order.Partial - 订单已部分成交。</li><li>Order.Complete - 订单已成交。</li><li>Order.Rejected - 订单已被经纪商拒绝。</li><li>Order.Margin - 执行该订单需要追加保证金。</li><li>Order.Cancelled - 确认订单已经被撤销。</li><li>Order.Expired - 订单已到期。</li></ul><h1 id="执行">执行</h1><h2 id="broker">Broker</h2><p>具体到不同的券商，会有不同的初始本金以及交易费用（包括佣金、平台费、SEC收取的费用等等）。对于回测来讲，还可以考虑滑点（ slippage）以及市场影响（ market impact ）。这些统称为交易条件。</p><p>这些可以通过两种方式进行设置：</p><ol type="1"><li>将交易条件作为参数的方式实例化 <code>Broker</code>类，生成新的实例，然后在 <code>cerebro</code> 里设置这个实例。</li><li>调用 <code>broker</code> 对象的 <code>set_xxx</code>方法去修改交易条件（通过 <code>get_xxx</code> 可以查看交易条件）。</li></ol><h3 id="交易费用">交易费用</h3><p><code>BackBroker</code> 中有一个 <code>commission</code>参数，用来全局设置交易手续费。</p><h4 id="默认设置模板">默认设置模板</h4><div class="code-wrapper"><pre><code class="hljs python">broker.setcommission(    commission=...,<span class="hljs-comment"># 佣金费率，根据 commtype 确定百分比还是固定</span>    margin=<span class="hljs-literal">None</span>,<span class="hljs-comment"># 期货保证金，只有 `stocklike=False` 时生效</span>    mult=...,<span class="hljs-comment"># 计算期货保证金的乘数</span>    commtype=<span class="hljs-literal">None</span>,<span class="hljs-comment"># 佣金类型 `COMM_PERC` 为百分比 `COMM_FIXED` 为固定 `None` 根据 margin 取值确定</span>    percabs=<span class="hljs-literal">True</span>,<span class="hljs-comment"># 百分比格式 `True` 表示 0.xx 这种格式 `False` 表示 xx% 这种格式</span>    stocklike=<span class="hljs-literal">False</span>,<span class="hljs-comment"># 是否为股票模式</span>    interest=...,<span class="hljs-comment"># 空头头寸地年化利息</span>    interest_long=<span class="hljs-literal">False</span>,<span class="hljs-comment"># 多头头寸地年化利息</span>    leverage=...,<span class="hljs-comment"># 杠杆比率</span>    automargin=<span class="hljs-literal">False</span>,<span class="hljs-comment"># 自动计算保证金</span>    name=<span class="hljs-literal">None</span>,<span class="hljs-comment"># 取值为 `None` 默认作用于全部数据集</span>)</code></pre></div><p>这种方式其实不太灵活，还是建议自定义设置。</p><h4 id="自定义设置">自定义设置</h4><p>要自定义交易费用设置，需要写自己的 <code>Commission</code> 类：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleCommission</span>(bt.CommInfoBase):        <span class="hljs-comment"># 对应 setcommission 中的参数，也可以增添新的全局参数</span>    params = (        (xxx, xxx),    )        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_getcommission</span>(<span class="hljs-params">self, size, price, pseudoexec</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        自定义交易费用计算方式</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_margin</span>(<span class="hljs-params">self, price</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        自定义佣金计算方式</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span></code></pre></div><p>然后将自定义的交易费用类<strong>实例化</strong>，再传递给<code>broker</code> ：</p><div class="code-wrapper"><pre><code class="hljs python">example_comm = ExampleCommission(...)<span class="hljs-comment"># `name` 参数用于指定该交易费用适用标的</span>broker.addcommissioninfo(example_comm, name=<span class="hljs-string">&#x27;xxx&#x27;</span>)</code></pre></div><h3 id="回测">回测</h3><h4 id="资金与持仓管理">资金与持仓管理</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 设置初始资金</span>broker.set_cash(xxx)<span class="hljs-comment"># 获取当前可用资金</span>broker.get_cash()<span class="hljs-comment"># 添加资金</span><span class="hljs-comment"># 正数表示添加，负数表示减少</span>broker.add_cash()<span class="hljs-comment"># 获取当前总资产</span>broker.get_value()<span class="hljs-comment"># 获取当前持仓情况， getposition() 需要指定具体数据集</span><span class="hljs-comment"># 持仓数量</span>broker.getposition(data).size<span class="hljs-comment"># 持仓成本价</span>broker.getposition(data).price</code></pre></div><h4 id="滑点管理">滑点管理</h4><p>滑点是<strong>回测</strong>里应该考虑的额外成本，因此只有<code>BackBroker</code> 实现了相关方法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 以百分比的方式估计滑点及市场影响</span>broker.set_slippage_perc(...)<span class="hljs-comment"># 以固定金额估计滑点及市场影响</span>broker.set_slippage_fixed(...)</code></pre></div><p>有关滑点的其他参数如下：</p><ul><li><code>slip_open</code> - bool - 是否对开盘价做滑点处理。</li><li><code>slip_match</code> - bool -是否将滑点处理后的新成交价与成交当天的价格区间最低价和最高价之间做匹配，如果为True ，则根据新成交价重新匹配调整价格区间，确保订单能被执行；如果为False，则不会与价格区间做匹配，订单不会执行，但会在下一日执行一个空订单。</li><li><code>slip_out</code> - bool -如果新成交价高于最高价或低于最高价，是否以超出的价格成交，如果为 True，则允许以超出的价格成交；如果为 Fasle，实际成交价将被限制在最高最低价格区间内；默认取值为 False 。</li><li><code>slip_limit</code> - bool - 是否对限价单执行滑点，如果为 True，即使 slip_match 为 Fasle ，也会对价格做匹配，确保订单被执行；如果为Fasle ，则不做价格匹配；默认取值为 True 。</li></ul><h4 id="成交量限制">成交量限制</h4><p>这里的成交量限制并不是分配仓位，而是一种对流动性的估计。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 设置最大固定股数成交量 xxx</span>filler = bt.broker.fillers.FixedSize(size=xxx)<span class="hljs-comment"># 设置最大固定百分比成交量 xxx</span><span class="hljs-comment"># 百分比为当前 Bar 总成交量的百分比</span>filler = bt.broker.fillers.FixedBarPerc(perc=xxx)<span class="hljs-comment"># 设置最大流动百分比的成交量 xxx</span><span class="hljs-comment"># 其中 minmov 是可选参数，默认为 None</span>filler = bt.broker.fillers.BarPointPerc(perc=xxx1， minmov=xxx2)broker.set_filler(filler=filler)</code></pre></div><p>前两种 <code>FixedSize</code> 与 <code>FixedBarPerc</code>都挺好理解，第三种 <code>BarPointPerc</code> 的计算过程为： <spanclass="math display">\[\begin{equation}\begin{aligned}parts&amp;=\frac{high-lowe+minmov}{minmov}\\volume_{max}&amp;=\frac{volume_{bar}}{parts}\times perc\\&amp;=\frac{minmov}{high-low+minmov}\times volume_{bar} \times perc\end{aligned}\end{equation}\]</span> 可以看到实际上就是在当前 Bar中，如果最低价最高价价差比较大，对成交量的限制就比较严格；如果最低价最高价价差比较小，限制则比较宽松。</p><h4 id="交易时机管理">交易时机管理</h4><p>Backtrader默认使用当日收盘后下单，次日以开盘价成交这种模式。但是也有当日下单，以当日价格（开盘价/收盘价）成交的选项，这种情况下是有可能使用未来数据的（比如下单的时候并不知道收盘价，但是却用收盘价来计算了订单数量和金额）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 以当日开盘价下单</span>broker.set_coo(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 以当日收盘价下单</span>broker.set_coc(<span class="hljs-literal">True</span>)</code></pre></div><p>但是值得注意的是，这里以当日开盘价下单其实意思是将下单时间放到下个交易日（本来是当前交易日下单，下个交易日成交）。</p><p>这里需要将交易的逻辑写在 <code>next_open()</code>,<code>nextstart_open()</code>, <code>prenext_open()</code> 中，而不是<code>next()</code> 中。</p><h3 id="实盘">？实盘</h3><h1 id="评估">评估</h1><h2 id="analyzer">Analyzer</h2><h3 id="内置分析器">内置分析器</h3><p>对于要评估的指标，在运行 <code>cerebro</code> 之前需要添加：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 添加分析器（指标）</span>cerebro.addanalyzer(    bt.analyzers.XXX,    _name=<span class="hljs-string">&quot;_XXX&quot;</span>,）<span class="hljs-comment"># 运行</span>result = cerebro.run()    <span class="hljs-comment"># 提取结果</span>xxx_result = result[<span class="hljs-number">0</span>].analyzers._XXX.get_analysis()</code></pre></div><h3 id="自定义分析器">自定义分析器</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleAnalyzer</span>(bt.Analyzer):        params = (        (xxx, xxx)    )        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        初始化属性、计算指标等</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-comment"># 以下发生时点和自定义 `Strategy` 一样</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">prenext</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextstart</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):        <span class="hljs-comment"># 与自定义 `Strategy` 一样的信息打印函数</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_order</span>(<span class="hljs-params">self, order</span>):        <span class="hljs-string">&#x27;&#x27;&#x27;通知订单信息&#x27;&#x27;&#x27;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_trade</span>(<span class="hljs-params">self, trade</span>):        <span class="hljs-string">&#x27;&#x27;&#x27;通知交易信息&#x27;&#x27;&#x27;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_cashvalue</span>(<span class="hljs-params">self, cash, value</span>):        <span class="hljs-string">&#x27;&#x27;&#x27;通知当前资金和总资产&#x27;&#x27;&#x27;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_fund</span>(<span class="hljs-params">self, cash, value, fundvalue, shares</span>):        <span class="hljs-string">&#x27;&#x27;&#x27;返回当前资金、总资产、基金价值、基金份额&#x27;&#x27;&#x27;</span>        <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_analysis</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">pass</span></code></pre></div><h2 id="observer">？Observer</h2>]]></content>
    
    
    <categories>
      
      <category>Economics&amp;Finance</category>
      
      <category>Investment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quant</tag>
      
      <tag>investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经济机器是怎样运行的</title>
    <link href="/2024/07/22/%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/2024/07/22/%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="经济机器是怎样运行的">经济机器是怎样运行的</h1><h2 id="生产率的提高">生产率的提高</h2><h3 id="交易">交易</h3><p>经济由无数个<strong>交易（ transaction）</strong>组成，交易是经济的最基本零件。</p><h3 id="货币">货币</h3><p>在交易中，买方使用<strong>货币（ currency ）/信用（ credit）</strong>与卖方交换<strong>商品（ good ）/服务（ service ）/金融资产（asset ）</strong>。 <span class="math display">\[支出=货币+信用\]</span> 支出是经济的驱动力。</p><h3 id="市场">市场</h3><p><span class="math display">\[价格=\frac{支出总额}{销量}\]</span></p><p>政府是交易的最大买方和卖方，政府由收税和花钱的<strong>中央政府和中央银行</strong>组成。</p><p>央行通过<strong>影响利率和发行更多货币</strong>来控制<strong>经济中的货币和信贷数量</strong>。</p><h3 id="信用">信用</h3><p><strong>信贷</strong>是经济中最重要的组成部分，信贷一旦产生就成为债务，<strong>债务是贷款人的资产（asset ），是借款人的负债（ debt）</strong>。信贷重要的原因是借款人一旦获得贷款，便可以增加支出，另一个人就增加了收入，从而刺激了经济。</p><p>信用良好的借款人具备两个条件：</p><ul><li>偿还能力 - 收入比债务高，借款人就具备偿还能力。</li><li>不能还债时的抵押物 - 有价值可以出售的资产。</li></ul><p>因此收入增加使信用增加，因此支出也会增加。一个人的支出是另一个人收入，从而使另一个人收入也增加，循环往复可以驱动经济增长，因此形成<strong>周期（period）</strong>。</p><p><strong>假设没有信贷</strong>，增加支出的唯一办法是增加收入，增加收入需要提高生产率，这时<strong>提高生产率是经济增长的唯一办法</strong>。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202406171712566.png" /></p><p>但是由于信贷的存在，实质上是向未来的自己借钱，未来的自己钱就会减少。在有信贷的经济体中，信贷也可以增加支出，因此，<strong>信贷也能推动经济增长</strong>。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202406171735065.png" /></p><p>不良信贷：信贷造成超过偿还能力的过度消费。</p><p>良性信贷：高效率的分配资源产生收入（借钱购买生产原材料提高生产率）。</p><h3 id="生产力">生产力</h3><p>在一项交易中，得到多少等于生产多少。<strong>长期</strong>来看，知识随着时间增多，从而提高<strong>生产率</strong>的水平。</p><p><strong>生产率</strong>的提高在<strong>长期</strong>中最重要，而<strong>信贷</strong>在<strong>短期</strong>中最重要。</p><blockquote><p>因为生产率的提高不会剧烈波动，因此不是经济起伏的一个重要动力。</p><p>但是债务是这种动力，因为在借贷时可以让消费超过产出，还贷时消费又要低于产出。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202406171705351.png" /></p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202406171710076.png" /></p></blockquote><h2 id="短期债务周期">短期债务周期</h2><p>在短期债务周期中，限制支出的唯一因素时贷款人和借款人的意愿（贷款意愿和借款意愿）。如果信贷易于获得，经济就会<strong>扩张</strong>；如果信贷不易获得，经济就会<strong>衰退</strong>。这个周期主要由央行控制，<strong>通常持续5-8 年</strong>。</p><h3 id="扩张">扩张</h3><p>支出持续增加，价格开始上涨。因为导致支出增加的是信贷，而信贷可以凭空即刻产生。</p><p>根据<spanclass="math inline">\(价格=\frac{支出金额}{销量}\)</span>这个公式，如果支出金额的增长速度超过销量的增长速度，价格就会上涨。物价的上涨被称为<strong>通货膨胀</strong>。</p><h3 id="衰退">衰退</h3><p>央行看到通货膨胀（价格上涨）时会<strong>提高利率</strong>。利率上涨会减少借债，增加偿贷成本，这样支出金额就会减少。由于支出减少，价格将下跌。物价的下跌被称为<strong>通货紧缩</strong>。</p><p>通货紧缩时期也是<strong>经济衰退</strong>期，如果衰退过于严重，并且通货膨胀不是问题，央行将会<strong>降低利率</strong>。利率下降会加速经济活动（借债），减少偿债成本，这样支出金额就会增加。</p><h2 id="长期债务周期">长期债务周期</h2><h3 id="泡沫">泡沫</h3><p>在每个短期债务周期的低谷和高峰后，经济增长和债务都超过前一个周期，这是由人促成的，因为人具有借更多钱花更多钱的倾向，而不喜欢偿还债务。因此在长期内，债务增加速度超过收入，从而形成<strong>长期债务周期</strong>，这个过程也被称为<strong>杠杆化</strong>或<strong>泡沫</strong>。</p><p>债务的增速超过收入，迫使人们削减支出，另一个人的收入开始下降，信用开始降低，借债减少，但是偿债继续增加，又会迫使另一个人的支出降低，如此往复。这时到达<strong>长期债务顶峰</strong>，周期开始逆转，进入<strong>去杠杆化时期</strong>。</p><h3 id="去杠杆化">去杠杆化</h3><p>在去杠杆化过程中，人们削减支出，收入下降，信贷消失，资产价格下跌，银行发生挤兑，社会紧张加剧，并形成恶行循环。</p><p>收入下降，偿债成本增加，信用枯竭，借款人无法借到足够的钱偿还债务，只能出售资产。出售热潮使市场充斥代售资产，资产价格下跌，抵押物价值下降，信用进一步降低，形成恶性循环。</p><p>长期债务周期中的去杠杆化和短期债务周期中的衰退不一样的地方在于，无法通过降低利率去加速经济活动，因为这时利率降低到接近零。</p><p>有 4 种办法可以应对去杠杆化：</p><ul><li>个人企业和政府<strong>削减支出</strong><ul><li>这种情况也被称为<strong>紧缩</strong>，目的是通过减少支出的方式减少债务，问题在于减少支出后，另一个人收入变少，如此循环，自己的收入也减少。收入下降的速度超过还债速度，会造成实际上还债负担更重。</li></ul></li><li>通过债务违约和重组<strong>减少债务</strong><ul><li>借款人不偿还贷款，借款人的债务是贷款人的资产，对贷款人来讲就是资产缩水，这种严重的经济收缩被称为<strong>萧条</strong>。萧条的一个主要特征是人们发现属于自己的财富中有很大一部分并不存在（借款人的债务违约对贷款人来讲就是资产消失）。</li></ul></li><li><strong>财富再分配</strong>将财富从富人转给穷人<ul><li>由于政府支出增加（失业救济金，刺激计划等以弥补经济活动减少），政府预算赤字飙升，只能通过<strong>加税</strong>或者<strong>举债</strong>来提升政府收入。但是由于人们的收入本来就在降低，因此加税不现实，只能向富人<strong>融资</strong>（增加富人的税）。</li></ul></li><li>央行<strong>发行货币</strong><ul><li>央行通过影响利率和发行更多货币来控制经济中的货币和信贷数量。这时，利率几乎没有下降空间，因此只能发行货币。央行通过发行的货币购买金融资产帮助推升资产价格，提高拥有金融资产的人的信用。</li><li>但是，央行可以印钱，却不能给人民送钱，因此为了刺激经济，央行和政府需要合作。央行购买债券，相当于借钱给政府，使其能运行赤字预算。</li><li>这种办法实际上是在弥补经济体中的支出金额（货币和信贷，信贷减少，通过增加货币保持平衡）。</li></ul></li></ul><p><strong>和谐去杠杆</strong>的关键在于，决策者需要平衡通货紧缩的办法（削减支出、减少债务、财富再分配）和通货膨胀的办法（发行货币）。</p><h3 id="通货再膨胀">通货再膨胀</h3><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202406181633778.png" /></p><blockquote><p>作者 3 条忠告</p><ul><li>不要让债务的增长速度超过收入 - 因为债务负担最终会压垮人</li><li>不要让收入的增长速度超过生产率 - 因为将会失去竞争力</li><li>尽一切努力提高生产率 - 因为生产率在长期内起关键作用</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Economics&amp;Finance</category>
      
      <category>Economics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quant</tag>
      
      <tag>investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>量化投资笔记</title>
    <link href="/2024/07/01/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/01/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概念图">概念图</h1><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202407031629653.png" /></p><p>量化交易的获利逻辑是<strong>通过执行交易（更改投资组合的配置）来获取利润</strong>。</p><h1 id="利润">利润</h1><p>交易的利润也称为收益（Profit），分为 Alpha Profit（Alpha 收益）和Beta Profit（Beta 收益）。</p><h2 id="alpha-收益">Alpha 收益</h2><p>Alpha 收益指的是投资者得到<strong>与市场波动无关</strong>的回报。</p><p>获得 Alpha收益的关键点是<strong>在交易中关于买卖时机的把握和持有头寸选择的技巧</strong>。</p><p>因此 Alpha策略被称为<strong>主动投资</strong>，研究独立于市场的超额收益。</p><h2 id="beta-收益">Beta 收益</h2><p>Beta 收益指的是投资者得到<strong>由市场因素带来</strong>的回报。</p><p>因此 Beta策略被称为<strong>被动投资</strong>，研究市场的整体收益。</p><p>通常，Alpha 是扣除市场基准回报之后的投资汇报率，可以写成如下的公式：<span class="math display">\[Profit=\alpha+\beta\]</span></p><h1 id="系统">系统</h1><p>量化交易系统指程序化（自动）地进行<strong>时机选择</strong>和<strong>头寸配置</strong>的系统。通常系统里面包含了数据接入与清洗的数据模块，根据预测提供投资组合的模型模块，根据分析执行交易的交易模块。</p><h1 id="模型">模型</h1><h2 id="alpha-模型">Alpha 模型</h2><p>Alpha 模型的目的是为了获取 Alpha收益，一般来讲根据驱动类型的不同分为<strong>理论驱动型</strong>和<strong>数据驱动型</strong>。</p><h3 id="理论驱动型-技术型">理论驱动型 / 技术型</h3><p>理论驱动型模型通过经济学原理来预测市场行为。理论驱动型模型的输入数据一般分为价格（Price）和基本面（Fundamental）这两种。</p><h4 id="价格">价格</h4><h5 id="趋势跟随策略-动量策略">趋势跟随策略 / 动量策略</h5><blockquote><p>Trend Following 趋势跟随</p><p>Momentum 动量</p></blockquote><p>趋势跟随策略的基本假定是<strong>在一定时间内市场通常是朝着同一方向变化</strong>，因此在趋势形成时买，在趋势消失时卖。其基本的经济学原理是<ahref="https://en.wikipedia.org/wiki/General_equilibrium_theory">市场均衡理论</a>，在市场形势逐渐明朗的过程中，会有越来越多的交易者采取相同的策略。这个策略的核心在于如何定义趋势，最常见的是使用滤波（filtering）和调理（conditioning）。缺点在于收益不稳定，比较适合趋势比较固定的时期，不太适合震荡时期。</p><p>竞争对动量策略的影响主要在于会缩短趋势持续的时间，在动量策略面临竞争的情况下，越早利用趋势的交易者越能盈利。</p><h5 id="反趋势策略-均值回归策略">反趋势策略 / 均值回归策略</h5><blockquote><p>Counter Trend 趋势反转</p><p>Mean Reversion 均值回归</p></blockquote><p>均值回归策略认为<strong>价格终究会沿着已有趋势的反方向来运动，不可能一直延续已有的趋势</strong>，因此在价格低于均值时买，在价格高于均值时卖。其基本的经济学原理是<ahref="https://en.wikipedia.org/wiki/Supply_and_demand">供需原理</a>，流动性带来的短期超买超卖<strong>在长期会回归均衡水平</strong>。这个策略的核心在于如何计算均值，最常见的是统计套利策略。缺点在于不太适合趋势性较强的时期，需要长期才会反转，考虑到机会成本和货币的时间成本，其实不一定能盈利。</p><p>竞争对均值回归策略的影响是逐渐消除套利机会，使这个策略几乎无利可图。</p><h5 id="技术情绪型策略">技术情绪型策略</h5><blockquote><p>Technical Sentiment 技术情绪</p></blockquote><p>技术情绪型策略主要通过追踪投资者情绪相关指标（交易价格、交易量以及波动性等）来判断预期回报。没有明确的经济学理论支持。</p><h4 id="基本面">基本面</h4><h5 id="价值型策略-收益型策略">价值型策略 / 收益型策略</h5><blockquote><p>Value 价值</p><p>Yield 收益</p></blockquote><p>价值型策略认为市场倾向于高估高风险资产的风险，低估低风险资产的风险，因此在估值过低时买，在估值过高时卖。这个策略的核心在于对买/卖股票的准确估值。缺点在于可能需要长期持有低估值的股票，也就是不好判断兑现估值的时间。</p><h5 id="成长型策略">成长型策略</h5><blockquote><p>Growth 成长</p></blockquote><p>成长型策略试图通过资产以往增长水平来预估未来增长的走势，因此倾向买入涨速快的资产。这个策略非常依赖市场的分析师和经济学家的观点。</p><h5 id="品质型策略">品质型策略</h5><blockquote><p>Quality 品质/质量</p></blockquote><p>品质型策略认为最好买入或持有高品质的资产而做空或减持低品质的资产。其基本概念是看重资金的安全性。这个策略的核心在于要前瞻性地关注品质（杠杆、收益多样性、管理水平以及欺诈风险各方面）的变化。缺点在于适合市场惨淡的时期，不适合市场良好的时期。</p><h3 id="经验驱动型-数据驱动型">经验驱动型 / 数据驱动型</h3><p>数据驱动型的策略主要是通过数据挖掘试图找出一些对未来由解释能力的模式，从而基于概率去交易。隐形假设是未来和历史很相似。</p><p>这种策略/模型具有两大优势：</p><ol type="1"><li>技术门槛更高，竞争者相对更少。</li><li>一定程度上可以分辨出一些没有经济理论支撑的市场行为。</li></ol><p>也有三大缺点：</p><ol type="1"><li>不好定义当前的市场环境。</li><li>不好确定寻找相似市场环境时的搜索算法。</li><li>不好确定最优历史数据的回溯时间段。</li></ol><h4 id="多因子策略">多因子策略</h4><p>Alpha因子是市场、基本面和替代数据的转化，包含预测信号。有些因子描述的是整个经济的基本变量，如增长、通胀、波动、生产率和人口风险。其他因子则代表了投资风格，如价值投资、增长投资和动量投资。还有一些因素是根据金融市场的经济学或机构设置或投资者行为（包括这种行为的已知偏差）来解释价格走势的。</p><p>因子对于机器学习来说就是特征，可以想办法将理论驱动型的结论变成一个因子，比如：</p><ul><li>技术指标 - 可以使用如 <code>TA-Lib</code>之类的技术指标库，从价格、成交量等历史时序数据从中提取因子（比如<code>RSI</code> , <code>MACD</code> 等等）。</li><li>市场数据变换 - 比如成交量加权价格最近一月的平均值、最近 x天的收益率、季节信息（简单的比如当前是第几个月）等等。</li><li>样本基本面数据 - 像行业（ LabelEncoder 或者 OneHotEncoder之后）、当前财务数据等等。</li><li>宏观基本面数据 - 包括各种指数及其数据变换。</li><li>第三方 API - 比如 <code>Fama/French</code> 的 5因子模型的因子值（有点滞后）。</li><li>另类数据 - 可以想办法将另类数据聚合成因子。</li></ul><p>因子构造的时候，不同的因子可能是属于不同量纲的时期，具体构造的时候也要注意量纲最好统一，另外也可以在这里进行头尾删除操作以增加稳定性。</p><h4 id="横截面模型">横截面模型</h4><p>所谓横截面模型是指在某个时点建立模型去预测<strong>未来某个时点</strong>的表现（Y ），这个时候每个样本的因子（ X）为<strong>某一支股票在某一天的数据</strong>。</p><p>一般来说可以分为回归模型和分类模型：</p><ul><li>回归 - 比如预测 1 天后的价格变动率（模型的 Y 为 <spanclass="math inline">\(\frac{Price_{t+1}}{Price_{t}}\)</span> ）。</li><li>分类 - 比如预测 1 天后的价格变动方向（模型的 Y为明日价格变动正负）。</li></ul><h3 id="策略实施的关键因素">策略实施的关键因素</h3><h4 id="目标值">目标值</h4><p>目标值（Label / Target）是什么：</p><ul><li>分类（二分类预测收益的正负）</li><li>回归（预测收益的变动率）</li><li>时序（预测价格变动的时间）</li></ul><h4 id="投资期限">投资期限</h4><ul><li>高频策略（high-frequency strategy） -预测期限不超过当日，日内交易，日末平仓。</li><li>短线策略（short-term strategy） -预测期限为近几天，通常持仓一天到两周。</li><li>中线策略（medium-term strategy） - 预测期限是几天到几个月。</li><li>长线策略（long-term strategy） - 通常持仓几个月或更长。</li></ul><h4 id="投资结构">投资结构</h4><p>预测金融产品<strong>自身</strong>的信息还是预测<strong>相对于其他</strong>产品的信息。</p><h4 id="投资范围">投资范围</h4><ul><li>地理范围（美股、港股还是 A 股）</li><li>资产种类（外汇、股票）</li><li>产品类别（股票、股指）</li></ul><h4 id="模型设置">模型设置</h4><p>特征（因子）的选择。</p><h4 id="运行频率">运行频率</h4><ul><li>运行频率高 -优点是带来更多的机会，缺点是投资组合变动频繁，给经纪商的佣金比较多。</li><li>运行频率低 -优点是留有余地大，缺点是投资组合变动时可能幅度很大，也容易错失交易机会。</li></ul><p>一般来说运行频率取决于很多因素。</p><h2 id="风险模型">风险模型</h2><p>风险管理时通过对敞口实施有目的的选择和规模控制来提高收益的质量和稳定性。</p><h3 id="风险规模">风险规模</h3><p>进行交易时，接受的敞口要在考虑收益和风险的保障范围内。</p><h4 id="控制规模的方式">控制规模的方式</h4><ol type="1"><li>硬性约束 - 比如规定某种产品头寸不能超过投资组合的3%。这种方式对临界值的处理太过武断。</li><li>惩罚 -建立惩罚函数（边际惩罚递增）。这种方式阐述的观点是有时候机会好到足以打破规矩。</li></ol><h4 id="度量风险的方式">度量风险的方式</h4><ol type="1"><li>通过纵向方式来度量不确定性的风险 -例如波动率，计算不同时期各个产品收益的标准差。越小越好。</li><li>通过给定产品范围对各种金融产品表现的相似水平进行测量 -计算给定时间的金融产品的横截面标准差（cross-sectional standarddeviation）。越大越好（说明金融产品表现种类更多样，更离散dispersion）。</li></ol><h4 id="限制值的使用范围">限制值的使用范围</h4><ol type="1"><li>对一个/一类产品的仓位加以限制。</li><li>管理投资组合整体的杠杆率，用在险价值（VaR，Value atRisk）估计投资组合的风险水平。</li></ol><h3 id="风险种类">风险种类</h3><h4 id="理论驱动型风险模型">理论驱动型风险模型</h4><p>经典的理论驱动型风险建模专注于已知的或<strong>系统性的风险因素</strong>。优点是囊括的风险因素有明确的意义，缺点是风险因素不会怎么变动（因为依赖理论）。</p><h4 id="经验数据驱动型风险模型">经验/数据驱动型风险模型</h4><p>数据驱动型风险模型是利用主成分分析（PCA）等统计方法从历史数据中识别出风险因素。优点是自适应性，因为可能发现新的风险因素，缺点是在市场环境变化的时候表现效果不好和由于满足统计学意义上的显著性需要大量数据。</p><h2 id="交易成本模型">交易成本模型</h2><blockquote><p>Transaction Cost 交易成本</p></blockquote><p>交易成本模型的基本理念是：交易是有成本的，除非有足够的理由，否则不应该进行交易。</p><p>交易成本主要由三部分构成：佣金和费用、滑点和市场冲击成本。</p><h3 id="佣金和费用">佣金和费用</h3><blockquote><p>Commissions &amp; Fees 佣金和费用</p></blockquote><p>由于使用了券商、交易所的服务，因此需要提供佣金。另外还需要付给监管者监管费用。</p><p>每个券商需要支付的费用不一样，构建交易系统计算成本的时候要分别处理计算。</p><h3 id="滑点">滑点</h3><blockquote><p>Slippage 滑点</p></blockquote><p><strong>滑点</strong>是<strong>交易者决定</strong>执行交易到<strong>订单被执行</strong>期间<strong>价差</strong>。简单来讲就是不是你看到一个价格卖单你就能以这个价格（或者比它低）买的。</p><p>对于市价单来讲，需要支付的是滑点成本。但是对于限价单来说，需要支付的应该叫机会成本（错失交易机会，少赚钱）。</p><h3 id="市场冲击成本">市场冲击成本</h3><blockquote><p>Market Impact 市场影响/市场冲击</p><p>Liquidity 流动性</p></blockquote><p>市场冲击成本是指交易者所交易的资产的供需动态而产生的成本。比如一笔流动性比较低的大额订单可能会大幅影响市场，完成交易时的价格可能不太友好。</p><p>为了减小市场冲击成本，可以从流动性、市值和拆分订单三个方向对股票进行限制。</p><h4 id="流动性限制">流动性限制</h4><p>可以根据股票的流动性来限制订单的大小（股数）。衡量流动性的一种常见方法是平均每日交易量（可以选近一段时期）。根据经验，每个订单不应该超过平均每日交易量的1% 。</p><h4 id="市值限制">市值限制</h4><p>减少市场影响的另一种方法是根据股票的市值去调整订单规模。比如说根据市值去加权，不过这里不应该使用线性加权，因为这样做小盘股和微盘股的权重基本是0 ，这样会使投资组合缺乏多样性。建议大盘股和小盘股的比例不超过 10 。</p><h4 id="拆单">拆单</h4><p>通过把大订单拆分为小订单并随着时间推移分别执行。这种方法的副作用是可能会增加滑点。</p><h3 id="交易成本模型种类">交易成本模型种类</h3><p>一般来说，交易成本曲线是二次型的，因为随着交易规模增大带来的市场冲击影响更大，交易成本上升的速度会更快。</p><h4 id="固定交易成本模型">固定交易成本模型</h4><p>假设无论订单规模如何，交易成本保持不变。这种模型计算非常简单，但往往不符合实际。</p><h4 id="线性交易成本模型">线性交易成本模型</h4><p>假设交易成本是线性的，做一个线性拟合。这种模型考虑了交易规模增加带来的交易成本增大。</p><h4 id="分段交易成本模型">分段交易成本模型</h4><p>分段做线性拟合。这种模型是对线性模型的优化。</p><h4 id="二次交易成本模型">二次交易成本模型</h4><p>用二次函数拟合交易成本与交易规模的关系，这种模型最贴近事实，但是不容易拟合准确，计算比较复杂。</p><h2 id="投资组合模型">投资组合模型</h2><p>量化投资组合模型构建主要分为两大类：基于规则的模型和基于优化的模型。模型的输出变量就是目标投资组合：理想的头寸以及各个头寸的规模。</p><h3 id="基于规则">基于规则</h3><h4 id="相等头寸加权">相等头寸加权</h4><p>每个产品购买一样多的金额，主要目的是通过在尽可能多的头寸上进行多样化投注来减缓风险。</p><h4 id="相等风险加权">相等风险加权</h4><p>基于波动率调整购买金额的比率，波动率越高，购买占比越少。</p><h4 id="alpha-驱动型">Alpha 驱动型</h4><p>根据 Alpha模型来决定购买信号强度的大小（比如上涨的概率，涨幅，涨速这些），结合波动率去做加权。</p><h3 id="基于优化">基于优化</h3><blockquote><p>Optimization 优化</p></blockquote><p>基本原理是<ahref="https://en.wikipedia.org/wiki/Modern_portfolio_theory">现代投资组合理论</a>：投资者一贯是风险厌恶型，如果两种产品收益相同但是风险水平不同，投资者倾向于选择低风险产品。由此引出风险调整收益（risk-adjustedreturn）。</p><p>要考虑的因素有 3 个：</p><ul><li>期望收益</li><li>期望波动率</li><li>期望相关性 - 一般用期望相关系数矩阵表示。</li></ul><h2 id="执行模型">执行模型</h2><h3 id="订单执行算法">订单执行算法</h3><p>主要对订单类型，订单规模，下单地点进行选择。</p><h4 id="订单类型">订单类型</h4><ul><li>市价单（进取订单） -一定会执行，只要有对应的相反订单就可以成交。</li><li>限价单（被动订单） - 可能不执行。</li></ul><p>限价指令簿（limit orderbook）是所有限定价格的买卖申报指令（都是限价单）的集合。</p><h4 id="订单规模">订单规模</h4><p>由于大订单的交易成本会不成比例地上涨（市场影响冲击），所以可以考虑分散出单降低交易成本。</p><h4 id="下单地点">下单地点</h4><ul><li>明交易平台 -市场参与者可以从限价指令簿种看到买/卖单的价格和规模等信息。</li><li>暗交易平台 - 订单不会公布。</li></ul><h3 id="交易基础设施">交易基础设施</h3><p>主要考虑以下几个因素：</p><ul><li>服务器位置</li><li>通信协议</li><li>操作系统</li><li>服务器硬件配置</li><li>软件及编程语言</li></ul><h1 id="数据">数据</h1><h3 id="数据类型">数据类型</h3><h4 id="市场数据">市场数据</h4><h5 id="价格-1">价格</h5><h5 id="交易量">交易量</h5><h4 id="基本面数据">基本面数据</h4><h5 id="cpi-消费者物价指数">CPI 消费者物价指数</h5><p><strong>CPI 是衡量通货膨胀的主要指标之一</strong>。一般定义超过 3%为通货膨胀，超过 5% 就是比较严重的通货膨胀。</p><p>发布时间表见 <ahref="https://www.bls.gov/schedule/news_release/cpi.htm">Schedule ofReleases for the Consumer Price Index</a> 。</p><h5 id="ppi-生产者物价指数">PPI 生产者物价指数</h5><p>PPI反映了工业企业生产环节的价格变动情况，用于衡量企业为了生产而购买的原材料、劳务等费用。与CPI 会有联动关系。</p><p>发布时间表见 <ahref="https://www.bls.gov/schedule/news_release/ppi.htm">Schedule ofReleases for the Producer Price Index</a> 。</p><h5 id="pmi-采购经理指数">PMI 采购经理指数</h5><p>PMI 是反映经济扩张还是收缩的指标，50 是分界线。PMI结果于每月第一个星期一发布。</p><p>PMI 高于 50 代表经济扩张，高出越多，越显示经济扩张良好；PMI 低于 50则代表经济收缩，低出越多，表明经济越萧条。</p><h5 id="adp-national-employment-report">ADP National EmploymentReport</h5><p>ADP俗称小非农，是对美国非农就业人口的预测，每个月第一个星期的星期三公布。</p><p><a href="https://adpemploymentreport.com/">ADP® EmploymentReport</a></p><h5 id="employment-situation">Employment Situation</h5><p>这个俗称大非农，指美国劳工部发布的非农业就业人数、就业率和失业率这三个数值，发布的时间为每个月第一个星期的星期五。</p><p><ahref="https://www.bls.gov/schedule/news_release/empsit.htm">Schedule ofReleases for the Employment Situation</a></p><h4 id="另类数据">另类数据</h4><blockquote><p>Alternative Data 另类数据</p></blockquote><p>这类数据往往是非结构化的，不过从这里去获得 Alpha信号相当于对于仅仅依靠市场数据和基本面数据的人来讲相当于是数据层面上的竞争领先。</p><h5 id="网络数据">网络数据</h5><p>比如推文，类似大众点评网站的评论。</p><h5 id="地理数据">地理数据</h5><p>包括位置编码，卫星图像等等。</p><h5 id="信用卡数据">信用卡数据</h5><p>可以用来分析最近的消费趋势。</p><h3 id="数据来源">数据来源</h3><ul><li>交易所 - 价格、交易量、时间戳、持仓量、空头持仓量、订单簿数据。</li><li>监管机构 -各个公司的财务报表、个股的大股东持股情况以及内部买卖活动。</li><li>政府 -宏观经济数据，如失业率（美国比较看重）、通货膨胀率（美国比较看重）和 GDP（中国比较看重）数据。</li><li>公司 - 财务报告及其他公告（如红利的变化等）。</li><li>新闻机构 - 新闻报道（主要是市场情绪相关）。</li><li>数据供应商 - 做以上数据的加工。</li></ul><h3 id="数据清洗">数据清洗</h3><ul><li>缺失值</li><li>异常值</li></ul><h4 id="分割调整">分割调整</h4><blockquote><p>Split Adjusted 分割调整</p></blockquote><p>一家公司股票被分割为 <span class="math inline">\(N\)</span>份，除息日为 <span class="math inline">\(T\)</span> 时，<spanclass="math inline">\(T\)</span> 之前所有价格都需要乘以 <spanclass="math inline">\(\frac{1}{N}\)</span> 。当 <spanclass="math inline">\(N\)</span> 小于 1 时，就是逆向分割。</p><h4 id="派息调整">派息调整</h4><blockquote><p>Dividend Adjusted 派息调整</p></blockquote><p>本质上就是公司派发给股东利息影响的股价调整。</p><p>当一家公司发行每股 <span class="math inline">\(d\)</span>美元的股息，除息日为 <span class="math inline">\(T\)</span> 时，<spanclass="math inline">\(T\)</span> 之前所有价格都需要乘以 <spanclass="math inline">\(\frac{Close_{T-1}-d}{Close_{T-1}}\)</span>。这种乘法分割方式是最常见的，比如 Yahoo Finance 就是这样做的。</p><h4 id="幸存者偏差">幸存者偏差</h4><blockquote><p>Survivorship Bias 幸存者偏差</p></blockquote><p>存活下来的资产肯定更优质，可能会造成策略回测普遍比实盘效果好。解决这个问题有以下做法：</p><ul><li>自己创建数据库，每日更新，但这样可能需要手动做分割调整和派息调整。</li><li>购买无幸存者偏差的数据库，但是一般比较贵。</li><li>使用近期的数据，这样可以减小影响，但是可能会丢失信息造成过拟合。</li></ul><h4 id="前视偏差">前视偏差</h4><blockquote><p>Look-Ahead Bias 前视偏差</p></blockquote><p>数据的前视偏差就是机器学习里的特征穿越，指某个时点用到了那时之后的数据。</p><h3 id="数据存储">数据存储</h3><ul><li>平面文件</li><li>指针平面文件（相当于给平面文件加了一个索引）</li><li>关系型数据库</li></ul><h1 id="评估">评估</h1><h3 id="样本集划分">样本集划分</h3><ul><li>训练集 - 用于模型训练，参数拟合。</li><li>测试集 -用于检验策略效果，在训练样本的时间之外。要注意的是在训练集上开发模型做特征衍生的时候<strong>不要向训练集透露测试集的特征分布情况</strong>，否则也可能会过拟合。</li></ul><h3 id="评价指标">评价指标</h3><h4 id="累积盈利图">累积盈利图</h4><h4 id="收益率">收益率</h4><h5 id="收益率-1">收益率</h5><p><span class="math display">\[R_{t}=\frac{P_{t}-P_{t-1}}{P_{t-1}}\]</span></p><p>其中 <span class="math inline">\(R_{t}\)</span> 代表 <spanclass="math inline">\(t-1\)</span> 到 <spanclass="math inline">\(t\)</span> 时刻的收益率，<spanclass="math inline">\(P_{t}\)</span> 代表资产在 <spanclass="math inline">\(t\)</span> 时刻的价格，<spanclass="math inline">\(P_{t-1}\)</span> 代表资产在 <spanclass="math inline">\(t-1\)</span> 时刻的价格。</p><h5 id="对数收益率">对数收益率</h5><p><span class="math display">\[r_{t}=ln(1+R_{t})=ln(\frac{P_{t}}{P_{t-1}})\]</span></p><p>其中 <span class="math inline">\(r_{t}\)</span>就是对数收益率，这样表示可以简化多阶段的收益，多阶段总对数收益率就是多阶段对数收益率的和。</p><h5 id="年化收益">年化收益</h5><p><span class="math display">\[R_{annual}=\frac{P_{t}-P_{t-1}}{t(days)}\times 252\]</span></p><p>其中 252 是平均每年的交易日天数。</p><h5 id="复合年增长率">复合年增长率</h5><p><span class="math display">\[CAGR=((\frac{EV}{BV})^{\frac{1}{n}}-1)\times 100\]</span></p><p>复合年增长率（ Compound Annual Growth Rate ）计算公式如上，其中 <spanclass="math inline">\(EV\)</span> 是投资组合的终值（ Ending Value，投资结束时的价值）， <span class="math inline">\(BV\)</span>是投资组合的初始价值（ Beginning Value ，投资开始时的价值）， <spanclass="math inline">\(n\)</span> 是投资组合的年数。</p><h5 id="波动率">波动率</h5><p><span class="math display">\[\sigma=Std(r)\]</span></p><p>注意这里的波动率（ Volatility）是收益率的<strong>样本</strong>标准差而不是价格的标准差。</p><blockquote><p>也就是说使用 numpy 时，要使用 <code>np.std(x, ddof=1)</code></p></blockquote><h4 id="收益率随时间的变异性">收益率随时间的变异性</h4><ul><li>块度</li></ul><h4 id="波峰波谷间的最大回撤">波峰波谷间的最大回撤</h4><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202407091808738.png" /></p><h5 id="最大回撤">最大回撤</h5><p>对于最大回撤来讲，值得考虑的有<strong>最大回撤的深度</strong>（一般来说小于10%）和<strong>最大回撤的周期</strong>（一般来说小于 4 个月）。</p><p>最大回撤深度指的是<strong>先出现的最大值</strong>与<strong>后出现的最小值</strong>的<strong>差值</strong>。（这里说的最值都是指当时而不是回溯）。</p><p>最大回撤周期指的是<strong>先出现的最大值</strong>与<strong>后面再到这个值</strong>的<strong>最长时间</strong>。</p><h5 id="最大回撤率">最大回撤率</h5><p><span class="math display">\[MaxDrawdown\%=\frac{Depth}{MaxValue}\]</span></p><h4 id="预测力">预测力</h4><p>机器学习的评价指标。</p><h4 id="胜率或盈利时间占比">胜率或盈利时间占比</h4><h4 id="回报相对于风险的比率">回报相对于风险的比率</h4><h5 id="夏普比率">夏普比率</h5><p><span class="math display">\[SharpRatio=\frac{E(R_{p})-R_{f}}{\sigma_{p}}\]</span></p><p>其中 <span class="math inline">\(E(R_{p})\)</span>代表投资组合的预期收益率， <span class="math inline">\(R_{f}\)</span>代表无风险利率。<strong>这里的无风险利率和收益率时间维度要一致。</strong></p><p>因此， <span class="math inline">\(E(R_{p})-R_{f}\)</span>代表投资组合的预期超额收益率 ， <spanclass="math inline">\(\sigma_{p}\)</span>代表投资组合超额收益率的波动率。</p><p>一般来说，夏普比率小于 1的策略不适合作为独立策略，保证每月盈利的策略年化夏普比率通常大于 2，保证每天盈利的策略年化夏普比率通常大于 3 。</p><p>为了方便比较不同策略的夏普比率，可以将夏普比率转化为年化夏普比率。拿月化夏普比率和年化夏普比率转化过程来说，年化预期超额收益<span class="math inline">\(E(R_{p})-R_{f}\)</span>会变成月化预期超额收益的 12 倍，而年化波动率则会变为月化波动率的 <spanclass="math inline">\(\sqrt{12}\)</span>倍，因此，最终的年化夏普比率是月化夏普比率的 <spanclass="math inline">\(\sqrt{12}\)</span> 倍。</p><h5 id="mar-比率">MAR 比率</h5><p><span class="math display">\[MARRatio=\frac{CAGR}{MaxDrawdown\%}\]</span></p><p>MAR 比率可以认为是风险调整后的复合年增长率，越高越好。</p><h5 id="信息比率">信息比率</h5><p><span class="math display">\[InformationRatio=\frac{E(R_{p}-R_{b})}{\sigma_{p-b}}\]</span></p><p>其中 <span class="math inline">\(E(R_{p}-R_{b})\)</span>代表预期投资组合的超额收益率，<spanclass="math inline">\(\sigma_{p-b}\)</span> 代表超额收益的波动率。</p><p>可以看到信息比率和夏普比率其实很像，夏普比率可以算是信息比率的一种特例，即以无风险利率为基准。</p><ul><li>杠杆率</li></ul><h4 id="与其他策略的关系">与其他策略的关系</h4><p>该策略是基于动量的、均值回归的、市场中性的、有方向性的吗？</p><h4 id="时间延迟">时间延迟</h4><ul><li>容量 - 比如想卖空的时候能不能卖空？</li><li>流动性</li></ul><h4 id="特定参数的敏感性">特定参数的敏感性</h4><p>这些技术是否引入了大量的参数，这可能会导致优化偏差？</p>]]></content>
    
    
    <categories>
      
      <category>Economics&amp;Finance</category>
      
      <category>Investment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quant</tag>
      
      <tag>investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cypher 与 neo4j</title>
    <link href="/2024/04/16/neo4j/"/>
    <url>/2024/04/16/neo4j/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="基础">基础</h1><h2 id="核心概念">核心概念</h2><p>Cypher 是一种专为图设计的查询语言。图由节点和关系构成。也被称为 CQL(Cypher Query Language) 。</p><h3 id="节点">节点</h3><p><strong>节点</strong>在 Cypher 中由括号 <code>()</code>表示，节点的<strong>标签</strong>（类似一个类的类名）由冒号<code>:</code> 表示。</p><div class="code-wrapper"><pre><code class="hljs CQL">(:Loan)</code></pre></div><p>这就是一个类型为 Loan 的节点。</p><blockquote><p>neo4j 推荐节点的标签使用<strong>大驼峰命名</strong>（类似 Python的类命名）。</p></blockquote><p>节点的<strong>属性</strong>以类似 JSON的语法指定，不过不一定需要双引号，单引号也可以。<strong>属性名称区分大小写。</strong></p><div class="code-wrapper"><pre><code class="hljs CQL">(:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)</code></pre></div><p>这就是一个带有属性的 Loan 节点。</p><blockquote><p>neo4j 推荐节点和关系的属性使用<strong>小驼峰命名</strong>（类似 Java的变量名）。</p></blockquote><h3 id="关系">关系</h3><p>节点之间的<strong>关系</strong>由两个破折号表示 <code>--</code>，关系的<strong>方向</strong>由大于符号 <code>&gt;</code> 或小于符号<code>&lt;</code> 表示。关系的<strong>类型</strong>用方括号<code>[]</code> 与冒号 <code>:</code> 表示。</p><div class="code-wrapper"><pre><code class="hljs CQL">[:USE_IN]</code></pre></div><blockquote><p>neo4j 推荐关系的类型使用<strong>大写加下划线命名</strong>（类似Python 的常量命名）。</p></blockquote><p>将节点与关系结合表示：</p><div class="code-wrapper"><pre><code class="hljs CQL">(p:Person)-[:APPLIED]-&gt;[l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;]</code></pre></div><p>这里表示了一个 Person （ p 和 l 都不用管，这个是变量，相当于在这段CQL 语句里的别名而已，节点本身跟这个没关系，有点像 SQL 查询时所用的<code>AS</code> ）APPLIED 了一笔 Loan ，这笔 Loan 的 loanId 为 123，createdAt 为 2024-04-10 。</p><h2 id="数据类型">数据类型</h2><h3 id="数据类型-1">数据类型</h3><p>neo4j 中有如下数据类型：</p><ul><li><p>String 字符串</p></li><li><p>Integer 整数</p><ul><li>在 neo4j 里其实是 Long 。</li></ul></li><li><p>Float 浮点数</p></li><li><p>Boolean 布尔值</p></li><li><p>Date/Datetime 日期/时间</p><ul><li>日期类型可以用 <code>x.year, x.month, x.day</code>这样的方式提取信息。</li></ul></li><li><p>Point 点</p></li><li><p>Lists of values 列表</p><ul><li>在 neo4j 里其实是 StringArray 。</li><li>列表中的值必须具有相同的数据类型。</li></ul></li></ul><h3 id="类型转换函数">类型转换函数</h3><table><thead><tr class="header"><th style="text-align: left;">函数</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>toBoolean(s)</code></td><td style="text-align: left;">将字符串转换为布尔值</td></tr><tr class="even"><td style="text-align: left;"><code>toFloat(s)</code></td><td style="text-align: left;">将字符串转换为浮点数</td></tr><tr class="odd"><td style="text-align: left;"><code>toInteger(s)</code></td><td style="text-align: left;">将字符串转换为整数</td></tr><tr class="even"><td style="text-align: left;"><code>toString(v)</code></td><td style="text-align: left;">将值转换为字符串</td></tr><tr class="odd"><td style="text-align: left;"><code>date(s)</code></td><td style="text-align: left;">将字符串转换为日期</td></tr><tr class="even"><td style="text-align: left;"><code>datetime(s)</code></td><td style="text-align: left;">将字符串转换为时间</td></tr><tr class="odd"><td style="text-align: left;">split(s, x)</td><td style="text-align: left;">将字符串拆分为列表，其中 s表示要拆分的字符串，x 表示分隔符</td></tr></tbody></table><h2 id="读取">读取</h2><h3 id="match-return-简单查询">MATCH RETURN 简单查询</h3><p>使用 <code>MATCH</code> 关键字匹配节点，可以在节点里面用 JSON的方式做条件筛选。准确来讲更像是 <code>MATCH ... RETURN</code>一起实现了 SQL 里类似 <code>SELECT</code> 的效果。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 查询在 2024-04-10 创建的 Loan 的 loanId 属性MATCH (l:Loan &#123;createdAt: &#x27;2024-04-10&#x27;&#125;)RETURN l.loanId</code></pre></div><p>除了匹配节点，也可以匹配关系，<strong>在匹配关系的时候，不一定需要指定方向</strong>。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 查询有人申请的 Loan 的 loanId 属性MATCH (p:Person)-[:APPLIED]-&gt;(l:Loan)RETURN l.loanId// 查询所有指向其他节点的节点MATCH (l)--&gt;() RETURN l</code></pre></div><p>可以使用 <code>;</code> 来执行多段查询。</p><h3 id="optional-match-选择性匹配">OPTIONAL MATCH 选择性匹配</h3><p>类似 MATCH ，但是对模式的缺失部分使用空值填充（ MATCH是直接不匹配）。</p><h3 id="where-条件过滤">WHERE 条件过滤</h3><h4 id="and-和-or">AND 和 OR</h4><p>使用 <code>WHERE</code> 结合 <code>AND</code> ， <code>OR</code>关键字可以进行更复杂的查询。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 查询在 2024-04-10 创建的 Loan 的 loanId 属性MATCH (l:Loan &#123;createdAt: &#x27;2024-04-10&#x27;&#125;)RETURN l.loanId// 查询在 2024-04-10 创建的 Loan 的 loanId 属性MATCH (l:Loan)WHERE l.createdAt = &#x27;2024-04-10&#x27;RETURN l.loanId// 查询在 2024-04-10 创建的 Loan 的 loanId 属性MATCH (l)WHERE l:Loan AND l.createdAt = &#x27;2024-04-10&#x27;RETURN l.loanId</code></pre></div><p>上面三段语句是等价的。</p><h4 id="和-和-和-和">&gt; 和 &lt; 和 &gt;= 和 &lt;= 和 &lt;&gt;</h4><p>在 <code>WHERE</code> 里还能使用类似 Python 一样的使用范围过滤。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 查询 loanId 大于 122 且小于等于 124 的 Loan 节点MATCH (l:Loan)WHERE l.loanId &gt; 122 AND l.loanId &lt;= 124RETURN l// 查询 loanId 大于 122 且小于等于 124 的 Loan 节点MATCH (l:Loan)WHERE 122 &lt; l.loanId &lt;= 124RETURN l// 查询 loanId 不等于 122 的节点MATCH (l:Loan)WHERE l.loanId &lt;&gt; 122RETURN l</code></pre></div><p>上面两段语句是等价的。</p><h4 id="is-null-和-is-not-null">IS NULL 和 IS NOT NULL</h4><p>属性的值不能为空，如果属性的值为空等价于没有这个属性。这个语法也可以说是查询属性是否存在。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 查询没有 createdAt 属性 Loan 节点MATCH (l:Loan)WHERE l.createdAt IS NULLRETURN l// 查询有 createdAt 属性的 Loan 节点MATCH (l:Loan)WHERE l.createdAt IS NOT NULLRETURN l</code></pre></div><h4 id="字符串函数-starts-with-和-end-with-和-contains">字符串函数STARTS WITH 和 END WITH 和 CONTAINS</h4><p><code>toLower()</code> 函数和 <code>toUpper()</code>函数能够将查询转换为小写/大写，但是如果查询过程中<strong>使用了大小写转换，索引会失效</strong>。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 返回人名以 mo 开头的 Person 节点MATCH (p:Person)WHERE toLower(p.name) STARTS WITH &#x27;mo&#x27;RETURN p</code></pre></div><h4 id="使用列表进行过滤-in">使用列表进行过滤 IN</h4><p>有点类似 SQL 里的 IN 。</p><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)WHERE p.born IN [1965, 1966, 1970]RETURN p.name</code></pre></div><h4 id="查询标签是否存在">查询标签是否存在</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)WHERE l:ApprovedLoanRETURN l</code></pre></div><h3 id="return-返回结果">RETURN 返回结果</h3><h4 id="排序-order-by">排序 ORDER BY</h4><p>这个和 SQL 的用法一样，ORDER BY 加上 ASC（升序） 或者 DESC（降序）表示去控制返回顺序，如果不写默认就是升序。</p><h4 id="limit-与-skip">LIMIT 与 SKIP</h4><p>这个用法依然和 SQL一样，表示对返回数量的限制或者是否执行跳过操作（常用于分页）。</p><h4 id="去重-distinct">去重 DISTINCT</h4><p>DISTINCT 用在 RETURN 后面表示去重。</p><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (:Person)-[]-&gt;(l:Loan)RETURN DISTINCT p.name</code></pre></div><h4 id="投影">投影</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 返回 Loan 节点的所有属性MATCH (l:Loan)RETURN l &#123;.*&#125; AS loan// 仅返回 Loan 节点的 loanId 属性MATCH (l:Loan)RETURN l &#123;.loanId&#125; AS loan</code></pre></div><p>另外这里还可以额外定义一个不存在的属性作为返回的内容，就像这样：</p><div class="code-wrapper"><pre><code class="hljs CQL">// 返回 Loan 节点的所有属性并加一个 isSuccess 的属性// 注意这个 isSuccess 的附加属性前面没有 &#x27;.&#x27;MATCH (l:Loan)RETURN l &#123;.*, isSuccess: true&#125; AS loan</code></pre></div><p>直接返回节点的时候，实际上每行返回这 4 个内容：</p><ul><li>identity - 唯一标识符</li><li>labels - 列表形式的 Label （因为一个节点可以是多个 Label ）</li><li>elementId - 对象 Id</li><li>properties - 属性的键值对</li></ul><h4 id="case-when-...-then-条件返回">CASE WHEN ... THEN 条件返回</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 对不同年龄的 Person 分别返回不一样的标识MATCH (p:Person)RETURNCASEWHEN p.born.year &lt; 1960 THEN &#x27;old&#x27;WHEN 1960 &lt;= p.born.year &lt; 2000 THEN &#x27;middle&#x27;ELSE p.born.year &gt;= 2000 THEN &#x27;young&#x27;ENDAS ageGroup</code></pre></div><h4 id="返回路径">返回路径</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 返回所有 Person APPLIED Loan 的路径MATCH p = ((p:Person)-[:APPLIED]-&gt;(l:Loan))RETURN p</code></pre></div><p>有一些可以用于分析路径的函数：</p><ul><li><code>length(p)</code> - 返回路径长度（关系数）。</li><li><code>nodes(p)</code> - 返回一个包含路径上所有节点的列表。</li><li><code>relationship(p)</code> -返回一个包含路径上所有关系的列表。</li></ul><h3 id="暂存结果-with">暂存结果 WITH</h3><p><code>WITH</code> 关键字类似 <code>RETURN</code>关键字，能够返回中间结果，在需要一个中间变量存储的场景很有用。</p><p>另外由于聚合函数不能用在 <code>WHERE</code>条件过滤中，因此这种情况下 <code>WITH</code> 会比较有用。</p><h3 id="union-与-union-all">UNION 与 UNION ALL</h3><p>使用 <code>UNION</code> 关键字连接查询结果，类似 SQL，<code>UNION</code> 要去重，<code>UNION ALL</code> 不去重。</p><h3 id="函数">函数</h3><h4 id="exists-匹配模式">exists 匹配模式</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)-[:APPLIED]-&gt;(l:Loan)WHERE NOT exists( (p)-[:DEFAULTED]-&gt;(l:Loan) )RETURN p.name</code></pre></div><h4 id="labels-查看节点标签">labels 查看节点标签</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)RETURN labels(l)</code></pre></div><h4 id="types-查看关系类型">types 查看关系类型</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH ()-[r:APPLIED]-&gt;()RETURN types(r)</code></pre></div><h4 id="keys-查看属性名">keys 查看属性名</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)RETURN keys(l)</code></pre></div><h4 id="count-计数">count 计数</h4><div class="code-wrapper"><pre><code class="hljs CQL">//查看有多少个 Loan 节点MATCH (l:Loan)RETURN count(l)</code></pre></div><p><code>count(n)</code> 这种写法将不会包括 <code>n</code>为空的情况，<code>count(*)</code> 会包括 <code>n</code> 为空的情况。</p><h4 id="type-查看类型">type 查看类型</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)-[r]-&gt;(l:Loan)RETURN p.name AS personName, type(r) AS relationshipType</code></pre></div><h4 id="collect-转为列表">collect 转为列表</h4><p><code>collect</code> 函数将结果聚合为列表。</p><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)RETURN collect(l.loanId) AS loanIds</code></pre></div><p>可以用 <code>listObj[index]</code>这样的方式按索引访问列表的元素，比如上面的<code>collect(l.loanId)[0]</code> 返回第一个 Loan 节点的 loanId属性。</p><h4 id="unwind-列表展开">UNWIND 列表展开</h4><p><code>UNWIND</code> 关键字将列表转换为多行。</p><h4 id="日期与时间">日期与时间</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 返回当前日期MATCH (n) RETURN date() LIMIT 1// 返回当前日期与时间MATCH (n) RETURN datetime() LIMIT 1// 返回当前时间MATCH (n) RETURN time() LIMIT 1</code></pre></div><p>这三个函数可以传参，<code>datetime()</code> 采用 ISO8601的标准，假设不传时区，默认为 UTC 。</p><h4 id="时间间隔">时间间隔</h4><div class="code-wrapper"><pre><code class="hljs CQL">// duration.between(x.date1,x.date2)// 天数间隔// duration.inDays(x.datetime1,x.datetime2).days</code></pre></div><h3 id="分组与聚合">分组与聚合</h3><p>在 Cypher 中，分组是隐性完成的，不需要 SQL 中的 GROUP BY关键字，一旦使用 <code>count()</code>这样的聚合函数，所有非聚合结果的列就会成为分组键。</p><p>下面的生成式也会默认去聚合。</p><h4 id="列表生成式-list-comprehension">列表生成式 ListComprehension</h4><p>有点类似于 Python 的列表生成式的语法，生成一个列表作为结果返回。</p><div class="code-wrapper"><pre><code class="hljs CQL">// 以一个列表形式返回名字中有 M 或 V 的人名，否则返回空列表MATCH (p:Person)RETURN [x IN p.name WHERE x CONTAINS &#x27;M&#x27; OR x CONTAINS&#x27;V&#x27;]</code></pre></div><h4 id="模式生成式-pattern-comprehension">模式生成式 PatternComprehension</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 以一个列表的形式返回申请 Loan 的人名，如果一笔 Loan 没人申请过，就会是一个空列表MATCH (l:Loan)RETURN [(a:Person)-[:APPLIED]-&gt;(l:Loan)|a.name] AS applier_name</code></pre></div><h3 id="图查询-call">图查询 CALL</h3><h4 id="查询图里有哪些属性">查询图里有哪些属性</h4><div class="code-wrapper"><pre><code class="hljs CQL">CALL db.propertyKeys()</code></pre></div><p>一旦定义了属性键，即使当前没有节点或关系使用该属性键，该属性键也会保留在图中。</p><h4 id="查询图里有哪些标签">查询图里有哪些标签</h4><div class="code-wrapper"><pre><code class="hljs CQL">CALL db.labels()</code></pre></div><h4 id="查询图的数据模型">查询图的数据模型</h4><div class="code-wrapper"><pre><code class="hljs CQL">CALL db.schema.visualization()</code></pre></div><h4 id="查询图里的节点属性类型">查询图里的节点属性类型</h4><div class="code-wrapper"><pre><code class="hljs CQL">CALL db.schema.nodeTypeProperties()</code></pre></div><h4 id="查询图里的关系属性类型">查询图里的关系属性类型</h4><div class="code-wrapper"><pre><code class="hljs CQL">CALL db.schema.relTypeProperties()</code></pre></div><h3 id="图遍历与查询调优">图遍历与查询调优</h3><h4 id="explain-与-profile">EXPLAIN 与 PROFILE</h4><p><code>EXPLAIN</code> 和 SQL一样可以查看查询执行过程，是否走索引等。</p><p><code>PROFILE</code> 可以查看检索行数，内存使用，性能调优。</p><p>使用 EXPLAIN 和 PROFILE 的区别在于，EXPLAIN提供的是查询步骤的估计值，而 PROFILE提供的是查询的确切步骤和检索的行数。</p><h4 id="查询的一般过程">查询的一般过程</h4><ol type="1"><li>选定锚点 - 创建执行计划时，neo4j会先确定作为查询起点的节点集加载到内存，查询的锚点是节点集中最少的节点数（有的时候可能有多个锚点）。</li><li>展开路径 -如果查询指定了路径，下一步就是沿着该路径前进，这一步被称为展开路径。</li><li>返回结果 - 根据条件遍历返回结果（类似深度优先遍历）。</li></ol><h4 id="变长遍历">变长遍历</h4><p><code>shortestPath()</code> 和 <code>allShortestPath()</code>用于查询两个节点间的最短路径，如果有多条最短路径，<code>shortestPath()</code>返回一条（具体哪条不确定），<code>allShortestPath()</code>返回所有，用法如下：</p><div class="code-wrapper"><pre><code class="hljs CQL">// 查找与 loanId 这条 Loan 有关系的所有 Loan 节点MATCH p = shortestPath((l1:Loan)-[*]-(l2:Loan))WHERE l1.loanId = 123RETURN l2</code></pre></div><p>变长遍历写在关系里，用法如下：</p><div class="code-wrapper"><pre><code class="hljs CQL">// 两个节点正好能用 2 段关系连接()-[*2]-()// 两个节点用于连接的关系数大于等于 1()-[*1..]-()// 两个节点用于连接的关系数小于等于 3()-[*..3]-()// 两个节点用于连接的关系数大于等于 1 小于等于 3()-[*1..3]-()// 两个节点用于连接的关系数大于等于 1 小于等于 3 并且关系都是 APPLIED()-[:APPLIED*1..3]-()</code></pre></div><h4 id="优化点与思路">优化点与思路</h4><ul><li>避免指定非锚点的节点的标签（如果逻辑上可以），这一步的目的是避免做类型检查。</li></ul><h3 id="子查询">子查询</h3><div class="code-wrapper"><pre><code class="hljs CQL">CALL &#123;子查询&#125;</code></pre></div><h3 id="参数化">参数化</h3><p>在 Cypher 中，参数名以 <code>$</code> 开头。这样做的好处是对于</p><h4 id="设置参数">设置参数</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 设置单个参数 personName 为 Movis ，冒号后面一定要空格:param personName: &#x27;Movis&#x27;// 设置多个参数，以键值对的形式设置:params &#123;paramOne: &#x27;A&#x27;, paramTwo: 2&#125;// 设置整数最好使用 =&gt; 强制指定:param number=&gt;10</code></pre></div><h4 id="查看参数">查看参数</h4><div class="code-wrapper"><pre><code class="hljs CQL">:params</code></pre></div><h4 id="删除参数清空">删除参数（清空）</h4><div class="code-wrapper"><pre><code class="hljs CQL">:params &#123;&#125;</code></pre></div><h4 id="参数化查询">参数化查询</h4><div class="code-wrapper"><pre><code class="hljs CQL">// 设置参数 personName 为 Movis:param personName: &#x27;Movis&#x27;// 查询 Movis 申请的贷款的 loanIdMATCH (p:Person)-[:APPLIED]-&gt;(l:Loan)WHERE p.name = $personNameRETURN l.loanId</code></pre></div><h2 id="写入">写入</h2><h3 id="创建-merge-和-create">创建 MERGE 和 CREATE</h3><h4 id="创建节点">创建节点</h4><p>建议使用 <code>MERGE</code>关键字创建节点。另外一个也可以创建节点的关键字是 <code>CREATE</code>，使用 <code>CREATE</code>创建节点时，再添加节点之前不查找主键。如果确定数据时干净的，可以用<code>CREATE</code> 获得更快的速度，而 <code>MERGE</code>的优势是解决了重复问题。</p><div class="code-wrapper"><pre><code class="hljs CQL">MERGE (l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)</code></pre></div><p>也可以多个语句一起执行：</p><div class="code-wrapper"><pre><code class="hljs CQL">// 创建 Loan 和 Person 节点并返回这两个节点MERGE (l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)MERGE (p:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)RETURN l, p</code></pre></div><h4 id="创建关系">创建关系</h4><p>当为两个节点创建关系的时候，也可以用 <code>MERGE</code>，但这个关系必须满足：</p><ul><li>有类型</li><li>有方向</li></ul><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan &#123;loanId: 123&#125;)MATCH (p:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)MERGE (p)-[:APPLIED]-&gt;(l)</code></pre></div><p>关系和节点一样也可以用 JSON的格式创建属性，也可以同时创建节点和关系：</p><div class="code-wrapper"><pre><code class="hljs CQL">MERGE (l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)MERGE (p:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)MERGE (p)-[:APPLIED]-&gt;(l)</code></pre></div><p>甚至同时创建节点和关系可以简化为一句：</p><div class="code-wrapper"><pre><code class="hljs CQL">MERGE (:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)&lt;-[:APPLIED]-(:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)</code></pre></div><p><strong>默认情况下，不指定方向时， <code>MERGE</code>将按从左到右的方向创建关系。</strong></p><div class="code-wrapper"><pre><code class="hljs cql">// Person APPLIED LoanMERGE (:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)-[:APPLIED]-&gt;(:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)// Person APPLIED LoanMERGE (:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)-[:APPLIED]-(:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)</code></pre></div><p>上面两段语是等价的。</p><h4 id="merge-与-create">MERGE 与 CREATE</h4><p><code>MERGE</code>在创建之前将会去图中寻找是否有相关的模式，如果要创建的数据点存在就不会创建。可以使用下面的方法自定义<code>MERGE</code> 创建时的操作：</p><div class="code-wrapper"><pre><code class="hljs CQL">MERGE (l:Loan &#123;loanId:123&#125;)ON CREATE SET l.createdAt = &#x27;2024-04-10&#x27;ON MATCH SET l.createdAt = &#x27;2024-04-10&#x27;</code></pre></div><p>这样重复创建时将会有不同的属性。</p><h3 id="更新-set-和-remove">更新 SET 和 REMOVE</h3><h4 id="添加和更新-set">添加和更新 SET</h4><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)-[:APPLIED]-&gt;(l:Loan &#123;loanId: 123&#125;)SET p.born = 1965, l.createdAt = &#x27;2024-04-11&#x27;, l:ApprovedLoan</code></pre></div><p>可以用逗号分隔，一次性更新或添加多个属性或者标签。</p><h4 id="移除-remove-或者-set">移除 REMOVE 或者 SET</h4><p>可以用 <code>REMOVE</code> 关键字来删除：</p><ul><li>属性</li><li>标签</li></ul><div class="code-wrapper"><pre><code class="hljs CQL">// 移除 Person movis 的 born 属性MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)REMOVE p.born// 移除 Person movis 的 born 属性MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)SET p.born = NULL// 移除 Loan 的 ApprovedLoan 标签MATCH (l:Loan &#123;loanId: 123&#125;)REMOVE l:ApprovedLoan</code></pre></div><p><code>SET</code> 一个属性为空和 <code>REMOVE</code>这个属性是等价的，都是移除一个属性。</p><h3 id="删除-delete">删除 DELETE</h3><p>可以用 <code>DELETE</code> 关键字来删除：</p><ul><li>节点</li><li>关系</li></ul><div class="code-wrapper"><pre><code class="hljs CQL">// 删除节点MATCH (l:Loan &#123;loanId: 123&#125;)DELETE l// 删除关系MATCH (:Person &#123;name: &#x27;movis&#x27;&#125;)-[r:APPLIED]-&gt;(:Loan &#123;loanId: 123&#125;)DELETE r// 同时删除节点和关系MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)DETACH DELETE p</code></pre></div><p>值得注意的是，一个节点如果还有关系的时候， <code>DELETE</code>需要<strong>先删除关系再删除节点</strong>（节点与自己有关系也不能直接删）。除非使用<code>DETACH DELETE</code> 。</p><h2 id="约束">约束</h2><h3 id="创建唯一约束">创建唯一约束</h3><div class="code-wrapper"><pre><code class="hljs CQL">CREATE CONSTRAINT [约束名] [IF NOT EXISTS]FOR (n:Label名称)REQUIRE n.属性 IS UNIQUE</code></pre></div><p>其中加括号表明是可选项：</p><ul><li>约束名 - 如果不指定约束名，neo4j 会自动生成名称。</li><li>IF NOT EXISTS - 如果不加这句，当约束存在时，会报错。</li></ul><h3 id="查看约束">查看约束</h3><div class="code-wrapper"><pre><code class="hljs CQL">SHOW CONSTRAINTS</code></pre></div><h3 id="删除约束">删除约束</h3><div class="code-wrapper"><pre><code class="hljs CQL">DROP CONSTRAINT 约束名 [IF EXISTS]</code></pre></div><p>其中加括号表明是可选项：</p><ul><li>IF EXISTS - 如果不加这句，当约束不存在时，会报错。</li></ul><h2 id="从-csv-文件建图">从 CSV 文件建图</h2><h3 id="从-csv-文件导入数据">从 CSV 文件导入数据</h3><p>从 CSV 文件导入数据的语法为：</p><div class="code-wrapper"><pre><code class="hljs CQL">LOAD CSV [WITH HEADERS] FROM 文件地址 [AS 文件别名] [FIELDTERMINATOR 分隔符（这里要加引号）]</code></pre></div><p>其中加括号的表明是可选项：</p><ul><li><code>WITH HEADERS</code> - 声明是否有表头。</li><li><code>AS xxx</code> - 使用 xxx 作为别名。</li><li><code>FIELDTERMINATOR</code> - 指定分隔符，类似<code>pandas.load_csv()</code> 函数里的 <code>sep</code> 参数。</li></ul><p>但是这里仅仅是将数据导入到图数据库中了，并没有创建节点和关系。</p><h3 id="创建节点-1">创建节点</h3><p>假设有一张表里有想创建的 Loan 节点：</p><table><thead><tr class="header"><th>loan_id</th><th>created_at</th><th>amount</th></tr></thead><tbody><tr class="odd"><td>123</td><td>2024-01-02</td><td>200</td></tr><tr class="even"><td>456</td><td>2024-01-03</td><td>500</td></tr><tr class="odd"><td>789</td><td>2024-01-04</td><td>1000</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs CQL">LOAD CSV WITH HEADERS FROM 文件地址 [AS 文件别名]MERGE (l:Loan &#123;loanId: toInteger(文件别名.loan_id)&#125;)SETl.createdAt = 文件别名.created_at,l.amount = toInteger(文件别名.amount)</code></pre></div><p>这样就创建了 3 个 Loan 类型的节点，值得注意的是<strong>多行<code>SET</code> 是有逗号的</strong>。</p><h3 id="创建关系-1">创建关系</h3><p>假设有 Person 来 APPLIED Loan 这样的关系，在 APPLIED 关系上需要记录appliedAt 这个时间。</p><p>从一张 CSV 表格创建关系如下：</p><table><thead><tr class="header"><th>person_id</th><th>loan_id</th><th>applied_at</th></tr></thead><tbody><tr class="odd"><td>1</td><td>123</td><td>2024-01-01</td></tr><tr class="even"><td>2</td><td>346</td><td>2024-01-02</td></tr><tr class="odd"><td>3</td><td>789</td><td>2024-01-03</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs CQL">LOAD CSV WITH HEADERS FROM 文件地址 AS rowMATCH (p:Person &#123;personId: toInteger(row.person_id)&#125;)MATCH (l:Loan &#123;loanId: toInteger(row.loan_id)&#125;)MERGE (p)-[r:APPLIED]-&gt;(l)SET r.appliedAt = row.applied_at</code></pre></div><h2 id="附加标签">附加标签</h2><p>当查询有 Person APPLIED Loan 这种关系的 Person 时一般这样：</p><div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)-[:APPLIED]-&gt;(:Loan) RETURN p</code></pre></div><p>其实可以给 Person 创建一个 Applier标签，这样在查询这种关系时会更快（查询标签比查询关系快）：</p><div class="code-wrapper"><pre><code class="hljs CQL">// 创建 Applier 标签MATCH (p:Person)-[:APPLIED]-&gt;(:Loan) [WITH DISTINCT] SET p:Applier// 查询 Person APPLIED Loan 的 PersonMATCH (p:Applier) RETURN p</code></pre></div><p>其中，使用 <code>WITH DISTINCT</code> 会更具有写入效率。</p><h2 id="存储过程">存储过程</h2><h3 id="事务">事务</h3><p>在一个事务中，如果出现了错误，数据就会回滚。但是在单个事务中执行大量写入操作可能会导致性能问题和潜在的故障。</p><p>因此 Cypher 提供了自己控制事务的语句。</p><div class="code-wrapper"><pre><code class="hljs CQL">CALL &#123;  存储过程&#125; IN TRANSACTIONS [OF 数量 ROWS]</code></pre></div><p>其中加括号的表明是可选项：</p><ul><li>OF 数量 ROWS - 指定要处理的行数以进行批处理。</li></ul><h3 id="eager">Eager</h3><p>neo4j 在导入数据时有一种名为 <code>Eager</code>的机制，大概意思是在导入前会将数据全部加载到内存，这样的话可能会导致内存不足。避免Eager 的方式是将数据分为很多小部分，比如分别创建节点和关系。</p>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>graph</tag>
      
      <tag>neo4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《曼昆经济学原理（第八版） - 微观经济学》</title>
    <link href="/2024/03/29/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2024/03/29/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="导言">导言</h1><p>经济学研究的是<strong>资源的配置</strong>。因为资源是有稀缺性的。资源的稀缺性是指社会资源是有限的。</p><h2 id="经济学十大原理">经济学十大原理</h2><h3 id="决策时对目标面临取舍权衡">1. 决策时对目标面临取舍权衡</h3><p>不管是个人、家庭还是社会，都涉及到资源的分配。不管做出何种决策，实质上是在一个目标与另一个目标之间的权衡取舍。</p><p>社会面临的取舍比较经典的有：</p><ul><li>国防费用与生活水平的取舍。</li><li>清洁的环境与高收入水平的取舍。</li></ul><p>另一方面，社会面临效率与平等间的取舍。效率只利益最大化，平等则指成果的平均分配。这两者往往无法兼得。</p><h3 id="机会成本是为了得到某种东西而放弃的其它东西">2.机会成本是为了得到某种东西而放弃的其它东西</h3><p>机会成本计算错误通常有两种：</p><ul><li>误判的成本 -比如上大学的住宿费用。因为不上大学也是有住宿费用的，所以假设把住宿费用当作上大学的成本之一，实际是误判的。</li><li>漏判的成本 -比如时间。这是<strong>机会成本</strong>的典型代表，<strong>机会成本</strong>是指为了得到这种东西所必须放弃的东西。比如投资回报率必须跑赢无风险利率才算赚的，这里的无风险利润实际上就是机会成本。</li></ul><h3 id="理性人考虑边际量边际成本与边际收益">3.理性人考虑边际量（边际成本与边际收益）</h3><p>因为世界并不是非黑即白的二分类选择，很多时候只是针对某种行动计划的一种微小调整，这种调整就被称为<strong>边际行动</strong>。</p><p><strong>边际成本</strong>指这个边际行动所付出的成本，<strong>边际收益</strong>则指这个边际行动带来的收益。</p><p>比如每个月的电话每分钟通话费以边际成本这个角度来看，并不是总话费除以总时长，这是因为总话费里有一部分是每月固定话费。</p><p>所以决策时应该多考虑边际量，这被称为<strong>边际决策</strong>。</p><h3 id="人们会对激励做出反应">4. 人们会对激励做出反应</h3><p>由于理性人通过比较成本与收益做出决策，所以他们会对激励做出反应。所以分析一种决策（包括政策时），不仅应该考虑它的直接影响，还应该考虑它通过激励产生的不太明显的间接影响。</p><h3 id="贸易可以使每个人的状况都变得更好">5.贸易可以使每个人的状况都变得更好</h3><p>这是因为贸易可以使每个人专门从事自己擅长的活动。这是更合理高效的资源配置。</p><h3 id="市场通常是组织经济活动的一种好方法">6.市场通常是组织经济活动的一种好方法</h3><p>这里谈到了计划经济与市场经济两种模式当中，计划经济的缺点。</p><p>计划经济前提假设是计划者能够最佳地配置经济中的稀缺资源。但由于对数据的缺乏，往往并不能达到最佳。</p><p>而市场经济则是通过价格影响供需关系从而在大多数时候实现整个社会福利的最大化。</p><h3 id="政府有时可以改善市场结果">7. 政府有时可以改善市场结果</h3><p>市场经济需要实施产权制度，以便每个人可以拥有控制稀缺资源的能力。</p><p>然而有时候也会出现市场本身不能有效配置资源的情况，这被成为市场失灵，造成这种情况的原因有：</p><ul><li>外部性 - 一个人的行为对旁观者的福利产生了影响。</li><li>市场势力 - 单个经济活动者对市场价格有显著影响的能力（垄断）。</li></ul><p>如果政府干预经济提高了效率或者促进了平等，那么就可以改善市场结果。</p><h3 id="一国的生活水平取决于它生产物品与服务的能力">8.一国的生活水平取决于它生产物品与服务的能力</h3><p>生产物品与服务的能力又被成为生产率，或者生产效率，指的是每单位劳动投入所生产的物品与服务数量。</p><h3 id="当政府发行了过多货币时物价上升">9.当政府发行了过多货币时，物价上升</h3><p>当政府发行了过多货币，钱就会不值钱，就会出现通货膨胀（经济中物价总水平的上升）。</p><h3 id="社会面临通货膨胀与失业之间的短期权衡取舍">10.社会面临通货膨胀与失业之间的短期权衡取舍</h3><ol type="1"><li>货币量的增加会刺激消费。</li><li>由于供需关系消费增加物价提升与就业提升。</li></ol><p>因此社会面临通货膨胀和失业之间的短期权衡取舍。</p><h2 id="像经济学家一样思考">像经济学家一样思考</h2><h3 id="像科学家一样的经济学家">像科学家一样的经济学家</h3><p>科学方法指冷静地建立并检验有关世界如何运行的理论，这种建立理论、收集数据、分析数据、检验理论的方法适用于研究经济，因此这是经济学家和科学家的相似性。</p><p>经济学家会通过经济模型来了解世界。经济模型指的是利用假设来撇开和所研究问题无关的很多细节的模型。这里提到了两个模型：</p><ul><li><strong>循环流量图</strong>（circular-flow diagram）-一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型。特点是在物品与服务市场里，家庭是买方，企业是卖方，而在生产要素市场里，关系对调。</li><li><strong>生产可能性边界</strong>（production possibilitiesfrontier）-一个表示在可得到的生产要素与生产技术既定时，一个经济所能生产的产品数量的各种组合的图形。其中在生产可能性边界上代表效率，之内代表无效率，之外代表不可能。边界上的点斜率是此时商品X的<strong>机会成本，是可变的</strong>。斜率越大（越陡）代表机会成本越高，可以简单理解为把很多更适合做商品Y 的工人拿来做商品 X 。</li></ul><p><strong>微观经济学</strong>：研究<strong>家庭和企业</strong>如何做出决策以及它们如何在市场上相互交易的学科。</p><p><strong>宏观经济学</strong>：研究<strong>整体经济</strong>现象。</p><h3 id="像政策顾问一样的经济学家">像政策顾问一样的经济学家</h3><p><strong>实证</strong>表述：试图描述世界<strong>是</strong>什么样子的观点。（科学家）</p><p><strong>规范</strong>表述：试图描述世界<strong>应该是</strong>什么样子的观点。（政策顾问）涉及价值观。</p><h3 id="经济学家意见分歧的原因">经济学家意见分歧的原因</h3><p>经济学家意见有分歧也应证了<ahref="###1.%20决策时对目标面临取舍权衡">决策时对目标面临取舍权衡</a></p><ul><li>科学判断的不同 - 对实证的论证逻辑不同。</li><li>价值观的不同。</li></ul><h2 id="相互依存性与贸易的好处">相互依存性与贸易的好处</h2><h3 id="绝对优势与比较优势">绝对优势与比较优势</h3><p><strong>绝对优势</strong>指一个生产者用比另一个生产者更少的投入生产某种物品。</p><p><strong>比较优势</strong>指一个生产者以低于另一个生产者的<ahref="###2.%20机会成本是为了得到某种东西而放弃的其它东西">机会成本</a>生产某种物品的能力。</p><h3 id="贸易的意义">贸易的意义</h3><p><ahref="###5.%20贸易可以使每个人的状况都变得更好">贸易可以使社会上的每个人都获益</a>，因为它使人们可以专门从事他们具有<strong>比较优势</strong>的活动。这是由于可能会出现一个生产者在两个物品上都比另一个生产者具有绝对优势，但不会都具有比较优势。</p><p>对从贸易中获益的双方而言，他们进行贸易的价格在两个机会成本之间。</p><p>但是有可能对于两个生产者来讲，相比起对方都没有比较优势，这种情况下贸易不会带来好处。</p><h1 id="市场如何运行">市场如何运行</h1><h2 id="供给与需求的市场力量">供给与需求的市场力量</h2><h3 id="市场与竞争">市场与竞争</h3><p><strong>市场</strong>是由某种物品或服务的<strong>买者与卖者</strong>组成的一个群体。买者决定了一种产品的需求，而卖者决定了一种产品的供给。</p><p><strong>竞争</strong>市场指的是有许多买者与卖者，以至于每个人对市场价格的影响都微乎其微的市场。</p><p>但是市场有很多类型，这里提到了两种最极端的市场类型，剩下的市场类型都是介于这两者之间的：</p><ul><li>完全竞争 -完全竞争市场的买者和卖者必须接受市场决定的价格，因此他们被称为价格接受者。完全竞争的市场具备两个特征：<ol type="1"><li>可供销售的物品是完全相同的。</li><li>买者和卖者人数众多，以至于没有任何一个买者或卖者可以影响市场价格。</li></ol></li><li>完全垄断 - 一个市场只有一个卖者，并且由这个卖者决定价格。</li></ul><h3 id="需求">需求</h3><p><strong>需求量</strong>指的是买者愿意并且能够购买的一种物品的数量。</p><p>需求量受很多因素影响，其中起着主要因素的是价格。在其他条件不变时，一种物品的价格上升，对该物品的需求量减少；一种物品的价格下降，对该物品的需求量增加。这就是<strong>需求定理</strong>。（需求量与价格呈负相关）</p><p>需求表是需求定理的数据展示，表示一种物品的价格与需求量之间的关系，而需求曲线是图形展示。</p><p>市场需求是所有买者对某种特定物品或服务的需求量的总和。</p><p>如果某种因素使每一种<strong>既定价格水平下</strong>的需求量的增加，就称之为需求增加；反之则是需求减少。一些重要变量如下：</p><ul><li><p><strong>价格</strong> - 上文提到的需求定理。</p></li><li><p><strong>收入</strong> -收入增加导致的需求增加的物品称为<strong>正常物品</strong>。收入增加导致的需求减少的物品称为<strong>低档物品</strong>。</p></li><li><p><strong>相关物品的价格</strong> -当一种物品的价格增加（需求量减少）引起另一种物品的需求量增加，这两种物品被称为<strong>替代品</strong>。当一种物品的价格增加（需求量减少）引起另一种物品的需求量减少，这两种物品被称为<strong>互补品</strong>。</p></li><li><p><strong>爱好</strong> -这个因素对需求的影响比较明显，但是经济学家通常不解释而是考虑。</p></li><li><p><strong>预期</strong> -单个买者对其他因素的预期也会影响当前的需求量。</p></li><li><p><strong>买者的数量</strong> -以上因素是单个买者行为的因素，如果买者的数量增加，市场需求也会增加。</p></li></ul><h3 id="供给">供给</h3><p><strong>供给量</strong>指的是卖者愿意并且能够出售的一种物品的数量。</p><p>供给量也受很多因素影响，其中起着主要因素的依然是价格。在其他条件不变时，一种物品的价格上升，对该物品的供给量增加；一种物品的价格下降，对该物品的供给量增加。这就是<strong>供给定理</strong>。（供给量与价格呈正相关）</p><p>供给表是供给定理的数据展示，表示一种物品的价格与供给量之间的关系，而供给曲线是图形展示。</p><p>市场供给是所有卖者对某种特定物品或服务的供给量的总和。</p><p>如果某种因素使每一种<strong>既定价格水平下</strong>的供给量的增加，就称之为供给增加；反之则是供给减少。一些重要变量如下：</p><ul><li><strong>价格</strong> - 上文提到的供给定理。</li><li><strong>投入品价格</strong> -原材料的成本。一种物品的供给量与生产这种物品的投入品价格负相关。</li><li><strong>技术</strong> - 技术的进步带来供给量的增加。</li><li><strong>预期</strong> -单个卖者对其他因素的预期也会影响当前的供给量。</li><li><strong>卖者的数量</strong> -以上因素是单个卖者行为的因素，如果卖者的数量增加，市场供给也会增加。</li></ul><h3 id="供给与需求结合">供给与需求结合</h3><p>供给曲线与需求曲线相交于一点，这一点被称为<strong>市场均衡</strong>。这个点的价格被称为<strong>均衡价格</strong>（有时被称为市场出清价格，这个价格下每个人都得到了满足），这个点的数量被称为<strong>均衡数量</strong>。</p><p>在均衡价格时，买者愿意并且能够购买的物品量正好与卖者愿意并且能够出售的物品量相平衡。</p><p><strong>供求定理</strong>：任何一种物品的价格都会自发调整，使该物品的供给与需求达到平衡。这是因为：</p><ul><li>当市场价格高于均衡价格时，物品的供给量超过了需求量（超额供给），存在物品的<strong>过剩</strong>，过剩刺激卖家降低价格（因为卖不出去）。价格的降低提高了需求量，减少了供给量。价格会持续下降直到达到市场均衡为止。因此过剩是暂时的。</li><li>当市场价格低于均衡价格时，物品的需求量超过了供给量（超额需求），存在物品的<strong>短缺</strong>，短缺刺激卖家提高价格（因为提高价格不会影响销量）。价格的上升导致需求量减少，供给量增加。价格会持续上升直到达到市场均衡为止。因此短缺也是暂时的。</li></ul><p><strong>分析某事件市场均衡变动</strong>的三个步骤：</p><ol type="1"><li>确定该事件是使供给曲线移动还是使需求曲线移动（或者两者都移动）。</li><li>确定曲线移动的方向（增加导致对应曲线右移，减少导致对应曲线左移）。</li><li>用供求图说明这种移动如何改变均衡价格和均衡数量。</li></ol><p><strong>供给变动</strong>指供给曲线的变动，而在曲线上的移动称为<strong>供给量的变动</strong>。</p><p><strong>需求变动</strong>指需求曲线的变动，而在曲线上的移动称为<strong>需求量的变动</strong>。</p><table style="width:100%;"><thead><tr class="header"><th></th><th><strong>供给增加</strong></th><th><strong>供给未变</strong></th><th><strong>供给减少</strong></th></tr></thead><tbody><tr class="odd"><td><strong>需求增加</strong></td><td>价格不确定，数量增加</td><td>价格增加，数量增加</td><td>价格增加，数量不确定</td></tr><tr class="even"><td><strong>需求未变</strong></td><td>价格增加，数量增加</td><td>价格不变，数量不变</td><td>价格减少，数量减少</td></tr><tr class="odd"><td><strong>需求减少</strong></td><td>价格减少，数量不确定</td><td>价格减少，数量减少</td><td>价格不确定，数量减少</td></tr></tbody></table><p>市场经济利用供给与需求的力量决定了价格从而在各种竞争性的用途之间分配稀缺资源，这体现了<ahref="###6.%20市场通常是组织经济活动的一种好方法">市场通常是组织经济活动的一种好方法</a>。</p><h2 id="供给与需求的弹性">供给与需求的弹性</h2><p><strong>弹性</strong>是衡量买者与卖者对市场条件变化的反应程度的指标。</p><p><strong>需求（供给）价格弹性</strong>衡量需求量（供给量）对价格变动的反应程度。如果一种物品的需求量（供给量）对价格变动的反应很大，就说这种物品的需求（供给）是富有弹性的；如果一种物品的需求量（供给量）对价格变动的反应很小，就说这种物品的需求（供给）是缺乏弹性的。</p><h3 id="需求弹性">需求弹性</h3><p>以下为某些决定需求价格弹性的经验法则：</p><ul><li><strong>相近替代品的可获得性</strong> -有相近替代品的物品的需求往往富有弹性。</li><li><strong>必需品与奢侈品</strong> -必需品的需求往往缺乏弹性，而奢侈品的需求往往富有弹性。</li><li><strong>市场的定义</strong> -狭窄定义的市场的需求弹性往往大于宽泛定义的市场的需求弹性。比如香草冰淇淋的需求非常富有弹性，而食物的需求相当缺乏弹性。</li><li><strong>时间范围</strong> - 物品的需求往往在长期内更富有弹性。</li></ul><p><span class="math display">\[需求价格弹性=\frac{需求量变动的百分比}{价格变动的百分比}\]</span></p><p>由于用来计算百分比的分母不同会导致计算结果有一定差异，因此通常用中点法进行计算。<span class="math display">\[需求价格弹性=\frac{(Q_{2}-Q_{1})/[(Q_{2}+Q_{1})/2]}{(P_{2}-P_{1})/[(P_{2}-P_{1})/2]}\]</span><strong>值得注意的是，这样看起来似乎线性需求曲线的弹性就等于它的斜率。其实不是这样，要对价格高的点和价格低的点分开看（这样中点也不一样）。在价格高而数量少的各点上，需求富有弹性，而在价格低而数量多的点上，需求缺乏弹性。</strong></p><p>这里的 Q 是 Quantity ，P 是 Price 。 <span class="math display">\[总收益=P\times Q\]</span></p><ul><li>当需求价格弹性大于 1，即需求量变动的比例大于价格变动的比例时，需求是富有弹性的，价格上升将引起总收益减少（反方向变动）。</li><li>当需求价格弹性等于 1，即需求量变动的比例等于价格变动的比例时，需求具有单位弹性，价格变动总收益不变。</li><li>当需求价格弹性小于 1，即需求量变动的比例小于价格变动的比例时，需求是缺乏弹性的，价格上升将引起总收益增加（同方向变动）。</li></ul><p>除了需求价格弹性外，还有一些其他的需求弹性（与需求价格弹性不一样的是这里分正负）：</p><p><strong>需求收入弹性</strong>：衡量一种物品的需求量对消费者收入变动反应程度的指标。<span class="math display">\[需求收入弹性=\frac{需求量变动的百分比}{收入变动的百分比}\]</span>当需求收入弹性是正数时，表明这种物品是正常物品；当需求收入弹性是负数时，表明这种物品是低档物品。</p><p><strong>需求的交叉价格弹性</strong>：衡量一种物品需求量对另一种物品价格变动的反应程度的指标。<span class="math display">\[需求的交叉价格弹性=\frac{一种物品的需求量变动百分比}{另一种物品的价格变动百分比}\]</span>当交叉价格弹性是正数时，表明两种物品是替代品；当交叉价格弹性是负数时，表明两种物品是互补品。</p><h3 id="供给弹性">供给弹性</h3><p><strong>供给价格弹性</strong>取决于卖者改变他们所生产的物品量的<strong>灵活性</strong>。如果非常不灵活，供给缺乏弹性；如果非常灵活，供给富有弹性。</p><p>在大多数市场上，决定供给价格弹性的一个关键因素是所考虑的时间长短。供给的弹性在长期中通常都大于短期。<span class="math display">\[供给价格弹性=\frac{供给量变动的百分比}{价格变动的百分比}\]</span></p><h2 id="供给需求与政府政策">供给、需求与政府政策</h2><h3 id="价格控制">价格控制</h3><p>当政府对竞争市场实行<strong>限制性价格上限</strong>时，市场就产生了<strong>物品的短缺</strong>，而且卖者必须在大量潜在买者中配给稀缺物品。</p><p>当政府对竞争市场实行<strong>限制性价格下限</strong>时，市场就产生了<strong>物品的过剩</strong>，而且买者必须在大量潜在卖者中选购稀缺物品。</p><h3 id="税收">税收</h3><p><strong>税收归宿</strong>：税收负担在买者和卖者之间进行分配的方式。立法无法规定税收的真正负担，税收归宿取决于供给与需求。也就是说，<strong>对买者征税和对卖者征税是等同的</strong>。</p><p>当供给比需求更富有弹性时，税收负担更多地由买者承担。当需求比供给更富有弹性时，税收负担更多地由卖者承担。<strong>税收负担更多地落在缺乏弹性的市场一方</strong>身上。</p><h1 id="市场和福利">市场和福利</h1><h2 id="消费者生产者与市场效率">消费者、生产者与市场效率</h2><p><strong>福利经济学</strong>是研究资源配置如何影响经济福利的一门学问。</p><h3 id="消费者剩余">消费者剩余</h3><p><strong>支付意愿</strong>指的是每一个买者愿意支付的最高价格。</p><p><strong>消费者剩余</strong>指的是买者愿意为一种物品支付的量减去其为此实际支付的量。需求曲线给出的价格表示<strong>边际买者</strong>的支付意愿。<span class="math display">\[消费者剩余=面积(需求曲线-价格)\]</span>消费者剩余衡量了买者从一种物品中得到的自己感觉到的利益，这就是买者的福利。</p><h3 id="生产者剩余">生产者剩余</h3><p><strong>成本</strong>指的是卖者为了生产一种物品而必须放弃的所有东西的价值。</p><p><strong>生产者剩余</strong>指的是卖者出售一种物品得到的量减去其生产成本。供给曲线给出的价格表示边际卖者的成本。<span class="math display">\[生产者剩余=面积(价格-供给曲线)\]</span> 生产者剩余衡量了卖者的福利。</p><h3 id="市场效率">市场效率</h3><p><span class="math display">\[\begin{align}总剩余&amp;=消费者剩余+生产者剩余\\&amp;=面积(需求曲线-生产曲线)\end{align}\]</span></p><p>如果资源配置可以使<strong>总剩余最大化</strong>，那么这种配置是有<strong>效率</strong>的。</p><p>当价格等于均衡价格，数量等于均衡数量时，资源配置是有效率的，所以<ahref="###6.%20市场通常是组织经济活动的一种好方法">市场通常是组织经济活动的一种好方法</a>。</p><h3 id="市场失灵">市场失灵</h3><p>供求的力量可以有效地配置资源，这里有一些假设，最重要地两个是：</p><ol type="1"><li><strong>假设市场是完全竞争的</strong>。单个买家或者卖家不能影响价格。这种能影响价格的能力被称为<strong>市场势力</strong>。</li><li><strong>假设市场结果只影响参与市场的买者和卖者</strong>。环境污染就是典型例外，影响了没有参与市场的人。市场这种副作用被称为<strong>外部性</strong>。</li></ol><p>市场势力和外部性是一种被称为市场失灵的普遍现象。<strong>市场失灵</strong>指的是一些不受管制的市场不能有效地配置资源。</p><h2 id="税收的代价">税收的代价</h2><p><strong>无谓损失</strong>是指当税收（或者某种其他政策）扭曲了市场所引起的总剩余（这时的总剩余是指生产者剩余+消费者剩余+税收收入）的减少。</p><p>供给和需求的弹性越大，税收的无谓损失也越大。</p><p>随着税收规模的扩大，税收收入呈现为先增加后减少的曲线，这就是<strong>拉弗曲线</strong>。</p><h2 id="国际贸易">国际贸易</h2><p><strong>世界价格</strong>指的是一种物品在世界市场上通行的价格。一旦允许贸易，国内价格就上升到等于世界价格的水平。</p><p><strong>出口</strong>使国内物品的<strong>生产者</strong>状况<strong>变好</strong>了，<strong>消费者</strong>状况<strong>变坏</strong>了，但<strong>总体经济福利增加</strong>了。</p><p><strong>进口</strong>使国内物品的<strong>消费者</strong>状况<strong>变好</strong>了，<strong>生产者</strong>状况<strong>变坏</strong>了，但<strong>总体经济福利增加</strong>了。</p><p><strong>关税</strong>指的使对<strong>国外生产而在国内销售的物品（进口物品）</strong>征收的一种税。对该物品的出口没有影响。</p><p>关税提高了价格，减少了进口量，并使国内市场向没有贸易时的均衡移动。关税也会带来无谓损失。</p><p>支持自由贸易除了增加总体经济福利之外，还有一些其他好处：</p><ol type="1"><li>增加了物品的多样性。</li><li>通过规模经济降低了成本。</li><li>促进了竞争。</li><li>加强了思想交流。</li></ol><h1 id="公共部门经济学">公共部门经济学</h1><h2 id="外部性">外部性</h2><h3 id="正外部性和负外部性">正外部性和负外部性</h3><p>外部性指的是一个人的行为对<strong>旁观者福利</strong>的<strong>无补偿</strong>的影响。如果这种影响是不利的（比如污染环境），就是<strong>负外部性</strong>；如果这种影响是有利的（比如修复历史建筑），就是<strong>正外部性</strong>。</p><p>负外部性会导致私人成本（供给）<strong>低于</strong>社会成本（等于私人成本加外部成本），在需求不变的情况下，市场均衡时的数量会<strong>大于</strong>社会最优的数量。因此需要政府的激励提高私人成本或者降低私人价值（需求）。这种改变激励，以使人们考虑到自己行为的外部效应就是<strong>外部性内在化</strong>。</p><p>负外部性使市场胜场的数量<strong>大于</strong>社会合意的数量，正外部性使市场生产的数量<strong>小于</strong>社会合意的数量。为了解决这个问题，政府可以通过<strong>对有负外部性的物品征税</strong>和<strong>给予有正外部性的物品补贴</strong>来使外部性内在化。</p><h3 id="针对外部性的公共政策">针对外部性的公共政策</h3><p>政府可以通过两种方式对外部性做出反应：</p><ul><li><strong>命令与控制政策</strong>直接对行为做出<strong>管制</strong>。</li><li>以市场为基础的政策（<strong>矫正税和补贴</strong>）提供激励。</li></ul><h3 id="针对外部性的私人解决办法">针对外部性的私人解决办法</h3><p>第一种针对外部性的私人解决办法是考虑到自己的行为会对别人造成的影响；第二种针对外部性的私人解决办法是慈善行为。</p><p><strong>科斯定理</strong>认为如果私人各方可以<strong>无成本</strong>地就资源配置问题进行协商，那么，他们就可以自己解决外部性问题。但是由于<strong>各方在达成协议与遵守协议过程中所发生的成本（交易成本）</strong>的存在，有可能利益各方不能解决外部性问题。</p><h2 id="公共物品和公共资源">公共物品和公共资源</h2><p><strong>排他性</strong>是指一种物品具有得可以阻止一个人使用该物品的特性。</p><p><strong>消费中的竞争性</strong>是指一个人使用一种物品将减少其他人对该物品的使用的特性。</p><p>根据物品是否具有排他性和消费中的竞争性可以将物品分为四种类型：</p><table><thead><tr class="header"><th></th><th><strong>具有消费中的竞争性</strong></th><th><strong>不具有消费中的竞争性</strong></th></tr></thead><tbody><tr class="odd"><td><strong>具有排他性</strong></td><td>私人物品</td><td>俱乐部物品</td></tr><tr class="even"><td><strong>不具有排他性</strong></td><td>公共资源</td><td>公共物品</td></tr></tbody></table><p>公共物品和公共资源受外部性的影响主要是<strong>产权的缺失</strong>，产权的缺失意味着不具有排他性。如果没有政府的补贴，公共物品提供者将不愿意供给有效率的公共物品从而导致公共物品的供给不足，这是因为搭便车问题（得到某种收益但避免为此付费）；如果没有政府的管制或矫正税，公共资源将被过度消耗。</p><p>值得一提的是，有的物品是多样的，比如道路。不拥挤的道路是公共物品，不具有消费中的竞争性；而拥挤的道路是公共资源。</p><h2 id="税制的设计">税制的设计</h2><h3 id="税收与效率">税收与效率</h3><p><strong>税收引起的无谓损失来自于没有纳税的人，无谓损失的产生实际上是因为税收改变了没有纳税人的行为。</strong></p><p>所得税： <span class="math display">\[总平均税率=\frac{支付的总税收}{总收入}\]</span></p><p><span class="math display">\[边际税率=增加\ 1\ 单位收入所支付的额外税收\]</span></p><p>决定所得税无谓损失的是边际税率。</p><p>定额税是指对每个人等量增收的税收。</p><h3 id="税收与平等">税收与平等</h3><p><strong>受益原则</strong>指的是人们应该根据他们从政府服务中得到的收益来纳税的思想。</p><p><strong>支付能力原则</strong>指的是应该根据一个人可以承受的负担来对这个人征税的思想。</p><ul><li><strong>纵向平等</strong>主张支付能力更强的纳税人应该缴纳更多税收，强调支付能力纵向上的差异税收；<strong>横向平等</strong>主张有相似支付能力的纳税人应该缴纳等量税收，强调相同支付能力时的相似税收。</li><li><strong>比例税</strong>指的是高收入纳税人和低收入纳税人缴纳收入中<strong>相同</strong>比例的税收；<strong>累退税</strong>指的是高收入纳税人缴纳的税收在收入中所占的比例<strong>低于</strong>低收入纳税人的这一比例；<strong>累进税</strong>指的是高收入纳税人缴纳税收在收入中所占的比例<strong>高于</strong>低收入纳税人这一比例。</li></ul><h1 id="企业行为与产业组织">企业行为与产业组织</h1><h2 id="生产成本">生产成本</h2><h3 id="什么是成本">什么是成本</h3><p><strong>总收益</strong>指的是企业出售其产品所得到的货币量。</p><p><strong>总成本</strong>指的是企业用于生产的投入品的市场价值。</p><p><strong>利润</strong>指的是总收益减去总成本。 <spanclass="math display">\[利润=总收益-总成本\]</span><strong>显性成本</strong>指的是需要企业支出货币的投入成本。</p><p><strong>隐性成本</strong>指的是不需要企业支出货币的投入成本。 <spanclass="math display">\[经济利润=总收益-总成本(包括显性成本和隐性成本)\]</span></p><p><span class="math display">\[会计利润=总收益-总显性成本\]</span></p><h3 id="生产与成本">生产与成本</h3><p><strong>生产函数</strong>指的是用于生产一种物品的投入量与该物品产量之间的关系。</p><p>生产过程中的任何一种投入的<strong>边际产量</strong>是增加一单位投入所引起的产量增加。</p><h3 id="衡量成本的指标">衡量成本的指标</h3><p><strong>固定成本</strong>指的是不随着产量变动而变动的成本。</p><p><strong>可变成本</strong>指的是随着产量变动而变动的成本。 <spanclass="math display">\[平均总成本(ATC)=\frac{总成本}{产量}\\平均固定成本(AFC)=\frac{固定成本}{产量}\\平均可变成本(AVC)=\frac{可变成本}{产量}\\边际成本(MC)=\frac{总成本变动量}{产量变动量}\]</span> 平均总成本曲线呈现出一条 U 形的曲线，U形曲线的底端对应着使平均总成本最小的产量，这个产量被称为企业的<strong>有效规模</strong>。</p><p>当边际成本小于平均总成本的时候，随着产量增加，平均总成本下降；当边际成本大于平均总成本的时候，随着产量增加，平均总成本上升。这种关系引出了一个重要推论：<strong>边际成本曲线与平均总成本曲线在平均总成本曲线的最低点处相交</strong>。</p><h3 id="短期成本与长期成本">短期成本与长期成本</h3><p>由于在长期中<strong>固定成本</strong>是可变的，所以短期平均总成本曲线不同于长期平均总成本曲线。</p><p><strong>规模经济</strong>指的是长期平均总成本随产量增加而减少的特性；<strong>规模不经济</strong>指的是长期平均总成本随着产量增加而增加的特性。</p><h2 id="竞争市场上的企业">竞争市场上的企业</h2><h3 id="竞争市场上的收益">竞争市场上的收益</h3><p>竞争市场（ competitive market ）也称为完全竞争市场，具有以下 3个特征：</p><ul><li>市场上有许多买者与卖者 -也就是说买者和卖者都必须接收市场决定的价格，因此也被称为价格接受者。</li><li>各个卖者提供的物品大体上是相同的。</li><li>（可选）企业可以自由地进入或者退出市场。</li></ul><p><span class="math display">\[总收益(TR) = 产量(Q) \times 价格(P)\\平均收益(AR) = \frac{总收益}{产量}\\边际收益(MR) = \frac{总收益变动量}{产量变动量}\\平均收益(AR) = 边际收益(MR) = 物品的价格(P)\]</span></p><h3 id="利润最大化">利润最大化</h3><p><strong>利润最大化的规律不仅适用于竞争企业，也适用于其他类型的企业（其实就是边际成本和边际收益的关系）</strong>：</p><ul><li>如果边际收益大于边际成本（边际利润 &gt;0），那么企业应该增加其产量。</li><li>如果边际收益小于边际成本（边际利润 &lt;0），那么企业应该减少其产量。</li><li>在利润最大化的产量水平时，边际收益和边际成本相等。</li></ul><h3 id="单个竞争企业的供给曲线">单个竞争企业的供给曲线</h3><p>对于<strong>竞争企业</strong>来讲，边际收益是不变的，因此可以说边际成本曲线决定了企业在任何一种价格时愿意供给的物品数量，因此<strong>边际成本曲线</strong>也是竞争企业的<strong>供给曲线</strong>。但是：</p><p>在<strong>短期</strong>中，如果<strong>生产能得到的收益小于生产的可变成本，那么企业就会选择停止营业（企业在某个特定时期不生产任何东西的短期决策，而非退出市场）</strong>。<span class="math display">\[如果 P&lt;AVC，停止营业\]</span> 因此，竞争企业的短期供给曲线是可变成本曲线之上的那一部分。</p><p>这里说的是生产的可变成本而不是总成本，是因为<strong>固定成本在短期中是沉没成本（一种已经发生而且无法收回的成本）</strong>。</p><p>在<strong>长期</strong>中，如果<strong>平均收益小于平均总成本</strong>，那么企业就会选择<strong>退出市场（长期决策）</strong>。对于竞争企业来讲：<span class="math display">\[利润=(价格(P，同时也是平均收益)-平均总成本(ATC))\times Q\]</span></p><h3 id="竞争市场的供给曲线">竞争市场的供给曲线</h3><p>对于竞争市场来讲，主要考虑短期和长期两种情况，这是因为在短期中，企业数量是相对固定的，而在长期中企业数量则会变动。</p><p>在企业数量相对固定的短期中，市场的供给量就是企业供给量的累加。</p><p>对于长期来讲，由于<ahref="###4.%20人们会对激励做出反应">人们会对激励做出反应</a>，因此只要这个市场有利可图，就会有企业源源不断的涌入导致供给增加，需求不变的情况下价格就会降低，留在市场的企业利润就会减少，最终的情况下，留在市场中的企业的经济利润必定为零。如果这个市场一直在亏，其实就是激励企业退出，最终供给减少需求不变价格增高，留在市场的企业利润增加，最终的情况下，留在市场中的企业的经济利润必定为零。因此市场的长期供给曲线就等于边际成本和平均总成本交点的价格。</p><p>但是这里说的平均总成本包含了机会成本，这里说的企业经济利润为零并不是指企业会计利润为零，这时候是企业有会计利润，但是没有经济利润。</p><h2 id="垄断">垄断</h2><h3 id="垄断的原因">垄断的原因</h3><p>如果一个企业是其产品的唯一卖者，而且其产品并没有相近的替代品，那么这个企业就是一个垄断企业（monopoly），垄断企业具有影响其产品价格的能力，这个市场也被称为完全垄断市场。<strong>垄断产生的根本原因是进入壁垒</strong>，主要是以下3 种原因：</p><ul><li>垄断资源 - 生产所需要的关键资源由某个企业所有。</li><li>政府管制 - 政府给予单个企业排他性地生产某种物品或服务的权利。</li><li>生产流程 - 某个企业能以低于大多数企业的成本生产产品。</li></ul><h3 id="垄断企业的生产与定价决策">垄断企业的生产与定价决策</h3><p>在<strong>生产</strong>上，垄断企业的利润最大化<strong>产量</strong>是由<strong>边际收益曲线</strong>和<strong>边际成本曲线</strong>的<strong>交点</strong>决定的。</p><p>在<strong>定价</strong>上，垄断企业的利润最大化<strong>定价</strong>是<strong>利润最大化产量对应的需求曲线的价格</strong>。<span class="math display">\[对于竞争企业：价格(P)=边际收益(MR)=边际成本(MC)\\对于垄断企业：价格(P)&gt;边际收益(MR)=边际成本(MC)\]</span>垄断企业的供给曲线是没有意义的，因为垄断企业是由产量去确定价格，而不是由价格确定产量。</p><h3 id="垄断的福利代价">垄断的福利代价</h3><p>垄断造成了<strong>无谓损失</strong>，因为潜在的消费者不去购买价值高于其边际成本的物品，相当于这部分能赚的钱就没赚到。</p><p>但是垄断利润不一定是一种社会代价，因为垄断利润本身并不代表经济蛋糕的规模变小。</p><h3 id="价格歧视">价格歧视</h3><p><strong>价格歧视</strong>指的是以不同的价格向不同的顾客出售同一种物品（生产这一物品成本相同）的做法（差异化定价）。</p><p>价格歧视增加了垄断企业的利润，实际上是在压榨消费者剩余，增加生产者剩余。<strong>完全价格歧视</strong>（前提是知道每个消费者的支付意愿）可以把垄断利润最大化定价的无谓损失部分转化为生产者剩余，因此会<strong>增加市场总剩余</strong>。但是由于在实际中，很难做到完全价格歧视，因此，<strong>不完全的价格歧视可能会增加也可能会减少市场总剩余</strong>。</p><h3 id="针对垄断企业的公共政策">针对垄断企业的公共政策</h3><p>政府决策者会用以下 4 种方式之一来应对垄断问题：</p><ul><li>努力使垄断行业更具有竞争性 - 反对行业内巨头的合并，收购</li><li>管制垄断企业的行为</li><li>公有制 - 把一些垄断企业变为公共企业</li><li>不作为</li></ul><h2 id="垄断竞争">垄断竞争</h2><h3 id="不完全竞争市场">不完全竞争市场</h3><p>不完全竞争指的是很多行业<strong>介于完全竞争和完全垄断这两种极端情况之间</strong>的某一个位置，有以下2 种类型：</p><ul><li>寡头 -只有少数几个提供<strong>相似或者相同产品</strong>的卖者的市场结构。</li><li>垄断竞争 -存在许多出售<strong>相似但不相同产品</strong>的企业的市场结构。这里的相似不相同主要是针对完全竞争市场来讲的，假设是相同那就是完全竞争市场。<ul><li>许多卖者</li><li>产品存在差异</li><li>自由进入和退出</li></ul></li></ul><h3 id="有差异产品的竞争">有差异产品的竞争</h3><p>在<strong>短期</strong>中，垄断竞争企业依然选择<strong>边际收益等于边际成本</strong>的<strong>产量</strong>，这时对应的<strong>需求曲线的价格</strong>就是垄断竞争企业的<strong>定价</strong>。</p><p>在<strong>长期</strong>中，垄断竞争企业的平均总成本曲线与需求曲线会相切，价格大于边际利润体现了垄断市场的部分特点，价格等于平均总成本体现了完全竞争市场的部分特点。</p><p>垄断竞争和完全竞争的主要区别在于：</p><ul><li>生产力过剩 -这是因为需求曲线是一条向右下方倾斜的曲线，那么和平均总成本曲线的切点（利润最大化产量）必定在企业的<strong>有效规模（平均总成本最小的产量）</strong>左边，这时就造成了生产力过剩。</li><li>高于边际成本的价格加成 - 这应该说是垄断部分的特点。</li></ul><h3 id="广告">广告</h3><p>广告是垄断竞争的一个自然特征。关于广告是否有社会价值有争论，主要集中在<strong>广告是否提供信息</strong>和<strong>广告是促进还是抑制竞争</strong>这两方面。</p><h2 id="寡头">寡头</h2><p>寡头是只有少数几个提供<strong>相似或者相同产品</strong>的卖者的市场结构。因此寡头的关键特征是合作与利己之间的冲突。</p><h3 id="只有少数几个卖者的市场">只有少数几个卖者的市场</h3><p>寡头之间可能联合，达成<strong>产量和价格的一致</strong>的协议，这种协议被称为<strong>勾结（collusion ）</strong>，联合起来行事的企业集团被称为卡特尔（ cartel,直译为垄断）。</p><p>卡特尔的形成有利于寡头整体利益的最大化，但是由于<strong>瓜分利润的争斗</strong>，往往难以实现。最后寡头间可能形成<strong>纳什均衡：相互作用的经济主体在假定所有其他主体所选策略为既定的情况下，选择他们自己最优策略的状态。</strong></p><p>总之，当寡头企业单独地选择利润最大化的产量时，它们生产的产量大于垄断的产量水平，但小于竞争的产量水平；寡头价格低于垄断价格，但高于竞争价格（边际成本）。</p><p>寡头在单独做决策的时候主要考虑以下 2 点：</p><ul><li>产量效应 - 由于价格高于边际成本，在现行价格时每多销售 1单位产量都将增加利润。</li><li>价格效应 -提高产量将增加市场总销量，这就会降低水的价格并减少所销售的所有其他水的利润。</li></ul><p>如果产量效应大于价格效应，那么寡头将增加产量；如果产量效应小于价格效应，那么寡头将减少产量。</p><h3 id="合作经济学">合作经济学</h3><p>寡头想要达到垄断的效果，需要合作，但合作是有困难的，比如一个叫“<strong>囚徒困境</strong>”的典型博弈。</p><p>在博弈论中，如果无论其他参与者采取什么策略，某一策略都是一个参与者可以采取的最好策略，那么这种策略就被称为<strong>占优策略（dominantstrategy）</strong>。</p><p>寡头面临的囚徒困境对寡头自身来讲是不好的，但是对消费者来讲是好的。</p><h3 id="针对寡头企业的公共政策">针对寡头企业的公共政策</h3><p>对于政策决策者来讲，目的就是让寡头从合作变为竞争，因此普遍的做法是通过政策限制合作，也被称为<strong>反托拉斯法</strong>，但是反托拉斯法有一些争论，比如：</p><ul><li>转售价格维持 -如果一家公司对零售商的定价有限制，其目的可能是为了防止零售商之间的恶意竞争。</li><li>掠夺性定价 -掠夺性定价指的是寡头用低价抢占市场，然后称为垄断企业再定高价。这里的争论在于降价如何判断掠夺还是有利消费者和掠夺性降价本身不是一种有利可图的经营策略（因为掠夺性降价本身会让企业受到更大的损失，对方可以通过缩小市场规模来反制）上。</li><li>搭售 - 捆绑销售。</li></ul><h1 id="劳动市场经济学">劳动市场经济学</h1><h2 id="生产要素市场">生产要素市场</h2><p><strong>生产要素</strong>指的是用于生产物品与服务的投入。劳动、土地和资本是最重要的3 种生产要素。</p>]]></content>
    
    
    <categories>
      
      <category>Economics&amp;Finance</category>
      
      <category>Economics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>economics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《消费信用模型：定价、利润与组合》 - 读书笔记</title>
    <link href="/2023/11/28/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/"/>
    <url>/2023/11/28/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（pricing ）、利润（ profit ）与组合（ portfolio）出发，进行了详细的探讨和论述。</p><p>这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：</p><ul><li><p>贷款机构如何根据违约风险差异化定价。</p></li><li><p>贷款机构如何把违约评分变成利润评分。</p></li><li><p>如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。</p></li></ul><h1 id="消费信用和信用评分简介">1 消费信用和信用评分简介</h1><h2 id="引言消费信用的重要性和影响力">1.1引言：消费信用的重要性和影响力</h2><p>讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。</p><h2 id="违约信用评分的历史背景">1.2 违约信用评分的历史背景</h2><ul><li><p>申请评分 - A卡</p><p>信用评分技术诞生于 20 世纪 50年代，当时的学者认识到用来分类的<strong>统计学方法</strong>可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分-申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。</p><p>这里也提到了最常见的风险（坏客户定义）是申请者在获得贷款后 12个月内出现 90天及以上的逾期，<strong>这个只是坏客户定义的一种</strong>。</p><p>根据这样的坏客户定义得到的模型分数，讲究<strong>排序正确</strong>。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。</p></li><li><p>行为评分 - B卡</p><p>行为评分技术诞生于 20 世纪 80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分-贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。</p></li></ul><h2 id="贷款机构的目标">1.3 贷款机构的目标</h2><h3 id="银行的目标">1.3.1 银行的目标</h3><p>主要目标之一是让贷款带来最多的利润，对于同样的本金利润更高，也就是需要利润率最优。<span class="math display">\[profit\% = \frac{profit}{principal}\]</span>另一个目标是将贷款组合（可以理解为多笔贷款的组合）的风险回报控制在可接受的范围内。</p><p>第三个目标是扩大贷款组合的规模。</p><h3 id="贷款过程">1.3.2贷款过程</h3><ul><li><p>获得资金</p><p>通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。</p></li><li><p>建立消费贷款组合</p><p>找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。</p></li></ul><blockquote><p>这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。<strong>这里定价指的是定利率而不是额度。</strong></p><p>这里也提到了利润评分重点在于<strong>估计从借款人（ borrower）那里可能获得的现金流</strong>，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。</p></blockquote><h2 id="贷款决策的建模工具">1.4 贷款决策的建模工具</h2><p>银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，<strong>本质上都是决策问题</strong>。这里主要介绍了<strong>影响图（influence diagram ）</strong>和<strong>决策树（ decision tree）</strong>两种工具。</p><h3 id="影响图">1.4.1 影响图</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Influence_diagram">Influencediagram - Wikipedia</a></p></blockquote><p>一张影响图由三类节点（ node ）组成，之间由线（ arc）连接。三类节点是：</p><ul><li>决策（ 用矩形表示 ）</li><li>随机事件（ 用圆圈表示 ）</li><li>结果（ 用菱形表示 ）</li></ul><p>如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y的节点不同时，具有以下三种不同的含义。</p><ul><li>Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。</li><li>Y 是一个随机事件，那么条件概率 <spanclass="math inline">\(P(Y|X)\)</span> 和非条件概率 <spanclass="math inline">\(P(Y)\)</span> 并不相同。</li><li>Y 是一个结果，那么说明该结果受到了 X 的影响。</li></ul><h3 id="消费信贷中的申请决策影响图">1.4.2消费信贷中的申请决策影响图</h3><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%BE.png"alt="消费信贷中的申请决策影响图" /><figcaption aria-hidden="true">消费信贷中的申请决策影响图</figcaption></figure><h3 id="决策树">1.4.3 决策树</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Decision_tree">Decision tree -Wikipedia</a></p></blockquote><p>决策树中同样有三种类型的节点：</p><ul><li>决策（用矩形表示）</li><li>随机事件（用圆圈表示）</li><li>回报（ pay off ，用每条路径末端的数值表示）</li></ul><p><strong>值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。</strong></p><h3 id="消费信贷决策树">1.4.4 消费信贷决策树</h3><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91.png"alt="消费信贷决策树" /><figcaption aria-hidden="true">消费信贷决策树</figcaption></figure><p>假设借款人接受贷款概率 <span class="math inline">\(q\)</span>暂不影响决策。接受申请的条件是申请者的预测风险 <spanclass="math inline">\(X\)</span> （ <spanclass="math inline">\(X\)</span> 可能为高也可能为低）满足： <spanclass="math display">\[p(X)g+(1-p(X))(-l)&gt;0\]</span> 如果要考虑接受贷款的概率 <spanclass="math inline">\(q\)</span> 与每笔贷款的贷前管理费用 <spanclass="math inline">\(c\)</span> ，那么接受申请的条件变为： <spanclass="math display">\[q[p(X)g+(1-p(X))(-l)]&gt;c\]</span></p><p>核心就是<strong>利润包括借款人还款情况好时的盈利和还款情况坏时的损失</strong>。</p><h3 id="策略树">1.4.5 策略树</h3><p>贷款过程中的决策有很多，比如是否营销，是否授信，是否催收等等，其中有的决策里一种选择实际上就是终点，而另一种选择则只是决策的一个过程，比如不营销就没有后文了，是决策终点，而选择营销后还存在授信，催收等等决策。策略树就是整个策略的生命周期。</p><h2 id="概率比率和分数">1.5 概率、比率和分数</h2><h3 id="概率和比率">1.5.1 概率和比率</h3><p>提到了三种相互关联的方法来描述好借款人（A 卡一般是用还款差作为标签 1的定义，这里是用还款好作为标签 1 的定义）的可能性：</p><ul><li>事件发生的概率（ probability ） <spanclass="math inline">\(P(good)\)</span> 。</li><li>事件发生的比率（ odds ，好坏比） <spanclass="math inline">\(odds=\frac{P(good|x)}{P(bad|x)}\)</span> 。</li><li>包含了估计事件发生比率的所需信息的分数（ score ）或指数（ index）。</li></ul><h3 id="总体比率和信息比率">1.5.2 总体比率和信息比率</h3><p><strong>这里很重要地提到了分离了总体比率和信息比率的概念，当总体样本好坏比发生变化时，信息比率不变，总体比率会变。</strong>我的理解是提到了信息比率可以用来带来排序，而并不会受行情影响。对于贷款来讲，行情变坏时，仅能保持排序不变。</p><p><strong>证据权重 WOE （ weights of evidence）的公式为：</strong><span class="math display">\[WOE=ln(odds)=ln(\frac{P(good|x)}{P(bad|x)})\]</span> 相较于原始总体比率，证据权重是具有信息 x 或分数 s的人群的好人比率的对数。WOE为正表明这个组的好人概率比全部总体要好；若为负，则表明这组比总体要差一些。</p><h3 id="分数一个充分统计量">1.5.3 分数：一个充分统计量</h3><p>上面提到的信息比率是针对特征来讲的，这里的分数则是针对模型来讲的，这样做的目的是将向量（一个样本的多个特征）转化为标量（可以理解为是好人的概率）。</p><h3 id="对数比率分数">1.5.4 对数比率分数</h3><p>如果是好人的绝对概率是 p ，那么对数比率分数是： <spanclass="math display">\[Score_{log}=ln\frac{p}{1-p}\]</span> 这样做可以提高比较极端的人的差异，证明如下：</p><p>假设 9 个人的好人概率分别为 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8,0.9，他们每个人和下一个人的差异是恒定的0.1，如果是取对数比率分数的话，就变成了 -2.1972, -1.3863, -0.8473,-0.4055, 0.0, 0.4055, 0.8473, 1.3863,2.1972，可以看到左右两端的人和下一个人的差异是比较大的，而中间的人差异比较小。</p><h3 id="对数比率分数的分解">1.5.5 对数比率分数的分解</h3><p>这里提到单特征的 woe不随总体好坏比变化而变化，感觉指的是没有从总体好坏变化中得到额外信息，是样本估计总体的思想。既然woe没变，而总体对数评分变好了，所以某个特征的某个值的对数评分就会变高。</p><p>这是因为某个特征的某个值的对数比率分数公式为： <spanclass="math display">\[Score_{log\ in\ x}=Score_{log\_pop}+woe_{x}\]</span></p><h3 id="朴素-bayes-评分卡的构建">1.5.6 朴素 Bayes 评分卡的构建</h3><p>由上面单特征取值对对数比率分数的影响，<strong>在假设特征相互独立的前提下</strong>，根据Bayes 定理可得： <span class="math display">\[Score_{log}=Score_{log\_pop}+(woe_{x1}+woe_{x2}+...+woe_{xn})\]</span> 这个分数根据 sigmoid函数也可以转换为借款人是好人的概率，公式为： <spanclass="math display">\[P(good)=\frac{1}{1+e^{-Score_{log}}}\]</span> 但是由于特征实际上并不是相互独立的，所以这个方法不够稳健。</p><h3 id="分数分布">1.5.7 分数分布</h3><p>这里提到了好坏的分布很重要，可以通过条件分布函数将本是离散的分数（因为特征分箱导致的取值数量有限）变成连续的，从而简化分数的计算。</p><h2 id="分数的变换">1.6 分数的变换</h2><p>这节主要介绍了分数的几种变换和延展的方法。</p><h3 id="缩放自然分数">1.6.1 缩放自然分数</h3><p>回首对数分数的公式： <span class="math display">\[Score = ln(\frac{p}{1-p})\]</span> 很显然假设 p 小于0.5，也就是好人的概率小于坏人的概率，这个分数就是负的。同时，这个分数总体而言量级比较小，观感略差，因此对这个分数做线性变换就得到了缩放的自然分数：<span class="math display">\[Score_{scaled}=A+B\times Score_{original}\]</span> 这时问题就变成了 A，B 怎么求得。这里其实有两种思路。</p><p>第一种，想好某两个不同分数的好人概率，把 A，B当作未知数去求一个二元一次方程组，解得 A，B。</p><p>第二种，把 A作为一个基准分直接给定数值，然后想好每增加多少分好坏比（或者好人概率）翻倍，实质上是把B 当作未知数去求一个一元一次方程。</p><h3 id="缩放正态分布的分数">1.6.2 缩放正态分布的分数</h3><p>假设好人和坏人的分数分布是正态的，那么概率密度函数为： <spanclass="math display">\[f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^{2}}{2\sigma ^{2}}}\]</span> 再假设好人和坏人的方差是相同的，可以得到： <spanclass="math display">\[WOE=ln(\frac{f(Score|Good)}{f{Score|Bad}})=-\frac{\mu_{G}^{2}-\mu_{B}^{2}}{2\sigma^{2}}+\frac{\mu_{G}-\mu_{B}}{\sigma^{2}}\timesScore\]</span> 那么缩放的正态分布的分数可以表示为： <spanclass="math display">\[S_{scaled}=(ln\frac{P_{G}}{P_{B}}-\frac{\mu_{G}^{2}-\mu_{B}^{2}}{2\sigma^{2}})+\frac{\mu_{G}-\mu_{B}}{\sigma^{2}}\timesScore\]</span> 这种形式。</p><h3 id="多级评分卡">1.6.3 多级评分卡</h3><p>在有多个数据源的情况下，或者说有多级数据源的情况下（指有的数据能够先获取，有的数据后获取），常规方法是合并多个数据源，直接用所有特征来建立模型。</p><p>不过根据分数包含了所有评估风险的信息这个性质，可以直接把第一级数据源所建立模型的分数作为第二级数据源模型的特征，有点类似Stacking 的操作。</p><h3 id="风险率和时变分数">1.6.4 风险率和时变分数</h3><p>这里简单提了下考虑借款人变坏的时间问题。</p><h3 id="离散时间风险概率">1.6.5 离散时间风险概率</h3><p>考虑了不同时间违约带来的不同影响问题，为引入 LGD 做铺垫。</p><h2 id="贷款的回收和成本">1.7 贷款的回收和成本</h2><h3 id="单期贷款的回报率模型">1.7.1 单期贷款的回报率模型</h3><p>在放款受益大于无风险投资收益时，应该放贷： <spanclass="math display">\[P_{G}\times (1+r)+P_{B}\times(1-l_{LGD})&gt;1+r_{F}\]</span> 又因为： <span class="math display">\[P_{B} = 1-P_{G}\]</span> 可以求得： <span class="math display">\[p&gt;\frac{r_{F}+l_{LGD}}{r+l_{LGD}}\\或\\r&gt;\frac{r_{F}+(1-p)\times l_{LGD}}{p}\]</span></p><h3 id="单期企业债券的回报率模型">1.7.2 单期企业债券的回报率模型</h3><h3 id="消费贷款的利润率和回报率">1.7.3 消费贷款的利润率和回报率</h3><p>用单期贷款回报率模型为基础，可以理解为贷款机构以无风险利率 <spanclass="math inline">\(r_{F}\)</span> 筹钱之后再以 <spanclass="math inline">\(r\)</span> 的利率借出去，这时假设筹钱的利率不是<span class="math inline">\(r_{F}\)</span> ，可以用 <spanclass="math inline">\(r_{B}\)</span> 替代 <spanclass="math inline">\(r_{F}\)</span> 。</p><h3 id="两期回报率模型">1.7.4 两期回报率模型</h3><h3 id="多期贷款">1.7.5 多期贷款</h3><h2 id="评分卡构建的基本原理">1.8 评分卡构建的基本原理</h2><h3 id="建立评分卡的基本方法">1.8.1 建立评分卡的基本方法</h3><h3 id="拒绝推断">1.8.2 拒绝推断</h3><h3 id="行为评分">1.8.3 行为评分</h3><h3 id="数据样本">1.8.4 数据样本</h3><h3 id="数据检验和整理">1.8.5 数据检验和整理</h3><h3 id="样本细分">1.8.6 样本细分</h3><h3 id="训练和检验样本">1.8.7 训练和检验样本</h3><h3 id="剔除特征变量">1.8.8 剔除特征变量</h3><h3 id="特征粗分类">1.8.9 特征粗分类</h3><h3 id="卡方和信息统计量">1.8.10 卡方和信息统计量</h3><h3 id="粗分类生成新变量">1.8.11 粗分类生成新变量</h3><h3 id="评分卡最终形成和检验">1.8.12 评分卡最终形成和检验</h3><h2 id="逻辑回归评分卡">1.9 逻辑回归评分卡</h2><h2 id="其他建立评分卡的方法">1.10 其他建立评分卡的方法</h2><h3 id="线性回归">1.10.1 线性回归</h3><h3 id="散度最大化">1.10.2 散度最大化</h3><h3 id="线性规划">1.10.3 线性规划</h3><h3 id="分类树">1.10.4 分类树</h3><h1 id="评分系统的评估">2 评分系统的评估</h1><h2 id="评分卡质量的评估">2.1 评分卡质量的评估</h2><h3 id="交叉验证法">2.1.1 交叉验证法</h3><h3 id="自展法">2.1.2 自展法</h3><h2 id="判别能力的测量">2.2 判别能力的测量</h2><h3 id="散度与信息量">2.2.1 散度与信息量</h3><h3 id="马氏距离">2.2.2 马氏距离</h3><h3 id="ks-统计量">2.2.3 KS 统计量</h3><h3 id="d-一致性统计量与-u-统计量">2.2.4 D 一致性统计量与 U 统计量</h3><h2 id="roc-曲线和-gini-系数">2.3 ROC 曲线和 Gini 系数</h2><h3 id="gini-系数和-auroc">2.3.1 Gini 系数和 AUROC</h3><h3 id="roc-曲线与-d-统计量ks统计量的关系">2.3.2 ROC 曲线与 D统计量、KS统计量的关系</h3><h3 id="gini-系数的边界">2.3.3 Gini 系数的边界</h3><h3 id="roc-曲线和商业决策">2.3.4 ROC 曲线和商业决策</h3><h3 id="cap-曲线与准确率">2.3.5 CAP 曲线与准确率</h3><h2 id="评分卡细分对判别能力的影响">2.4 评分卡细分对判别能力的影响</h2><h3 id="样本细分对-gini-系数的影响">2.4.1 样本细分对 Gini系数的影响</h3><h3 id="样本细分对-ks-统计量的影响">2.4.2 样本细分对 KS统计量的影响</h3><h3 id="样本细分对散度的影响">2.4.3 样本细分对散度的影响</h3><h2 id="评分卡预测概率的校准">2.5 评分卡预测概率的校准</h2><h3 id="二项检验">2.5.1 二项检验</h3><h3 id="二项检验的正态近似">2.5.2 二项检验的正态近似</h3><h3 id="卡方检验">2.5.3 卡方检验</h3><h2 id="分类预测正确程度的衡量">2.6 分类预测正确程度的衡量</h2><h3 id="混淆矩阵">2.6.1 混淆矩阵</h3><h3 id="第一类错误和第二类错误敏感度和特异度">2.6.2第一类错误和第二类错误，敏感度和特异度</h3><h3 id="交换集合">2.6.3 交换集合</h3><h3 id="最小错误成本">2.6.4 最小错误成本</h3><h1 id="基于风险定价">3 基于风险定价</h1><h2 id="消费信贷中的可变定价">3.1 消费信贷中的可变定价</h2><h3 id="可变定价">3.1.1 可变定价</h3><h3 id="差异化定价">3.1.2 差异化定价</h3><h3 id="响应率和接受率">3.1.3 响应率和接受率</h3><h2 id="无风险利率响应函数和最优定价">3.2无风险利率响应函数和最优定价</h2><h3 id="无风险响应率">3.2.1 无风险响应率</h3><h3 id="弹性">3.2.2 弹性</h3><h3 id="最大支付意愿">3.2.3 最大支付意愿</h3><h3 id="常见的响应函数">3.2.4 常见的响应函数</h3><h3 id="最优定价">3.2.5 最优定价</h3><h2 id="风险响应关系逆向选择和负担能力">3.3风险响应关系，逆向选择和负担能力</h2><h3 id="风险响应关系">3.3.1 风险响应关系</h3><h3 id="逆向选择">3.3.2 逆向选择</h3><h3 id="风险响应关系和逆向选择的区别">3.3.3风险响应关系和逆向选择的区别</h3><h3 id="负担能力">3.3.4 负担能力</h3><h2 id="基于风险的响应函数和定价">3.4 基于风险的响应函数和定价</h2><h3 id="基于风险的好人概率">3.4.1 基于风险的好人概率</h3><h3 id="基于风险的最优利率">3.4.2 基于风险的最优利率</h3><h3 id="无逆向选择的最优利率">3.4.3 无逆向选择的最优利率</h3><h3 id="有逆向选择的最优利率">3.4.4 有逆向选择的最优利率</h3><h2 id="多种优惠条件下的接受概率">3.5 多种优惠条件下的接受概率</h2><h3 id="贷款的多种优惠条件">3.5.1 贷款的多种优惠条件</h3><h3 id="逻辑接受概率函数">3.5.2 逻辑接受概率函数</h3><h3 id="线性规划估计最大支付意愿">3.5.3 线性规划估计最大支付意愿</h3><h3 id="加速生命模型估计最大支付意愿">3.5.4加速生命模型估计最大支付意愿</h3><h2 id="借贷博弈定价模型">3.6 借贷博弈定价模型</h2><h1 id="利润评分和动态模型">4 利润评分和动态模型</h1><h2 id="行为评分和账户动态管理">4.1 行为评分和账户动态管理</h2><h3 id="账户管理和利润率">4.1.1 账户管理和利润率</h3><h3 id="行为分数">4.1.2 行为分数</h3><h2 id="利润评分和风险回报矩阵">4.2 利润评分和风险回报矩阵</h2><h3 id="客户层面和产品层面的评分">4.2.1 客户层面和产品层面的评分</h3><h3 id="风险回报矩阵">4.2.2 风险回报矩阵</h3><h3 id="风险回报矩阵里的最优策略">4.2.3 风险回报矩阵里的最优策略</h3><h3 id="消费行为的动态估计">4.2.4 消费行为的动态估计</h3><h2 id="账户行为的-markov-链模型">4.3 账户行为的 Markov 链模型</h2><h3 id="markov-链的定义">4.3.1 Markov 链的定义</h3><h3 id="消费信用中的-markov-链模型">4.3.2 消费信用中的 Markov链模型</h3><h3 id="markov-链的参数估计和假设检验">4.3.3 Markov链的参数估计和假设检验</h3><h3 id="markov-链模型的延伸">4.3.4 Markov 链模型的延伸</h3><h2 id="markov-的利润率决策模型">4.4 Markov 的利润率决策模型</h2><h2 id="生存分析的违约评分系统">4.5 生存分析的违约评分系统</h2><h3 id="何时违约">4.5.1 何时违约</h3><h3 id="生存分析">4.5.2 生存分析</h3><h3 id="比例风险模型">4.5.3 比例风险模型</h3><h3 id="cox-比例风险模型">4.5.4 Cox 比例风险模型</h3><h3 id="建立比例风险模型">4.5.5 建立比例风险模型</h3><h3 id="比例风险行为分数">4.5.6 比例风险行为分数</h3><h2 id="生存分析利润模型">4.6 生存分析利润模型</h2><h3 id="生存分析计算利润率">4.6.1 生存分析计算利润率</h3><h3 id="风险竞争">4.6.2 风险竞争</h3><h1 id="组合信用风险和巴塞尔协议">5 组合信用风险和巴塞尔协议</h1><h2 id="组合信用风险">5.1 组合信用风险</h2><h3 id="组合层面的度量">5.1.1 组合层面的度量</h3><h3 id="组合层面的违约概率">5.1.2 组合层面的违约概率</h3><h3 id="违约损失率和组合层面的损失">5.1.3违约损失率和组合层面的损失</h3><h2 id="经济和监管资本">5.2 经济和监管资本</h2><h3 id="资产和负债">5.2.1 资产和负债</h3><h3 id="贷款中的风险">5.2.2 贷款中的风险</h3><h3 id="监管和经济资本">5.2.3 监管和经济资本</h3><h2 id="巴塞尔资本协议概述">5.3 巴塞尔资本协议概述</h2><h3 id="历史">5.3.1 历史</h3><h3 id="期望损失意外损失监管资本和在险价值">5.3.2期望损失、意外损失、监管资本和在险价值</h3><h3 id="组合不变性">5.3.3 组合不变性</h3><h3 id="巴塞尔模型中的监管资本">5.3.4 巴塞尔模型中的监管资本</h3><h3 id="消费信用的巴塞尔方程">5.3.5 消费信用的巴塞尔方程</h3><h3 id="小结">5.3.6 小结</h3><h2 id="巴塞尔新资本协议对信用评分的影响">5.4巴塞尔新资本协议对信用评分的影响</h2><h3 id="三角关系">5.4.1 三角关系</h3><h3 id="违约的定义">5.4.2 违约的定义</h3><h3 id="时点和周期违约概率">5.4.3 时点和周期违约概率</h3><h3 id="校准">5.4.4 校准</h3><h3 id="消费贷款中的企业信用模型">5.4.5 消费贷款中的企业信用模型</h3><h3 id="违约暴露">5.4.6 违约暴露</h3><h3 id="违约损失率">5.4.7 违约损失率</h3><h2 id="监管资本和最优临界分数">5.5 监管资本和最优临界分数</h2><h3 id="个人贷款接受决策的建模">5.5.1 个人贷款接受决策的建模</h3><h3 id="给定股权资本的组合最优临界分数">5.5.2给定股权资本的组合最优临界分数</h3><h3 id="可变股权资本的组合最优临界分数">5.5.3可变股权资本的组合最优临界分数</h3><h3 id="巴塞尔协议对-roc-曲线的影响">5.5.4 巴塞尔协议对 ROC曲线的影响</h3><h2 id="消费和企业贷款组合的信用风险建模">5.6消费和企业贷款组合的信用风险建模</h2><h3 id="企业信用模型的发展">5.6.1 企业信用模型的发展</h3><h3 id="基于信誉的消费结构模型">5.6.2 基于信誉的消费结构模型</h3><h3 id="基于负担能力的消费结构模型">5.6.3基于负担能力的消费结构模型</h3><h3 id="基于风险函数的消费简约模型">5.6.4基于风险函数的消费简约模型</h3><h3 id="基于-markov-链的消费简约模型">5.6.5 基于 Markov链的消费简约模型</h3><h2 id="消费信贷组合的压力测试">5.7 消费信贷组合的压力测试</h2><h3 id="巴塞尔协议中的压力测试">5.7.1 巴塞尔协议中的压力测试</h3><h3 id="敏感分析和情景分析">5.7.2 敏感分析和情景分析</h3><h3 id="违约概率的静态压力测试方法">5.7.3违约概率的静态压力测试方法</h3><h3 id="动态相关模型">5.7.4 动态相关模型</h3><h3 id="基于模型的动态方法">5.7.5 基于模型的动态方法</h3><h3 id="lgd-和-ead-的压力测试">5.7.6 LGD 和 EAD 的压力测试</h3>]]></content>
    
    
    <categories>
      
      <category>Economics&amp;Finance</category>
      
      <category>RiskControl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>credit</tag>
      
      <tag>decision</tag>
      
      <tag>economics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastAPI</title>
    <link href="/2023/06/20/FastAPI/"/>
    <url>/2023/06/20/FastAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="基础">基础</h1><h2 id="web-基础">WEB 基础</h2><table><thead><tr class="header"><th>请求方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>GET</td><td>请求 URL 的网页信息，并返回实体数据。一般用于查询数据</td></tr><tr class="even"><td>POST</td><td>向 URL 提交数据进行处理请求。比如提交表单或是上传文件</td></tr><tr class="odd"><td>PUT</td><td>向 URL 上传数据内容</td></tr><tr class="even"><td>DELETE</td><td>向 URL 发送删除资源请求</td></tr><tr class="odd"><td>HEAD</td><td>与 GET 请求类似，只返回响应头</td></tr><tr class="even"><td>CONNECT</td><td>HTTP/1.1 预留</td></tr><tr class="odd"><td>OPTIONS</td><td>获取服务器特定资源的 HTML 请求方法</td></tr><tr class="even"><td>TRACE</td><td>回复并显示服务器收到的请求</td></tr><tr class="odd"><td>PATCH</td><td>对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><p>URL （ Uniform ResourceLocator，资源定位符）代表一个网站上资源的详细地址。完整的 URL由以下部分依序组成：</p><ol type="1"><li>协议，如 HTTPS 协议。</li><li>主机名，可能是域名，如 <code>www.google.com</code> ，也可能是 IP地址加端口号，如 <code>192.168.1.1:80</code> 。</li><li>资源相对路径，指网站上资源相对的地址，可能还带有参数。</li></ol><p>HTTP 请求与响应详细实现步骤如下：</p><ol type="1"><li>客户端 TCP 连接到 Web 服务器。</li><li>客户端发送 HTTP 请求。</li><li>Web 服务器接受请求并返回 HTTP 响应。</li><li>释放 TCP 连接。</li><li>客户端解析响应数据。</li></ol><p>HTTP 请求大致组成如下：</p><ul><li>请求行（请求方法，URL，协议版本）</li><li>请求头</li><li>空行</li><li>请求数据</li></ul><p>HTTP 响应大致组成如下：</p><ul><li>状态行（协议版本，状态码，状态码描述）</li><li>响应头</li><li>空行</li><li>响应收据</li></ul><table><thead><tr class="header"><th>状态码</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>100</td><td>不带有响应对象的业务数据，需要请求后执行后续相关操作</td></tr><tr class="even"><td>200</td><td>成功</td></tr><tr class="odd"><td>201</td><td>也是成功，一般用于表示在数据库中创建了一条新的记录</td></tr><tr class="even"><td>204</td><td>提示客户端服务端成功处理，但没有返回内容</td></tr><tr class="odd"><td>300</td><td>重定向</td></tr><tr class="even"><td>400</td><td>客户端异常</td></tr><tr class="odd"><td>500</td><td>服务器异常</td></tr></tbody></table><h2 id="fastapi-框架组成">FastAPI 框架组成</h2><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202305120725715.png" /></p><p>FastAPI 功能建立在 Python 类型提示（3.7, 3.9, 3.10可能写法不一样）、Pydantic 框架、 Starlette 框架基础上。</p><h3 id="python-类型提示">Python 类型提示</h3><h4 id="使用方式">使用方式</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">data: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:    res: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>(data)    <span class="hljs-keyword">return</span> res</code></pre></div><p>变量或参数后面使用冒号指定类型，不过运行时没用，也是防君子不防小人的一种体现。</p><h4 id="基础数据类型">基础数据类型</h4><ul><li>int - 整型</li><li>float - 浮点型</li><li>str - 字符串型</li><li>bool - 逻辑型</li><li>bytes - 字节型</li></ul><h4 id="泛型">泛型</h4><ul><li><p>list - 列表泛型</p></li><li><p>tuple - 元组泛型</p></li><li><p>set - 集合泛型</p></li><li><p>dict - 字典泛型</p></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-comment"># 3.7</span>my_list: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = []timestamp: <span class="hljs-type">Optional</span>[datetime] = <span class="hljs-literal">None</span><span class="hljs-comment"># 3.9</span>my_list: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []timestamp: <span class="hljs-type">Optional</span>[datetime] = <span class="hljs-literal">None</span><span class="hljs-comment"># 3.10</span>my_list: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []timestamp: datetime | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span></code></pre></div><h4 id="自定义类">自定义类</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>):        self.name = name<span class="hljs-comment"># output: movis</span><span class="hljs-built_in">print</span>(Person(<span class="hljs-string">&#x27;movis&#x27;</span>).name)</code></pre></div><h3 id="pydantic-框架">Pydantic 框架</h3><p><a href="https://docs.pydantic.dev/latest/">Pydantic</a> 是一套基于Python 类型提示的数据模型定义及验证的框架。</p><p>这个框架在<strong>运行时</strong>强制执行类型提示。</p><h3 id="starlette-框架">Starlette 框架</h3><p>Starlette 是一个轻量级高性能的异步服务网关接口框架（ASGI）。</p><h1 id="请求">请求</h1><ol type="1"><li>用户向浏览器提交请求数据。</li><li>浏览器封装请求数据冰箱 Web 服务器提交。</li><li>Web 服务器处理请求数据。</li></ol><h2 id="路径参数">路径参数</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file_path</span>(<span class="hljs-params">file_name: <span class="hljs-built_in">str</span></span>):    <span class="hljs-built_in">print</span>(file_name)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div><p>写在 <code>get</code> 请求路径里的 <code>&#123;file_name&#125;</code>这部分就是路径参数，可以定义类型，有类型路径参数的数据会有验证。</p><h3 id="路由访问顺序">路由访问顺序</h3><p>与代码里路由顺序有关，具体为从上到下。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/test&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test_file</span>():    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: <span class="hljs-string">&#x27;this is test&#x27;</span>&#125;<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file_path</span>(<span class="hljs-params">file_name: <span class="hljs-built_in">str</span></span>):    <span class="hljs-built_in">print</span>(file_name)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div><p>如上代码的访问顺序是如果 <code>/file/test</code> 会执行<code>read_test_file()</code> 而不是 <code>read_csv_file_path()</code>。</p><h3 id="枚举的应用">枚举的应用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<span class="hljs-keyword">class</span> <span class="hljs-title class_">FileEnum</span>(<span class="hljs-title class_ inherited__">Enum</span>):    file1 = <span class="hljs-string">&quot;file_one&quot;</span>    file2 = <span class="hljs-string">&quot;file_two&quot;</span><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_file_path</span>(<span class="hljs-params">file_name: FileEnum</span>):    <span class="hljs-built_in">print</span>(file_name)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div><h3 id="路径参数类">路径参数类</h3><p>当想要给路径参数添加约束条件时（校验路径参数）可以使用<code>Path</code> 这个查询参数类。这样代码更加规范。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Path<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#123;item_id&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">..., gt=<span class="hljs-number">3</span></span>)</span>):    <span class="hljs-keyword">return</span> item_id</code></pre></div><p>这样可以指定，<code>item_id</code> 必传并且必须大于 3 。</p><p>具体用法可以看 <ahref="https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/">PathParameters and Numeric Validations - FastAPI</a> 。</p><h2 id="查询参数">查询参数</h2><p>指 <code>path?p1=v1&amp;p2=v2</code> 这种形式。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/file/&#123;file_name&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_file_path</span>(<span class="hljs-params">file_name: FileEnum, q: <span class="hljs-built_in">str</span></span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;path parameter:&#x27;</span>, file_name)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;query parameter&#x27;</span>, q)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;file_name&#x27;</span>: file_name&#125;</code></pre></div><p>在这个示例中，<code>file_name</code> 是路径参数，<code>q</code>这是查询参数，可以看到没有出现在 <code>app.get</code> 后的路径里。</p><p>那么请求 <code>URL</code> 是 <code>xxx/file/file_one?q=v</code>这种形式。</p><p>如果 <code>read_csv_file_path</code> 这个函数声明里写了<code>q</code>的默认值，那么这个查询参数就是一个可选的查询参数，否则就是必选查询参数。将这个示例改写为可选查询参数为：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_file_path</span>(<span class="hljs-params">file_name: FileEnum, q: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):<span class="hljs-comment"># 其实 q: str = None 这样写也可以</span></code></pre></div><h3 id="参数类型转换">参数类型转换</h3><p>通过 <code>URL</code>传递的查询参数，参数值的原始类型是字符串，如果这个函数定义的是<code>int</code> 或者是 <code>bool</code> 那么 FastAPI会验证参数并转换为对应的类型。</p><p>其中 <code>bool</code> 类型可以将如下字符串转义为 <code>True</code>或者 <code>False</code> ：</p><ul><li>True<ul><li><code>q=True</code> , <code>q=true</code> , <code>q=1</code> ,<code>q=yes</code> ，注意这里 1 这个值是可以的，123 这种是不行的。</li></ul></li><li>False<ul><li><code>q=False</code> , <code>q=false</code> , <code>q=0</code> ,<code>q=no</code></li></ul></li></ul><p>对于多路径参数和多查询参数的情况，路径参数的顺序必须是正确的，查询参数的顺序可以随意调换。</p><h3 id="查询参数类">查询参数类</h3><p>当想要给查询参数添加约束条件时（校验查询参数）可以使用<code>Query</code> 这个查询参数类。这样代码更加规范。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Query<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">q: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Query(<span class="hljs-params"><span class="hljs-literal">None</span>, min_length=<span class="hljs-number">3</span></span>)</span>):    <span class="hljs-keyword">return</span> q</code></pre></div><p>具体用法可以看 <ahref="https://fastapi.tiangolo.com/tutorial/query-params-str-validations/">QueryParameters and String Validations - FastAPI</a> 。</p><h2 id="请求体">请求体</h2><p>客户端发送给服务端的受数据模型约束的请求数据称为请求体（ Request Body），默认是 JSON 形式，<strong>请求体不能使用 <code>GET</code>方法</strong>，需要使用 <code>POST</code> 、<code>PUT</code>、<code>DELETE</code> 、<code>PATCH</code> 方法之一。</p><h3 id="对象请求体">对象请求体</h3><p>在 FastAPI 中，所有请求体实现对象，通过创建类继承 Pydantic 的BaseModel 类实现定义。</p><p>假设我需要一个路径为 <code>/items/</code> 的接口，请求体格式为：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    name<span class="hljs-punctuation">:</span> &#x27;xxx&#x27;<span class="hljs-punctuation">,</span>    num<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>这两个参数并将其返回给客户端，那么写法为：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):    name: <span class="hljs-built_in">str</span>    num: <span class="hljs-built_in">int</span><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">created_item</span>(<span class="hljs-params">item: Item</span>):    <span class="hljs-keyword">return</span> item</code></pre></div><p>值得注意的是，由于 <code>Item</code> 类已经定义了数据类型，比如<code>num</code> 为 <code>int</code> ，假设 <code>num</code>没传数字是会报错的。</p><h3 id="常规数据类型请求体">常规数据类型请求体</h3><p>上面定义了继承 Pydantic 的 <code>schema</code>类，因为请求体里是个对象，但是请求体也可能不是个对象，是基础数据类型，可以这样写：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Body<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">created_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">str</span> = Body(<span class="hljs-params"></span>)</span>):    <span class="hljs-keyword">return</span> item</code></pre></div><p>这里主要体现了和查询参数的区别，如果不写这个 <code>Body</code>，很显然这个 <code>item</code> 就是个查询参数。</p><h3 id="表单和文件">表单和文件</h3><p>表单和文件实际上也是在请求体中传给服务端的，都依赖第三方库<code>python-multipart</code> 。</p><p>表单比较常见的应用就是登录时的提交。</p><p>写法为：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/login/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>):    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;username&#x27;</span>: username, <span class="hljs-string">&#x27;password&#x27;</span>: password&#125;</code></pre></div><p>官网教程有用过 <code>username: Annotated[str, Form()]</code>这种写法， 这样的话 <code>username</code>就不再是请求体里的内容而是查询参数。</p><p>从上面可以看到，其实请求体实质上是以一个对象的方式传递的，包括自定义继承<code>Pydantic</code> 的 <code>BaseModel</code>的对象，<code>Body</code> 对象，<code>Form</code> 对象。</p><p>上传文件也是用类似的方式，即 <code>File</code>对象。这里有两种方式接收文件。</p><p>第一种的参数类型为 bytes，用来接收 HTTP 上传的文件流。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/upload/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: <span class="hljs-built_in">bytes</span> = File(<span class="hljs-params"></span>)</span>):    <span class="hljs-keyword">return</span> file[:<span class="hljs-number">20</span>]</code></pre></div><p>第二种的参数类型为 UploadFile，这种情况下，当内存中的数据尺寸超过最大限制后，会将部分数据存储在磁盘中。这种方式比较适合处理大文件，比如图片，视频等。还可以获得文件名。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> File, UploadFile<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/upload/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: UploadFile = File(<span class="hljs-params"></span>)</span>):    <span class="hljs-keyword">return</span> file.filename</code></pre></div><h2 id="cookie-参数">Cookie 参数</h2><p>HTTP Cookie是服务器发送到客户端并保存在本地的一小块数据，一般用来记录用户登录状态和浏览器行为。在FastAPI 中可以通过 <code>Cookie</code> 参数处理 <code>Cookie</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Cookie<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">c: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Cookie(<span class="hljs-params"><span class="hljs-literal">None</span></span>)</span>):    <span class="hljs-keyword">return</span> c</code></pre></div><p>然后需要在浏览器设置 <code>Cookie</code> ：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081045370.png" /></p><p>返回内容如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081046482.png" /></p><p>URL 里是没有传 Cookie 的信息的。</p><p>具体可以见 <ahref="https://fastapi.tiangolo.com/tutorial/cookie-params/">CookieParameters - FastAPI</a> 与 <ahref="https://www.starlette.io/responses/#set-cookie">Responses - SetCookie - Starlette</a>。</p><h2 id="请求头">请求头</h2><p>在 FastAPI 中可以通过 <code>Header</code>参数处理请求头（响应头其实也可以）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Header<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">user_agent: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Header(<span class="hljs-params"></span>)</span>):    <span class="hljs-keyword">return</span> user_agent</code></pre></div><p>这样就可以拿到 <code>User-Agent</code> 。</p><p>具体可以见 <ahref="https://fastapi.tiangolo.com/tutorial/header-params/">HeaderParameters - FastAPI</a> 。</p><h2 id="请求类">请求类</h2><p>在某些情况下，不需要对数据进行校验和转换，可以使用 FastAPI 中的<code>Request</code> 类。</p><p>比如需要返回客户端的 IP ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Request<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):    <span class="hljs-keyword">return</span> request.client.host</code></pre></div><h1 id="响应">响应</h1><ol type="1"><li>Web 服务器解析请求数据。</li><li>数据逻辑处理。</li><li>服务器将响应数据发送回浏览器。</li><li>浏览器渲染响应数据。</li></ol><h2 id="响应模型">响应模型</h2><p>在请求中，请求体中的数据以数据模型形式传递给服务端，好处是可以自动做数据验证。在响应中其实也有同样的方式传递给客户端。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIn</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):    name: <span class="hljs-built_in">str</span>    password: <span class="hljs-built_in">str</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserOut</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):    name: <span class="hljs-built_in">str</span><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/signup/&#x27;</span>, response_model=UserOut</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_customer</span>(<span class="hljs-params">user: UserIn</span>):    <span class="hljs-keyword">return</span> user</code></pre></div><p>只需要在 <code>app.post</code> 或者 <code>app.get</code>装饰器中添加参数 <code>response_model = YOUR_SCHEMA</code>就可以了。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080709699.png" /></p><p>当然，请求模型和响应模型可以是同一个模型。</p><p>在上述例子中，可以通过继承的方式简化数据模型的定义（比如<code>UserIn</code> 和 <code>UserOut</code> 继承同一个基类<code>UserBase</code> ），也可以通过<code>reponse_model</code> 使用<code>typing</code> 里的 <code>Union</code>使用多种响应模型，按顺序匹配直至匹配为止。</p><p>一般来讲，数据模型可以分为三类，请求数据模型，响应数据模型，业务数据模型（跟数据库有关）。</p><h2 id="响应类">响应类</h2><p>路径操作函数在返回响应数据时，可以返回基础数据类型、泛型、数据模型的数据，FastAPI会将不同类型的数据都转换成兼容 JSON格式的字符串，再通过响应对象返回给客户端。除此之外，也可以再路径操作函数中直接使用FastAPI 的内置响应类，返回特殊类型的数据，比如XML、HTML、文件等。具体响应类型如下：</p><h3 id="纯文本响应">纯文本响应</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> PlainTextResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=PlainTextResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Response&quot;</span></code></pre></div><p>返回的内容为：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080823675.png" /></p><p>可以看到这里浏览器是没有渲染的。</p><h3 id="html-响应">HTML 响应</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=HTMLResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Response&quot;</span></code></pre></div><p>返回的内容为：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080824082.png" /></p><p>可以看到这里浏览器已经渲染了。</p><p>可以打开开发者工具观察和上一个的不同，体现在：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306080825151.png" /></p><p>另外，这样写也是可以的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> HTMLResponse(<span class="hljs-string">&quot;Response&quot;</span>)</code></pre></div><h3 id="重定向响应">重定向响应</h3><p>HTTP 重定向也是 Web服务中常见的响应方式，此方式不返回数据，仅返回一个新的 URL地址，比如百度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> RedirectResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=RedirectResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> RedirectResponse(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)</code></pre></div><p>返回的响应就变成了百度的页面。但是这里更重要的是这个<code>return</code> 后这个网址要写全，这里写 <code>www.baidu.com</code>不加协议是不行的。</p><h3 id="json-响应">JSON 响应</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> JSONResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=JSONResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> JSONResponse(content=&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;xx&#x27;</span>&#125;, status_code=<span class="hljs-number">404</span>)</code></pre></div><p>可以看到 <code>JSONResponse</code> 这个类可以更改<code>status_code</code> （其实 <code>XXResponse</code>类都可以），不同公司可能对不同错误要求返回不同 <code>status_code</code>，这里就可以派上用场。</p><h3 id="通用响应">通用响应</h3><p>根据自己需要的 <code>media_type</code> 自己写，比如<code>application/json</code> 或 <code>application/xml</code> 等 :</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> Response<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=Response</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> Response(content=<span class="hljs-string">&#x27;&#123;&quot;1&quot;: &quot;xx&quot;&#125;&#x27;</span>, media_type=<span class="hljs-string">&#x27;application/json&#x27;</span>)</code></pre></div><p>其实<strong>剩下的响应都是继承这个响应的</strong>。这里有几个参数可以了解：</p><ul><li><code>content</code> ：要响应的内容，可以是 <code>str</code> 或者是<code>bytes</code> 类型。</li><li><code>status_code</code> ：HTTP 状态码，<code>int</code> 类型。</li><li><code>headers</code> ：响应头，<code>dict</code> 类型。</li><li><code>media_type</code> ：媒体类型的文本，<code>str</code>类型，可以在 IANA 查看 <ahref="https://www.iana.org/assignments/media-types/media-types.xhtml">MediaTypes</a> 。</li></ul><h3 id="流响应">流响应</h3><p>指使用字节流进行传输。字节流响应的内容是二进制格式，这里以<code>csv</code> 文件举例（可以说明和文件响应的不同之处）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> StreamingResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=StreamingResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file_like.csv&#x27;</span>, mode=<span class="hljs-string">&#x27;rb&#x27;</span>)    <span class="hljs-keyword">return</span> StreamingResponse(f, media_type=<span class="hljs-string">&#x27;text/csv&#x27;</span>) <span class="hljs-comment"># 这里需要指定媒体文件类型</span></code></pre></div><p>这样下载的文件不会带有文件名的信息。</p><h3 id="文件响应">文件响应</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> FileResponse<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=FileResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> FileResponse(<span class="hljs-string">&#x27;file_like.csv&#x27;</span>, media_type=<span class="hljs-string">&#x27;text/csv&#x27;</span>, filename=<span class="hljs-string">&#x27;file_like.csv&#x27;</span>)</code></pre></div><p>与流响应相比，文件响应可以接收更多的参数：</p><ul><li><code>path</code> ：路径，而非文件对象。</li><li><code>filename</code> ：文件名，会包含在响应头的<code>Content-Disposition</code> 中。</li></ul><p>使用 <code>StreamingResponse</code>类时，需要先将文件打开，载入文件对象进行返回，文件内容是一次性读取的，如果文件很大，就会占用很大的内存。使用<code>FileResponse</code> 类时，通过文件路径指定生成了一个<code>FileRespnse</code>类实例，文件是异步读取的，会占用更少的内存。所以推荐使用文件响应。</p><h2 id="自定义-cookie">自定义 Cookie</h2><p>服务器设置 Cookie 的方式是先创建响应实例，再调用响应实例的<code>set_cookie</code> 方法。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;)    response.set_cookie(key=<span class="hljs-string">&#x27;used_id&#x27;</span>, value=<span class="hljs-string">&#x27;123&#x27;</span>)    <span class="hljs-keyword">return</span> response</code></pre></div><p>调用后可以看到，在浏览器已经返回 <code>cookie</code> ：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081222439.png" /></p><h2 id="响应头">响应头</h2><p>和自定义 Cookie 类似，如果想自定义响应头，需要在实例化<code>Response</code> 类时传入 <code>header</code> 这个参数，如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Test Server&#x27;</span>&#125;)    <span class="hljs-keyword">return</span> response</code></pre></div><p>可以看到：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081225963.png" /></p><p>在设置响应头时，有三个规定：</p><ol type="1"><li>设置服务器内置的 Header 的名称可以直接设置，比如这里的<code>User-Agent</code> 。</li><li>设置自定义的 Header 的名称要以 <strong><code>X-</code></strong>开头。</li><li>自定义 Header 的名称和内容都不要包含下划线 <code>_</code>，因为很多服务器会默认过滤下划线。</li></ol><h2 id="响应码">响应码</h2><p>自定义响应状态码可以在实例化 <code>Response</code>类时传入，比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, status_code=<span class="hljs-number">203</span>)    <span class="hljs-keyword">return</span> response</code></pre></div><p>当然可以通过导入 <code>status</code>这个模块，在写代码时能更清楚想向客户端传递什么信息，比如上述改写成：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> status<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#x27;</span>, response_class=JSONResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">request: Request</span>):    response = JSONResponse(content=&#123;<span class="hljs-string">&#x27;res&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, status_code=status.HTTP_203_NON_AUTHORITATIVE_INFORMATION)    <span class="hljs-keyword">return</span> response</code></pre></div><p>两者效果都如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306081237061.png" /></p><h1 id="异常处理">异常处理</h1><p>FastAPI提供了异常处理机制，是为了对异常信息的抛出和处理进行统一管理，增加代码可读性。</p><h2 id="httpexception">HTTPException</h2><p>使用 <code>raise</code> 关键字抛出 <code>HTTPException</code>异常，如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> HTTPException<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#123;item_id&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span></span>):    <span class="hljs-keyword">if</span> item_id == <span class="hljs-number">3</span>:        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">&#x27;Error item_id&#x27;</span>)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;item_id&#x27;</span>: item_id&#125;</code></pre></div><p>当路径参数中的 <code>item_id</code> 为 3时，客户端会收到一条如下的响应：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120506790.png" /></p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120506339.png" /></p><h2 id="全局异常管理器">全局异常管理器</h2><p>用 <code>HTTPException</code>的方式抛出异常，在大型项目中不太方便管理。为了实现逻辑处理与异常处理的分离，FastAPI提供了一种全局异常处理器的方式。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span>(<span class="hljs-title class_ inherited__">Exception</span>): <span class="hljs-comment"># 定义异常类</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.name = name<span class="hljs-meta">@app.exception_handler(<span class="hljs-params">TestException</span>) </span><span class="hljs-comment"># 注册全局异常管理器</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_handler</span>(<span class="hljs-params">request: Request, exc: TestException</span>): <span class="hljs-comment"># 定义异常处理函数</span>    <span class="hljs-keyword">return</span> JSONResponse(status_code=<span class="hljs-number">404</span>, content=&#123;<span class="hljs-string">&#x27;detail&#x27;</span>: <span class="hljs-string">&#x27;Error item_id.&#x27;</span>&#125;)<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/item/&#123;item_id&#125;&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span></span>):    <span class="hljs-keyword">if</span> item_id == <span class="hljs-number">3</span>:        <span class="hljs-keyword">raise</span> TestException(<span class="hljs-built_in">str</span>(item_id))    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;item_id&#x27;</span>: item_id&#125;</code></pre></div><p>通过这种写法，得到的效果和上面 <code>HTTPException</code>的方式是一样的。但是异常处理这部分，也就是<code>test_exception_handler</code>这个函数已经和逻辑处理分离开，而且异常信息的格式也可以自定义，比如不用<code>JSONResponse</code> 而改用 <code>PlainTextResponse</code>就可以返回一段文本而不是 json 格式的数据。</p><h2 id="requestvalidationerror">RequestValidationError</h2><p>这里主要是 <code>RequestValidationError</code>，与前面请求模型里的数据格式验证相对应，当数据格式验证失败时，也可以采取自定义的方式返回错误信息。上面这个例子，如果不自定义，当数据格式验证错误时：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120555362.png" /></p><p>在某些时候需要自定义这个信息，比如在公司里可能需要约定正确和错误的格式，这时就可以自定义：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.exception_handler(<span class="hljs-params">RequestValidationError</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">validation_exception_handler</span>(<span class="hljs-params">request: Request, exc: Exception</span>):    <span class="hljs-keyword">return</span> JSONResponse(status_code=<span class="hljs-number">200</span>, content=&#123;<span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;-2&quot;</span>&#125;)</code></pre></div><p>这样的话当数据格式验证错误时，返回的 <code>Status Code</code> 仍然是200，而错误信息变成了：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120558009.png" /></p><h1 id="中间件">中间件</h1><p>FastAPI中间件实际上是服务端的一种函数，在每个请求处理之前被调用，又在每个响应返回给客户端之前被调用。（也就是函数内部不再需要自己调用）</p><h2 id="自定义中间件">自定义中间件</h2><p>如下是一个在 <code>header</code> 里添加 <code>X-Process-Time</code>的中间件：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.middleware(<span class="hljs-params"><span class="hljs-string">&#x27;http&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_process_time_header</span>(<span class="hljs-params">request: Request, call_next</span>):    start_time = time.time()    response = <span class="hljs-keyword">await</span> call_next(request)    end_time = time.time()    response.headers[<span class="hljs-string">&#x27;X-Process-Time&#x27;</span>] = <span class="hljs-built_in">str</span>(end_time - start_time)    <span class="hljs-keyword">return</span> response</code></pre></div><p>这样在给服务端发请求时：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306120636748.png" /></p><h2 id="corsmiddleware">CORSMiddleware</h2><p>针对前后端分离的软件项目开发方式，有一种称为 CORS （ Cross-OriginResource Sharing，跨域资源共享）的机制，用于<strong>保护后端服务的安全</strong>。</p><p>这里所说的 <strong>域</strong> 指 HTTP协议、主机名、端口的组合。多见于前端访问后端接口访问不通。</p><p>针对这种情况，我们可以如下操作：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.cors <span class="hljs-keyword">import</span> CORSMiddlewareapp.add_middleware(    CORSMiddleware,    allow_origins=[<span class="hljs-string">&#x27;http://localhost:9000&#x27;</span>], <span class="hljs-comment"># 这里写前端访问的网址</span>    allow_credentials=<span class="hljs-literal">True</span>,    allow_methods=[<span class="hljs-string">&#x27;*&#x27;</span>],    allow_headers=[<span class="hljs-string">&#x27;*&#x27;</span>],)</code></pre></div><p>以下是 CORSMiddleware 的配置说明：</p><ul><li><code>allow_origins</code> ：允许跨域请求的源域列表，使用<code>['*']</code> 代表允许任何源。</li><li><code>allow_origin_regex</code>：使用正则表达式匹配的源允许跨域请求。</li><li><code>allow_methods</code> ：允许跨域请求的 HTTP 方法列表，默认为<code>['GET']</code> ，可以使用 <code>['*']</code>来允许所有标准方法。</li><li><code>allow_headers</code> ：允许跨域请求的 HTTP请求头列表，默认为空，可以使用 <code>[*]</code> 来允许所有请求头。</li><li><code>allow_credentials</code> ：是否支持跨域请求用 cookies，默认<code>False</code> 不支持。如果设置为 <code>True</code> ，则<code>allow_origins</code> 不能为 <code>['*']</code> 。</li><li><code>expose_headers</code>：指示可以被浏览器访问的响应信息头，默认为 <code>[]</code> 。</li><li><code>max_age</code> ：设定浏览器缓存 CORS响应的最长事件，单位是秒，默认值为 600 。</li></ul><p>在不配置 CORSMiddleware 时，不允许任何跨域的访问。</p><h2 id="httpsredirectmiddleware">HTTPSRedirectMiddleware</h2><p>HTTPS 的全称为 Hyper Text Transfer Protocol over Secure SocketLayer，通过安全套接字层的超文本传输协议，在 HTTP 上加入了 SSL 。</p><p>该中间件的作用是约束传入的请求地址必须是 HTTPS 开头，对于任何传入的以HTTP 开头的请求地址，都将被重定向到 HTTPS 开头的地址上。</p><p>代码只需要一行：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.httpsredirect <span class="hljs-keyword">import</span> HTTPSRedirectMiddlewareapp.add_middleware(HTTPSRedirectMiddleware)</code></pre></div><h2 id="trustedhostmiddleware">TrustedHostMiddleware</h2><p>这个中间件用来设置域名访问白名单，和 <code>CORSMiddleware</code>类似：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.trustedhost <span class="hljs-keyword">import</span> TrustedHostMiddlewareapp.add_middleware(TrustedHostMiddleware, allowed_hosts=[<span class="hljs-string">&#x27;baidu.com&#x27;</span>])</code></pre></div><p>这样设置后，只允许域名为 <code>baidu.com</code>的主机访问，比如本地的 <code>127.0.0.1</code>并不在白名单里，如果访问就会：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306121020121.png" /></p><h2 id="gzipmiddleware">GZipMiddleware</h2><p>这个一个请求头有 <code>Accept-Encoding:GZip</code>时，对响应数据进行压缩，再发送给客户端，客户端拿到响应，先解压缩的中间件，使用方法也很简单：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.middleware.gzip <span class="hljs-keyword">import</span> GZipMiddlewareapp.add_middleware(GZipMiddleware, minimum_size=<span class="hljs-number">1000</span>)</code></pre></div><p>总的来说，中间件类似于一种通信预处理小工具，可以实现一些基础功能，避免重复造轮子，让开发者更专注于业务逻辑，更多可以看<a href="https://www.starlette.io/middleware/">Middleware -Starlette</a> 。</p><h1 id="依赖注入">依赖注入</h1><p>依赖注入是指本来接收各种参数构造一个对象，现在只接收一个参数——已经实例化的对象，这样的话就不用关心这个对象的创建，销毁等问题。</p><h2 id="函数依赖注入">函数依赖注入</h2><p>假设有一个功能是返回参数名，这个功能很多接口都会用，那么我们就可以采用依赖注入的方式减少代码量，比如定义一个依赖函数返回参数名，然后在要用这个功能的接口里都指定依赖：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):<span class="hljs-string">&quot;&quot;&quot; 定义依赖函数 &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> item<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> user<span class="hljs-comment"># @app.get(&#x27;/items/&#x27;)</span><span class="hljs-comment"># async def read_item(name: Optional[str]):</span><span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name&#125;</span><span class="hljs-comment"># @app.get(&#x27;/users/&#x27;)</span><span class="hljs-comment"># async def read_user(name: Optional[str]):</span><span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name&#125;</span></code></pre></div><p>这里的这个 <code>depend_func</code>就是依赖函数，而下面所注释的部分则是不使用依赖注入方式的接口。假设我现在一个新需求，返回<code>name</code>时还需要返回当前时间，对于依赖注入的方式，只需要修改依赖函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):<span class="hljs-string">&quot;&quot;&quot; 定义依赖函数 &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name, <span class="hljs-string">&#x27;time&#x27;</span>:time.time()&#125;</code></pre></div><p>而对于不是依赖注入的方式则需要去两个接口里分别修改：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># @app.get(&#x27;/items/&#x27;)</span><span class="hljs-comment"># async def read_item(name: Optional[str]):</span><span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name, &#x27;time&#x27;:time.time()&#125;</span><span class="hljs-comment"># @app.get(&#x27;/users/&#x27;)</span><span class="hljs-comment"># async def read_user(name: Optional[str]):</span><span class="hljs-comment">#     return &#123;&#x27;name&#x27;: name, &#x27;time&#x27;:time.time()&#125;</span></code></pre></div><p>这里共享代码逻辑的好处就体现出来了。</p><h2 id="类依赖注入">类依赖注入</h2><p>同样的方式可以将依赖函数封装成一个参数类，增加了代码的可读性。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DependClass</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.name = name<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">DependClass</span>)</span>):    <span class="hljs-keyword">return</span> item<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">DependClass</span>)</span>):    <span class="hljs-keyword">return</span> user</code></pre></div><h2 id="依赖注入的嵌套">依赖注入的嵌套</h2><p>像<ahref="##函数依赖注入">函数依赖注入</a>说到的时间功能，可以如下写：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func2</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func2</span>), need_time: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span></span>):    <span class="hljs-keyword">if</span> need_time:        <span class="hljs-keyword">return</span> &#123;**name, <span class="hljs-string">&#x27;time&#x27;</span>: time.time()&#125;    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> name<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> item<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> user</code></pre></div><p>这里 <code>read_item</code> 和 <code>read_user</code> 依赖了<code>depend_func</code> ，而 <code>depend_func</code> 又依赖了<code>depend_func2</code> ，可以看到返回参数名的逻辑其实并不是在<code>depend_func</code> 里完成的，而是在 <code>depend_func2</code>里完成的。</p><p>当程序用到的多个依赖项都依赖于某一个共同的子依赖项时，FastAPI默认会在第一次执行这个子依赖项时，将其执行结果放在缓存中，以保证对路径操作函数的单次请求，无论定义了多少子依赖项，这个共同的子依赖项只会执行一次。如果不想将其结果放入缓存，可以把<code>use_cache</code> 参数设置为 <code>False</code> 。</p><p>如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func, use_cache=<span class="hljs-literal">False</span></span>)</span>):    <span class="hljs-keyword">return</span> item</code></pre></div><h2 id="装饰器中使用依赖注入">装饰器中使用依赖注入</h2><p>假设 <code>read_item</code> 和 <code>read_user</code> 在传入<code>is_test='test'</code> 时都会抛出异常，而不需要<code>is_test</code> 的返回值，那么这个依赖可以放在装饰器中，就像：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):    <span class="hljs-string">&quot;&quot;&quot;定义依赖函数，请求参数依赖&quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func_test</span>(<span class="hljs-params">is_test: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>):    <span class="hljs-string">&quot;&quot;&quot;定义依赖函数，装饰器中的依赖&quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> is_test == <span class="hljs-string">&#x27;test&#x27;</span>:        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&#x27;This is the test&#x27;</span>)<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span>, dependencies=[Depends(<span class="hljs-params">depend_func_test</span>)]</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> item<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span>, dependencies=[Depends(<span class="hljs-params">depend_func_test</span>)]</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> user</code></pre></div><p>或者放到实例化 <code>FastAPI()</code> 对象中的<code>dependencies</code> 参数中，也是一样的效果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func_test</span>(<span class="hljs-params">is_test: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>):    <span class="hljs-keyword">if</span> is_test == <span class="hljs-string">&#x27;test&#x27;</span>:        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&#x27;This is the test&#x27;</span>)app = FastAPI(dependencies=[Depends(depend_func_test)])<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name&#125;<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> item<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/users/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">user: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">return</span> user</code></pre></div><h2 id="依赖项中的-yield">依赖项中的 yield</h2><p>FastAPI 支持再依赖函数中使用 yield 替代return，这样做的目的是在<strong>路径操作函数</strong>执行完成后，再执行一些其他操作。比较典型的应用场景是文件的读写，数据库会话连接。在FastAPI 官方教程中 <ahref="https://fastapi.tiangolo.com/tutorial/sql-databases/">SQL(Relational) Databases - FastAPI</a> 里，有这样一段代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Dependency</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():    db = SessionLocal()    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">yield</span> db    <span class="hljs-keyword">finally</span>:        db.close()<span class="hljs-comment"># yield 的意义</span></code></pre></div><p>这里这个 <code>get_db</code>实际上是一个依赖项，可能在路径操作函数中会依赖它。</p><p><strong>假设我们不在路径操作函数中依赖它，而在普通函数中依赖它，那么依赖它这个普通函数必须被路径操作函数依赖。简而言之就是依赖链顶端必须是路径操作函数（否则会报错）。</strong></p><p>这样是可以的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):    <span class="hljs-keyword">return</span> db<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">pass</span></code></pre></div><p>这样却不可以：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depend_func</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):    <span class="hljs-keyword">return</span> db<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">depend_func</span>)</span>):    <span class="hljs-keyword">pass</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">或者是</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):    <span class="hljs-keyword">pass</span></code></pre></div><p>因为这时 <code>read_test</code> 已经变为一个普通函数，如果想在<code>read_test</code> 里使用 <code>get_db</code>这个生成器，那么就要像使用生成器一样使用它：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>(<span class="hljs-params">db: Session = <span class="hljs-built_in">next</span>(<span class="hljs-params">get_db(<span class="hljs-params"></span>)</span>)</span>):    <span class="hljs-keyword">pass</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">或者是</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test</span>():    <span class="hljs-keyword">for</span> db <span class="hljs-keyword">in</span> get_db():    <span class="hljs-keyword">pass</span></code></pre></div><h2 id="依赖类的可调用实例">依赖类的可调用实例</h2><p>依赖类本身是可调用的，但是如果想让类的实例也可调用，那么需要实现<code>__call__</code> 这个方法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DependClass</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.name = name    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, q: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> q:            <span class="hljs-keyword">return</span> self.name <span class="hljs-keyword">in</span> q        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">is_dog: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">DependClass(<span class="hljs-params"><span class="hljs-string">&#x27;dog&#x27;</span></span>)</span>), is_cat: <span class="hljs-built_in">bool</span> = Depends(<span class="hljs-params">DependClass(<span class="hljs-params"><span class="hljs-string">&#x27;cat&#x27;</span></span>)</span>)</span>):    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;is_dog&#x27;</span>: is_dog, <span class="hljs-string">&#x27;is_cat&#x27;</span>: is_cat&#125;</code></pre></div><p>结果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306200447727.png" /></p><h1 id="数据库操作">数据库操作</h1><h2 id="sqlalchemy">SQLAlchemy</h2><p>SQLAlchemy 是一个 ORM（ Object Relationship Mapping，对象关系映射）工具，作用就是像操作对象一样（因为这样比较符合习惯）与数据库交互。在我另一篇文章《SQLModel》 中那个框架其实就是基于 SQLAlchemy。</p><h2 id="连接-mysql">连接 MySQL</h2><p>像 PostgreSQL，SQLite 这些关系型数据库其实和 Mysql 差不多，这里以Mysql 举例，主要是完成以下几件事情：</p><h3 id="连接数据库">连接数据库</h3><p>一般放在 <code>database.py</code>文件中，代码一般就是负责建立连接：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_baseSQLALCHEMY_DATABASE_URL = <span class="hljs-string">&quot;mysql://username:password@ipaddress:port/databse&quot;</span>engine = create_engine(SQLALCHEMY_DATABASE_URL)SessionLocal = sessionmaker(autocommit=<span class="hljs-literal">False</span>, bind=engine)Base = declarative_base()</code></pre></div><ol type="1"><li><p>定义连接地址与驱动</p><ul><li><p>```python SQLALCHEMY_DATABASE_URL ="mysql://username:password@ipaddress:port/databse"<div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">   -</span> 当然其实连接 MySQL 的驱动有很多种，比如 <span class="hljs-code">`mysqldb`</span> ，<span class="hljs-code">`pymysql`</span> 等等。这里可以用 <span class="hljs-code">```mysql+mysqldb://username:password@ipaddress:port/databse``` </span>这样的方式去选择。<span class="hljs-bullet">   -</span> 另外，如果使用 SSH 的方式那么这一步可能还要复杂一点，原理就是首先要创建 SSH 连接，然后这里的 IP 与端口填写 SSH 映射的。<span class="hljs-bullet">2.</span> 创建连接引擎<span class="hljs-bullet">   -</span> <span class="hljs-code">```python</span><span class="hljs-code">     engine = create_engine(SQLALCHEMY_DATABASE_URL)</span></code></pre></div></p></li><li><p>熟悉 pandas 的应该知道这里这个引擎就是 <code>pd.read_sql()</code>这个方法中需要的引擎。</p></li></ul></li><li><p>创建本地会话</p><ul><li>```python SessionLocal = sessionmaker(autocommit=False, bind=engine)<div class="code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-number">4</span>. 创建数据模型基类   - ```python     Base = declarative_base()</code></pre></div></li></ul></li></ol><p>一般 <code>database.py</code> 就放这些内容。</p><h3 id="创建-orm-数据模型">创建 ORM 数据模型</h3><p>数据模型一般写在 <code>models.py</code>文件中，每个类其实就是数据库的一张表。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Integer, String<span class="hljs-keyword">from</span> .database <span class="hljs-keyword">import</span> Base <span class="hljs-comment"># 刚刚创建的 Base</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemModel</span>(<span class="hljs-title class_ inherited__">Base</span>):    __tablename__ = <span class="hljs-string">&quot;item&quot;</span>        <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)    name = Column(String)</code></pre></div><h3 id="创建-pydantic-数据模型">创建 Pydantic 数据模型</h3><p>用 Pydantic 实现的数据模型主要为了实现数据的读写操作，并提供 API接口文档，一般写在 <code>schemas.py</code> 文件中。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemSchema</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):    name: <span class="hljs-built_in">str</span>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:        orm_mode = <span class="hljs-literal">True</span></code></pre></div><p>在内部类 <code>Config</code> 中配置 <code>orm_mode = True</code>的作用是让 Pydantic 模型可以从 ORM模型读取数据，如果不写的话，只能从字典读取数据。</p><h3 id="实现-crud-操作">实现 CRUD 操作</h3><p>CRUD ：Create 增加，Read 查询，Update 更改，Delete删除。也就是我们常说的增删改查。</p><p>一般写在 <code>crud.py</code> 文件中。</p><p>这里要遵循 SQLAlchemy 的方式去实现这几个操作，以单个 C R 为例。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">db: Session, item: ItemSchema</span>):    db_item = ItemModel(name=item.name)        db.add(db_item)    db.commit()    db.refresh(db_item)        <span class="hljs-keyword">return</span> db_item<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">db: Session</span>):    <span class="hljs-keyword">return</span> db.query(ItemModel).first()</code></pre></div><p>具体使用 CRUD操作的逻辑不写在这里，一般写在请求函数中。具体步骤一般如下：</p><ol type="1"><li><p>导入所需模块。</p></li><li><p>```python Base.metadata.create_all(bind=engine)<div class="code-wrapper"><pre><code class="hljs csharp">   这段代码的作用是**生成数据库表**，这是 SQLAlchemy 提供的最简洁的方式。<span class="hljs-number">3.</span> 使用依赖注入的方式将 `SessionLocal` 管理。   ```<span class="hljs-function">python</span><span class="hljs-function">   def <span class="hljs-title">get_db</span>():</span><span class="hljs-function">       db</span> = SessionLocal()       <span class="hljs-keyword">try</span>:           <span class="hljs-keyword">yield</span> db       <span class="hljs-keyword">finally</span>:           db.close()</code></pre></div></p></li><li><p>根据业务需求定义路径操作函数。</p></li></ol><h2 id="连接-redis">连接 Redis</h2><h3 id="连接数据库-1">连接数据库</h3><p>类似关系型数据库，连接 Redis 同样采用依赖注入的方式：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rdb</span>():    pool = ConnectionPool(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">6379</span>)    rdb = Redis(connection_pool=pool)    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">yield</span> rdb    <span class="hljs-keyword">finally</span>:        rdb.close()</code></pre></div><h3 id="增加数据与更改数据">增加数据与更改数据</h3><p>增加和更改数据都只需要调用 <code>set</code> 方法就行了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span>, response_model=Item</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_item</span>(<span class="hljs-params">item: Item, rdb: Redis = Depends(<span class="hljs-params">get_rdb</span>)</span>):    rdb.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;test&#x27;</span>, json.dumps(item.<span class="hljs-built_in">dict</span>()))    <span class="hljs-keyword">return</span> item</code></pre></div><h3 id="查询数据">查询数据</h3><p>查询数据需要调用 <code>get</code> 方法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span>, response_model=Item</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_item</span>(<span class="hljs-params">rdb: Redis = Depends(<span class="hljs-params">get_rdb</span>)</span>):    item = rdb.get(<span class="hljs-string">&#x27;test&#x27;</span>)    <span class="hljs-keyword">return</span> json.loads(item)</code></pre></div><h3 id="删除数据">删除数据</h3><p>删除数据需要调用 <code>delete</code> 方法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">&#x27;/items/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_item</span>(<span class="hljs-params">rdb: Redis = Depends(<span class="hljs-params">get_rdb</span>)</span>):    rdb.delete(<span class="hljs-string">&#x27;test&#x27;</span>)</code></pre></div><h1 id="安全">安全</h1><h2 id="安全机制">安全机制</h2><h3 id="oauth-2-令牌授权安全机制">OAuth 2 令牌授权安全机制</h3><p>OAuth 2是一个关于令牌授权的开放网络规范，主要特点是在资源使用者与资源提供者之间，建立一个认证服务器。流程如下：</p><ol type="1"><li>资源使用者向资源提供者发起认证请求</li><li>资源提供者同意给予资源使用者授权</li><li>资源使用者使用上一步获得的授权，向认证服务器申请令牌</li><li>认证服务器对资源使用者进行认证成功后，向资源使用者发放<em>令牌</em></li><li>资源使用者借助令牌向资源服务器申请使用资源</li><li>资源服务器确认令牌正确后，向资源使用者开放受保护的资源</li></ol><p>其中最关键的是资源提供者如何给资源使用者授权，OAuth 2 定义了 4种授权模式：</p><ul><li>授权码模式 -先从资源提供者处申请授权码，根据授权码从认证服务器申请令牌。最常用。</li><li>隐藏模式 -直接在请求种传递令牌，通过链接跳转的方式将令牌传递给另一个资源使用者。适合前端应用服务短期授权。</li><li>密码模式 - 资源使用者通过提供用户名合密码的方式申请令牌。适合提供OAuth 2 认证的自身平台。</li><li>客户端凭证模式 - 通过交换凭证（应用ID，应用密钥）的方式，获取认证信息和令牌。适合后端应用服务之间的授权。</li></ul><h3 id="openid-connect">OpenID Connect</h3><p>OpenID Connect 是一种基于 OAuth 2 的规范，是建立在 OAuth 2协议上的一个简单的身份标识层，也就是说比起 OAuth 2的<strong>访问令牌</strong>多了一个<strong>身份标识令牌</strong>。</p><h3 id="openapi">OpenAPI</h3><p>OpenAPI 是一套用于构建 API 的开放规范。在 OpenAPI规范中，关于安全模式的类型有以下几种：</p><ul><li>APIKey - 用来通过查询参数、Header 参数、Cookie 参数传递密钥。</li><li>HTTP - 使用标准 HTTP 身份认证系统，包含三种类型：<ol type="1"><li>使用 Authorization 请求头，并且包含以 Bearer 开头的加密令牌。</li><li>使用 HTTP 标准身份认证。</li><li>使用 HTTP 摘要身份认证。</li></ol></li><li>OAuth 2 - 使用 OAuth 2 规范中定义的 4 种授权模式。</li><li>OpenID Connect - 使用 OpenID Connect 规范进行认证。</li></ul><p>FastAPI 基于 OpenAPI 规范构建了自动交互式文档。</p><h2 id="基于-oauth-2-的安全机制">基于 OAuth 2 的安全机制</h2><h3 id="jwt-token-bearer">JWT Token &amp; Bearer</h3><p>JWT（Json Web Tokens）是一种安全标准，将 JSON对象编入一个没有空格的长字符串中。</p><p>我们这里使用 <code>python-jose</code> 包实现。</p><p>在没有 Token 认证时，我们用于记录一个用户可能会用到以下函数：</p><ul><li><code>get_db</code> - 依赖函数，用于 FastAPI和数据库有交互时连接的建立。</li><li><code>create_user</code> - 新建一个用户。</li><li><code>get_user</code> - 查询一个用户。</li></ul><p>这时我们遇到一个问题，就是其实我们并不知道当前用户是谁。当我们需要提供差异化服务时，我们就做不到。因此，我们需要对每个用户进行一个身份认证。思路如下：</p><ul><li>创建一个工具函数用于 hash用户的密码，也就是加盐。那么由于密码已经加盐，我们就需要再创建一个工具函数用于校验接收的密码是否与存储的hash value匹配。这两个函数是为了认证并返回用户，具体的功能还需要一个工具函数实现。这一步统称为密码加盐相关处理。</li><li>配置 JWT 令牌签名，包括算法、令牌过期时间。创建一个工具函数用于生成token 的编码与解码。</li><li>在业务相关模块用到上面 2 个模块实现业务逻辑。</li></ul><h4 id="密码-hash-相关">密码 Hash 相关</h4><p>密码加盐指存储密码散列形式而不是明文，这样做提高了密码的安全性。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext_pwd_context = CryptContext(schemes=[<span class="hljs-string">&#x27;bcrypt&#x27;</span>], deprecated=<span class="hljs-string">&#x27;auto&#x27;</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_password</span>(<span class="hljs-params">plain_password: <span class="hljs-built_in">str</span>, hashed_password: <span class="hljs-built_in">str</span></span>):    <span class="hljs-keyword">return</span> _pwd_context.verify(plain_password, hashed_password)<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_password_hash</span>(<span class="hljs-params">password</span>):    <span class="hljs-keyword">return</span> _pwd_context.<span class="hljs-built_in">hash</span>(password)<span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate_user</span>(<span class="hljs-params">db: Session, username: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>):    user = read_user(db=db, username=username)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> verify_password(password, user.hashed_password):        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">return</span> user</code></pre></div><p>用 <code>passlib</code> 包可以实现密码加盐与校验密码。</p><ul><li><code>get_password_hash</code> - 实现了对来自用户的密码进行 hash处理。</li><li><code>verify_password</code> -实现了验证收到的密码是否与存储的哈希值相符。</li><li><code>authenticate_user</code> - 认证并返回用户，可以看到这里是根据<code>username</code> 与 <code>password</code> 查询。</li></ul><h4 id="jwt-相关">JWT 相关</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwtSECRET_KEY = <span class="hljs-string">&quot;b8f7673c0929ee8fa7e9974ba7fbd3e999f2a526189dab012258381c4a044dd7&quot;</span>ALGORITHM = <span class="hljs-string">&quot;HS256&quot;</span>ACCESS_TOKEN_EXPIRE_MINUTES = <span class="hljs-number">5</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_token</span>(<span class="hljs-params">data: <span class="hljs-built_in">dict</span></span>):    to_encode = data.copy()    expries_delta = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    expire = datetime.utcnow() + expries_delta    to_encode.update(&#123;<span class="hljs-string">&#x27;exp&#x27;</span>: expire&#125;)    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    <span class="hljs-keyword">return</span> encoded_jwt<span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_token</span>(<span class="hljs-params">token: <span class="hljs-built_in">str</span></span>):    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])    <span class="hljs-keyword">return</span> payload.get(<span class="hljs-string">&#x27;username&#x27;</span>)</code></pre></div><ul><li><p><code>create_token</code> -这里我们可以看到，生成令牌的逻辑其实就是 <code>jwt.encode</code>一个函数，为了设置过期时间，这里需要将一个 <code>datetime</code>对象（过期的时间点，这里实现方式是当前时间 <code>datetime</code>对象加上时间偏移 <code>timedelta</code> 对象）作为 value 传入到名为<code>exp</code> 的 key 中。然后 <code>jwt.encode</code>会返回一个长字符串，也就是令牌。官方文档的方式是把过期时间作为函数参数传入，这样也不错。</p><p>这里需要注意的是，由于时区问题的存在，<code>jose</code>源码里有一段：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> time_claim <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;exp&quot;</span>, <span class="hljs-string">&quot;iat&quot;</span>, <span class="hljs-string">&quot;nbf&quot;</span>]:    <span class="hljs-comment"># Convert datetime to a intDate value in known time-format claims</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(claims.get(time_claim), datetime):        claims[time_claim] = timegm(claims[time_claim].utctimetuple())</code></pre></div><p>很显然这个包是把这个 <code>datetime</code> 对象当作 <code>utc</code>时间来处理，所以我们在生成时间的时候一定要用<code>datetime.utcnow()</code> 而不是 <code>datetime.now()</code>。</p></li><li><p><code>extract_token</code> -令牌的解码很简单，直接调用即可，<code>jose</code> 源码里有一个函数叫<code>_validate_exp</code>是来验证令牌是否过期的，如果过期就会抛出异常，所以我们在这里不需要自己处理令牌过期问题。</p></li></ul><h4 id="业务逻辑相关">业务逻辑相关</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):    access_token: <span class="hljs-built_in">str</span>    token_type: <span class="hljs-built_in">str</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBase</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):    username: <span class="hljs-built_in">str</span>    email: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>    full_name: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:        orm_mode = <span class="hljs-literal">True</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi.security <span class="hljs-keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm<span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> JWTErroroauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="hljs-string">&quot;login&quot;</span>)<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&#x27;/login/&#x27;</span>, response_model=schemas.Token</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">form: OAuth2PasswordRequestForm = Depends(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):    user = services.authenticate_user(db, form.username, form.password)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:        <span class="hljs-keyword">raise</span> HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=<span class="hljs-string">&#x27;Username or password is invalid.&#x27;</span>)    access_token = services.create_token(data=&#123;<span class="hljs-string">&#x27;username&#x27;</span>: user.username&#125;)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;access_token&#x27;</span>: access_token, <span class="hljs-string">&#x27;token_type&#x27;</span>: <span class="hljs-string">&#x27;bearer&#x27;</span>&#125;<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&#x27;</span>, response_model=schemas.User</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_current_user</span>(<span class="hljs-params">token: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">oauth2_scheme</span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):    invalid_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,                                      detail=<span class="hljs-string">&#x27;Username or password is invalid.&#x27;</span>)    <span class="hljs-keyword">try</span>:        username: <span class="hljs-built_in">str</span> = services.extract_token(token)        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">raise</span> invalid_exception    <span class="hljs-keyword">except</span> JWTError:        <span class="hljs-keyword">raise</span> invalid_exception    user = services.read_user(db, username=username)    <span class="hljs-keyword">if</span> user <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        <span class="hljs-keyword">raise</span> invalid_exception    <span class="hljs-keyword">return</span> user</code></pre></div><p>这里有两个接口，<code>login</code> 和 <code>get_current_user</code>：</p><ul><li><code>login</code> -业务逻辑是，首先校验用户名和密码（登陆），校验成功后发放令牌。</li><li><code>get_current_user</code> -从令牌里拿到用户名，根据用户名去数据库查询用户相关信息。</li></ul><h1 id="异步">异步</h1><p>理解异步需要先理解几个概念：</p><h2 id="进程与线程">进程与线程</h2><ul><li>进程 / Process -进程是计算机<strong>资源分配和调度</strong>的最小单位。所以不同进程之间的数据是不共享的，需要通过网络通信比如TCP/IP 端口通信实现资源共享。</li><li>线程 / Thread -线程是计算机<strong>运算调度</strong>的最小单位。所以不同线程之间的数据是有可能共享的（处在同一个进程时），此时通过共享内存可实现线程间的通信。</li></ul><h2 id="阻塞与非阻塞">阻塞与非阻塞</h2><ul><li>阻塞 / Blocking -阻塞是指一个线程所访问的资源被其他线程占用时，需要等待其他线程完成操作，<strong>在等待期间该线程自身无法继续其他操作</strong>，常见的阻塞有：网络I/O 、磁盘 I/O 、用户输入阻塞。</li><li>非阻塞 / Non-Blocking -非阻塞是指线程在等待其他线程过程中，自身不被阻塞，<strong>等待期间可以执行其他操作</strong>。</li></ul><h2 id="同步与异步">同步与异步</h2><ul><li>同步 / Synchronous -同步是指为了完成某个操作，多个线程必须按照特定的通信方式协调一致，<strong>按顺序执行，前面的执行完了，后面才能执行</strong>。</li><li>异步 / Asynchronous -异步是指为了完成某个操作，无需特定的通信方式协调也可完成任务的方式。</li></ul><p>这里提到的通信方式，通常有：</p><ul><li>信号量 - 用于控制并发的数量。比如某个网站一秒内只能接收本机 500次访问，那么为了避免网站服务器压力过大，可以在客户端使用信号量做控制。</li><li>锁 -确保并发时数据安全。比如两个线程一起访问一个数，逻辑都为如果此数为奇数，则加一否则不变。当一个数原本是奇数时，两个线程同时访问（或者说一个线程访问时另外个线程正在加一，但还没加上去），最后结果是奇数，这种就是数据不安全。可以通过在线程访问时加一个锁，等访问完毕加一完毕释放此锁达保证数据安全。</li><li>同步队列 - 一个自带锁的队列。</li></ul><h2 id="并发与并行">并发与并行</h2><ul><li>并发 / Concurrency - 看起来同时执行。</li><li>并行 / Parallelism - 实际上同时执行。</li></ul><h2 id="gil">GIL</h2><p>Python是一种动态解释型语言。动态指值的类型是在运行时确定，解释指不需要编译直接运行。运行<code>.py</code> 文件的代码需要一个 Python 解释器。</p><p>GIL 全称 Global Interpreter Lock，全局解释器锁，是一种全局互斥锁。作用是每个线程在执行的过程中都需要先获取GIL ，保证同一时刻只有一个线程能控制 Python解释器。好处显然是保证了数据的线程安全，坏处就是效率比较低，没有充分运用CPU 多核的优势。</p><p>但是值得注意的是，并不是有了 GIL 就没有多线程这一说了，比如网络 I/O的典型应用爬虫一样可以多线程执行。另外，协程的出现很好的解决了性能损失的问题。</p><h2 id="协程-coroutine">协程 / Coroutine</h2><p>协程成为微线程，是一种用户态的轻量级线程，也就是操作系统是没有协程这个概念的，是用户自己在用类似多线程的方式进行任务的切换以实现并发目的。</p><p>Python 中有一个库叫 <code>Asyncio</code>，要使用这个库要理解几个概念以及用法。因为我本人主要是从事数据方面的工作，时常用到<code>jupyter notebook</code> ，在那里面想正常使用需要：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nest_asyncionest_asyncio.apply()</code></pre></div><h3 id="事件循环">事件循环</h3><p>事件循环时每个异步应用的核心，用于管理异步任务和回调、执行网络 I/O操作，以及运行子线程等等。大概类似于一个包含很多任务的循环队列。</p><div class="code-wrapper"><pre><code class="hljs python">loop = asyncio.get_event_loop()</code></pre></div><p>事件循环可以这样拿到。</p><h3 id="协程">协程</h3><p>协程本质上是一个函数，特点是在代码块中可以将执行权交给其他协程。当调用协程函数时，不会立即执行，而是返回一个协程对象。需要将协程对象注册到事件循环当中，由事件循环负责调用。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>, time.time())    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>, time.time())<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">await</span> test()    <span class="hljs-keyword">await</span> test()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    asyncio.run(main())</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306261339057.png" /></p><p>这里可以看到实际上，这两个协程并没有并发执行。那么如果要让他们并发执行，则需要任务。</p><h3 id="任务">任务</h3><p>在事件循环中，使用 Task 对象运行协程，Task对象可以说是顾名思义，就是一个任务，比如刚刚那个 <code>test</code>协程如果想并发执行，可以：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>, time.time())    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>, time.time())<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    task1 = asyncio.create_task(test())    task2 = asyncio.create_task(test())    <span class="hljs-keyword">await</span> task1    <span class="hljs-keyword">await</span> task2asyncio.run(main())</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306261340442.png" /></p><p>可以看到用 <code>asyncio.create_task()</code> 可以创建 Task对象。也可以先去拿到事件循环 <code>event_loop</code> ，再用<code>loop.create_task()</code> 创建 Task 对象。</p><p>有时遇到多个任务我们可以往 <code>list</code> 里添加 <code>task</code>，然后用 <code>asyncio.wait(task_list)</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>, time.time())    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>, time.time())<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    task_list = []    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):        task_list.append(asyncio.create_task(test()))    <span class="hljs-keyword">await</span> asyncio.wait(task_list)asyncio.run(main())</code></pre></div><h3 id="future">Future</h3><p>一个 Future对象代表一个异步操作的最终结果，是一个比较底层的东西。</p><p>关于异步这块，我个人觉得有必要直接读官方的文档：</p><ul><li><ahref="https://docs.python.org/3/library/asyncio-task.html">Coroutinesand Tasks — Python 3.11.4 documentation</a></li><li><ahref="https://docs.python.org/3/library/asyncio-future.html">Futures —Python 3.11.4 documentation</a></li></ul><h1 id="应用管理">应用管理</h1><h2 id="配置项管理">配置项管理</h2><h3 id="环境变量">环境变量</h3><p>在 Windows 系统中设置环境变量和打印环境变量如下所示：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270435936.png" /></p><p>但是这样做似乎并没有保存，如果想要保存，可以从 <em>我的电脑 - 属性 -高级系统设置 - 高级 - 环境变量</em>这里去设置环境变量，举个例子，假设安装了 JAVA ，很有可能配置了名为<code>JAVA_HOME</code> 的环境变量。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> os.getenv(<span class="hljs-string">&#x27;JAVA_HOME&#x27;</span>)</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270505462.png" /></p><p>有时为了安全性考虑，可能会把密钥存储在环境变量中。</p><h3 id="配置">配置</h3><p>在 Pydantic 中，前面已经使用了 <code>BaseModel</code>作为数据类的基类，另外还有一个 <code>BaseSettings</code>可以用作配置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseSettings<span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>(<span class="hljs-title class_ inherited__">BaseSettings</span>):    verson: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;0.1.0a&#x27;</span>settings = Settings()app = FastAPI()<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: settings.verson&#125;</code></pre></div><p>作为一个类，每次在使用的时候需要实例化。</p><h2 id="应用事件处理">应用事件处理</h2><h3 id="程序启动事件">程序启动事件</h3><p>有参装饰器 <code>app.on_event()</code> 传入参数 <code>startup</code>即可。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;startup&quot;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_log</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FastAPI start&#x27;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;=&#x27;</span>))</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270519403.png" /></p><h3 id="程序停止事件">程序停止事件</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;shutdown&quot;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">end_log</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FastAPI shutdown&#x27;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;=&#x27;</span>))</code></pre></div><p>当 FastAPI应用程序被停止时，会执行所有停止事件。但与启动事件不同，如果停止事件执行失败，不会影响应用程序的关闭过程。所以，尽量不要在停止事件中写入耗时或者是特别重要的操作。</p><h2 id="应用挂载">应用挂载</h2><p>FastAPI 提供了一种方式，可以用一个主应用管理各个子应用，这个过程称为<strong>挂载</strong> 。挂载可以通过 <code>app.mount()</code> 实现。</p><div class="code-wrapper"><pre><code class="hljs python">app = FastAPI()test1_app = FastAPI()test2_app = FastAPI()app.mount(<span class="hljs-string">&#x27;/test1&#x27;</span>, test1_app)app.mount(<span class="hljs-string">&#x27;/test2&#x27;</span>, test2_app)<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-string">&#x27;main app&#x27;</span>&#125;<span class="hljs-meta">@test1_app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-string">&#x27;test1 app&#x27;</span>&#125;<span class="hljs-meta">@test2_app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-string">&#x27;test2 app&#x27;</span>&#125;</code></pre></div><p>然后这三个接口的访问方式及结果为：</p><p>主接口：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270528429.png" /></p><p>test1 接口：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270529686.png" /></p><p>test2 接口：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270530840.png" /></p><p>当挂载对象是外部应用，比如 Flask 应用时，可以使用<code>WSGIMiddleware</code> 中间件：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<span class="hljs-keyword">from</span> fastapi.middleware.wsgi <span class="hljs-keyword">import</span> WSGIMiddleware<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = FastAPI()flaskapp = Flask(__name__)app.mount(<span class="hljs-string">&#x27;/flask&#x27;</span>, WSGIMiddleware(flaskapp))</code></pre></div><h2 id="路由管理">路由管理</h2><p>在真实的应用程序中，会有几十个甚至上百个路由，如果都放在<code>main.py</code> 中，那么主文件会非常复杂，可以使用<code>APIRouter</code> 这个路由类抽离出来。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, APIRouterapp = FastAPI()openapi = APIRouter(    prefix=<span class="hljs-string">&#x27;/openapi&#x27;</span>,    tags=[<span class="hljs-string">&#x27;openapi&#x27;</span>],    dependencies=[],    responses=&#123;<span class="hljs-number">404</span>: &#123;        <span class="hljs-string">&#x27;detail&#x27;</span>: <span class="hljs-string">&#x27;Not Found&#x27;</span>    &#125;&#125;,)<span class="hljs-meta">@openapi.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;app.include_router(openapi)</code></pre></div><p>可以看到，这样 <code>/openapi/</code> 这个接口就被分离出来了。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270547196.png" /></p><h2 id="目录结构管理">目录结构管理</h2><p>在实际项目中，一般由团队成员共同讨论决定目录结构，也没有说哪种方式就是最好的。</p><p>这里可以参考一下 FastAPI 这个框架作者给的一个全栈项目 <ahref="https://github.com/tiangolo/full-stack-fastapi-postgresql">FullStack FastAPI and PostgreSQL - Base Project Generator</a>中后端部分的目录结构。</p><ul><li>app<ul><li><code>main.py</code> - 主文件</li><li>api<ul><li>routers - Router</li><li>errors - Error</li><li>dependencies - 依赖</li></ul></li><li>core<ul><li>setting - 综合设置</li><li>database - 数据库相关设置</li><li>security - 安全设置</li></ul></li><li>services - 业务逻辑</li><li>crud - 数据库的各种操作</li><li>models - 数据库模型</li><li>schemas - 数据模型</li></ul></li></ul><h1 id="模板">模板</h1><p>FastAPI是一个服务器端框架，主要用于提供服务器端的数据接口，但在某些场景下，仍然需要使用传统的页面模板技术，提供Web 界面（前后端不分离）。</p><p>接口函数的主要作用是处理业务逻辑返回响应。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。使用模板后，由模板负责渲染表现内容，后端接口负责处理业务逻辑。</p><p>模板仅仅是文本文件。它可以生成任何基于文本的格式（ HTML 、 XML 、 CSV、 LaTex 等等）。 它并没有特定的扩展名， <code>.html</code> 或<code>.xml</code> 都是可以的。</p><p>这里介绍一下 Jinja2 这个模板的使用。详情可参考 <ahref="https://jinja.palletsprojects.com/en/3.1.x/templates/">TemplateDesigner Documentation — Jinja Documentation (3.1.x)</a>这份官方文档。</p><h2 id="注释">注释</h2><div class="code-wrapper"><pre><code class="hljs clean">&#123;# 注释 #&#125;</code></pre></div><h2 id="变量">变量</h2><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">变量名</span> &#125;&#125;</span></code></pre></div><p>最终在文件或网页中，这里可以直接得到变量值。</p><h2 id="转义">转义</h2><div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">raw</span> %&#125;</span><span class="language-xml"></span><span class="language-xml">这部分不会被转义</span><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endraw</span> %&#125;</span></code></pre></div><h2 id="循环">循环</h2><div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> list %&#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span></code></pre></div><h2 id="条件-if">条件 IF</h2><div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> item is not None %&#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span></code></pre></div><h2 id="作用域with">作用域With</h2><div class="code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">with</span></span> name = test %&#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; name &#125;&#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endwith</span></span> %&#125;</span></code></pre></div><h2 id="fastapi-应用-jinja2">FastAPI 应用 Jinja2</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request<span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse<span class="hljs-keyword">from</span> fastapi.templating <span class="hljs-keyword">import</span> Jinja2Templatesapp = FastAPI()templates = Jinja2Templates(directory=<span class="hljs-string">&#x27;templates&#x27;</span>)<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=HTMLResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request: Request, input_str: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Hello World !&#x27;</span></span>):    <span class="hljs-keyword">return</span> templates.TemplateResponse(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;request&#x27;</span>: request, <span class="hljs-string">&#x27;input_str&#x27;</span>: input_str&#125;)</code></pre></div><p>后端代码如上所示，不难看出，当用户请求 <code>index</code>这个接口的时候，接口返回的数据是 <code>request</code> 和<code>input_str</code> ，到 <code>index.html</code>这个文件中，那么再来看下这个前端文件的具体内容：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&#123;&#123; request &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; input_str &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>这里这个 <code>request</code> 和 <code>input_str</code>其实就是接口给的，最终效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270743752.png" /></p><p>我们可以用 <code>StaticFiles</code> 挂载静态资源比如 CSS文件，例如：</p><p>后端 <code>main.py</code> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request<span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse<span class="hljs-keyword">from</span> fastapi.templating <span class="hljs-keyword">import</span> Jinja2Templates<span class="hljs-keyword">from</span> fastapi.staticfiles <span class="hljs-keyword">import</span> StaticFilesapp = FastAPI()app.mount(<span class="hljs-string">&#x27;/static&#x27;</span>, StaticFiles(directory=<span class="hljs-string">&#x27;static&#x27;</span>), name=<span class="hljs-string">&#x27;static&#x27;</span>)templates = Jinja2Templates(directory=<span class="hljs-string">&#x27;templates&#x27;</span>)<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, response_class=HTMLResponse</span>)</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request: Request, input_str: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Hello World !&#x27;</span></span>):    <span class="hljs-keyword">return</span> templates.TemplateResponse(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;request&#x27;</span>: request, <span class="hljs-string">&#x27;input_str&#x27;</span>: input_str&#125;)</code></pre></div><p>HTML 文件 <code>templates/index.html</code> ：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&#123;&#123; request &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, path=&#x27;/style.css&#x27;) &#125;&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; input_str &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>CSS 文件 <code>static/style.css</code> ：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;    <span class="hljs-attribute">font-style</span>: italic;    <span class="hljs-attribute">text-align</span>: center;&#125;</code></pre></div><p>最终可以得到效果：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202306270752899.png" /></p><h1 id="测试">测试</h1><h1 id="部署">部署</h1>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Python</category>
      
      <category>Backend</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>fastapi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matplotlib&amp;seaborn 包的学习</title>
    <link href="/2023/04/16/matplotlib%E4%B8%8Eseaborn/"/>
    <url>/2023/04/16/matplotlib%E4%B8%8Eseaborn/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://matplotlib.org/stable/index.html">matplotlib官方文档</a></p></blockquote><h1 id="matplotlib-基础概念">matplotlib 基础概念</h1><h2 id="快速开始">1 - 快速开始</h2><h3 id="图的组成">图的组成</h3><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304161118323.png" /></p><p>上图给出了 matplotlib 图像中各种组成部分，其中比较重要的有：</p><ul><li><code>Axis</code> - 单个轴，比如 x 轴或是 y 轴。</li><li><code>Axes</code> - 坐标系，一个坐标系可以包含很多个轴。</li><li><code>Figure</code> -图，一个图可以包含很多个坐标系，可以理解每个坐标系是一份子图。</li><li><code>Artist</code> - 图中可以看到的所有东西。</li></ul><h3 id="输入类型">输入类型</h3><p>官方文档的意思是希望是一个 <code>numpy.array</code> 对象。</p><h3 id="代码风格">代码风格</h3><p>假设我需要画出 y = -x+4 的折线图：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304161151618.png" /></p><p>我的代码风格大概分为两种：</p><h4 id="面向对象风格">面向对象风格</h4><p>显式创建 <code>Figure</code> 与 <code>Axes</code>，将它们视为对象，调用它们的方法。<strong>这种手法比较灵活。</strong></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">x = np.linspace(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)fig, ax = plt.subplots()ax.plot(x, -x+<span class="hljs-number">4</span>)ax.set_xlabel(<span class="hljs-string">&#x27;x axis&#x27;</span>)ax.set_ylabel(<span class="hljs-string">&#x27;y axis&#x27;</span>)ax.set_title(<span class="hljs-string">&#x27;y=-x+4&#x27;</span>)plt.show()</code></pre></div><h4 id="pyplotmatlab-风格">pyplot/matlab 风格</h4><p>依赖 <code>pyplot</code>画图。<strong>这种手法比较简洁。</strong></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">x = np.linspace(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)plt.plot(x, -x+<span class="hljs-number">4</span>)plt.xlabel(<span class="hljs-string">&#x27;x axis&#x27;</span>)plt.ylabel(<span class="hljs-string">&#x27;y axis&#x27;</span>)plt.title(<span class="hljs-string">&#x27;y=-x+4&#x27;</span>)plt.show()</code></pre></div><h4 id="函数包装">函数包装</h4><p>官方的示例是将 <code>Axes</code>作为一个参数传入函数，在此坐标系上画图。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_func</span>(<span class="hljs-params">ax, x, y, *args, **kwargs</span>):    out = ax.plot(x, y, *args, **kwargs)    <span class="hljs-keyword">return</span> outx = np.linspace(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)fig, ax = plt.subplots()write_func(ax, x, -x + <span class="hljs-number">4</span>)</code></pre></div><h3 id="元素样式">元素样式</h3><p>包括填充颜色，轮廓颜色，线的样式，线的宽度等。</p><p>比如：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304171141651.png" /></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">x = np.linspace(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)fig, ax = plt.subplots()<span class="hljs-comment"># 设置颜色为红色，线宽度为 5，线样式为虚线</span>ax.plot(x, -x+<span class="hljs-number">4</span>, color=<span class="hljs-string">&#x27;r&#x27;</span>, linewidth=<span class="hljs-number">5</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>)ax.set_xlabel(<span class="hljs-string">&#x27;x axis&#x27;</span>)ax.set_ylabel(<span class="hljs-string">&#x27;y axis&#x27;</span>)ax.set_title(<span class="hljs-string">&#x27;y=-x+4&#x27;</span>)plt.show()</code></pre></div><h3 id="标签画图">标签画图</h3><p>标签的显示方式和副轴标签的显示方式如下。</p><p>假设图为：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304171415979.png" /></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">data = pd.DataFrame(&#123;<span class="hljs-string">&#x27;type&#x27;</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>], <span class="hljs-string">&#x27;y&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]&#125;)data2 = data.groupby([<span class="hljs-string">&#x27;type&#x27;</span>])[<span class="hljs-string">&#x27;y&#x27;</span>].agg([<span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-string">&#x27;sum&#x27;</span>]).reset_index()data2[<span class="hljs-string">&#x27;ratio&#x27;</span>] = (data2[<span class="hljs-string">&#x27;sum&#x27;</span>]/data2[<span class="hljs-string">&#x27;count&#x27;</span>]).<span class="hljs-built_in">round</span>(<span class="hljs-number">4</span>)fig, ax1 = plt.subplots()ax2 = ax1.twinx()l1 = ax1.bar(data2[<span class="hljs-string">&#x27;type&#x27;</span>].values, data2[<span class="hljs-string">&#x27;count&#x27;</span>].values)l2, = ax2.plot(data2[<span class="hljs-string">&#x27;type&#x27;</span>].values, data2[<span class="hljs-string">&#x27;ratio&#x27;</span>].values, color=<span class="hljs-string">&#x27;r&#x27;</span>)plt.legend([l1, l2], [<span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-string">&#x27;1_probability&#x27;</span>])plt.show()</code></pre></div><h3 id="轴的刻度">轴的刻度</h3><p>每个 <code>Axes</code> 都有两个（或三个） <code>Axis</code>对象，分别代表 X 轴和 Y轴。这些对象控制轴的比例、刻度定位器和刻度格式。可以附加其他轴来显示更多的轴对象。</p><p>比方说我需要画两个图（一个 X 轴正常，另一个 X 轴为对数坐标轴）：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304171423188.png" /></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">x = np.linspace(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)fig, axs = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, layout=<span class="hljs-string">&#x27;constrained&#x27;</span>)axs[<span class="hljs-number">0</span>].plot(x, -x+<span class="hljs-number">4</span>)axs[<span class="hljs-number">1</span>].set_xscale(<span class="hljs-string">&#x27;log&#x27;</span>)axs[<span class="hljs-number">1</span>].plot(x, -x+<span class="hljs-number">4</span>)plt.show()</code></pre></div><h3 id="主题颜色">主题颜色</h3><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304180846385.png" /></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">x, y = np.meshgrid([-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])z = x+yfig, ax = plt.subplots()pc = ax.pcolormesh(x, y, z, vmin=-<span class="hljs-number">1</span>, vmax=<span class="hljs-number">2</span>)fig.colorbar(pc, ax=ax)plt.show()</code></pre></div><h3 id="复合图与坐标系">复合图与坐标系</h3><p>官网给的例子是：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202304180849327.png" /></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">fig, ax = plt.subplot_mosaic([[<span class="hljs-string">&#x27;upleft&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span>], [<span class="hljs-string">&#x27;lowleft&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span>]], layout=<span class="hljs-string">&#x27;constrained&#x27;</span>)ax[<span class="hljs-string">&#x27;upleft&#x27;</span>].set_title(<span class="hljs-string">&#x27;upleft&#x27;</span>)ax[<span class="hljs-string">&#x27;lowleft&#x27;</span>].set_title(<span class="hljs-string">&#x27;lowleft&#x27;</span>)ax[<span class="hljs-string">&#x27;right&#x27;</span>].set_title(<span class="hljs-string">&#x27;right&#x27;</span>)plt.show()</code></pre></div><h2 id="pyplot-教程">2 - Pyplot 教程</h2><h3 id="pyplot-介绍">Pyplot 介绍</h3><p><code>matplotlib.pyplot</code> 是一个函数集合，使<code>matplotlib</code> 像 <code>MATLAB</code> 一样工作。每个<code>pyplot</code>函数都会对一个图形进行一些改变：例如，创建一个图形，在图形中创建一个绘图区，在绘图区绘制一些线条，用标签来装饰图形等等。</p>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Visualization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>matplotlib</tag>
      
      <tag>seaborn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「编程能力」 - 学习计划</title>
    <link href="/2023/02/22/Leetcode%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/"/>
    <url>/2023/02/22/Leetcode%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="编程能力入门">编程能力入门</h1><h2 id="基本数据类型">基本数据类型</h2><h3 id="在区间范围内统计奇数数目">1523. 在区间范围内统计奇数数目</h3><p>首先就分为四种情况：</p><table><thead><tr class="header"><th>low</th><th>high</th><th>result</th></tr></thead><tbody><tr class="odd"><td>奇数</td><td>奇数</td><td><span class="math inline">\(=(high-low)//2 + 1\)</span></td></tr><tr class="even"><td>奇数</td><td>偶数</td><td><span class="math inline">\(=(high-low)//2 + 1\)</span></td></tr><tr class="odd"><td>偶数</td><td>奇数</td><td><span class="math inline">\(=(high-low)//2 + 1\)</span></td></tr><tr class="even"><td>偶数</td><td>偶数</td><td><span class="math inline">\(=(high-low)//2\)</span></td></tr></tbody></table><p>这就有了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countOdds</span>(<span class="hljs-params">self, low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> (high - low)//<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> low&amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> high&amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (high - low)//<span class="hljs-number">2</span> + <span class="hljs-number">1</span></code></pre></div><p>问题在于我发现这个算法好像不怎么快。如果要比这个更快的话只能没有这个<code>if</code> 的条件判断了。</p><p>如果要合二为一的话，我想到一个问题，[0, 一个数 <code>x</code> ]的奇数个数怎么计算呢？</p><p>很容易得出结果是 <spanclass="math inline">\((x+1)//2\)</span>，按照这个思路，其实就是<code>(high+1)//2 - (low+1)//2</code>，但是稍有不同的是这个式子其实没有算 <code>low</code> 这个数，如果<code>low</code> 这个数是个奇数的话，因此：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countOdds</span>(<span class="hljs-params">self, low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> (high+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span> - low//<span class="hljs-number">2</span></code></pre></div><h3 id="去掉最低工资和最高工资后的工资平均值">1491.去掉最低工资和最高工资后的工资平均值</h3><p>直接调用函数是比较直接的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">self, salary: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">sum</span>(salary)-<span class="hljs-built_in">max</span>(salary)-<span class="hljs-built_in">min</span>(salary))/(<span class="hljs-built_in">len</span>(salary)-<span class="hljs-number">2</span>)</code></pre></div><p>我们也可以尽量把操作放在一次循环里。</p><div class="code-wrapper"><pre><code class="hljs python3">class Solution:    def average(self, salary: List[int]) -&gt; float:        salary_max = salary[0]        salary_min = salary[0]        salary_sum = 0        for i in salary:            salary_sum += i            if i &gt; salary_max:                salary_max = i            elif i &lt; salary_min:                salary_min = i        return (salary_sum-salary_max-salary_min)/(len(salary)-2)</code></pre></div><p>这里有个小坑，假如你的初始最大值是 <code>1e3</code>，也就是理论上最小值，初始最小值是 <code>1e6</code>也就是理论上的最大值，这里不能写 <code>if elif</code>，因为对第一个值是最小值的情况会解答错误。</p><h2 id="运算符">运算符</h2><h3 id="位1的个数">191. 位1的个数</h3><p>首先可以转换成字符串，然后统计字符 <code>'1'</code> 的个数。这里取<code>[2:]</code> 主要是用 <code>bin()</code> 这个函数转换之后是<code>0bxxx</code> 这种形式。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        n_str = <span class="hljs-built_in">bin</span>(n)[<span class="hljs-number">2</span>:]        <span class="hljs-keyword">return</span> n_str.count(<span class="hljs-string">&#x27;1&#x27;</span>)</code></pre></div><p>从位运算的角度考虑，判断奇偶可以用 <code>n&amp;1==1?</code>相当于看最后一位是不是 <code>1</code> ，所以可以将数字不断向右移位来判断<code>1</code> 的个数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += n&amp;<span class="hljs-number">1</span>            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>还有个操作 <code>n&amp;(n-1)</code> 作用是将最右端的 <code>1</code>置 <code>0</code> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            n &amp;= n-<span class="hljs-number">1</span>            res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="整数的各位积和之差">1281. 整数的各位积和之差</h3><p>模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subtractProductAndSum</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        bit_sum = <span class="hljs-number">0</span>        bit_mul = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> n:            temp = n%<span class="hljs-number">10</span>            n //= <span class="hljs-number">10</span>            bit_sum += temp            bit_mul *= temp        <span class="hljs-keyword">return</span> bit_mul - bit_sum</code></pre></div><h2 id="条件语句">条件语句</h2><h3 id="三角形的最大周长">976. 三角形的最大周长</h3><p>最开始想的是列出所有排列组合然后看满足条件的排列组合，找周长最大的那个，然后<code>OOT</code> 了。</p><p>后来发觉这个其实是个排序然后滑动窗口的问题，由大到小（逆序）排序后，从最左开始滑动包含3 个数的窗口，当遇到满足条件的窗口直接返回窗口内数的和，否则返回 0。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestPerimeter</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>))        x = <span class="hljs-number">0</span>        y = <span class="hljs-number">1</span>        z = <span class="hljs-number">2</span>        nums_len = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> z&lt;nums_len:            <span class="hljs-keyword">if</span> nums[x]+nums[y]&gt;nums[z] <span class="hljs-keyword">and</span> nums[y]+nums[z]&gt;nums[x] <span class="hljs-keyword">and</span> nums[x]+nums[z]&gt;nums[y]:                <span class="hljs-keyword">return</span> nums[x]+nums[y]+nums[z]            x += <span class="hljs-number">1</span>            y += <span class="hljs-number">1</span>            z += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><h3 id="找到最近的有相同-x-或-y-坐标的点">1779. 找到最近的有相同 X 或 Y坐标的点</h3><p>简单模拟，这道题的坑在于这里的下标指的是点在 <code>points</code>中的位置而非点的 x 坐标。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nearestValidPoint</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        m_dis_min = <span class="hljs-number">10001</span>        res = -<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> index,point <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(points):            <span class="hljs-keyword">if</span> point[<span class="hljs-number">0</span>] == x <span class="hljs-keyword">or</span> point[<span class="hljs-number">1</span>] == y:                m_dis = <span class="hljs-built_in">abs</span>(point[<span class="hljs-number">0</span>]-x)+<span class="hljs-built_in">abs</span>(point[<span class="hljs-number">1</span>]-y)                <span class="hljs-keyword">if</span> m_dis &lt; m_dis_min:                    res = index                    m_dis_min = m_dis        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="循环">循环</h2><h3 id="数组元素积的符号">1822. 数组元素积的符号</h3><p>没有必要真的去乘，只需要关注数的正负性对结果的影响。循环遍历数组：</p><ul><li>如果是正数，乘积不变号，进入下次循环。</li><li>如果是 0 ，乘积为 0 ，跳出循环。</li><li>如果是负数，乘积变号，进入下次循环。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arraySign</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:                res *= -<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="判断能否形成等差数列">1502. 判断能否形成等差数列</h3><p>先排序，并从前两个数求得差值，在依次遍历，如果发现某连续两个数的差值不等于之前求的差值，则说明不是等差数列，否则是等差数列。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canMakeArithmeticProgression</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">sorted</span>(arr))        diff = arr[<span class="hljs-number">1</span>]-arr[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> arr[i+<span class="hljs-number">1</span>]-arr[i] != diff:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="快乐数">202. 快乐数</h3><p>这个过程让我想到《火影忍者》里的忍术伊邪那美，我们试想下如果处在一个循环的进程中，你什么时候会发现你循环了呢？那就是过去的东西再次重复的时候。所以这道题很显然就是用一个<code>set</code> 来存储过程中出现的数，如果出现的数在 <code>set</code>里了就说明不是快乐数，否则是快乐数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        num_set = &#123;n&#125;        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span>:            temp = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> n!=<span class="hljs-number">0</span>:                temp += (n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>)                n //= <span class="hljs-number">10</span>            n = temp            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> num_set:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                num_set.add(n)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="仅执行一次字符串交换能否使两个字符串相等">1790.仅执行一次字符串交换能否使两个字符串相等</h3><p>定义一个数组记录不相同的值的下标，如果两个字符串不同，当且仅当数组长度为2 且字符串 <code>s1</code> 与 <code>s2</code>不同的数交叉相等时，满足题意。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> s1 == s2:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        counter = []        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s2):            <span class="hljs-keyword">if</span> v != s1[i]:                counter.append(i)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(counter) == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> s2[counter[<span class="hljs-number">0</span>]] == s1[counter[<span class="hljs-number">1</span>]] <span class="hljs-keyword">and</span> s2[counter[<span class="hljs-number">1</span>]] == s1[counter[<span class="hljs-number">0</span>]]:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h2 id="函数">函数</h2><h3 id="n-叉树的前序遍历">589. N 叉树的前序遍历</h3><p>递归，前序遍历（又称 NLR）其实很简单，就是先遍历根节点，遍历子节点，和深度优先搜索是一样的，所以：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            res.append(node.val)            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:                dfs(child)        dfs(root)        <span class="hljs-keyword">return</span> res</code></pre></div><p>非递归，用栈的思想，从根节点开始，先添加节点值进结果，在反序添加孩子的值进栈，每次循环出栈一个节点并打印，再添加。这个是更直观的深度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        res = []        stack = [root]        <span class="hljs-keyword">while</span> stack:            temp = stack.pop()            res.append(temp.val)            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(temp.children):                stack.append(child)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="下一个更大元素-i">496. 下一个更大元素 I</h3><p>我们逆序遍历 <code>nums2</code> ，可以用一个 <code>stack</code>来记录比当前所有数都大的数，如果比当前数小就出栈直到比当前数大或者非空，那么遍历到下一个更大元素实际上就是栈顶元素。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(nums2):            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> i&gt;stack[-<span class="hljs-number">1</span>]:                stack.pop()            hashmap[i] = stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>            stack.append(i)        <span class="hljs-keyword">return</span> [hashmap[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1]</code></pre></div><h3 id="缀点成线">1232. 缀点成线</h3><p>一条直线上的点斜率相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkStraightLine</span>(<span class="hljs-params">self, coordinates: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:        dy = coordinates[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]        dx = coordinates[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> coordinates[<span class="hljs-number">2</span>:]:            <span class="hljs-keyword">if</span> (point[<span class="hljs-number">1</span>]-coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])*dx != (point[<span class="hljs-number">0</span>]-coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])*dy:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p>这样写是为了避免除数为 0 的情况。</p><h2 id="数组">数组</h2><h3 id="所有奇数长度子数组的和">1588. 所有奇数长度子数组的和</h3><p>很显然这必然是一道数学题。我们先用的解法，遍历数组模拟流程：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumOddLengthSubarrays</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        arr_len = <span class="hljs-built_in">len</span>(arr)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(arr_len):            temp = <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> i+temp &lt;= arr_len:                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> arr[i:i+temp]:                    res += v                temp += <span class="hljs-number">2</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>之后我们想一种数学关系，先列出一个矩阵：</p><table style="width:100%;"><thead><tr class="header"><th>长度</th><th>数组</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr class="odd"><td>1</td><td>[1]</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>2</td><td>[1, 2]</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>3</td><td>[1, 2, 3]</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>4</td><td>[1, 2, 3, 4]</td><td>2</td><td>3</td><td>3</td><td>2</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>5</td><td>[1, 2, 3, 4, 5]</td><td>3</td><td>4</td><td>5</td><td>4</td><td>3</td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>6</td><td>[1, 2, 3, 4, 5, 6]</td><td>3</td><td>5</td><td>6</td><td>6</td><td>5</td><td>3</td><td></td><td></td><td></td></tr><tr class="odd"><td>7</td><td>[1, 2, 3, 4, 5, 6, 7]</td><td>4</td><td>6</td><td>8</td><td>8</td><td>8</td><td>6</td><td>4</td><td></td><td></td></tr><tr class="even"><td>8</td><td>[1, 2, 3, 4, 5, 6, 7, 8]</td><td>4</td><td>6</td><td>8</td><td>9</td><td>9</td><td>8</td><td>6</td><td>4</td><td></td></tr><tr class="odd"><td>9</td><td>[1, 2, 3, 4, 5, 6, 7, 8, 9]</td><td>5</td><td>8</td><td>11</td><td>12</td><td>13</td><td>12</td><td>11</td><td>8</td><td>5</td></tr></tbody></table><p>可以发现多项式的系数呈现对称关系。</p><p>以 5 为例，呈现这样的分布经过了 1, 3, 5 这 3个奇数向量的相加，其中：</p><ul><li>1 - 1, 1, 1, 1, 1</li><li>3 - 1, 2, 3, 2, 1</li><li>5 - 1, 1, 1, 1, 1</li></ul><p>以 7 为例，呈现这样的分布经过了 1, 3, 5, 7 这 4个奇数向量的相加，其中：</p><ul><li>1 - 1, 1, 1, 1, 1, 1, 1</li><li>3 - 1, 2, 3, 3, 3, 2, 1</li><li>5 - 1, 2, 3, 3, 3, 2, 1</li><li>7 - 1, 1, 1, 1, 1, 1, 1</li></ul><p>再以 9 为例，呈现这样的分布经过了 1, 3, 5, 7, 9 这 5个奇数向量的相加，其中：</p><ul><li>1 - 1, 1, 1, 1, 1, 1, 1, 1, 1</li><li>3 - 1, 2, 3, 3, 3, 3, 3, 2, 1</li><li>5 - 1, 2, 3, 4, 5, 4, 3, 2, 1</li><li>7 - 1, 2, 3, 3, 3, 3, 3, 2, 1</li><li>9 - 1, 1, 1, 1, 1, 1, 1, 1, 1</li></ul><p>那可以看到 5 和 9 还算是相同的规律，7 好像有所不同和 3有点像，那么我们去寻找 7哪里不同，结合上文的对称关系，我们首先找每个数组的中间的数有什么不同：</p><ul><li><p>3 的中间数 2 - 左右各有 1 个数，此系数为 2 = 1*1 + 1*1。左右各有1 个奇数， 0 个偶数。</p></li><li><p>5 的中间数 3 - 左右各有 2 个数，此系数为 5 = 1*1 + 2*2。左右各有1 个奇数， 1 个偶数。</p></li><li><p>7 的中间数 4 - 左右各有 3 个数，此系数为 8 = 2*2 + 2*2。左右各有2 个奇数， 1 个偶数。</p></li><li><p>9 的中间数 5 - 左右各有 4 个数，此系数为 13 = 2*2 + 3*3。左右各有2 个奇数， 2 个偶数。</p></li></ul><p>可以看到其实每个中间数的系数其实=左右奇数数量的平方+左右偶数数量加 1的平方。</p><p>然后再观察 9 的其他项发现这个公式容易推广成每个数的系数 =左边奇数个数*右边奇数个数 + (左边偶数个数+1)*(右边偶数个数+1)。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumOddLengthSubarrays</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        arr_len = <span class="hljs-built_in">len</span>(arr)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(arr_len):            left_count, right_count = i, arr_len-i-<span class="hljs-number">1</span>            left_odds = (left_count+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>            right_odds = (right_count+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>            left_evens = left_count//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>            right_evens = right_count//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>            res += arr[i]*(left_odds*right_odds+left_evens*right_evens)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="移动零">283. 移动零</h3><p>这道快慢指针问题在算法专题里刷过，其核心就是慢指针记录，快指针遍历。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        slow = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> fast, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> value:                nums[slow] = value                slow += <span class="hljs-number">1</span>        nums[slow::] = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(slow, <span class="hljs-built_in">len</span>(nums))]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="最富有客户的资产总量">1672. 最富有客户的资产总量</h3><p>这道题就是遍历每位客户，直接求每位客户资产和求最大值就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumWealth</span>(<span class="hljs-params">self, accounts: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">sum</span>, accounts))</code></pre></div><h3 id="矩阵对角线元素的和">1572. 矩阵对角线元素的和</h3><p>这道题注意一下矩阵行列数为奇数和偶数时的不同情况就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diagonalSum</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        n = <span class="hljs-built_in">len</span>(mat)        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> n&amp;<span class="hljs-number">1</span>:            res = -mat[n//<span class="hljs-number">2</span>][n//<span class="hljs-number">2</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            res += mat[i][i]+mat[i][-i-<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="重塑矩阵">566. 重塑矩阵</h3><p>在数据结构的专项计划里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        m = <span class="hljs-built_in">len</span>(mat)        <span class="hljs-keyword">if</span> m*n != r*c:            <span class="hljs-keyword">return</span> mat        res = [[<span class="hljs-number">0</span>]*c <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r)]        <span class="hljs-keyword">for</span> loc <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m*n):                res[loc//c][loc%c] = mat[loc//n][loc%n]        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="字符串">字符串</h2><h3 id="交替合并字符串">1768. 交替合并字符串</h3><p>简单模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeAlternately</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        word1_len = <span class="hljs-built_in">len</span>(word1)        word2_len = <span class="hljs-built_in">len</span>(word2)        min_len = <span class="hljs-built_in">min</span>(word1_len, word2_len)        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_len):            res.append(word1[i])            res.append(word2[i])        <span class="hljs-keyword">if</span> min_len == word1_len:            res.append(word2[min_len:word2_len])        <span class="hljs-keyword">else</span>:            res.append(word1[min_len:word1_len])        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)</code></pre></div><h3 id="设计-goal-解析器">1678. 设计 Goal 解析器</h3><p>简单替换。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">interpret</span>(<span class="hljs-params">self, command: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        command = command.replace(<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>)        command = command.replace(<span class="hljs-string">&#x27;()&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>)        command = command.replace(<span class="hljs-string">&#x27;(al)&#x27;</span>,<span class="hljs-string">&#x27;al&#x27;</span>)        <span class="hljs-keyword">return</span> command</code></pre></div><h3 id="找不同">389. 找不同</h3><p>对两个字符串计数找不同。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheDifference</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s_dict = collections.Counter(s)        t_dict = collections.Counter(t)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(t_dict-s_dict)[<span class="hljs-number">0</span>]</code></pre></div><p>巧用 ASCII 码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheDifference</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-built_in">ord</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> t)-<span class="hljs-built_in">sum</span>(<span class="hljs-built_in">ord</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> s))</code></pre></div><h3 id="转换成小写字母">709. 转换成小写字母</h3><p>Python 里面的最直接用法当然是调用 <code>lower()</code> 函数了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toLowerCase</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> s.lower()</code></pre></div><p>不过做题的话我觉得可以用 ASCII 码的方式，用 <code>list</code> 和<code>str.join()</code> 来代替 <code>Java</code> 里类似<code>StringBuffer, StringBuilder</code> 这样的东西，如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toLowerCase</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            c_ascii = <span class="hljs-built_in">ord</span>(i)            <span class="hljs-keyword">if</span> <span class="hljs-number">65</span>&lt;=c_ascii&lt;=<span class="hljs-number">90</span>:                res.append(<span class="hljs-built_in">chr</span>(c_ascii+<span class="hljs-number">32</span>))            <span class="hljs-keyword">else</span>:                res.append(i)        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)</code></pre></div><p>当然字符串相加也行：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toLowerCase</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            c_ascii = <span class="hljs-built_in">ord</span>(i)            <span class="hljs-keyword">if</span> <span class="hljs-number">65</span>&lt;=c_ascii&lt;=<span class="hljs-number">90</span>:                res += <span class="hljs-built_in">chr</span>(c_ascii+<span class="hljs-number">32</span>)            <span class="hljs-keyword">else</span>:                res += i        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="解码字母到整数映射">1309. 解码字母到整数映射</h3><p>依然是 ASCII码完整数字和字母的转换，需要一个前探指针探一下后两位是不是<code>#</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">freqAlphabets</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&#x27;&#x27;</span>        s_len = <span class="hljs-built_in">len</span>(s)        i = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i&lt;s_len:            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> s[i] == <span class="hljs-string">&#x27;2&#x27;</span>) <span class="hljs-keyword">and</span> i+<span class="hljs-number">2</span>&lt;s_len <span class="hljs-keyword">and</span> s[i+<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;#&#x27;</span>:                res += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(s[i:i+<span class="hljs-number">2</span>])+<span class="hljs-number">96</span>)                i += <span class="hljs-number">3</span>            <span class="hljs-keyword">else</span>:                res += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(s[i])+<span class="hljs-number">48</span>)                i += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="验证外星语词典">953. 验证外星语词典</h3><p>模拟逻辑。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAlienSorted</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], order: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(order):            hashmap[v] = i        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(words)-<span class="hljs-number">1</span>):            s1 = words[i]            s2 = words[i+<span class="hljs-number">1</span>]            flag = <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) &gt; <span class="hljs-built_in">len</span>(s2):                flag = <span class="hljs-literal">True</span>                min_len = <span class="hljs-built_in">len</span>(s2)            <span class="hljs-keyword">else</span>:                min_len = <span class="hljs-built_in">len</span>(s1)            j = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> j&lt;min_len:                <span class="hljs-keyword">if</span> hashmap[s2[j]] &gt; hashmap[s1[j]]:                    flag = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">elif</span> hashmap[s2[j]] &lt; hashmap[s1[j]]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                j += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> flag:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h2 id="链表-树">链表 &amp; 树</h2><h3 id="二进制链表转整数">1290. 二进制链表转整数</h3><p>最直观的用 <code>list</code>存储链表每个节点的值，最后再调用进制转换的方法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDecimalValue</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; <span class="hljs-built_in">int</span>:        res = []        <span class="hljs-keyword">while</span> head:            res.append(<span class="hljs-built_in">str</span>(head.val))            head = head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(res), <span class="hljs-number">2</span>)</code></pre></div><p>好像用字符串快一些。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDecimalValue</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; <span class="hljs-built_in">int</span>:        res = []        <span class="hljs-keyword">while</span> head:            res.append(<span class="hljs-built_in">str</span>(head.val))            head = head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(res), <span class="hljs-number">2</span>)</code></pre></div><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDecimalValue</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_dec</span>(<span class="hljs-params">node:ListNode</span>)-&gt;<span class="hljs-built_in">tuple</span>:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.<span class="hljs-built_in">next</span>:                <span class="hljs-keyword">return</span> node.val, <span class="hljs-number">0</span>            res, count = get_dec(node.<span class="hljs-built_in">next</span>)            count += <span class="hljs-number">1</span>            res += node.val&lt;&lt;count            <span class="hljs-keyword">return</span> res, count        <span class="hljs-keyword">return</span> get_dec(head)[<span class="hljs-number">0</span>]</code></pre></div><p>还有就是从前到后找时，每次先把前面的和乘 2，相当于一个 n位的二进制数，最左已经乘了 n-1 次。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDecimalValue</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> head:            res = (res&lt;&lt;<span class="hljs-number">1</span>) + head.val            head = head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="链表的中间结点">876. 链表的中间结点</h3><p>在算法的学习计划里做过，就是快慢指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        slow = head        fast = head        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:            slow = slow.<span class="hljs-built_in">next</span>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> slow</code></pre></div><h3 id="二叉树的最大深度">104. 二叉树的最大深度</h3><p>广度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        queue = collections.deque()        queue.append(root)        depth = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> queue:            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.popleft()                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)            depth += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> depth</code></pre></div><p>深度优先搜索，递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><h3 id="左叶子之和">404. 左叶子之和</h3><p>广度优先搜索加一个标志位。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumOfLeftLeaves</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        queue = collections.deque()        queue.append((root, <span class="hljs-number">0</span>))        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> queue:            node, is_left = queue.popleft()            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, <span class="hljs-number">1</span>))            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, <span class="hljs-number">0</span>))            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">and</span> is_left: res += node.val        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="容器-库">容器 &amp; 库</h2><h3 id="根据数字二进制下-1-的数目排序">1356. 根据数字二进制下 1的数目排序</h3><p>我们需要一个 <code>dict</code> ，以 1 的数量为 <code>key</code>，<code>value</code> 则是一个 <code>list</code> 用来记录同 1的数量的数字。</p><p>首先我们遍历数组可以将这个 <code>dict</code> 填充好数据。</p><p>然后对 <code>dict</code> 的 <code>value</code> 里每个<code>list</code> 排序，处理相同 1 数量的顺序。</p><p>然后根据 <code>dict</code> 的 <code>key</code> 的顺序将<code>list</code> 放入结果中。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortByBits</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">one_count</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">int</span>:            res = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> num:                res += <span class="hljs-number">1</span>                num &amp;= num-<span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> res                hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:            count = one_count(i)            <span class="hljs-keyword">if</span> count <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[count] = [i]            <span class="hljs-keyword">else</span>:                hashmap[count].append(i)        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> hashmap.keys():            unsort_value = hashmap[k]            hashmap[k] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">sorted</span>(unsort_value))        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(hashmap, key=<span class="hljs-keyword">lambda</span> x:x):            res += hashmap[i]        <span class="hljs-keyword">return</span> res</code></pre></div><p>也可以调用 Python 的 <code>sorted</code> 函数修改排序规则。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortByBits</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:             <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(arr, key=<span class="hljs-keyword">lambda</span> x: (<span class="hljs-built_in">bin</span>(x).count(<span class="hljs-string">&#x27;1&#x27;</span>), x))</code></pre></div><h3 id="用栈实现队列">232. 用栈实现队列</h3><p>在数据结构学习计划里做过了，这里不再赘述。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.stack_in = []        self.stack_out = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">while</span> self.stack_out:            self.stack_in.append(self.stack_out.pop())        self.stack_in.append(x)        <span class="hljs-keyword">while</span> self.stack_in:            self.stack_out.append(self.stack_in.pop())    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack_out.pop()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack_out[-<span class="hljs-number">1</span>]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack_out) == <span class="hljs-number">0</span></code></pre></div><h3 id="有效的字母异位词">242. 有效的字母异位词</h3><p>也在数据结构学习计划里做过，这里展示一下用<code>collections.Counter</code>的方法，这种计数的问题其实都可以用这个方式，效果挺好。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> collections.Counter(s)==collections.Counter(t)</code></pre></div><h3 id="存在重复元素">217. 存在重复元素</h3><p>这个也在数据结构学习计划里做过，考察是否知道 <code>set</code>这个概念。</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h2 id="类-对象">类 &amp; 对象</h2><h3 id="设计停车系统">1603. 设计停车系统</h3><p>这个应该是考察面向对象的简单设计。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkingSystem</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, big: <span class="hljs-built_in">int</span>, medium: <span class="hljs-built_in">int</span>, small: <span class="hljs-built_in">int</span></span>):        self.big = big        self.medium = medium        self.small = small    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addCar</span>(<span class="hljs-params">self, carType: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        match carType:            case <span class="hljs-number">1</span>:                <span class="hljs-keyword">if</span> self.big&gt;<span class="hljs-number">0</span>:                    self.big -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            case <span class="hljs-number">2</span>:                <span class="hljs-keyword">if</span> self.medium&gt;<span class="hljs-number">0</span>:                    self.medium -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            case <span class="hljs-number">3</span>:                <span class="hljs-keyword">if</span> self.small&gt;<span class="hljs-number">0</span>:                    self.small -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            case _:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>尽量写优雅一点吧。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkingSystem</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, big: <span class="hljs-built_in">int</span>, medium: <span class="hljs-built_in">int</span>, small: <span class="hljs-built_in">int</span></span>):        self.park = [big, medium, small]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addCar</span>(<span class="hljs-params">self, carType: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> carType&gt;<span class="hljs-built_in">len</span>(self.park) <span class="hljs-keyword">or</span> carType&lt;<span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> self.park[carType-<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>:            self.park[carType-<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="区域和检索---数组不可变">303. 区域和检索 - 数组不可变</h3><p>正常来讲应该是这样的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):        self.nums = nums    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumRange</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.nums[left:right+<span class="hljs-number">1</span>])</code></pre></div><p>但是很慢，为什么呢？作为一个类来讲，查询的次数是很多的。如果每次查询都得重新累加，就会非常慢。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):        self.nums = [<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            self.nums.append(self.nums[-<span class="hljs-number">1</span>]+i)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumRange</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.nums[right+<span class="hljs-number">1</span>] - self.nums[left]</code></pre></div><p>这里体现出了前缀和的思想，在初始化遍历的时候就把前缀和写好，查询会非常快。</p><h1 id="编程能力基础">编程能力基础</h1><h3 id="单调数列">896. 单调数列</h3><p>我们用 <code>flag</code>来记录数列的单调性，但未知晓数列的单调性时不将它初始化，知晓之后再初始化。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMonotonic</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        flag = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> flag:                <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i]&gt;nums[i+<span class="hljs-number">1</span>]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> flag == -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i]&lt;nums[i+<span class="hljs-number">1</span>]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> nums[i]&gt;nums[i+<span class="hljs-number">1</span>]:                    flag = -<span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> nums[i]&lt;nums[i+<span class="hljs-number">1</span>]:                    flag = <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="找出字符串中第一个匹配项的下标">28.找出字符串中第一个匹配项的下标</h3><p>切片去匹配。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        m = <span class="hljs-built_in">len</span>(haystack)        n = <span class="hljs-built_in">len</span>(needle)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-n+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> haystack[i:i+n] == needle:                <span class="hljs-keyword">return</span> i        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><p>或者用双指针去比较。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        m = <span class="hljs-built_in">len</span>(haystack)        n = <span class="hljs-built_in">len</span>(needle)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-n+<span class="hljs-number">1</span>):            t = <span class="hljs-number">0</span>            flag = <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> haystack[i] == needle[t]:                flag = <span class="hljs-literal">True</span>                k = i                <span class="hljs-keyword">while</span> t&lt;n:                    <span class="hljs-keyword">if</span> haystack[k] != needle[t]:                        flag = <span class="hljs-literal">False</span>                    t += <span class="hljs-number">1</span>                    k += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> flag:                <span class="hljs-keyword">return</span> i        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h3 id="平衡二叉树">110. 平衡二叉树</h3><p>第一种是自顶向下判断是否左右子树平衡，相当于我们从根节点开始，先查找左右子数的最大高度，差值&lt;= 1则说明根节点是平衡的，再去找左子节点是否平衡，右子节点是否平衡，依次遍历完。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isBalanced</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_height</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            left = get_height(node.left)            right = get_height(node.right)            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">max</span>(left, right)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        left = get_height(root.left)        right = get_height(root.right)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(left-right) &gt; <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> self.isBalanced(root.left) <span class="hljs-keyword">and</span> self.isBalanced(root.right)</code></pre></div><p>当然自顶向下的遍历会有很多重复的计算，实际上在求最大高度的时候可以携带一个信息，来表明是否是AVL 树，比如如果已经不是 AVL 树就直接返回 -1，而不再返回当前节点的最大高度。这就叫自底向上的遍历。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isBalanced</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_height</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            left = get_height(node.left)            <span class="hljs-keyword">if</span> left == -<span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>            right = get_height(node.right)            <span class="hljs-keyword">if</span> right == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">abs</span>(left-right)&gt;<span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">max</span>(left, right)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> get_height(root)&gt;=<span class="hljs-number">0</span></code></pre></div><h3 id="重复的子字符串">459. 重复的子字符串</h3><p>遍历扫描字符串，实际上只需要扫描一半即可，因为如果扫描一半还没有发现有重复的子字符串其实就没有了。</p><p>如果左 <code>i</code> 个字符与右 <code>i</code>个字符相等，并且字符串等于左 <code>i</code>个字符的重复时，说明可以通过重复子字符串构成。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatedSubstringPattern</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        s_len = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len//<span class="hljs-number">2</span>):            <span class="hljs-keyword">if</span> s_len%(i+<span class="hljs-number">1</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[:i+<span class="hljs-number">1</span>] == s[s_len-i-<span class="hljs-number">1</span>:] <span class="hljs-keyword">and</span> s[:i+<span class="hljs-number">1</span>]*(s_len//(i+<span class="hljs-number">1</span>)) == s:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>如果字符串能有重复子字符串构成，比如像 <code>ababab</code>这种，移除左边的 <code>a</code> 和右边的 <code>b</code>其实也还有构成的元素 <code>ab</code> 。将字符串乘 2 ，即<code>abababababab</code> 移除左边的 <code>a</code> 和右边的<code>b</code> ，可以发现 <code>ababab</code> 仍然在<code>bababababa</code> 里面。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatedSubstringPattern</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> s <span class="hljs-keyword">in</span> (s+s)[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>]</code></pre></div><h3 id="逆波兰表达式求值">150. 逆波兰表达式求值</h3><p>后缀表达式求值，我记得是当时学数据结构时栈的测试题，当时涉及中缀表达式转后缀再求值，除了数字栈还需要有符号栈，这里一个数字栈就够了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evalRPN</span>(<span class="hljs-params">self, tokens: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        num_stack = []        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tokens:            match t:                case <span class="hljs-string">&#x27;+&#x27;</span>:                    a = num_stack.pop()                    b = num_stack.pop()                    num_stack.append(b+a)                case <span class="hljs-string">&#x27;-&#x27;</span>:                    a = num_stack.pop()                    b = num_stack.pop()                    num_stack.append(b-a)                case <span class="hljs-string">&#x27;*&#x27;</span>:                    a = num_stack.pop()                    b = num_stack.pop()                    num_stack.append(b*a)                case <span class="hljs-string">&#x27;/&#x27;</span>:                    a = num_stack.pop()                    b = num_stack.pop()                    num_stack.append(<span class="hljs-built_in">int</span>(b/a))                case _:                    num_stack.append(<span class="hljs-built_in">int</span>(t))        <span class="hljs-keyword">return</span> num_stack.pop()</code></pre></div><h3 id="加一">66. 加一</h3><p>可以考虑先求加一再生成结果数组。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plusOne</span>(<span class="hljs-params">self, digits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> digits:            res = res*<span class="hljs-number">10</span>+i        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(res+<span class="hljs-number">1</span>)]</code></pre></div><p>但是其实在加的过程中就可以得到答案，那就是 digits 不进位的时候。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plusOne</span>(<span class="hljs-params">self, digits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(digits)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            digits[i] += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> digits[i] &gt;= <span class="hljs-number">10</span>:                digits[i] -= <span class="hljs-number">10</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> digits        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>] + digits</code></pre></div><h3 id="二叉树中的链表">1367. 二叉树中的链表</h3><p>遍历树的时候存储下每个节点的路径，如果一个节点路径后 <code>n</code>位与长度为 <code>n</code>的链表相同，那么就满足题意，否则遍历完树之后就不存在。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubPath</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        stack = []        stack.append((root, [root.val]))        linked_lst = []        linked_len = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> head:            linked_lst.append(head.val)            linked_len += <span class="hljs-number">1</span>            head = head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> stack:            node, path = stack.pop()            <span class="hljs-keyword">if</span> path[-linked_len:] == linked_lst:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">if</span> node.left: stack.append((node.left, path+[node.left.val]))            <span class="hljs-keyword">if</span> node.right: stack.append((node.right, path+[node.right.val]))        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="字符串相乘">43. 字符串相乘</h3><p>如果转成整数形式的话：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(num1)*<span class="hljs-built_in">int</span>(num2))</code></pre></div><p>或者模拟多位数乘法运算。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-number">0</span>        flag1 = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num1[::-<span class="hljs-number">1</span>]:            adv = <span class="hljs-number">0</span>            temp = <span class="hljs-number">0</span>            flag2 = <span class="hljs-number">1</span>            i = <span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">48</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> num2[::-<span class="hljs-number">1</span>]:                j = <span class="hljs-built_in">ord</span>(j)-<span class="hljs-number">48</span>                mul = (i*j+adv)                adv = mul//<span class="hljs-number">10</span>                temp += (mul%<span class="hljs-number">10</span>)*flag2                flag2 *= <span class="hljs-number">10</span>            res += (temp+adv*flag2) * flag1            flag1 *= <span class="hljs-number">10</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(res)</code></pre></div><h3 id="二进制求和">67. 二进制求和</h3><p>转成数求和。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(a,<span class="hljs-number">2</span>)+<span class="hljs-built_in">int</span>(b,<span class="hljs-number">2</span>))[<span class="hljs-number">2</span>:]</code></pre></div><p>模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        carry = <span class="hljs-literal">False</span>        res = <span class="hljs-string">&#x27;&#x27;</span>        len_a = <span class="hljs-built_in">len</span>(a)        len_b = <span class="hljs-built_in">len</span>(b)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-<span class="hljs-number">1</span>, -<span class="hljs-built_in">max</span>(len_a,len_b)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i&lt;-len_a:                temp = <span class="hljs-built_in">int</span>(b[i])            <span class="hljs-keyword">elif</span> i&lt;-len_b:                temp = <span class="hljs-built_in">int</span>(a[i])            <span class="hljs-keyword">else</span>:                temp = <span class="hljs-built_in">int</span>(a[i])+<span class="hljs-built_in">int</span>(b[i])            <span class="hljs-keyword">if</span> carry:                temp += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> temp &gt;= <span class="hljs-number">2</span>:                carry = <span class="hljs-literal">True</span>                temp -= <span class="hljs-number">2</span>            <span class="hljs-keyword">else</span>:                carry = <span class="hljs-literal">False</span>            res = <span class="hljs-built_in">str</span>(temp) + res        <span class="hljs-keyword">if</span> carry:            res = <span class="hljs-string">&#x27;1&#x27;</span> + res        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="数组形式的整数加法">989. 数组形式的整数加法</h3><p>这道题考察的是对各种情况的处理，算是一道简单的模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addToArrayForm</span>(<span class="hljs-params">self, num: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(num)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            num[i] += (k%<span class="hljs-number">10</span>)+carry            <span class="hljs-keyword">if</span> num[i] &gt;= <span class="hljs-number">10</span>:                num[i] -= <span class="hljs-number">10</span>                carry = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                carry = <span class="hljs-number">0</span>            k //= <span class="hljs-number">10</span>        k += carry        res = []        <span class="hljs-keyword">while</span> k:            res.append(k%<span class="hljs-number">10</span>)            k //= <span class="hljs-number">10</span>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]+num</code></pre></div><h3 id="每日温度">739. 每日温度</h3><p>首先上暴力，但是超时了。然后我想可能是个前缀和的问题（准确地说应该叫后缀差），然而依然没有头绪，因此从<ahref="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">代码随想录</a>前辈这里学习了一下这种应该用地数据结构叫单调栈。简单来说就是我们需要维护一个单调递增栈（或者叫最小栈，从栈头到栈尾单调递增），这个栈其实记的是下标，每次遍历到一个元素有三种情况，对应操作如下：</p><ul><li>如果遍历到的元素小于栈顶元素 - 当前元素入栈。</li><li>如果遍历到的元素等于栈顶元素 - 当前元素入栈。</li><li>如果遍历到的元素大于栈顶元素<ul><li>这种情况下如果当前元素入栈会破坏栈的单调性。</li><li>首先我们需要将比当前元素小的元素都出栈，在出栈时就可以说明当前元素是出栈那个元素的下一个更大值，因此可以对结果数组赋值。</li><li>当前元素进栈。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temperatures: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        temperatures_len = <span class="hljs-built_in">len</span>(temperatures)        stack = [<span class="hljs-number">0</span>]        res = [<span class="hljs-number">0</span>] * temperatures_len        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, temperatures_len):            <span class="hljs-keyword">if</span> temperatures[i] &lt;= temperatures[stack[-<span class="hljs-number">1</span>]]:                stack.append(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack)!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> temperatures[i]&gt;temperatures[stack[-<span class="hljs-number">1</span>]]:                    res[stack[-<span class="hljs-number">1</span>]] = i - stack[-<span class="hljs-number">1</span>]                    stack.pop()                stack.append(i)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="最后一个单词的长度">58. 最后一个单词的长度</h3><p>简单的模拟计数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLastWord</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        count_start = <span class="hljs-literal">False</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s[::-<span class="hljs-number">1</span>]:            <span class="hljs-keyword">if</span> i != <span class="hljs-string">&#x27; &#x27;</span>:                count_start = <span class="hljs-literal">True</span>                res += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> count_start:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="旋转图像">48. 旋转图像</h3><p>两次轴对称。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:        n = <span class="hljs-built_in">len</span>(matrix)        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, c):                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            matrix[r][:] = matrix[r][::-<span class="hljs-number">1</span>]</code></pre></div><h3 id="判断矩阵经轮转后是否一致">1886. 判断矩阵经轮转后是否一致</h3><p>应该算是上道题的进阶版吧。判断矩阵本身和旋转 3次有没有和目标矩阵一样就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRotation</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">matrix</span>):            n = <span class="hljs-built_in">len</span>(matrix)            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):                <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, c):                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                matrix[r][:] = matrix[r][::-<span class="hljs-number">1</span>]            <span class="hljs-keyword">return</span> matrix        <span class="hljs-keyword">if</span> mat == target:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):            mat = rotate(mat)            <span class="hljs-keyword">if</span> mat == target:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="螺旋矩阵">54. 螺旋矩阵</h3><p>这是一道模拟题，考察对边界的控制。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spiralOrder</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        printed = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        r,c = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        res = []        direction = <span class="hljs-string">&#x27;r&#x27;</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            res.append(matrix[r][c])            printed[r][c] = <span class="hljs-number">1</span>            match direction:                case <span class="hljs-string">&#x27;r&#x27;</span>:                    <span class="hljs-keyword">if</span> c+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r][c+<span class="hljs-number">1</span>]:                        c += <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> r+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r+<span class="hljs-number">1</span>][c]:                        direction = <span class="hljs-string">&#x27;b&#x27;</span>                        r += <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">break</span>                case <span class="hljs-string">&#x27;b&#x27;</span>:                    <span class="hljs-keyword">if</span> r+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r+<span class="hljs-number">1</span>][c]:                        r += <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> c&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r][c-<span class="hljs-number">1</span>]:                        direction = <span class="hljs-string">&#x27;l&#x27;</span>                        c -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">break</span>                case <span class="hljs-string">&#x27;l&#x27;</span>:                    <span class="hljs-keyword">if</span> c&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r][c-<span class="hljs-number">1</span>]:                        c -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> r&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r-<span class="hljs-number">1</span>][c]:                        direction = <span class="hljs-string">&#x27;t&#x27;</span>                        r -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">break</span>                case <span class="hljs-string">&#x27;t&#x27;</span>:                    <span class="hljs-keyword">if</span> r&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r-<span class="hljs-number">1</span>][c]:                        r -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> c+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> printed[r][c+<span class="hljs-number">1</span>]:                        direction = <span class="hljs-string">&#x27;r&#x27;</span>                        c += <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="最接近原点的-k-个点">973. 最接近原点的 K 个点</h3><p>用 <code>dict</code> 来统计某距离所有的点，然后对 <code>dict</code>进行排序，从前往后往结果里更新点，最终当更新到 k 个点时返回答案。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kClosest</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        hashmap = &#123;&#125;        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> points:            distance = i[<span class="hljs-number">0</span>]*i[<span class="hljs-number">0</span>]+i[<span class="hljs-number">1</span>]*i[<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> distance <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[distance] = [[i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]]]            <span class="hljs-keyword">else</span>:                hashmap[distance] += [[i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]]]        sorted_dis = <span class="hljs-built_in">sorted</span>(hashmap)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sorted_dis:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &lt; k:                res += hashmap[i]        <span class="hljs-keyword">return</span> res</code></pre></div><p>不过既然都用自带的排序了也可以直接根据距离排序后取前 k 个点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kClosest</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]+x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>])[:k]</code></pre></div><h3 id="等差子数组">1630. 等差子数组</h3><p>暴力，对每一组取出来依次判断，判断的方法就是找到数列第一个差值，然后依次遍历看是否都等差。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkArithmeticSubarrays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], l: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], r: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">bool</span>]:        res = []        <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(l,r):            temp = nums[i:j+<span class="hljs-number">1</span>]            temp = <span class="hljs-built_in">sorted</span>(temp)            diff = temp[<span class="hljs-number">1</span>]-temp[<span class="hljs-number">0</span>]            flag = <span class="hljs-literal">True</span>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j-i):                <span class="hljs-keyword">if</span> temp[k+<span class="hljs-number">1</span>]-temp[k] != diff:                    flag = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>            res.append(flag)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="n-叉树的层序遍历">429. N 叉树的层序遍历</h3><p>经典树的广度优先搜索，跟二叉树层次遍历区别不大。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        queue = collections.deque()        queue.append(root)        res = []        <span class="hljs-keyword">while</span> queue:            temp = []            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.popleft()                temp.append(node.val)                <span class="hljs-keyword">if</span> node.children:                    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:                        queue.append(child)            res.append(temp)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="下一个更大元素-ii">503. 下一个更大元素 II</h3><p>单调栈。解决循环数组的方式可以是将数组看成 2倍长，然后从尾端开始遍历，只要遍历完成每一个数都应该找过下一个更大元素了。我们假设理论索引是<code>i</code> ，实际索引是 <code>j=i%len(nums)</code>代表实际应该判断的位置，然后用一个单调递增（栈顶 &lt;栈底）的单调栈。单调栈的思路见 <ahref="###496.%20下一个更大元素%20I">496. 下一个更大元素 I</a> 与 <ahref="###739.%20每日温度">739. 每日温度</a> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElements</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        nums_len = <span class="hljs-built_in">len</span>(nums)        res = [-<span class="hljs-number">1</span>] * nums_len        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>*nums_len-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            j = i%nums_len            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> nums[j]&gt;=stack[-<span class="hljs-number">1</span>]:                stack.pop()            res[j] = stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>            stack.append(nums[j])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="下一个更大元素-iii">556. 下一个更大元素 III</h3><p>首先 <code>n</code> 如果小于 12，肯定是不存在满足题意的数的，直接返回 -1 。</p><p>然后将 <code>n</code> 转换为一个 <code>List[str]</code>的列表，从后往前遍历，如果找到了某一位比它后一位的值小，记录这个索引，退出遍历，我们设这个索引为<code>flag</code> 。当然，也可能存在找不到索引的情况，也返回 -1 。</p><p>此时下一个更大的值实际上是把 <code>flag</code> 位上的数和<strong>在<code>flag</code> 后面并且比他大的最小值交换</strong>，再对<code>str[flag+1:]</code> 从小到大排序。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">12</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        digits = [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n)]        flag = -<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(digits)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> digits[i] &gt; digits[i-<span class="hljs-number">1</span>]:                flag = i-<span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">if</span> flag == -<span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        temp = digits[flag:]        target = <span class="hljs-literal">None</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(temp)):            <span class="hljs-keyword">if</span> temp[i] &gt; temp[<span class="hljs-number">0</span>]:                target = i        temp[<span class="hljs-number">0</span>], temp[target] = temp[target], temp[<span class="hljs-number">0</span>]        temp = temp[:<span class="hljs-number">1</span>] + <span class="hljs-built_in">sorted</span>(temp[<span class="hljs-number">1</span>:])        res = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(digits[:flag]+temp))        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> res&gt;=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span> <span class="hljs-keyword">else</span> res</code></pre></div><h3 id="通知所有员工所需的时间">1376. 通知所有员工所需的时间</h3><p>这道题算是一个加了权的 N 叉树，或者说是一个加了权的有向无环图。</p><p>首先我们不考虑树的思想，直接使用暴力解法，就是对每一个人进行遍历，去推总裁找到他们所需时间。这个时间的最大值显然就是通知所有员工所需的时间。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        direct_info = [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> informTime]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            j = i            temp = informTime[j]            <span class="hljs-keyword">while</span> manager[j] != -<span class="hljs-number">1</span>:                j = manager[j]                temp += informTime[j]            direct_info[i] = temp        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(direct_info)</code></pre></div><p>这个代码是很慢的，因为会去计算很多重复的通知时间，即回溯过程中上层树结构都一样了，这就是自底向上的计算思路。当然也可以优化，因为实际上去统计的是底层员工的时间，因此我们只需要计算每个底层员工就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        direct_info = [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> informTime]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">if</span> informTime[i] != <span class="hljs-number">0</span>:                <span class="hljs-keyword">continue</span>            j = i            temp = informTime[j]            <span class="hljs-keyword">while</span> manager[j] != -<span class="hljs-number">1</span>:                j = manager[j]                temp += informTime[j]            direct_info[i] = temp        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(direct_info)</code></pre></div><p>当然其实还能再优化，我们可以用空间换时间，开一个数组专门记录当前员工是否被搜过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:              direct_info = [<span class="hljs-number">0</span>]*n        <span class="hljs-keyword">def</span> <span class="hljs-title function_">stats_time</span>(<span class="hljs-params">i</span>):            <span class="hljs-keyword">if</span> manager[i] != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> direct_info[i] == <span class="hljs-number">0</span>:                direct_info[i] = informTime[manager[i]] + stats_time(manager[i])            <span class="hljs-keyword">return</span> direct_info[i]                res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">if</span> informTime[i] == <span class="hljs-number">0</span>:               res = <span class="hljs-built_in">max</span>(res, stats_time(i))         <span class="hljs-keyword">return</span> res</code></pre></div><p>为了避免重复计算，我们在这里还可以采用自顶向下的思路，就是树的搜索，搜过了就不再搜了。这里可以考虑用一个<code>dict</code> 来辅助记录上级与下级的关系。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> staff, boss <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(manager):            <span class="hljs-keyword">if</span> boss <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[boss] = [staff]            <span class="hljs-keyword">else</span>:                hashmap[boss] += [staff]        stack = [(headID, informTime[headID])]        max_time = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> stack:            p,t = stack.pop()            max_time = <span class="hljs-built_in">max</span>(max_time, t)            <span class="hljs-keyword">if</span> p <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">for</span> staff <span class="hljs-keyword">in</span> hashmap[p]:                    stack.append((staff, t+informTime[staff]))        <span class="hljs-keyword">return</span> max_time</code></pre></div><h3 id="字母异位词分组">49. 字母异位词分组</h3><p>这道题之前在数据结构里计划里做过，核心在于创造一个合适的<code>hashmap</code> 的 <code>key</code> 。</p><p>第一种是数组记录（因为只有 26 个小写英文字母）转元组作为<code>key</code> 的方式。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> strs:            temp = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:                temp[<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>            temp = <span class="hljs-built_in">tuple</span>(temp)            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[temp] = [t]            <span class="hljs-keyword">else</span>:                hashmap[temp] += [t]        <span class="hljs-keyword">return</span> [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> hashmap.values()]</code></pre></div><p>第二种是排序的方式。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:            temp = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>([_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> i]))            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[temp] = [i]            <span class="hljs-keyword">else</span>:                hashmap[temp] += [i]        <span class="hljs-keyword">return</span> [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> hashmap.values()]</code></pre></div><h3 id="找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h3><p>其实这道题就是哈希计数的题，首先最直接的比较计数结果是否一样。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        p_count = collections.Counter(p)        p_len = <span class="hljs-built_in">len</span>(p)        s_len = <span class="hljs-built_in">len</span>(s)        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-p_len+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> collections.Counter(s[i:i+p_len]) == p_count:                res.append(i)        <span class="hljs-keyword">return</span> res</code></pre></div><p>这样能过，但是很慢，这里有一个显著的问题，那就是如果 <code>s</code>的子串和 <code>p</code>不是字母异位词，不需要统计完这个子串，因此我们需要在这里剪枝。</p><p>但是很遗憾，速度慢似乎并不是因为剪枝引起的。因为剪枝过后居然超出时间限制了，这里可以说明<code>collections.Counter</code> 比我想象中要快很多。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        p_count = <span class="hljs-built_in">dict</span>(collections.Counter(p))        p_len = <span class="hljs-built_in">len</span>(p)        s_len = <span class="hljs-built_in">len</span>(s)        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-p_len+<span class="hljs-number">1</span>):            temp = deepcopy(p_count)            flag = <span class="hljs-literal">True</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> s[i:i+p_len]:                <span class="hljs-keyword">if</span> j <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> temp <span class="hljs-keyword">or</span> temp[j] == <span class="hljs-number">0</span>:                    flag = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>                temp[j] -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> flag:                res.append(i)        <span class="hljs-keyword">return</span> res</code></pre></div><p>然后我考虑了滑动窗口，也是一种优化。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        p_count = collections.Counter(p)        s_len = <span class="hljs-built_in">len</span>(s)        l, r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(p)        count = collections.Counter(s[:r])        res = []        <span class="hljs-keyword">while</span> r&lt;=s_len:            <span class="hljs-keyword">if</span> count == p_count:                res.append(l)            count.subtract(&#123;s[l]:<span class="hljs-number">1</span>&#125;)            <span class="hljs-keyword">if</span> r&lt;s_len:                count.subtract(&#123;s[r]:-<span class="hljs-number">1</span>&#125;)            l += <span class="hljs-number">1</span>            r += <span class="hljs-number">1</span>            count = +count        <span class="hljs-keyword">return</span> res</code></pre></div><p>看起来不在 hash 上面做文章，这个效率是高不了了。</p><p>这里建议采用 <a href="###49.%20字母异位词分组">49. 字母异位词分组</a>中数组记录（因为只有 26 个小写英文字母）转元组作为 <code>key</code>的方式。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        s_len = <span class="hljs-built_in">len</span>(s)        l, r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(p)        p_count = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> p:            p_count[<span class="hljs-built_in">ord</span>(t)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>        count = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> s[l:r]:            count[<span class="hljs-built_in">ord</span>(t)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>        res = []        <span class="hljs-keyword">while</span> r&lt;s_len+<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> count == p_count:                res.append(l)            <span class="hljs-keyword">if</span> r&lt;s_len:                count[<span class="hljs-built_in">ord</span>(s[l])-<span class="hljs-number">97</span>] -= <span class="hljs-number">1</span>                count[<span class="hljs-built_in">ord</span>(s[r])-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>            l += <span class="hljs-number">1</span>            r += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="乘积小于-k-的子数组">713. 乘积小于 K 的子数组</h3><p>我觉得这个都不能算滑动窗口了，应该是一个双指针问题，右指针指向子数组的右边，并且在每一轮循环中右指针的位置是不变的。左指针指向的位置是<strong>当前右指针下满足条件的最左位置</strong>。最后进行一个对<code>k</code> 值的剪枝就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSubarrayProductLessThanK</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        res, left, temp = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> right, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            temp *= value            <span class="hljs-keyword">while</span> temp&gt;=k:                temp //= nums[left]                left += <span class="hljs-number">1</span>            res += right-left+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="二维区域和检索---矩阵不可变">304. 二维区域和检索 -矩阵不可变</h3><p>经典前缀和设计加快查询求和速度。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>):        m = <span class="hljs-built_in">len</span>(matrix)        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        presum = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m+<span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):                presum[i][j] = matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + presum[i-<span class="hljs-number">1</span>][j] + presum[i][j-<span class="hljs-number">1</span>] - presum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]        self.presum = presum    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumRegion</span>(<span class="hljs-params">self, row1: <span class="hljs-built_in">int</span>, col1: <span class="hljs-built_in">int</span>, row2: <span class="hljs-built_in">int</span>, col2: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.presum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] + self.presum[row1][col1] - self.presum[row2+<span class="hljs-number">1</span>][col1] - self.presum[row1][col2+<span class="hljs-number">1</span>]</code></pre></div><h3 id="最小差值-ii">910. 最小差值 II</h3><p>观察一下能想到这道题就是一组数大于某个值就 <code>-k</code>，小于某个值就 <code>+k</code>，我最开始的猜测是平均值。发现不对，至少处理不了一个数等于平均值的情况。昨天刚看了一下概率论的几个流派，按照古典派的思想，当一个事件有两种可能性但我们并不清楚的时候，它的可能性都是一半。所以取特定的值肯定与这个思想冲突很大。因此我选择排序之后逐一判断，结果过了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestRangeII</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        nums = <span class="hljs-built_in">sorted</span>(nums)        res = nums[-<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):            num_min = <span class="hljs-built_in">min</span>(nums[<span class="hljs-number">0</span>]+k, nums[i]-k)            num_max = <span class="hljs-built_in">max</span>(nums[-<span class="hljs-number">1</span>]-k, nums[i-<span class="hljs-number">1</span>]+k)            res = <span class="hljs-built_in">min</span>(num_max-num_min, res)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="重排链表">143. 重排链表</h3><p>这道题可以用双端队列解决，先扫描链表进队，然后左出一个右出一个直至队空。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reorderList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-literal">None</span>:        queue = collections.deque()        <span class="hljs-keyword">while</span> head:            queue.append(head)            head = head.<span class="hljs-built_in">next</span>        dummy = ListNode()        node = dummy        <span class="hljs-keyword">while</span> queue:            <span class="hljs-keyword">if</span> queue:                node.<span class="hljs-built_in">next</span> = queue.popleft()                node = node.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> queue:                node.<span class="hljs-built_in">next</span> = queue.pop()                node = node.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        head = dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="复制带随机指针的链表">138. 复制带随机指针的链表</h3><p>Python 中的 <code>deepcopy()</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:        <span class="hljs-keyword">return</span> deepcopy(head)</code></pre></div><p>先遍历 <code>head</code> ，同时构建新节点，同时将节点的对应关系加入<code>hashmap</code> 中。之后再根据 <code>hashmap</code> 添加<code>random</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:        dummy = head        res = Node(<span class="hljs-number">0</span>)        node = res        hashmap = &#123;&#125;        <span class="hljs-keyword">while</span> dummy:            node.<span class="hljs-built_in">next</span> = Node(dummy.val)            node = node.<span class="hljs-built_in">next</span>            hashmap[dummy] = node            dummy = dummy.<span class="hljs-built_in">next</span>        dummy = head        node = res.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> dummy:            node.random = hashmap[dummy.random] <span class="hljs-keyword">if</span> dummy.random <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>            dummy = dummy.<span class="hljs-built_in">next</span>            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div><h3 id="两数相加">2. 两数相加</h3><p>在数据结构里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        node = dummy        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:            temp = carry            <span class="hljs-keyword">if</span> l1:                temp += l1.val                l1 = l1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> l2:                temp += l2.val                l2 = l2.<span class="hljs-built_in">next</span>            carry = temp // <span class="hljs-number">10</span>            temp %= <span class="hljs-number">10</span>            node.<span class="hljs-built_in">next</span> = ListNode(temp)            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> carry:            node.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="两数相加-ii">445. 两数相加 II</h3><p>可以采用的一种思路就是先对链表取数相加再构建新链表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        num1 = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l1:            num1 = num1*<span class="hljs-number">10</span> + l1.val            l1 = l1.<span class="hljs-built_in">next</span>        num2 = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l2:            num2 = num2*<span class="hljs-number">10</span> + l2.val            l2 = l2.<span class="hljs-built_in">next</span>        dummy = ListNode()        node = dummy        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(num1+num2):            node.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">int</span>(i))            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="旋转链表">61. 旋转链表</h3><p>用一个 <code>list</code> 记录每个节点位置，再相应操作。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        lst = []        <span class="hljs-keyword">while</span> head:            lst.append(head)            head = head.<span class="hljs-built_in">next</span>        k %= <span class="hljs-built_in">len</span>(lst)        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> lst[<span class="hljs-number">0</span>]        node_1 = lst[-k-<span class="hljs-number">1</span>]        node_2 = lst[-k]        node_3 = lst[-<span class="hljs-number">1</span>]        node_4 = lst[<span class="hljs-number">0</span>]        node_1.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        node_3.<span class="hljs-built_in">next</span> = node_4        <span class="hljs-keyword">return</span> node_2</code></pre></div><h3 id="二叉搜索树迭代器">173. 二叉搜索树迭代器</h3><p>数据结构里做过。首先将搜索树结果中序遍历，之后再创建迭代器输出。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):        nums = []        stack = []        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:            <span class="hljs-keyword">while</span> root:                stack.append(root)                root = root.left            root = stack.pop()            nums.append(root.val)            root = root.right        self.index = <span class="hljs-number">0</span>        self.nums = nums        self.<span class="hljs-built_in">len</span> = <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        res = self.nums[self.index]        self.index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> self.index&lt;self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="座位预约管理系统">1845. 座位预约管理系统</h3><p>可以采用单调栈解决问题，预约的过程是出栈，解除预约是进栈。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeatManager</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>):        self.stack = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reserve</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack.pop()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unreserve</span>(<span class="hljs-params">self, seatNumber: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        temp = []        <span class="hljs-keyword">while</span> self.stack <span class="hljs-keyword">and</span> seatNumber&gt;self.stack[-<span class="hljs-number">1</span>]:            temp.append(self.stack.pop())        self.stack.append(seatNumber)        <span class="hljs-keyword">while</span> temp:            self.stack.append(temp.pop())</code></pre></div><p>另一个需要用到堆队列算法，可以参考 <ahref="https://docs.python.org/3/library/heapq.html">heapq — Heap queuealgorithm — Python 3.11.1 documentation</a> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeatManager</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>):        self.heap = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>))    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reserve</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> heappop(self.heap)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unreserve</span>(<span class="hljs-params">self, seatNumber: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        heappush(self.heap, seatNumber)</code></pre></div><h3 id="柠檬水找零">860. 柠檬水找零</h3><p>利用 <code>dict</code> 做一个对零钱的统计模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lemonadeChange</span>(<span class="hljs-params">self, bills: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;            <span class="hljs-number">5</span>:<span class="hljs-number">0</span>,            <span class="hljs-number">10</span>:<span class="hljs-number">0</span>        &#125;        <span class="hljs-keyword">for</span> bill <span class="hljs-keyword">in</span> bills:            match bill:                case <span class="hljs-number">5</span>:                    hashmap[<span class="hljs-number">5</span>] += <span class="hljs-number">1</span>                case <span class="hljs-number">10</span>:                    hashmap[<span class="hljs-number">10</span>] += <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> hashmap[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">0</span>:                        hashmap[<span class="hljs-number">5</span>] -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                case <span class="hljs-number">20</span>:                    <span class="hljs-keyword">if</span> hashmap[<span class="hljs-number">10</span>] &gt; <span class="hljs-number">0</span>:                        hashmap[<span class="hljs-number">10</span>] -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> hashmap[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">1</span>:                        hashmap[<span class="hljs-number">5</span>] -= <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                    <span class="hljs-keyword">if</span> hashmap[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">0</span>:                        hashmap[<span class="hljs-number">5</span>] -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="最小栈">155. 最小栈</h3><p>数据结构里做过，用两个栈解决问题，一个存顺序，一个存最小值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.stack = []        self.minstack = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> self.minstack:            _<span class="hljs-built_in">min</span> = self.minstack[-<span class="hljs-number">1</span>]            _<span class="hljs-built_in">min</span> = <span class="hljs-built_in">min</span>(val, _<span class="hljs-built_in">min</span>)            self.minstack.append(_<span class="hljs-built_in">min</span>)            self.stack.append(val)        <span class="hljs-keyword">else</span>:            self.minstack.append(val)            self.stack.append(val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:        self.stack.pop()        self.minstack.pop()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.minstack[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="扁平化嵌套列表迭代器">341. 扁平化嵌套列表迭代器</h3><p>深度优先搜索，但是重点在于我们必须在 <code>hasNext()</code>里去维护栈，否则结果可能会有无效空值，比如 <code>[[]]</code>这种输入。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedIterator</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nestedList: [NestedInteger]</span>):        self.stack = [t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> nestedList][::-<span class="hljs-number">1</span>]        <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack.pop().getInteger()        <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">while</span> self.stack:            node = self.stack.pop()            <span class="hljs-keyword">if</span> node.isInteger():                self.stack.append(node)                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                self.stack += node.getList()[::-<span class="hljs-number">1</span>]                <span class="hljs-keyword">return</span> self.hasNext()        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="设计一个验证系统">1797. 设计一个验证系统</h3><p>重点在于题目中这句，过期事件<strong>优先于</strong>其他操作。<code>dict</code> 哈希实现。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationManager</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, timeToLive: <span class="hljs-built_in">int</span></span>):        self.timeToLive = timeToLive        self.hashmap = &#123;&#125;    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, tokenId: <span class="hljs-built_in">str</span>, currentTime: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.hashmap[tokenId]=self.timeToLive+currentTime    <span class="hljs-keyword">def</span> <span class="hljs-title function_">renew</span>(<span class="hljs-params">self, tokenId: <span class="hljs-built_in">str</span>, currentTime: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> tokenId <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.hashmap <span class="hljs-keyword">or</span> self.hashmap[tokenId] &lt;= currentTime:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        self.hashmap[tokenId]=self.timeToLive+currentTime    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countUnexpiredTokens</span>(<span class="hljs-params">self, currentTime: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> self.hashmap.items():            <span class="hljs-keyword">if</span> v &gt; currentTime:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="设计链表">707. 设计链表</h3><p>数据结构里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>        self.nums = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.nums[index]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.addAtIndex(<span class="hljs-number">0</span>, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.addAtIndex(self.<span class="hljs-built_in">len</span>, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> index &gt; self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        index = <span class="hljs-built_in">max</span>(index, <span class="hljs-number">0</span>)        self.<span class="hljs-built_in">len</span> += <span class="hljs-number">1</span>        self.nums.insert(index, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        self.<span class="hljs-built_in">len</span> -= <span class="hljs-number">1</span>        <span class="hljs-keyword">del</span> self.nums[index]</code></pre></div><h3 id="o1-时间插入删除和获取随机元素">380. O(1)时间插入、删除和获取随机元素</h3><p>用 <code>set</code> , <code>random</code>实现插入、删除和随机获取的逻辑。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.<span class="hljs-built_in">set</span> = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.<span class="hljs-built_in">set</span>:            self.<span class="hljs-built_in">set</span>.add(val)            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">in</span> self.<span class="hljs-built_in">set</span>:            self.<span class="hljs-built_in">set</span>.remove(val)            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRandom</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> random.choice(<span class="hljs-built_in">list</span>(self.<span class="hljs-built_in">set</span>))</code></pre></div><h3 id="设计循环队列">622. 设计循环队列</h3><p>用 <code>list</code> 模拟队列。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, k: <span class="hljs-built_in">int</span></span>):        self.queue = []        self.max_len = k        self.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">enQueue</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> self.<span class="hljs-built_in">len</span> == self.max_len:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.queue.append(value)        self.<span class="hljs-built_in">len</span> += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deQueue</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> self.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.queue.pop(<span class="hljs-number">0</span>)        self.<span class="hljs-built_in">len</span> -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Front</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> self.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.queue[<span class="hljs-number">0</span>]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Rear</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> self.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.queue[-<span class="hljs-number">1</span>]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isFull</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">len</span> == self.max_len</code></pre></div><p>使用 <code>deque</code> 双端队列。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, k: <span class="hljs-built_in">int</span></span>):        self.queue = collections.deque()        self.max_len = k    <span class="hljs-keyword">def</span> <span class="hljs-title function_">enQueue</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.queue) == self.max_len:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.queue.append(value)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deQueue</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.queue.popleft()        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Front</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        res = self.queue.popleft()        self.queue.appendleft(res)        <span class="hljs-keyword">return</span> res    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Rear</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        res = self.queue.pop()        self.queue.append(res)        <span class="hljs-keyword">return</span> res    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isFull</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.queue) == self.max_len</code></pre></div><h3 id="我的日程安排表-i">729. 我的日程安排表 I</h3><p>用一个 <code>list</code> 里，存储元组进行简单模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.calendar = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">book</span>(<span class="hljs-params">self, start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        flag = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.calendar:            <span class="hljs-keyword">if</span> start &lt; i[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> end &gt; i[<span class="hljs-number">0</span>]:                flag = <span class="hljs-literal">False</span>                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">if</span> flag:            self.calendar.append((start, end))        <span class="hljs-keyword">return</span> flag</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构」 - 学习计划</title>
    <link href="/2023/02/21/leetcode%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/02/21/leetcode%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构入门">数据结构入门</h1><h2 id="数组">数组</h2><h3 id="存在重复元素">217. 存在重复元素</h3><p>简单 set 来判断是否有元素重复。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="最大子数组和">53. 最大子数组和</h3><p>首先数组限定了必有至少 1 个元素，那么我们可以假设最大子数和<code>max_sum</code> 等于数组第 1 个元素。</p><p>这时我们思考，假如数组中有一段是最大子数和，那么其左右肯定是 0 或者比0 小的子数和，所以我们可以定义一个 <code>temp_sum</code> ，初始化为 0，遍历子数并累加，当它小于 0 时，把它置 0（代表从这开始不加了），当它大于 <code>max_sum</code>时，<code>max_sum = temp_sum</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        max_sum = nums[<span class="hljs-number">0</span>]        temp_sum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            temp_sum += i            <span class="hljs-keyword">if</span> temp_sum &gt; max_sum:                max_sum = temp_sum            <span class="hljs-keyword">if</span> temp_sum &lt; <span class="hljs-number">0</span>:                temp_sum = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> max_sum</code></pre></div><h3 id="两数之和">1. 两数之和</h3><p>可以建立一个 <code>dict</code>来记录数组遍历过的值和它的下标，这样每次遍历到一个数时，看一下<code>target-x</code> 是否在 <code>dict</code>里就可以找到之前出现的数和这个数的和等于 <code>target</code> 的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            temp = target - v            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> [hashmap[temp], i]            <span class="hljs-keyword">else</span>:                hashmap[v] = i        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="合并两个有序数组">88. 合并两个有序数组</h3><p>这道题需要反着来，从 <code>nums1</code>后面开始放数，优先放大的数，这个不是很容易想到。放的过程中有 4种情况：</p><table><thead><tr class="header"><th>Situation</th><th>Operation</th></tr></thead><tbody><tr class="odd"><td>两数组都没放完 <code>nums2</code> 的大</td><td>放 <code>nums2</code> 的数， <code>nums2</code> 的指针左移。</td></tr><tr class="even"><td>两数组都没放完 <code>nums1</code> 的大</td><td>放 <code>nums1</code> 的数， <code>nums1</code> 的指针左移。</td></tr><tr class="odd"><td><code>nums1</code> 的数放完了</td><td>放 <code>nums2</code> 的数， <code>nums2</code> 的指针左移。</td></tr><tr class="even"><td><code>nums2</code> 的数放完了</td><td>不用放 <code>nums1</code> 的数了因为本来就在里面，跳出循环。</td></tr></tbody></table><p>所以其实跳出循环的条件就是 <code>nums2</code>的数放完了，剩下的情况里只有两数组都没放完 <code>nums1</code>的大这种情况需要放 <code>nums1</code> 的数，因此：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">while</span> n &gt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> m&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums1[m-<span class="hljs-number">1</span>] &gt; nums2[n-<span class="hljs-number">1</span>]:                nums1[m+n-<span class="hljs-number">1</span>] = nums1[m-<span class="hljs-number">1</span>]                m -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                nums1[m+n-<span class="hljs-number">1</span>] = nums2[n-<span class="hljs-number">1</span>]                n -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="两个数组的交集-ii">350. 两个数组的交集 II</h3><p>用两个 <code>dict</code>分别计数数组中每个数出现的次数，然后遍历其中一个 <code>dict</code>，如果数满足两个 <code>dict</code> 里 <code>key</code> 都有取<code>value</code> 的最小值，然后将 <code>value</code> 个<code>key</code> 加入结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersect</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        counter1 = &#123;&#125;        counter2 = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> counter1:                counter1[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                counter1[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> counter2:                counter2[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                counter2[i] += <span class="hljs-number">1</span>        res = []        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> counter1.items():            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> counter2:                t = <span class="hljs-built_in">min</span>(v, counter2[k])                res += [k]*t        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h3><p>动态规划的入门题，卖是建立在买的基础上的。在找到买入更低点时更新最大利润直到找到下个买入最低点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        price_min = <span class="hljs-number">1e5</span>        profit_max = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:            <span class="hljs-keyword">if</span> i &lt; price_min:                price_min = i            <span class="hljs-keyword">if</span> i-price_min &gt; profit_max:                profit_max = i-price_min        <span class="hljs-keyword">return</span> profit_max</code></pre></div><h3 id="重塑矩阵">566. 重塑矩阵</h3><p>比较直观的解法，假设有一个点 <code>(a,b)</code> 在源矩阵<code>m*n</code> 里面，如果源矩阵用一维数组表示，那么它的位置就是<code>b+a*n</code> ，对于一个新矩阵 <code>r*c</code> 来讲，它对应<code>r</code> 的位置就应该是 <code>((b+a*n)//c, (b+a*n)%c)</code>这个点：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        m = <span class="hljs-built_in">len</span>(mat)        <span class="hljs-keyword">if</span> m*n != r*c:            <span class="hljs-keyword">return</span> mat        res = [[<span class="hljs-number">0</span>]*c <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r)]        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                res[(col+row*n)//c][(col+row*n)%c] = mat[row][col]        <span class="hljs-keyword">return</span> res</code></pre></div><p>这里我们用了两层循环，其实如果用一维数组做循环也可以，重点变成双方都找<code>(loc//column, loc%column)</code> 的位置了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        m = <span class="hljs-built_in">len</span>(mat)        <span class="hljs-keyword">if</span> m*n != r*c:            <span class="hljs-keyword">return</span> mat        res = [[<span class="hljs-number">0</span>]*c <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r)]        <span class="hljs-keyword">for</span> loc <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m*n):                res[loc//c][loc%c] = mat[loc//n][loc%n]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="杨辉三角">118. 杨辉三角</h3><p>又是一道考察多维数组的题，我们可以模拟题目描述中的动画：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = [[<span class="hljs-number">1</span>]]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows-<span class="hljs-number">1</span>):            temp = [<span class="hljs-number">1</span>]            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res[-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>):                temp.append(res[-<span class="hljs-number">1</span>][k]+res[-<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>])            temp += [<span class="hljs-number">1</span>]            res.append(temp)        <span class="hljs-keyword">return</span> res</code></pre></div><p>然后我们也可以想象下这个假如是个二维数组坐标系：</p><table><thead><tr class="header"><th></th><th><strong>col</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><strong>row</strong></td><td>1</td><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td>1</td><td>1</td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td>1</td><td>2</td><td>1</td><td></td><td></td></tr><tr class="even"><td></td><td>1</td><td>3</td><td>3</td><td>1</td><td></td></tr><tr class="odd"><td></td><td>1</td><td>4</td><td>6</td><td>4</td><td>1</td></tr></tbody></table><p>在 <code>row-col</code> 坐标系上非行首行尾点 <code>(a,b)</code>其实等于 <code>(a-1, b-1)+(a-1, b)</code> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = [[<span class="hljs-number">1</span>]*(row+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows)]        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, numRows):            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, row):                res[row][col] = res[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>]+res[row-<span class="hljs-number">1</span>][col]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="有效的数独">36. 有效的数独</h3><p>我们首先遍历一遍数独，得到一个每个数的存储信息的 <code>dict</code>：</p><ul><li><code>dict</code> 的 <code>key</code> - 存放每个数，除了<code>'.'</code> 这个代表空白的值。</li><li><code>dict</code> 的 <code>value</code> - 存放一个 <code>list</code>，这个 <code>list</code> 里存放的是<code>(row_index, col_index, block_index)</code> 的 <code>tuple</code>用来记录这个数的位置信息。</li></ul><p>得到信息后对字典每个 <code>value</code> 进行判断，需要当前<code>list</code> 里的 <code>row_index</code> ， <code>col_index</code>， <code>block_index</code>都不相同，任意一个相同时返回错误，否则返回正确。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:        num_loc = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_loc:                        num_loc[board[i][j]] = [(i,j,((i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>)))]                    <span class="hljs-keyword">else</span>:                        num_loc[board[i][j]].append((i,j,((i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>))))        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> num_loc.values():            row_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)            col_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)            block_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> v:                <span class="hljs-keyword">if</span> i[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> row_set:                    row_set.add(i[<span class="hljs-number">0</span>])                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> col_set:                    col_set.add(i[<span class="hljs-number">1</span>])                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> i[<span class="hljs-number">2</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> block_set:                    block_set.add(i[<span class="hljs-number">2</span>])                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p>然后就可以发现上面的逻辑可以优化，上述逻辑是先放后比，边放边比会更快。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:        row_record = [<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]        col_record = [<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]        block_record = [<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">in</span> row_record[i]:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">in</span> col_record[j]:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                    <span class="hljs-keyword">if</span> board[i][j] <span class="hljs-keyword">in</span> block_record[(i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>)]:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                    row_record[i].add(board[i][j])                    col_record[j].add(board[i][j])                    block_record[(i//<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+(j//<span class="hljs-number">3</span>)].add(board[i][j])        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="矩阵置零">73. 矩阵置零</h3><p>和上面这道题思路比较像，先统计一下 0 的位置信息，再修改。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:        row_record = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        col_record = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        m = <span class="hljs-built_in">len</span>(matrix)        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:                    row_record.add(i)                    col_record.add(j)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> row_record:                matrix[i][:] = [<span class="hljs-number">0</span>]*n            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> col_record:                    matrix[i][j] = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h2 id="字符串">字符串</h2><h3 id="字符串中的第一个唯一字符">387. 字符串中的第一个唯一字符</h3><p><code>dict</code> 存储频次。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> hashmap[v] == <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> i        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><p><code>dict</code> 存储唯一元素的下标，否则存储 -1。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[v] = i            <span class="hljs-keyword">else</span>:                hashmap[v] = -<span class="hljs-number">1</span>        res = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> i != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i &lt; res:                res = i        <span class="hljs-keyword">if</span> res == <span class="hljs-built_in">len</span>(s):            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="赎金信">383. 赎金信</h3><p>用 <code>dict</code> 做一个简单的计数，再判断。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote: <span class="hljs-built_in">str</span>, magazine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        magazine_dict = &#123;&#125;        ransomNote_dict = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> magazine:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> magazine_dict:                magazine_dict[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                magazine_dict[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ransomNote:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ransomNote_dict:                ransomNote_dict[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                ransomNote_dict[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> ransomNote_dict.items():            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> magazine_dict:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> v &gt; magazine_dict[k]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="有效的字母异位词">242. 有效的字母异位词</h3><p>用 <code>dict</code> 做一个简单的计数统计，再判断。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashmap[i] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h2 id="链表">链表</h2><h3 id="环形链表">141. 环形链表</h3><p>快慢双指针能否相遇的问题，如果相遇了就是有环，没有相遇就是没有环。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        fast = slow = head        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:            slow = slow.<span class="hljs-built_in">next</span>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> fast == slow:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="合并两个有序链表">21. 合并两个有序链表</h3><p>迭代，链表的修改需要找到待插入节点的上一个节点，因此，我们需要定义一个<code>pre</code> 节点方便修改，同时为了方便返回结果，我们还需要一个<code>dummy</code> 节点用于记录一开始的位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        pre = dummy        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:                pre.<span class="hljs-built_in">next</span> = list1                list1 = list1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                pre.<span class="hljs-built_in">next</span> = list2                list2 = list2.<span class="hljs-built_in">next</span>            pre = pre.<span class="hljs-built_in">next</span>        pre.<span class="hljs-built_in">next</span> = list2 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> list1        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> list2        <span class="hljs-keyword">elif</span> list2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> list1        <span class="hljs-keyword">elif</span> list1.val &lt;= list2.val:            list1.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1.<span class="hljs-built_in">next</span>, list2)            <span class="hljs-keyword">return</span> list1        <span class="hljs-keyword">else</span>:            list2.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="hljs-built_in">next</span>)            <span class="hljs-keyword">return</span> list2</code></pre></div><h3 id="移除链表元素">203. 移除链表元素</h3><p>迭代，同样一个 <code>pre</code> 节点方便删元素，一个<code>dummy</code> 节点方便返回头指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        pre = dummy        <span class="hljs-keyword">while</span> head:            <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.val == val:                head = head.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> head:                pre.<span class="hljs-built_in">next</span> = head                head = head.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                pre.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>            pre = pre.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>虽然过了，但是我仔细一看上面的代码其实逻辑有问题，最外层的<code>while head</code> 根本不应该写成循环，因为推动循环变化的是<code>pre</code> 这个点，优化一下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode(<span class="hljs-number">0</span>, head)        pre = dummy        <span class="hljs-keyword">while</span> pre.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> pre.<span class="hljs-built_in">next</span>.val != val:                pre = pre.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                pre.<span class="hljs-built_in">next</span> = pre.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>递归。这里也注意递归条件。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> head        head.<span class="hljs-built_in">next</span> = self.removeElements(head.<span class="hljs-built_in">next</span>, val)        <span class="hljs-keyword">return</span> head <span class="hljs-keyword">if</span> head.val != val <span class="hljs-keyword">else</span> head.<span class="hljs-built_in">next</span></code></pre></div><h3 id="反转链表">206. 反转链表</h3><p>用栈进行反转。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        stack = []        <span class="hljs-keyword">while</span> head:            stack.append(head.val)            head = head.<span class="hljs-built_in">next</span>        dummy = ListNode()        node = dummy        <span class="hljs-keyword">while</span> stack:            node.<span class="hljs-built_in">next</span> = ListNode(stack.pop())            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>但是这个都把值提出来了，不太正规。</p><p>我们可以使用双指针迭代，一个指针在前一个指针在后，遍历链表时修改指针的方向。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        pre = <span class="hljs-literal">None</span>        cur = head        <span class="hljs-keyword">while</span> cur:            temp = cur.<span class="hljs-built_in">next</span>            cur.<span class="hljs-built_in">next</span> = pre            pre = cur            cur = temp        <span class="hljs-keyword">return</span> pre</code></pre></div><p>还可以用递归，其中递归是参考的 <ahref="https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">206.反转链表 - 力扣（Leetcode）</a> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> head        cur = self.reverseList(head.<span class="hljs-built_in">next</span>)        head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> cur</code></pre></div><h3 id="删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h3><p>可以使用 <code>set</code> 只保留重复元素。</p><div class="code-wrapper"><pre><code class="hljs python">hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)dummy = ListNode()pre = dummy<span class="hljs-keyword">while</span> head:    <span class="hljs-keyword">if</span> head.val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:        hashset.add(head.val)        pre.<span class="hljs-built_in">next</span> = head        pre = pre.<span class="hljs-built_in">next</span>    head = head.<span class="hljs-built_in">next</span>pre.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>不过，因为这道题是已经排序的链表，也就是说重复元素都是连着出现的，所以也可以这样，根据下一个元素是否重复来决定是移动指针还是插值：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> head        node = head        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.val == node.<span class="hljs-built_in">next</span>.val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h2 id="栈-队列">栈 / 队列</h2><h3 id="有效的括号">20. 有效的括号</h3><p>用栈处理，左符号进栈右符号出栈匹配，出现任何错误或者最后栈非空都是<code>False</code> ，否则是 <code>True</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            match i:                case <span class="hljs-string">&#x27;(&#x27;</span>: stack.append(i)                case <span class="hljs-string">&#x27;)&#x27;</span>:                     <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                case <span class="hljs-string">&#x27;&#123;&#x27;</span>: stack.append(i)                case <span class="hljs-string">&#x27;&#125;&#x27;</span>:                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                case <span class="hljs-string">&#x27;[&#x27;</span>: stack.append(i)                case <span class="hljs-string">&#x27;]&#x27;</span>:                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack</code></pre></div><h3 id="用栈实现队列">232. 用栈实现队列</h3><p>我的做法是有两个栈分别叫 <code>stack_in</code> 和<code>stack_out</code> ，<code>stack_in</code>负责用于转换数据的顺序（因为队列和栈顺序是反着的），<code>stack_out</code>存着正确的出队，查看队顶，查看队空的顺序。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.stack_in = []        self.stack_out = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">while</span> self.stack_out:            self.stack_in.append(self.stack_out.pop())        self.stack_in.append(x)        <span class="hljs-keyword">while</span> self.stack_in:            self.stack_out.append(self.stack_in.pop())    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack_out.pop()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack_out[-<span class="hljs-number">1</span>]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack_out) == <span class="hljs-number">0</span></code></pre></div><h2 id="树">树</h2><h3 id="二叉树的前序遍历">144. 二叉树的前序遍历</h3><p>二叉树的遍历顺序（前中后）指的是根节点遍历是在前中后哪个位置，比如这道题，前序，根节点在前。</p><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">def</span> <span class="hljs-title function_">NLR</span>(<span class="hljs-params">node:<span class="hljs-type">Optional</span>[TreeNode]</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            res.append(node.val)            NLR(node.left)            NLR(node.right)                    NLR(root)        <span class="hljs-keyword">return</span> res</code></pre></div><p>非递归，类似深度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            res.append(node.val)            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="二叉树的中序遍历">94. 二叉树的中序遍历</h3><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node:<span class="hljs-type">Optional</span>[TreeNode]</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            LNR(node.left)            res.append(node.val)            LNR(node.right)                LNR(root)        <span class="hljs-keyword">return</span> res</code></pre></div><p>非递归的方式，我们可以看上面递归的方法，其实在打印之前，是不对右节点进行处理的，也就是说是针对每一次循环都是先处理左节点到打印，想明白这件事，我们对栈的变化情况其实心里就有数了。</p><p>值得注意的是这个中序遍历其实用的是指针去遍历，而不是用栈遍历。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        stack = []        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:            <span class="hljs-keyword">while</span> root:                stack.append(root)                root = root.left            root = stack.pop()            res.append(root.val)            root = root.right        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="二叉树的后序遍历">145. 二叉树的后序遍历</h3><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LRN</span>(<span class="hljs-params">node:<span class="hljs-type">Optional</span>[TreeNode]</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            LRN(node.left)            LRN(node.right)            res.append(node.val)        LRN(root)        <span class="hljs-keyword">return</span> res</code></pre></div><p>这个有点骚，已知前序遍历是 NLR，后续遍历是LRN，我们可以将前序遍历魔改一下成为，NRL，再反转一下结果就变成了LRN。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            res.append(node.val)            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]</code></pre></div><h3 id="二叉树的层序遍历">102. 二叉树的层序遍历</h3><p>经典广度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        queue = collections.deque()        res = []        queue.append(root)        <span class="hljs-keyword">while</span> queue:            temp = []            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.popleft()                temp.append(node.val)                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)            res.append(temp)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="二叉树的最大深度">104. 二叉树的最大深度</h3><p>昨天刚在编程能力学习计划里做了。递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><p>广度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        res = <span class="hljs-number">0</span>        queue = collections.deque()        queue.append(root)        <span class="hljs-keyword">while</span> queue:            res += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.popleft()                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="对称二叉树">101. 对称二叉树</h3><p>我们可以用二叉树层次遍历的思想进行广度优先搜索。每一层都必须是对称的否则直接不是对称二叉树。同时为了处理空节点的情况，即使空节点也要添加值<code>None</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        queue = collections.deque()        queue.append(root)        <span class="hljs-keyword">while</span> queue:            temp = []            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.popleft()                <span class="hljs-keyword">if</span> node.left:                    temp.append(node.left.val)                    queue.append(node.left)                <span class="hljs-keyword">else</span>:                    temp.append(<span class="hljs-literal">None</span>)                <span class="hljs-keyword">if</span> node.right:                    temp.append(node.right.val)                    queue.append(node.right)                <span class="hljs-keyword">else</span>:                    temp.append(<span class="hljs-literal">None</span>)            <span class="hljs-keyword">if</span> temp != temp[::-<span class="hljs-number">1</span>]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p>递归，这里主要考虑终止递归的条件：</p><ul><li>左节点和右节点都为空 - 对称，返回 <code>True</code> 。</li><li>左右节点空了一个 - 非对称，返回 <code>False</code> 。</li><li>左右节点都非空但值不相等 - 非对称，返回 <code>False</code> 。</li><li>左右节点都非空且值相等 -需要递归比较（左节点的左子节点，右节点的右子节点）和（左节点的右子节点，右节点的左子节点）。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">left, right</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">or</span> right):                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">and</span> right):                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> left.val != right.val:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> DFS(left.left, right.right) <span class="hljs-keyword">and</span> DFS(left.right, right.left)        <span class="hljs-keyword">return</span> DFS(root.left, root.right)</code></pre></div><h3 id="翻转二叉树">226. 翻转二叉树</h3><p>递归翻转。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)        <span class="hljs-keyword">return</span> root</code></pre></div><p>层次反转，广度优先搜索的思想：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        queue = collections.deque()        queue.append(root)        <span class="hljs-keyword">while</span> queue:            node = queue.popleft()            node.left, node.right = node.right, node.left            <span class="hljs-keyword">if</span> node.left: queue.append(node.left)            <span class="hljs-keyword">if</span> node.right: queue.append(node.right)        <span class="hljs-keyword">return</span> root</code></pre></div><p>深度优先搜索的思想：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            node.left, node.right = node.right, node.left            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)        <span class="hljs-keyword">return</span> root</code></pre></div><h3 id="路径总和">112. 路径总和</h3><p>深度优先搜索，非递归方法。实质上就是每次往栈里填节点的时候填上当前路径的和，当节点为叶子节点的时候可以看一下路径和是否等于目标值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        stack = [(root, root.val)]        <span class="hljs-keyword">while</span> stack:            node, temp = stack.pop()            <span class="hljs-keyword">if</span> node.right: stack.append((node.right, temp+node.right.val))            <span class="hljs-keyword">if</span> node.left: stack.append((node.left, temp+node.left.val))            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">and</span> temp == targetSum:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>广度优先搜索也能解决。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        queue = collections.deque()        queue.append((root, root.val))        <span class="hljs-keyword">while</span> queue:            node, temp = queue.popleft()            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, temp+node.right.val))            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, temp+node.left.val))            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">and</span> temp == targetSum:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>递归，递归似乎比上面两种快很多。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">and</span> root.right:            <span class="hljs-keyword">return</span> self.hasPathSum(root.left, targetSum-root.val) <span class="hljs-keyword">or</span> self.hasPathSum(root.right, targetSum-root.val)        <span class="hljs-keyword">if</span> root.left:            <span class="hljs-keyword">return</span> self.hasPathSum(root.left, targetSum-root.val)        <span class="hljs-keyword">if</span> root.right:            <span class="hljs-keyword">return</span> self.hasPathSum(root.right, targetSum-root.val)        <span class="hljs-keyword">return</span> root.val == targetSum</code></pre></div><h3 id="二叉搜索树中的搜索">700. 二叉搜索树中的搜索</h3><p>二叉搜索树的重要特征就是左子树的所有值 &lt;= 根节点的值 &lt;=右子树的所有值，因此我们可以通过值的比较快速定位到目标值的节点。</p><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> root.val == val:            <span class="hljs-keyword">return</span> root        <span class="hljs-keyword">if</span> root.val &lt; val <span class="hljs-keyword">and</span> root.right:            <span class="hljs-keyword">return</span> self.searchBST(root.right, val)        <span class="hljs-keyword">if</span> root.val &gt; val <span class="hljs-keyword">and</span> root.left:            <span class="hljs-keyword">return</span> self.searchBST(root.left, val)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>非递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">while</span> root:            <span class="hljs-keyword">if</span> root.val == val:                <span class="hljs-keyword">return</span> root            <span class="hljs-keyword">elif</span> root.val &lt; val:                root = root.right            <span class="hljs-keyword">elif</span> root.val &gt; val:                root = root.left        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="二叉搜索树中的插入操作">701. 二叉搜索树中的插入操作</h3><p>在不考虑树的深度的情况下插入新节点到二叉搜索树中还是非常容易的，与上题相似。</p><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> TreeNode(val)        <span class="hljs-keyword">if</span> root.val &gt; val:            <span class="hljs-keyword">if</span> root.left:                root.left = self.insertIntoBST(root.left, val)            <span class="hljs-keyword">else</span>:                root.left = TreeNode(val)        <span class="hljs-keyword">if</span> root.val &lt; val:            <span class="hljs-keyword">if</span> root.right:                root.right = self.insertIntoBST(root.right, val)            <span class="hljs-keyword">else</span>:                root.right = TreeNode(val)        <span class="hljs-keyword">return</span> root</code></pre></div><p>非递归，在循环里插入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> TreeNode(val)        dummy = root        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            <span class="hljs-keyword">if</span> root.val &gt; val:                <span class="hljs-keyword">if</span> root.left:                    root = root.left                <span class="hljs-keyword">else</span>:                    root.left = TreeNode(val)                    <span class="hljs-keyword">break</span>            <span class="hljs-keyword">elif</span> root.val &lt; val:                <span class="hljs-keyword">if</span> root.right:                    root = root.right                <span class="hljs-keyword">else</span>:                    root.right = TreeNode(val)                    <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> dummy</code></pre></div><p>非递归，在循环外插入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> TreeNode(val)        dummy = root        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            <span class="hljs-keyword">if</span> root.val &gt; val <span class="hljs-keyword">and</span> root.left:                root = root.left            <span class="hljs-keyword">elif</span> root.val &lt; val <span class="hljs-keyword">and</span> root.right:                root = root.right            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">if</span> root.val &gt; val:            root.left = TreeNode(val)        <span class="hljs-keyword">else</span>:            root.right = TreeNode(val)        <span class="hljs-keyword">return</span> dummy</code></pre></div><h3 id="验证二叉搜索树">98. 验证二叉搜索树</h3><p>自定义一个递归方法去设置上下限。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">DST</span>(<span class="hljs-params">root, min_val, max_val</span>):            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">and</span> root.right:                <span class="hljs-keyword">if</span> min_val &lt; root.left.val &lt; root.val &lt; root.right.val &lt; max_val:                    <span class="hljs-keyword">return</span> DST(root.left, min_val, root.val) <span class="hljs-keyword">and</span> DST(root.right, root.val, max_val)                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> root.left:                <span class="hljs-keyword">if</span> min_val &lt; root.left.val &lt; root.val &lt; max_val:                    <span class="hljs-keyword">return</span> DST(root.left, min_val, root.val)                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> root.right:                <span class="hljs-keyword">if</span> min_val &lt; root.val &lt; root.right.val &lt; max_val:                    <span class="hljs-keyword">return</span> DST(root.right, root.val, max_val)                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> DST(root, -<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span>)</code></pre></div><p>也可以中序遍历完了再做比较。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        res = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            LNR(node.left)            res.append(node.val)            LNR(node.right)        LNR(root)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)-<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> res[i] &gt;= res[i+<span class="hljs-number">1</span>]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p>对于中序遍历来讲，可以边遍历边比较会更快。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        pre = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)        stack = []        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:            <span class="hljs-keyword">while</span> root:                stack.append(root)                root = root.left            root = stack.pop()            <span class="hljs-keyword">if</span> root.val &lt;= pre:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            pre = root.val            root = root.right        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="两数之和-iv---输入二叉搜索树">653. 两数之和 IV -输入二叉搜索树</h3><p>我们可以用 hash 加遍历树的方式来寻找有无两数之和。非递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTarget</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            hashset.add(k-node.val)            <span class="hljs-keyword">if</span> node.left: stack.append(node.left)            <span class="hljs-keyword">if</span> node.right: stack.append(node.right)        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTarget</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            hashset.add(k-node.val)            <span class="hljs-keyword">return</span> DFS(node.left) <span class="hljs-keyword">or</span> DFS(node.right)         <span class="hljs-keyword">return</span> DFS(root)</code></pre></div><h3 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h3><p>上道题感觉其实与二叉搜索树没什么关系，这道是真有。</p><p>我们先不管这个二叉搜索树的性质，使用树的层次遍历并开一个祖先列表，将一个节点所有祖先都放入列表中，直到找到<code>p</code> ， <code>q</code>两个节点然后再从后往前去比较两个祖先列表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:        queue = collections.deque()        queue.append((root,[root]))        p_ancestors = <span class="hljs-literal">None</span>        q_ancestors = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> queue:            node, ancestors = queue.pop()            <span class="hljs-keyword">if</span> node == p:                p_ancestors = ancestors            <span class="hljs-keyword">if</span> node == q:                q_ancestors = ancestors            <span class="hljs-keyword">if</span> p_ancestors <span class="hljs-keyword">and</span> q_ancestors:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, ancestors+[node.left]))            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, ancestors+[node.right]))        <span class="hljs-keyword">for</span> p_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(p_ancestors):            <span class="hljs-keyword">for</span> q_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(q_ancestors):                <span class="hljs-keyword">if</span> p_ancestor == q_ancestor:                    <span class="hljs-keyword">return</span> p_ancestor        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>这个效率确实低了很多。</p><p>我们可以利用二叉搜索树的性质，如果两个节点的值都比某个节点值大，这两个节点都应该在这个节点右边。如果两个节点值都比某个节点值小，这两个节点都应该在某个节点左边。否则这个节点就是两个节点的最近公共祖先。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:        <span class="hljs-keyword">if</span> p.val &lt; root.val <span class="hljs-keyword">and</span> q.val &lt; root.val:            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.left, p, q)        <span class="hljs-keyword">if</span> p.val &gt; root.val <span class="hljs-keyword">and</span> q.val &gt; root.val:            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.right, p, q)        <span class="hljs-keyword">return</span> root</code></pre></div><h1 id="数据结构基础">数据结构基础</h1><h2 id="数组-1">数组</h2><h3 id="只出现一次的数字">136. 只出现一次的数字</h3><p>异或运算的性质。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y:x^y, nums)</code></pre></div><h3 id="多数元素">169. 多数元素</h3><p>对元素计数，找出大于 <code>len(nums)//2</code> 的元素。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_len_half = <span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>        counter = collections.Counter(nums)        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> counter:            <span class="hljs-keyword">if</span> counter[k] &gt; nums_len_half:                <span class="hljs-keyword">return</span> k        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="三数之和">15. 三数之和</h3><p>强行三数之和转两数之和（ hash ）+ 去重。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums, target, begin_index</span>):            hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)            res = []            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(begin_index, <span class="hljs-built_in">len</span>(nums)):                temp = target-nums[i]                <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">in</span> hashset:                    res.append([nums[i],temp])                <span class="hljs-keyword">else</span>:                    hashset.add(nums[i])            <span class="hljs-keyword">return</span> res                res = []        zero = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            two = twoSum(nums, -v, i+<span class="hljs-number">1</span>)            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(two) != <span class="hljs-number">0</span>:                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> two:                    <span class="hljs-keyword">if</span> v==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>:                        zero = <span class="hljs-literal">True</span>                        <span class="hljs-keyword">continue</span>                    flag = <span class="hljs-literal">True</span>                    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:                        <span class="hljs-keyword">if</span> v <span class="hljs-keyword">in</span> r <span class="hljs-keyword">and</span> j[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> r <span class="hljs-keyword">and</span> j[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> r:                            flag = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">if</span> flag:                        res.append([v]+j)        <span class="hljs-keyword">if</span> zero:            res.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])        <span class="hljs-keyword">return</span> res</code></pre></div><p>太慢了，我甚至怀疑不是 Python 都过不了测试用例：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212260937219.png" /></p><p>双指针法，见注释。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        nums = <span class="hljs-built_in">sorted</span>(nums)<span class="hljs-comment"># 靠排序达到去重效果</span>        nums_len = <span class="hljs-built_in">len</span>(nums)        res = []        <span class="hljs-keyword">if</span> nums_len &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums[-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len-<span class="hljs-number">2</span>):<span class="hljs-comment"># 寻找元素 a</span>            <span class="hljs-keyword">if</span> nums[i]&gt;<span class="hljs-number">0</span>:<span class="hljs-comment"># 剪枝</span>                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:<span class="hljs-comment"># 对元素 a 去重</span>                <span class="hljs-keyword">continue</span>            left = i+<span class="hljs-number">1</span><span class="hljs-comment"># 寻找元素 b</span>            right = nums_len-<span class="hljs-number">1</span><span class="hljs-comment"># 寻找元素 c</span>            <span class="hljs-keyword">while</span> left&lt;right:                temp_sum = nums[i]+nums[left]+nums[right]<span class="hljs-comment"># 这里和下面的 if-elif-else 语句都在寻找三数之和为 0</span>                <span class="hljs-keyword">if</span> temp_sum &gt; <span class="hljs-number">0</span>:                    right -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> temp_sum &lt; <span class="hljs-number">0</span>:                    left += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res.append([nums[i], nums[left], nums[right]])                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[left] == nums[left+<span class="hljs-number">1</span>]: left += <span class="hljs-number">1</span><span class="hljs-comment"># 对元素 b 去重</span>                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[right] == nums[right-<span class="hljs-number">1</span>]: right -= <span class="hljs-number">1</span><span class="hljs-comment"># 对元素 c 去重</span>                    left += <span class="hljs-number">1</span>                    right -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="颜色分类">75. 颜色分类</h3><p>这道题是一道盲点问题，其实不需要排序，只需要统计，统计完之后根据统计结果直接替换就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortColors</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        counter = collections.Counter(nums)        index = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter[i]):                nums[index] = i                index += <span class="hljs-number">1</span></code></pre></div><h3 id="合并区间">56. 合并区间</h3><p>暴力法，用一个 <code>record</code>数组记录有数的位置，这种思路的问题在于要处理 <code>[1,1], [2,2]</code>与 <code>[1,2], [2,2]</code> 的区别，因为在 <code>record</code>数组上的记录都是 <code>record[1]=1, record[2]=1</code>。这里采取的方式是将 <code>record</code> 数组扩大两倍，这样<code>[1,1], [2,2]</code> 就表现为 <code>record[2]=1, record[4]=1</code>，而 <code>[1,2], [2,2]</code> 则表现为<code>record[2]=1, record[3]=1, record[4]=1</code> ，得以区分。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        record = [<span class="hljs-number">0</span>] * <span class="hljs-number">20002</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>, i[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>):                record[j] = <span class="hljs-number">1</span>        i = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i&lt;=<span class="hljs-number">20001</span>:            <span class="hljs-keyword">if</span> record[i] == <span class="hljs-number">0</span>:                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                pre = i+<span class="hljs-number">1</span>                <span class="hljs-keyword">while</span> pre&lt;=<span class="hljs-number">20001</span> <span class="hljs-keyword">and</span> record[pre]:                    pre += <span class="hljs-number">1</span>                res.append([i//<span class="hljs-number">2</span>, pre//<span class="hljs-number">2</span>])                i = pre        <span class="hljs-keyword">return</span> res</code></pre></div><p>贪心。首先需要将 <code>intervals</code> 数组按 <code>i[0]</code>排序，排序之后进行遍历，这时会有两种情况：</p><ul><li>当前遍历的 <code>t[0]</code> 大于结果数组 <code>res</code> 最后一个<code>i[1]</code> 的值，代表从现在开始就不连续了，直接将 <code>t</code>加入结果数组。</li><li>当前遍历的 <code>t[0]</code> 小于等于结果数组 <code>res</code>最后一个 <code>i[1]</code> 的值，也就是连续，这时候应该对<code>res[-1]</code> 和 <code>t</code>取并集，不过由于已经排了序，所以其实就是 <code>res[-1][1]</code>右边边界取 <code>t[1]</code> 和 <code>res[-1][1]</code> 的更大值。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        arr_sort = <span class="hljs-built_in">sorted</span>(intervals, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])        res = [arr_sort[<span class="hljs-number">0</span>]]        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> arr_sort:            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>]&gt;res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:                res.append(t)            <span class="hljs-keyword">else</span>:                res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], t[<span class="hljs-number">1</span>])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="设计哈希映射">706. 设计哈希映射</h3><p>调用 <code>dict</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.hashmap = &#123;&#125;    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.hashmap[key] = value    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.hashmap:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.hashmap[key]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.hashmap:            <span class="hljs-keyword">del</span> self.hashmap[key]</code></pre></div><h3 id="杨辉三角-ii">119. 杨辉三角 II</h3><p>与构建杨辉三角很类似，直接沿用构建杨辉三角的思路，取结果数组里最后一行的数组就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRow</span>(<span class="hljs-params">self, rowIndex: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">if</span> rowIndex == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>]        res = [[<span class="hljs-number">1</span>]*(row+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rowIndex+<span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, rowIndex+<span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, row):                res[row][col] = res[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>]+res[row-<span class="hljs-number">1</span>][col]        <span class="hljs-keyword">return</span> res[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="旋转图像">48. 旋转图像</h3><p>先沿右对角线做一次轴对称，再沿中线做一次轴对称。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:        n = <span class="hljs-built_in">len</span>(matrix)        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, c):                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            matrix[r][:] = matrix[r][::-<span class="hljs-number">1</span>]</code></pre></div><h3 id="螺旋矩阵-ii">59. 螺旋矩阵 II</h3><p>模拟过程：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateMatrix</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]        direction = (<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>)        direct = [<span class="hljs-string">&#x27;r&#x27;</span>]*(n-<span class="hljs-number">1</span>) + [<span class="hljs-string">&#x27;b&#x27;</span>]*(n-<span class="hljs-number">1</span>) + [<span class="hljs-string">&#x27;l&#x27;</span>]*(n-<span class="hljs-number">1</span>)        index = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">1</span>:            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):                direct += direction[index]*(n-<span class="hljs-number">2</span>)                index = (index+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>            n -= <span class="hljs-number">1</span>        count = <span class="hljs-number">2</span>        r = <span class="hljs-number">0</span>        c = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> direct:            match d:                case <span class="hljs-string">&#x27;r&#x27;</span>:                    c += <span class="hljs-number">1</span>                case <span class="hljs-string">&#x27;b&#x27;</span>:                    r += <span class="hljs-number">1</span>                case <span class="hljs-string">&#x27;l&#x27;</span>:                    c -= <span class="hljs-number">1</span>                case <span class="hljs-string">&#x27;t&#x27;</span>:                    r -= <span class="hljs-number">1</span>            res[r][c] = count            count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="搜索二维矩阵-ii">240. 搜索二维矩阵 II</h3><p>直接使用暴力法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        m = <span class="hljs-built_in">len</span>(matrix)        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> matrix[i][j] == target:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>？？？打败了 90 % 的人？</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212291126962.png" /></p><p>说实话我肯定不能接受。这题肯定跟二分有关系的。</p><p>对每一行都使用二分查找搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        m = <span class="hljs-built_in">len</span>(matrix)        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            l, r = <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> l&lt;=r:                mid = (l+r) // <span class="hljs-number">2</span>                <span class="hljs-keyword">if</span> matrix[i][mid] == target:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">elif</span> matrix[i][mid] &lt; target:                    l = mid + <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    r = mid - <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>从右上角或者左下角开始搜，思路差不多。以右上角开始为例，可以发现向左值都在减小，向下值都在增加，所以可以利用这个性质搜。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        m = <span class="hljs-built_in">len</span>(matrix)        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        i = <span class="hljs-number">0</span>        j = n-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> i&lt;m <span class="hljs-keyword">and</span> j&gt;=<span class="hljs-number">0</span>:            <span class="hljs-keyword">if</span> matrix[i][j] == target:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">elif</span> matrix[i][j] &gt; target:                j -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                i += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="无重叠区间">435. 无重叠区间</h3><p>先排序之后用贪心的思想过滤每个区间。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eraseOverlapIntervals</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        intervals = <span class="hljs-built_in">sorted</span>(intervals, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])        bound = -<span class="hljs-number">1e5</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> intervals:            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>] &lt; bound:                res += <span class="hljs-number">1</span>                bound = <span class="hljs-built_in">min</span>(bound, t[<span class="hljs-number">1</span>])            <span class="hljs-keyword">else</span>:                bound = t[<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="递增的三元子序列">334. 递增的三元子序列</h3><p>首先使用暴力，不幸地超出时间限制了。一看 <code>nums.length</code> 哦5e5 啊，O(n3) 那肯定 OOT 了。</p><p>ok，试了一些基础方法，比如转 <code>hashmap</code>存下标这样的方式还是没能解这个题。但是能感觉到这个题解的代码是一个动态的过程，但又列不出状态转移方程，那肯定就是贪心了。定义<code>min_1</code> 记录最小值，定义 <code>min_2</code>记录第二小值，那么当一个数比目前的第二小值大时显然就得到了解。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increasingTriplet</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        min_1 = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)        min_2 = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i &lt;= min_1:                min_1 = i            <span class="hljs-keyword">elif</span> i&lt;= min_2:                min_2 = i            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="除自身以外数组的乘积">238. 除自身以外数组的乘积</h3><p>前缀和问题，分别正序和逆序遍历数组找出当前元素之前的积得到<code>pre</code> 与 <code>suf</code> 数组，将 <code>suf</code>反序（因为是逆序遍历的），然后对于结果来说就是当前位置的前缀积与后缀积相乘。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        pre = []        suf = []        temp = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            pre.append(temp)            temp *= i        temp = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums[::-<span class="hljs-number">1</span>]:            suf.append(temp)            temp *= i        suf[:] = suf[::-<span class="hljs-number">1</span>]        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            res.append(pre[i]*suf[i])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="和为-k-的子数组">560. 和为 K 的子数组</h3><p>前缀和 + hashmap 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        pre_sum = [<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            pre_sum.append(pre_sum[-<span class="hljs-number">1</span>]+i)        hashmap = &#123;<span class="hljs-number">0</span>:<span class="hljs-number">1</span>&#125;        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            temp = pre_sum[i+<span class="hljs-number">1</span>]-k            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">in</span> hashmap:                res += hashmap[temp]            <span class="hljs-keyword">if</span> pre_sum[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[pre_sum[i+<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[pre_sum[i+<span class="hljs-number">1</span>]] += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="字符串-1">字符串</h2><h3 id="字符串相加">415. 字符串相加</h3><p>模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addStrings</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&quot;&quot;</span>        i, j, carry = <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-number">0</span>:            n1 = <span class="hljs-built_in">int</span>(num1[i]) <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            n2 = <span class="hljs-built_in">int</span>(num2[j]) <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            temp = n1 + n2 + carry            carry = temp // <span class="hljs-number">10</span>            res = <span class="hljs-built_in">str</span>(temp % <span class="hljs-number">10</span>) + res            i, j = i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span> + res <span class="hljs-keyword">if</span> carry <span class="hljs-keyword">else</span> res</code></pre></div><h3 id="最长回文串">409. 最长回文串</h3><p>用 <code>dict</code> 去统计每个字符出现的次数，如果是偶数可以直接用<code>n</code> 个字符构成回文串，如果是奇数则可以用 <code>n-1</code>个字符来构成，不过这时要标记遇到了奇数，之后如果标记位为真说明遇到了奇数，结果就会加1 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        hashmap = &#123;&#125;        flag = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> value&amp;<span class="hljs-number">1</span>:                res += value - <span class="hljs-number">1</span>                flag = <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                res += value        <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> res</code></pre></div><h3 id="单词规律">290. 单词规律</h3><p>用 <code>dict</code> 去计数匹配。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        dict_pos = &#123;&#125;        dict_nag = &#123;&#125;        lst_ptn = <span class="hljs-built_in">list</span>(pattern)        lst_s = s.split()        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst_ptn) != <span class="hljs-built_in">len</span>(lst_s):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(lst_ptn, lst_s):            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_pos:                dict_pos[k] = v            dict_nag[v] = k        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_pos) != <span class="hljs-built_in">len</span>(dict_nag):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_pos.items():            <span class="hljs-keyword">if</span> k != dict_nag[v]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="划分字母区间">763. 划分字母区间</h3><p>用 <code>dict</code>去记录每个字母首次出现尾次出现的索引，然后根据首次出现的索引排序，遍历排序后的索引，并记录首次索引和尾次索引。会遇到3 种情况：</p><ul><li>遍历的首次索引大于当前记录的尾次出现索引 -将当前结果添加，更新当前记录的首次索引和尾次索引。</li><li>遍历的尾次索引大于当前记录的尾次索引 - 更新当前记录的尾次索引。</li><li>遍历的首尾区间被当前记录的索引包含 - 不处理。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionLabels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[v] = (i, i)            <span class="hljs-keyword">else</span>:                start, end = hashmap[v]                hashmap[v] = (start, i)        sorted_index = <span class="hljs-built_in">sorted</span>(hashmap.items(), key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])        res = []        start = -<span class="hljs-number">1</span>        end = -<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sorted_index:            <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; end:                res.append(end-start+<span class="hljs-number">1</span>)                start = i[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]                end = i[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]            <span class="hljs-keyword">elif</span> i[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &gt; end:                end = i[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]        res.append(end-start+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>:]</code></pre></div><h3 id="字母异位词分组">49. 字母异位词分组</h3><p>这道题主要考察如何将具有相同特征（字母异位词）作为 <code>dict</code>的 <code>key</code> ，毕竟如果只是对每个字母做计数得到的子<code>dict</code> 是不能作为 <code>key</code>的。因此首先我想到的是计数之后再双循环去处理，不幸地超时了。然后可以将每个单词重新排序后作为<code>key</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:            temp = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>([_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> i]))            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[temp] = [i]            <span class="hljs-keyword">else</span>:                hashmap[temp] += [i]        <span class="hljs-keyword">return</span> [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> hashmap.values()]</code></pre></div><p>官解里提到的另一种方法实际也是再找寻合适的 <code>key</code>，也是不排序直接计数的方法，我最开始也这样想但是没想到。官解这里采用长度为26 的 <code>list</code>来记录字母出现的次数，<code>ord(x)-ord('a')</code>即为对应数组下标，再将 <code>list</code> 转为 <code>tuple</code>以实现哈希。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> strs:            temp = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:                temp[<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>            temp = <span class="hljs-built_in">tuple</span>(temp)            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[temp] = [t]            <span class="hljs-keyword">else</span>:                hashmap[temp] += [t]        <span class="hljs-keyword">return</span> [_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> hashmap.values()]</code></pre></div><h3 id="字符串相乘">43. 字符串相乘</h3><p>这题前几天在编程能力计划里做过，不再赘述。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-number">0</span>        flag1 = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num1[::-<span class="hljs-number">1</span>]:            adv = <span class="hljs-number">0</span>            temp = <span class="hljs-number">0</span>            flag2 = <span class="hljs-number">1</span>            i = <span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">48</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> num2[::-<span class="hljs-number">1</span>]:                j = <span class="hljs-built_in">ord</span>(j)-<span class="hljs-number">48</span>                mul = (i*j+adv)                adv = mul//<span class="hljs-number">10</span>                temp += (mul%<span class="hljs-number">10</span>)*flag2                flag2 *= <span class="hljs-number">10</span>            res += (temp+adv*flag2) * flag1            flag1 *= <span class="hljs-number">10</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(res)</code></pre></div><h3 id="重复的dna序列">187. 重复的DNA序列</h3><p>用 2 个 <code>set</code>来记录，一个存放已经出现过的序列，另一个用来存放结果，如果已经出现过，就添加进结果中。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRepeatedDnaSequences</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        res = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):            temp = s[i:i+<span class="hljs-number">10</span>]            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(temp)            <span class="hljs-keyword">else</span>:                res.add(temp)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(res)</code></pre></div><h3 id="最长回文子串">5. 最长回文子串</h3><p>暴力，过了。从长到短取序列，如果某个序列是回文串，直接返回他。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s_len = <span class="hljs-built_in">len</span>(s)        c_len = s_len        <span class="hljs-keyword">while</span> c_len &gt; <span class="hljs-number">0</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-c_len+<span class="hljs-number">1</span>):                temp = s[i:i+c_len]                <span class="hljs-keyword">if</span> temp == temp[::-<span class="hljs-number">1</span>]:                    <span class="hljs-keyword">return</span> temp            c_len -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>中心扩散算法，对每个点开始从中心往左右两边扩散直到扩散结果不是回文串。这个算法的难点在于有两种情况，比如<code>aba</code> 与 <code>abba</code> 这两个字符串，都从第一个<code>b</code>开始扩散，很难同时进行处理，所以这里需要假设两种情况扩散的结果，选取最大回文串。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_palindrome</span>(<span class="hljs-params">s, l, r</span>):            <span class="hljs-keyword">while</span> l&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r&lt;<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[l]==s[r]:                l -= <span class="hljs-number">1</span>                r += <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> l,r                s_len = <span class="hljs-built_in">len</span>(s)        left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):            l1, r1 = get_palindrome(s, i, i)            l2, r2 = get_palindrome(s, i, i+<span class="hljs-number">1</span>)            <span class="hljs-keyword">if</span> r1-l1 &gt; right-left:                left, right = l1,r1            <span class="hljs-keyword">if</span> r2-l2 &gt; right-left:                left, right = l2,r2        <span class="hljs-keyword">return</span> s[left+<span class="hljs-number">1</span>:right]</code></pre></div><p>中心扩散这个算法其实有点动态规划的思想在里面，我之前其实很少遇到二维dp ，这里用 <code>dp[i][j]</code> 表示字符串 <code>s[i:j]</code>是否是回文字符串，可以列出如下状态转移方程： <spanclass="math display">\[dp[i][j]=\begin{cases}dp[i+1][j-1]\&amp;(s[i]==s[j])\ \ \ \ if\ j&gt;i+1\\s[i]==s[j]\ \ \ \ if\ j=i+1\\True\ \ \ \ if\ i==j\end{cases}\]</span>但是得注意，这里跟暴力不太一样，是从小往大推，不是从大往小推（否则算<code>dp[i][j]</code> 时根本不知道 <code>dp[i+1][j-1]</code> ）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s_len = <span class="hljs-built_in">len</span>(s)        dp = [[<span class="hljs-literal">False</span>]*s_len <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):            dp[i][i] = <span class="hljs-literal">True</span>        start, max_len = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> c_len <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,s_len+<span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-c_len+<span class="hljs-number">1</span>):                j = i+c_len-<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> s[i] != s[j]:                    dp[i][j] = <span class="hljs-literal">False</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">if</span> j&gt;i+<span class="hljs-number">1</span>:                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]                    <span class="hljs-keyword">else</span>:                        dp[i][j] = <span class="hljs-literal">True</span>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> c_len&gt;max_len:                    start = i                    max_len = c_len        <span class="hljs-keyword">return</span> s[start:start+max_len]</code></pre></div><p>但是动态规划，这里也不快。</p><h2 id="链表-1">链表</h2><h3 id="两数相加">2. 两数相加</h3><p>一种方式是先把 <code>l1</code> 与 <code>l2</code>的数都取出来相加之后再根据结果生成新的链表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        num1 = <span class="hljs-number">0</span>        digit = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l1:            num1 += l1.val*digit            l1 = l1.<span class="hljs-built_in">next</span>            digit *= <span class="hljs-number">10</span>        num2 = <span class="hljs-number">0</span>        digit = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l2:            num2 += l2.val*digit            l2 = l2.<span class="hljs-built_in">next</span>            digit *= <span class="hljs-number">10</span>        res_num = num1+num2        dummy = ListNode()        temp = dummy        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(res_num)[::-<span class="hljs-number">1</span>]:            temp.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">int</span>(i))            temp = temp.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>否则我们需要哨兵节点用于返回最终的链表，并需要前置节点用于将当前数位两数之和结果相加。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        node = dummy        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:            temp = carry            <span class="hljs-keyword">if</span> l1:                temp += l1.val                l1 = l1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> l2:                temp += l2.val                l2 = l2.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> temp &gt;= <span class="hljs-number">10</span>:                temp -= <span class="hljs-number">10</span>                carry = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                carry = <span class="hljs-number">0</span>            node.<span class="hljs-built_in">next</span> = ListNode(temp)            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> carry:            node.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="环形链表-ii">142. 环形链表 II</h3><p>用 <code>set</code>存储每个节点然后遍历链表，如果节点已经存在，那么这个节点就是入环第一个节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">while</span> head:            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(head)                head = head.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> head        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>快慢指针，快指针走的步数减去慢指针走的步数一定是环的整数倍。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        fast, slow = head, head        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            slow = slow.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> fast == slow:                temp = head                <span class="hljs-keyword">while</span> temp != slow:                    temp = temp.<span class="hljs-built_in">next</span>                    slow = slow.<span class="hljs-built_in">next</span>                <span class="hljs-keyword">return</span> temp        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="相交链表">160. 相交链表</h3><p>用 <code>set</code> 存储 <code>headA</code> 的每个节点，然后遍历<code>headB</code> 看节点是否在 <code>set</code> 中。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        setA = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">while</span> headA:            setA.add(headA)            headA = headA.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> headB:            <span class="hljs-keyword">if</span> headB <span class="hljs-keyword">in</span> setA:                <span class="hljs-keyword">return</span> headB            headB = headB.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>或者用两个 <code>set</code> 存储，在时间效率上有一定的优化。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        setA, setB = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>), <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">while</span> headA <span class="hljs-keyword">or</span> headB:            <span class="hljs-keyword">if</span> headA:                <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">in</span> setB: <span class="hljs-keyword">return</span> headA                setA.add(headA)                headA = headA.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> headB:                <span class="hljs-keyword">if</span> headB <span class="hljs-keyword">in</span> setA: <span class="hljs-keyword">return</span> headB                setB.add(headB)                headB = headB.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>双指针，一个以 <code>headA+headB</code> 顺序遍历，一个以<code>headB+headA</code> 顺序遍历，相遇的时候就是相交节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> headA <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> headB:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        nodeA = headA        nodeB = headB        <span class="hljs-keyword">while</span> nodeA != nodeB:            nodeA = headB <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nodeA <span class="hljs-keyword">else</span> nodeA.<span class="hljs-built_in">next</span>            nodeB = headA <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nodeB <span class="hljs-keyword">else</span> nodeB.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> nodeA</code></pre></div><h3 id="删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素II</h3><p>一个哨兵节点用于返回结果链表，另一个用于记录新链表节点。循环遍历<code>head</code> ，假设 <code>temp</code> 是 <code>head</code>节点的下个节点：</p><ul><li>如果 <code>temp</code> 是空节点或者<code>temp.val != head.val</code> 则将当前 <code>head</code>节点添加至记录。</li><li>否则 <code>head</code> 移到不是重复元素的位置。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        node = dummy        <span class="hljs-keyword">while</span> head:            temp = head.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp <span class="hljs-keyword">or</span> temp.val != head.val:                node.<span class="hljs-built_in">next</span> = head                head = head.<span class="hljs-built_in">next</span>                node = node.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">while</span> temp <span class="hljs-keyword">and</span> temp.val == head.val:                    temp = temp.<span class="hljs-built_in">next</span>                head = temp        node.<span class="hljs-built_in">next</span> = head        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="两两交换链表中的节点">24. 两两交换链表中的节点</h3><p>模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">return</span> head        dummy = ListNode()        node = dummy        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.<span class="hljs-built_in">next</span>:            p1 = head            p2 = head.<span class="hljs-built_in">next</span>            p1.<span class="hljs-built_in">next</span>, p2.<span class="hljs-built_in">next</span> = p2.<span class="hljs-built_in">next</span>, p1            node.<span class="hljs-built_in">next</span> = p2            node = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            head = head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="设计链表">707. 设计链表</h3><p><code>list</code> 实现。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>        self.nums = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.nums[index]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.addAtIndex(<span class="hljs-number">0</span>, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.addAtIndex(self.<span class="hljs-built_in">len</span>, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> index &gt; self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        index = <span class="hljs-built_in">max</span>(index, <span class="hljs-number">0</span>)        self.<span class="hljs-built_in">len</span> += <span class="hljs-number">1</span>        self.nums.insert(index, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        self.<span class="hljs-built_in">len</span> -= <span class="hljs-number">1</span>        <span class="hljs-keyword">del</span> self.nums[index]</code></pre></div><p>单向链表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span></span>):        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.size = <span class="hljs-number">0</span>        self.head = ListNode(<span class="hljs-number">0</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.size:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        node = self.head        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index+<span class="hljs-number">1</span>):            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> node.val    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.addAtIndex(<span class="hljs-number">0</span>, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        self.addAtIndex(self.size, val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> index &gt; self.size:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        index = <span class="hljs-built_in">max</span>(index, <span class="hljs-number">0</span>)        self.size += <span class="hljs-number">1</span>        node = self.head        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):            node = node.<span class="hljs-built_in">next</span>        temp = ListNode(val)        temp.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = temp    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.size:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        self.size -= <span class="hljs-number">1</span>        node = self.head        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):            node = node.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span></code></pre></div><h3 id="k-个一组翻转链表">25. K 个一组翻转链表</h3><p>用栈可以很轻松的解决，直接每次 <code>k</code>个节点进栈，然后出栈生成新链表，为了防止节点不够进栈的情况，每次进栈前先记录一下节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        res = ListNode()        node = res        stack = []        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            pre = head            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:                    node.<span class="hljs-built_in">next</span> = pre                    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span>                stack.append(head)                head = head.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">while</span> stack:                temp = stack.pop()                node.<span class="hljs-built_in">next</span> = temp                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="重排链表">143. 重排链表</h3><p>在编程能力里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reorderList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-literal">None</span>:        queue = collections.deque()        <span class="hljs-keyword">while</span> head:            queue.append(head)            head = head.<span class="hljs-built_in">next</span>        dummy = ListNode()        node = dummy        <span class="hljs-keyword">while</span> queue:            <span class="hljs-keyword">if</span> queue:                node.<span class="hljs-built_in">next</span> = queue.popleft()                node = node.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> queue:                node.<span class="hljs-built_in">next</span> = queue.pop()                node = node.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        head = dummy.<span class="hljs-built_in">next</span></code></pre></div><h2 id="栈-队列-1">栈 / 队列</h2><h3 id="最小栈">155. 最小栈</h3><p>最开始读这道题没读懂，后面发现原来这个题既想记录元素入栈的顺序又想记录最小值，那么比较合理的就是采用空间换时间的方法，两个栈，一个正常存数，一个存最小值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.stack = []        self.minstack = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-keyword">if</span> self.minstack:            _<span class="hljs-built_in">min</span> = self.minstack[-<span class="hljs-number">1</span>]            _<span class="hljs-built_in">min</span> = <span class="hljs-built_in">min</span>(val, _<span class="hljs-built_in">min</span>)            self.minstack.append(_<span class="hljs-built_in">min</span>)            self.stack.append(val)        <span class="hljs-keyword">else</span>:            self.minstack.append(val)            self.stack.append(val)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:        self.stack.pop()        self.minstack.pop()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> self.minstack[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="移除无效的括号">1249. 移除无效的括号</h3><p>可以采用一个栈来记录有效的括号，遍历字符串时，如果遇到左括号，下标入栈，如果遇到右括号，那么判断是否可出栈，能出则出，不能说明这个右括号是无效的，把下标记录一下。遍历完成后，还在栈里的下标说明这些左括号找不到匹配的右括号，也记录。最后凡是记录的位置不添加到结果里。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minRemoveToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        stack = []        error = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;(&#x27;</span>:                stack.append(i)            <span class="hljs-keyword">elif</span> v == <span class="hljs-string">&#x27;)&#x27;</span>:                <span class="hljs-keyword">if</span> stack:                    stack.pop()                <span class="hljs-keyword">else</span>:                    error.add(i)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:            error.add(i)        res = []        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> error:                res.append(v)        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)</code></pre></div><h3 id="找出游戏的获胜者">1823. 找出游戏的获胜者</h3><p>可以采用一个队列来模拟实际游戏情况。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheWinner</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        queue = collections.deque()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):            queue.append(i)        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">1</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):                temp = queue.popleft()                <span class="hljs-keyword">if</span> i!=k-<span class="hljs-number">1</span>:                    queue.append(temp)        <span class="hljs-keyword">return</span> queue.popleft()</code></pre></div><p>但是其实我们是知道哪个位置的元素被删的，是 <code>start+k-1</code>这个位置，所以可以直接删这个元素。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheWinner</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        flag = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>)]        start = <span class="hljs-number">0</span>        count = n        <span class="hljs-keyword">while</span> count != <span class="hljs-number">1</span>:            index = (start+k-<span class="hljs-number">1</span>)%count            flag.pop(index)            start = index            count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> flag[<span class="hljs-number">0</span>]</code></pre></div><h2 id="树-1">树</h2><h3 id="将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h3><p>从数组中点开始递归构建二叉平衡树。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_BST</span>(<span class="hljs-params">l, r</span>):            mid = (l+r) // <span class="hljs-number">2</span>            node = TreeNode(nums[mid])            <span class="hljs-keyword">if</span> l&lt;=mid-<span class="hljs-number">1</span>:                node.left = insert_BST(l,mid-<span class="hljs-number">1</span>)            <span class="hljs-keyword">if</span> r&gt;=mid+<span class="hljs-number">1</span>:                node.right = insert_BST(mid+<span class="hljs-number">1</span>,r)            <span class="hljs-keyword">return</span> node                <span class="hljs-keyword">return</span> insert_BST(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)</code></pre></div><h3 id="从前序与中序遍历序列构造二叉树">105.从前序与中序遍历序列构造二叉树</h3><p>二叉树的前序遍历是 <code>NLR</code> ，中序遍历是 <code>LNR</code>，因此，<code>preorder</code> 的首个元素一定是 <code>root</code>节点，然后根据 <code>root</code> 在 <code>inorder</code>中的位置可以区分出左右子树的 <code>inorder</code>，然后可以根据左右子树的 <code>inorder</code> 数量来找出左右子树的<code>preorder</code> 。递归构造二叉树。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        node = TreeNode(preorder[<span class="hljs-number">0</span>])        index_node = inorder.index(preorder[<span class="hljs-number">0</span>])        left_num = index_node        node.left = self.buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-number">1</span>+left_num], inorder[:index_node])        node.right = self.buildTree(preorder[<span class="hljs-number">1</span>+left_num:], inorder[index_node+<span class="hljs-number">1</span>:])        <span class="hljs-keyword">return</span> node</code></pre></div><p>我们可以使用 <code>dict</code>对于查找根节点进行一个优化，但是就不能像上面那样传新的 <code>list</code>了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:            <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build</span>(<span class="hljs-params">preorder_left, preorder_right, inorder_left, inorder_right</span>):            <span class="hljs-keyword">if</span> preorder_left &gt; preorder_right:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            preorder_root = preorder_left            inorder_root = hashmap[preorder[preorder_root]]            root = TreeNode(preorder[preorder_root])            size_left_subtree = inorder_root - inorder_left            root.left = _build(preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>)                       root.right = _build(preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right)            <span class="hljs-keyword">return</span> root        hashmap=&#123;v:i <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(inorder)&#125;        <span class="hljs-keyword">return</span> _build(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder)-<span class="hljs-number">1</span>)</code></pre></div><h3 id="二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</h3><p>简单的层次遍历，根据不同层数添加不同遍历方向的值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        queue = [root]        res = []        count = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> queue:            temp = []            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.pop(<span class="hljs-number">0</span>)                temp.append(node.val)                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)            <span class="hljs-keyword">if</span> count&amp;<span class="hljs-number">1</span>:                res.append(temp)            <span class="hljs-keyword">else</span>:                res.append(temp[::-<span class="hljs-number">1</span>])            count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="二叉树的右视图">199. 二叉树的右视图</h3><p>依然是二叉树的层次遍历，我们在添加节点时从右往左添加并且只将第一个出队的值添加进结果中即可。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        queue = [root]        res = []        <span class="hljs-keyword">while</span> queue:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.pop(<span class="hljs-number">0</span>)                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:                    res.append(node.val)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="路径总和-ii">113. 路径总和 II</h3><p>带其它信息的搜索，深度优先搜索和广度优先搜索都可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        queue = collections.deque()        res = []        queue.append((root, [root.val], root.val))        <span class="hljs-keyword">while</span> queue:            node, path, path_sum = queue.popleft()            <span class="hljs-keyword">if</span> node.left: queue.append((node.left, path+[node.left.val], path_sum+node.left.val))            <span class="hljs-keyword">if</span> node.right: queue.append((node.right, path+[node.right.val], path_sum+node.right.val))            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:                <span class="hljs-keyword">if</span> path_sum == targetSum:                    res.append(path)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h3><p>在查询并删除某个节点中，可能会遇到以下几种情况。</p><ul><li>当前节点为空，返回空节点。</li><li>当前节点值大于目标值，那么应该去左子树寻找目标节点，相当于对左子树运用同样的函数删一次，因此<code>root.left = self.deleteNode(root.left, key)</code> 。</li><li>当前节点值小于目标值，那么应该去右子树寻找目标节点。</li><li>当前节点值等于目标值，也就是找到了。<ul><li>如果没有左子树，那么直接用右子节点覆盖当前节点就行了。</li><li>同样如果没有右子树，那么直接用左子节点覆盖当前节点就行了。</li><li>如果都有的话，可以将左子树接到右子树的最左节点，然后用右子树覆盖当前节点。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> root.val &gt; key:            root.left = self.deleteNode(root.left, key)        <span class="hljs-keyword">elif</span> root.val &lt; key:            root.right = self.deleteNode(root.right, key)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left: <span class="hljs-keyword">return</span> root.right            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.right: <span class="hljs-keyword">return</span> root.left            node = root.right            <span class="hljs-keyword">while</span> node.left:                node = node.left            node.left = root.left            root = root.right        <span class="hljs-keyword">return</span> root</code></pre></div><p>还有一种方法，将二叉搜索树中序遍历，并且如果遇到目标值就跳过。在根据<code>list</code> 构造二叉搜索树的方法生成新的树。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        nums = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            LNR(node.left)            <span class="hljs-keyword">if</span> node.val != key: nums.append(node.val)            LNR(node.right)        LNR(root)        nums_len = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">if</span> nums_len == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_BST</span>(<span class="hljs-params">l, r</span>):            mid = (l+r)//<span class="hljs-number">2</span>            node = TreeNode(val=nums[mid])            <span class="hljs-keyword">if</span> l&lt;=mid-<span class="hljs-number">1</span>:                node.left = insert_BST(l, mid-<span class="hljs-number">1</span>)            <span class="hljs-keyword">if</span> r&gt;=mid+<span class="hljs-number">1</span>:                node.right = insert_BST(mid+<span class="hljs-number">1</span>, r)            <span class="hljs-keyword">return</span> node        <span class="hljs-keyword">return</span> insert_BST(<span class="hljs-number">0</span>, nums_len-<span class="hljs-number">1</span>)</code></pre></div><h3 id="二叉搜索树中第k小的元素">230. 二叉搜索树中第K小的元素</h3><p>暴力解法，先将二叉搜索树中序遍历，然后返回第 <code>K</code>小的元素。递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        nums = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">LNR</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            LNR(node.left)            nums.append(node.val)            LNR(node.right)        LNR(root)        <span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]</code></pre></div><p>非递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        nums = []        stack = []        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:            <span class="hljs-keyword">while</span> root:                stack.append(root)                root = root.left            root = stack.pop()            nums.append(root.val)            root = root.right        <span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]</code></pre></div><p>其实在非递归这里可以看出来，只要数组里有 <code>k</code>个元素就行了，根本不需要遍历完。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        counter = <span class="hljs-number">0</span>        stack = []        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:            <span class="hljs-keyword">while</span> root:                stack.append(root)                root = root.left            root = stack.pop()            counter += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> counter == k: <span class="hljs-keyword">return</span> root.val            root = root.right        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="二叉搜索树迭代器">173. 二叉搜索树迭代器</h3><p>在初始化 <code>__init__</code>里把二叉搜索树的遍历结果写好，之后就很简单。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):        nums = []        stack = []        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:            <span class="hljs-keyword">while</span> root:                stack.append(root)                root = root.left            root = stack.pop()            nums.append(root.val)            root = root.right        self.index = <span class="hljs-number">0</span>        self.nums = nums        self.<span class="hljs-built_in">len</span> = <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:        res = self.nums[self.index]        self.index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> self.index&lt;self.<span class="hljs-built_in">len</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h3><p>暴力解法，搜索 <code>p</code> , <code>q</code>。遍历找出这两个节点，并且记录路径，逆序比较后得到最近公共祖先。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:        queue = collections.deque()        queue.append((root,[root]))        p_ancestors = <span class="hljs-literal">None</span>        q_ancestors = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> queue:            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node, ancestors = queue.pop()                <span class="hljs-keyword">if</span> node == p:                    p_ancestors = ancestors                <span class="hljs-keyword">if</span> node == q:                    q_ancestors = ancestors                <span class="hljs-keyword">if</span> p_ancestors <span class="hljs-keyword">and</span> q_ancestors:                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">if</span> node.left: queue.append((node.left, ancestors+[node.left]))                <span class="hljs-keyword">if</span> node.right: queue.append((node.right, ancestors+[node.right]))        <span class="hljs-keyword">for</span> p_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(p_ancestors):            <span class="hljs-keyword">for</span> q_ancestor <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(q_ancestors):                <span class="hljs-keyword">if</span> p_ancestor == q_ancestor:                    <span class="hljs-keyword">return</span> p_ancestor        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="二叉树的序列化与反序列化">297. 二叉树的序列化与反序列化</h3><p>都可以使用二叉树的遍历去解决。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root</span>):        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>        res = []        queue = collections.deque()        queue.append(root)        <span class="hljs-keyword">while</span> queue:            node = queue.popleft()            <span class="hljs-keyword">if</span> node:                res.append(<span class="hljs-built_in">str</span>(node.val))                queue.append(node.left)                queue.append(node.right)            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;,&#x27;</span>.join(res)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data</span>):        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        data = data.split(<span class="hljs-string">&#x27;,&#x27;</span>)        root = TreeNode(data[<span class="hljs-number">0</span>])        queue = collections.deque()        queue.append(root)        i = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> queue:            node = queue.popleft()            <span class="hljs-keyword">if</span> data[i] != <span class="hljs-string">&#x27;&#x27;</span>:                node.left = TreeNode(<span class="hljs-built_in">int</span>(data[i]))                queue.append(node.left)            i += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> data[i] != <span class="hljs-string">&#x27;&#x27;</span>:                node.right = TreeNode(<span class="hljs-built_in">int</span>(data[i]))                queue.append(node.right)            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> root</code></pre></div><h2 id="图">图</h2><h3 id="找到小镇的法官">997. 找到小镇的法官</h3><p>用 <code>dict</code> 记录每个人的信任其人数，用 <code>set</code>记录信任过别人的人，如果满足信任某个人人数等于 <code>n-1</code>并且他没有信任的人，他就是法官，否则没有法官。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findJudge</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, trust: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;i:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#125;        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> p,t <span class="hljs-keyword">in</span> trust:            hashset.add(p)            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[t] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[t] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> p,count <span class="hljs-keyword">in</span> hashmap.items():            <span class="hljs-keyword">if</span> count == n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> p        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h3 id="可以到达所有点的最少点数目">1557.可以到达所有点的最少点数目</h3><p>推演几次可以发现可以到达所有点的最少点其实就是不能由其它点到达的点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findSmallestSetOfVertices</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashset = &#123;t <span class="hljs-keyword">for</span> f,t <span class="hljs-keyword">in</span> edges&#125;        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset]</code></pre></div><h3 id="钥匙和房间">841. 钥匙和房间</h3><p>这个和上道题不一样的是这道题的图是有可能有环的，因此直接沿用上道题的方法可能不行，可以加一个栈或队列进行图的搜索，搜索结果就是<code>0</code> 能到达的点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canVisitAllRooms</span>(<span class="hljs-params">self, rooms: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        queue = collections.deque()        queue.append(<span class="hljs-number">0</span>)        <span class="hljs-keyword">while</span> queue:            node = queue.popleft()            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> rooms[node]:                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                    queue.append(i)                    hashset.add(i)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(rooms)):            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h2 id="优先队列">优先队列</h2><h3 id="数组中的第k个最大元素">215. 数组中的第K个最大元素</h3><p>可以调用优先队列 <code>heapq</code> 这个包。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        heapq.heapify(nums)        res = <span class="hljs-literal">None</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-k+<span class="hljs-number">1</span>):            res = heapq.heappop(nums)        <span class="hljs-keyword">return</span> res</code></pre></div><p>当然实质上排序也是可以的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>)[k-<span class="hljs-number">1</span>]</code></pre></div><p>我这里排序能过，应该是快排，如果我设立一个 <code>k</code>大小的数组用来存放前 <code>k</code>大的值，然后用二分法去添加新的比这个数组最小值更大的值的方法，过不了，应该是重构<code>list</code> 太慢了。</p><h3 id="前-k-个高频元素">347. 前 K 个高频元素</h3><p>用 <code>dict</code> 进行计数（其实用<code>collections.Counter</code> 更快），然后根据数量排序就行。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        counter = collections.Counter(nums)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(counter, reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x:counter[x])[:k]</code></pre></div><p>或者。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        counter = collections.Counter(nums).most_common(k)        <span class="hljs-keyword">return</span> [t[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> counter]</code></pre></div><h3 id="根据字符出现频率排序">451. 根据字符出现频率排序</h3><p>先对每个字符计数，再根据计数排序，再构建结果字符串。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">frequencySort</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        hashmap = collections.Counter(s)        feq = <span class="hljs-built_in">sorted</span>(hashmap, key=<span class="hljs-keyword">lambda</span> x:hashmap[x], reverse=<span class="hljs-literal">True</span>)        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> feq:            res += t*hashmap[t]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="最接近原点的-k-个点">973. 最接近原点的 K 个点</h3><p>之前做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kClosest</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]+x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>])[:k]</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>linked list</tag>
      
      <tag>array</tag>
      
      <tag>tree</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「SQL」 - 学习计划</title>
    <link href="/2022/12/22/leetcodeSQL/"/>
    <url>/2022/12/22/leetcodeSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="sql-入门">SQL 入门</h1><h2 id="选择">选择</h2><h3 id="大的国家">595. 大的国家</h3><p>简单的条件筛选。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    name,    population,    areaFROM    WorldWHERE    area &gt;= 3000000    OR population &gt;= 25000000;</code></pre></div><h3 id="可回收且低脂的产品">1757. 可回收且低脂的产品</h3><p>也是简单的条件筛选。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    product_idFROM    ProductsWHERE    low_fats = &#x27;Y&#x27;    AND recyclable = &#x27;Y&#x27;;</code></pre></div><h3 id="寻找用户推荐人">584. 寻找用户推荐人</h3><p>这道题注意 <code>!=</code> , <code>=</code> , <code>&gt;</code> ,<code>&lt;</code> 这些会忽略 <code>NULL</code> ，让结果中没有<code>NULL</code> 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    nameFROM    customerWHERE    referee_id != 2    OR referee_id IS NULL;</code></pre></div><h3 id="从不订购的客户">183. 从不订购的客户</h3><p>子查询：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    Name AS CustomersFROM    CustomersWHERE    Id NOT IN (        SELECT DISTINCT CustomerId FROM Orders    );</code></pre></div><p>左连接：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    Name AS CustomersFROM    Customers    LEFT JOIN Orders ON Customers.Id = Orders.CustomerIdWHERE    Orders.CustomerId IS NULL;</code></pre></div><h2 id="排序-修改">排序 &amp; 修改</h2><h3 id="计算特殊奖金">1873. 计算特殊奖金</h3><p>两次查询结果合并， <code>UNION+WHERE</code> ：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    employee_id,    salary AS bonusFROM    EmployeesWHERE    employee_id &amp; 1    AND name NOT LIKE &#x27;M%&#x27;UNIONSELECT    employee_id,    0 AS bonusFROM    EmployeesWHERE    employee_id &amp; 1 != 1    OR name LIKE &#x27;M%&#x27;ORDER BY    employee_id ASC;</code></pre></div><p>MySQL 中有个函数 LEFT 也可以：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    employee_id,    salary AS bonusFROM    EmployeesWHERE    employee_id &amp; 1    AND LEFT(name, 1) != &#x27;M&#x27;UNIONSELECT    employee_id,    0 AS bonusFROM    EmployeesWHERE    employee_id &amp; 1 != 1    OR LEFT(name, 1) = &#x27;M&#x27;ORDER BY    employee_id ASC;</code></pre></div><p>CASE WHEN 也可以：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    employee_id,    (CASE WHEN employee_id&amp;1 AND LEFT(name, 1) != &#x27;M&#x27; THEN salary ELSE 0 END) AS bonusFROM    EmployeesORDER BY    employee_id ASC;</code></pre></div><p>IF 也可以：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    employee_id,    IF(employee_id&amp;1 AND LEFT(name, 1) != &#x27;M&#x27;, salary, 0) AS bonusFROM    EmployeesORDER BY    employee_id ASC;</code></pre></div><h3 id="变更性别">627. 变更性别</h3><p>IF 函数：</p><div class="code-wrapper"><pre><code class="hljs mysql">UPDATE    SalarySET    sex=IF(sex=&#x27;m&#x27;, &#x27;f&#x27;, &#x27;m&#x27;);</code></pre></div><p>CASE WHEN 语句：</p><div class="code-wrapper"><pre><code class="hljs mysql">UPDATE    SalarySET    sex=(CASE sex WHEN &#x27;m&#x27; THEN &#x27;f&#x27; ELSE &#x27;m&#x27; END);</code></pre></div><p>还有个 ASCII 码于字符转换的方法：</p><div class="code-wrapper"><pre><code class="hljs mysql">UPDATE    SalarySET    sex=CHAR(109+102-ASCII(sex));</code></pre></div><h3 id="删除重复的电子邮箱">196. 删除重复的电子邮箱</h3><p>自连接：</p><div class="code-wrapper"><pre><code class="hljs mysql">DELETE     p1FROM    Person AS p1,Person AS p2WHERE    p1.id &gt; p2.id    AND p1.email = p2.email;</code></pre></div><h2 id="字符串处理函数正则">字符串处理函数/正则</h2><h3 id="修复表中的名字">1667. 修复表中的名字</h3><p>CONCAT, UPPER, LOWER, LEFT, SUBSTRING 这几个函数的用法。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    user_id,    CONCAT(UPPER(LEFT(name,1)), LOWER(LOWER(SUBSTRING(name, 2)))) AS nameFROM    UsersORDER BY    user_id ASC;</code></pre></div><h3 id="按日期分组销售产品">1484. 按日期分组销售产品</h3><p>刷 SQL 我怎么感觉算是刷 SQL 函数的使用。这道题是讲 GROUP_CONCAT这个函数：</p><div class="code-wrapper"><pre><code class="hljs mysql">GROUP_CONCAT(DISTINCT expression    ORDER BY expression    SEPARATOR sep);</code></pre></div><p>还有就是 COUNT 这个函数括号里可以有 DISTINCT 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    sell_date,    COUNT(DISTINCT product) AS num_sold,    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR &#x27;,&#x27;) AS productsFROM    ActivitiesGROUP BY    sell_dateORDER BY    sell_date ASC;</code></pre></div><h3 id="患某种疾病的患者">1527. 患某种疾病的患者</h3><p>LIKE 的用法，两种情况：</p><ul><li>第一个元素以 <code>DIAB1</code> 开头，对应 <code>'DIAB1%'</code>。</li><li>非第一个元素以 <code>DIAB1</code> 开头，对应 <code>'% DIAB1%'</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    patient_id,    patient_name,    conditionsFROM    PatientsWHERE    conditions LIKE &#x27;DIAB1%&#x27;    OR conditions LIKE &#x27;% DIAB1%&#x27;;</code></pre></div><h2 id="组合查询-指定选取">组合查询 &amp; 指定选取</h2><h3 id="丢失信息的雇员">1965. 丢失信息的雇员</h3><p>MySQL 居然没有 FULL OUTER JOIN ，所以我们可以使用 LEFT JOIN 加 RIGHTJOIN 这种方式实现。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t1.employee_idFROM    Employees AS t1    LEFT JOIN Salaries AS t2 ON t1.employee_id = t2.employee_idWHERE    t2.salary IS NULLUNIONSELECT    t2.employee_idFROM    Employees AS t1    RIGHT JOIN Salaries AS t2 ON t1.employee_id = t2.employee_idWHERE    t1.name IS NULLORDER BY    employee_id ASC;</code></pre></div><p>可以用 GROUP BY 的方式实现，讲两张表的 <code>employee_id</code> UNIONALL（与 UNION 的区别就是不去重）起来，计数等于 1 的<code>employee_id</code> 就是信息缺失的。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t.employee_idFROM    (        SELECT employee_id FROM Employees        UNION ALL        SELECT employee_id FROM Salaries    ) AS tGROUP BY    t.employee_idHAVING    COUNT(t.employee_id) = 1ORDER BY    t.employee_id ASC;</code></pre></div><h3 id="每个产品在不同商店的价格">1795. 每个产品在不同商店的价格</h3><p>列转行问题，可以用 UNION ALL （这里不会重复，这里主要是比 UNION快）。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT product_id, &#x27;store1&#x27; AS store, store1 AS price FROM Products WHERE store1 IS NOT NULLUNION ALLSELECT product_id, &#x27;store2&#x27; AS store, store2 AS price FROM Products WHERE store2 IS NOT NULLUNION ALLSELECT product_id, &#x27;store3&#x27; AS store, store3 AS price FROM Products WHERE store3 IS NOT NULL;</code></pre></div><h3 id="树节点">608. 树节点</h3><p>感觉很多 SQL的题考察的都是对这门语言的熟练程度而不是逻辑，比如这道题的逻辑很简单，就是：</p><ul><li><code>p_id</code> 为空， Root</li><li><code>p_id</code> 不为空 <code>id</code> 不是别人的<code>p_id</code> ，Leaf</li><li><code>p_id</code> 不为空 <code>id</code> 是别人的 <code>p_id</code>，Inner</li></ul><p>CASE WHEN ELSE 语句：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    id,    CASE        WHEN p_id IS NULL THEN &#x27;Root&#x27;        WHEN id NOT IN (SELECT p_id FROM tree WHERE p_id IS NOT NULL) THEN &#x27;Leaf&#x27;        ELSE &#x27;Inner&#x27;    END AS TypeFROM    treeORDER BY    id;</code></pre></div><p>IF 语句：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    id,    IF(p_id IS NULL, &#x27;Root&#x27;, IF(id NOT IN (SELECT p_id FROM tree WHERE p_id IS NOT NULL), &#x27;Leaf&#x27;, &#x27;Inner&#x27;)) AS TypeFROM    treeORDER BY    id;</code></pre></div><h3 id="第二高的薪水">176. 第二高的薪水</h3><p>除开最高薪水的最高薪水：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    MAX(salary) AS SecondHighestSalaryFROM    EmployeeWHERE    salary != (        SELECT MAX(salary) FROM Employee    );</code></pre></div><p>从大到小排序去重后排第二的薪水：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT (    SELECT DISTINCT        salary    FROM        Employee    ORDER BY        salary DESC    LIMIT 1 OFFSET 1) AS SecondHighestSalary;</code></pre></div><h2 id="合并">合并</h2><h3 id="组合两个表">175. 组合两个表</h3><p>简单的连接，注意要包含 <code>Person</code> 表的信息即可。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t1.firstName,    t1.lastName,    t2.city,    t2.stateFROM    Person AS t1    LEFT JOIN Address AS t2 ON t1.personId = t2.personId;</code></pre></div><h3 id="进店却未进行过交易的顾客">1581. 进店却未进行过交易的顾客</h3><p>首先查满足条件的 <code>customer_id</code> ，然后再用 GROUP BY进行统计。以构建一张中间表的形式在 FROM 里：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    customer_id,    COUNT(*) AS count_no_transFROM    (        SELECT            t1.customer_id        FROM            Visits AS t1            LEFT JOIN Transactions AS t2 ON t1.visit_id = t2.visit_id        WHERE            t2.transaction_id IS NULL    ) AS tGROUP BY    customer_id;</code></pre></div><p>放在 WHERE 里：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    customer_id,    COUNT(*) AS count_no_transFROM    VisitsWHERE    visit_id NOT IN(SELECT DISTINCT visit_id FROM Transactions)GROUP BY    customer_id;</code></pre></div><h3 id="文章浏览-i">1148. 文章浏览 I</h3><p>DISTINCT 去重。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT    author_id AS idFROM    ViewsWHERE    author_id = viewer_idORDER BY    id ASC;</code></pre></div><h3 id="上升的温度">197. 上升的温度</h3><p><code>ADDDATE</code> 函数的使用。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    today.idFROM    Weather AS yesterday,    Weather AS todayWHERE    today.recordDate = ADDDATE(yesterday.recordDate, INTERVAL 1 DAY)    AND today.temperature &gt; yesterday.temperature;</code></pre></div><p>或者用 <code>DATE_ADD</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    today.idFROM    Weather AS yesterday,    Weather AS todayWHERE    today.recordDate = DATE_ADD(yesterday.recordDate, INTERVAL 1 DAY)    AND today.temperature &gt; yesterday.temperature;</code></pre></div><h3 id="销售员">607. 销售员</h3><p>子查询。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    nameFROM    SalesPersonWHERE    sales_id NOT IN (        SELECT            o.sales_id        FROM            Orders AS o            INNER JOIN Company AS c ON o.com_id = c.com_id        WHERE            c.name = &#x27;RED&#x27;    )</code></pre></div><h2 id="计算函数">计算函数</h2><h3 id="查询近30天活跃用户数">1141. 查询近30天活跃用户数</h3><p>这道题考察分组查询统计，首先 COUNT 里是可以用<code>DISTINCT user_id</code> 来去重的，然后可以用 <code>DATE_SUB</code>函数。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    activity_date AS day,    COUNT(DISTINCT user_id) AS active_usersFROM    ActivityWHERE    activity_date &gt; DATE_SUB(&quot;2019-07-27&quot;, INTERVAL 30 DAY)    AND activity_date &lt;= &quot;2019-07-27&quot;GROUP BY    activity_date;</code></pre></div><p>当然也可以用 <code>DATE_ADD</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    activity_date AS day,    COUNT(DISTINCT user_id) AS active_usersFROM    ActivityWHERE    activity_date &gt; DATE_ADD(&quot;2019-07-27&quot;, INTERVAL -30 DAY)    AND activity_date &lt;= &quot;2019-07-27&quot;GROUP BY    activity_date;</code></pre></div><h3 id="每天的领导和合伙人">1693. 每天的领导和合伙人</h3><p>这道题应该是考察 GOURP BY 可以按多列分组。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    date_id,    make_name,    COUNT(DISTINCT lead_id) AS unique_leads,    COUNT(DISTINCT partner_id) AS unique_partnersFROM    DailySalesGROUP BY    date_id, make_name;</code></pre></div><h3 id="求关注者的数量">1729. 求关注者的数量</h3><p>其实就是对 <code>user_id</code> 进行 GROUP BY：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    user_id,    COUNT(*) AS followers_countFROM    FollowersGROUP BY    user_idORDER BY    user_id ASC;</code></pre></div><h3 id="订单最多的客户">586. 订单最多的客户</h3><p>首先找 <code>customer</code>与其的订单数量，然后从中可以找到最多的订单数量，最后再查谁的订单数量等于最多的订单数量。嵌套子查询。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    MAX(order_count)FROM(    SELECT        customer_number,        COUNT(*) AS order_count    FROM        Orders    GROUP BY        customer_number) AS t</code></pre></div><p>也可以直接用 <code>customer</code> 的订单数量从大到小排序，只输出 1个值，只查 <code>customer_number</code> 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    customer_numberFROM    OrdersGROUP BY    customer_numberORDER BY    count(*) DESCLIMIT 1</code></pre></div><h3 id="游戏玩法分析-i">511. 游戏玩法分析 I</h3><p>直接用 GROUP BY 加 MIN 就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    player_id,    MIN(event_date) AS first_loginFROM    ActivityGROUP BY    player_id;</code></pre></div><h3 id="年最后一次登录">1890. 2020年最后一次登录</h3><p>这道题是 GROUP BY 加 MAX，比上道题多了个 WHERE 筛选年份。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    user_id,    MAX(time_stamp) AS last_stampFROM    LoginsWHERE    time_stamp &gt;= DATE(&#x27;2020-01-01&#x27;)    AND time_stamp &lt; DATE(&#x27;2021-01-01&#x27;)GROUP BY    user_id;</code></pre></div><p>也可以这样</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    user_id,    MAX(time_stamp) AS last_stampFROM    LoginsWHERE    YEAR(time_stamp) = 2020GROUP BY    user_id;</code></pre></div><h3 id="查找每个员工花费的总时间">1741. 查找每个员工花费的总时间</h3><p>GROUP BY + SUM 函数，GROUP BY 是可以分组 2 列的。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    event_day AS day,    emp_id,    SUM(out_time-in_time) AS total_timeFROM    EmployeesGROUP BY    event_day, emp_id</code></pre></div><h2 id="控制流">控制流</h2><h3 id="股票的资本损益">1393. 股票的资本损益</h3><p>收益等于每笔卖出减去买入的和，也就等于总卖出减去总买入，所以可以用SUM 和 IF 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    stock_name,    SUM(IF(operation=&#x27;Sell&#x27;, price, 0))-SUM(IF(operation=&#x27;Buy&#x27;, price, 0)) AS capital_gain_lossFROM    StocksGROUP BY    stock_name;</code></pre></div><p>当然可以把买入看作支出，卖出看作收入，那么两个 SUM IF可以合并成一个。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    stock_name,    SUM(IF(operation=&#x27;Sell&#x27;, price, -price))AS capital_gain_lossFROM    StocksGROUP BY    stock_name;</code></pre></div><h3 id="排名靠前的旅行者">1407. 排名靠前的旅行者</h3><p>IFNULL 函数的使用，ORDER BY 的多列操作。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t1.name,    IFNULL(SUM(t2.distance), 0) AS travelled_distanceFROM    Users AS t1    LEFT JOIN Rides AS t2 ON t1.id = t2.user_idGROUP BY    t1.idORDER BY    travelled_distance DESC, t1.name ASC;</code></pre></div><h3 id="市场分析-i">1158. 市场分析 I</h3><p>SUM IF YEAR 三个函数的使用，这题跟 Item 这张表没啥关系。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t1.user_id AS buyer_id,    t1.join_date,    SUM(IF(YEAR(t2.order_date) = 2019, 1, 0)) AS orders_in_2019FROM    Users AS t1    LEFT JOIN Orders AS t2 ON t1.user_id = t2.buyer_idGROUP BY    t1.user_id;</code></pre></div><p>还有种，<code>JOIN table ON condition</code> 后面居然可以用 AND再加条件，是我没想到的。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t1.user_id AS buyer_id,    t1.join_date,    COUNT(t2.buyer_id) AS orders_in_2019FROM    Users AS t1    LEFT JOIN Orders AS t2 ON t1.user_id = t2.buyer_id AND YEAR(t2.order_date) = 2019GROUP BY    t1.user_id;</code></pre></div><p>而且在 ON 这里加跟在 WHERE 这里加不一样，如下图：</p><p>ON 添加条件限定 2019 年：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212211008315.png" /></p><p>WHERE 添加条件限定 2019 年：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212211008555.png" /></p><h3 id="查找重复的电子邮箱">182. 查找重复的电子邮箱</h3><p>GROUP BY + COUNT + HAVING 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    EmailFROM    PersonGROUP BY    EmailHAVING    COUNT(*) &gt; 1;</code></pre></div><h3 id="合作过至少三次的演员和导演">1050.合作过至少三次的演员和导演</h3><p>依然是 GROUP BY + COUNT + HAVING 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    actor_id,    director_idFROM    ActorDirectorGROUP BY    actor_id, director_idHAVING    COUNT(*)&gt;=3;</code></pre></div><h3 id="银行账户概要-ii">1587. 银行账户概要 II</h3><p>子查询 + GROUP BY + IFNULL + SUM 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    name,    balanceFROM(    SELECT        t1.name,        IFNULL(SUM(t2.amount), 0) AS balance    FROM        Users AS t1        LEFT JOIN Transactions AS t2 ON t1.account = t2.account    GROUP BY        t1.account) AS tWHERE    balance &gt; 10000;</code></pre></div><p>当然直接用 GROUP BY + IFNULL + HAVING 也可以，因为 HAVING 针对的就是GROUP BY 之后的结果。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    t1.name,    IFNULL(SUM(t2.amount), 0) AS balanceFROM    Users AS t1    LEFT JOIN Transactions AS t2 ON t1.account = t2.accountGROUP BY    t1.accountHAVING    balance &gt; 10000;</code></pre></div><h3 id="销售分析iii">1084. 销售分析III</h3><p>可以用子查询 + 连接的方式，不过需要去重。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT    t1.product_id,    t1.product_nameFROM    Product AS t1    INNER JOIN Sales AS t2 ON t1.product_id = t2.product_idWHERE    t1.product_id NOT IN (        SELECT product_id        FROM Sales        WHERE YEAR(sale_date) != 2019 OR MONTH(sale_date) &gt; 3    );</code></pre></div><p>两个子查询也是可以的。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT    product_id,    product_nameFROM    ProductWHERE    product_id NOT IN (        SELECT product_id        FROM Sales        WHERE YEAR(sale_date) != 2019 OR MONTH(sale_date) &gt; 3    )    AND product_id IN (        SELECT DISTINCT product_id        FROM Sales    );</code></pre></div><p>当然可以在一个子查询里用 MAX + MIN 两个函数做控制。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT    product_id,    product_nameFROM    ProductWHERE    product_id IN (        SELECT product_id        FROM Sales        GROUP BY product_id        HAVING MAX(sale_date) &lt;= &#x27;2019-03-31&#x27; AND MIN(sale_date) &gt;= &#x27;2019-01-01&#x27;    );</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 697 704</title>
    <link href="/2022/12/08/leetcode20221208/"/>
    <url>/2022/12/08/leetcode20221208/</url>
    
    <content type="html"><![CDATA[<h1 id="数组的度">697. 数组的度</h1><p>需要建立两个映射，以解决这道题针对的度与最小长度两个问题，这两个映射其实可以用一个<code>Dict(key=v, value=[first_index, last_index, degree])</code>这种格式建立，然后再遍历一下映射。找出最小的长度<code>min(last_index-first_index+1)</code> 即可。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findShortestSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[v] = [i, i, <span class="hljs-number">1</span>]            <span class="hljs-keyword">else</span>:                hashmap[v][<span class="hljs-number">1</span>] = i                hashmap[v][<span class="hljs-number">2</span>] += <span class="hljs-number">1</span>        min_len = <span class="hljs-number">1</span>        max_degree = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> lst <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> lst[<span class="hljs-number">2</span>] &gt; max_degree:                min_len = lst[<span class="hljs-number">1</span>]-lst[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>                max_degree = lst[<span class="hljs-number">2</span>]            <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">2</span>] == max_degree:                min_len = <span class="hljs-built_in">min</span>(min_len, lst[<span class="hljs-number">1</span>]-lst[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> min_len</code></pre></div><h1 id="二分查找">704. 二分查找</h1><p>就是一个简单的二分搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left+right) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == target:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                left = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash， binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 661 674 680 682 693</title>
    <link href="/2022/12/07/leetcode20221207/"/>
    <url>/2022/12/07/leetcode20221207/</url>
    
    <content type="html"><![CDATA[<h1 id="图片平滑器">661. 图片平滑器</h1><p>模拟逐步扫描，这里由于后面的结果不受前面的结果影响，所以需要一个<code>deepcopy()</code> 来开个新的 <code>m*n</code> 的数组。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">imageSmoother</span>(<span class="hljs-params">self, img: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m = <span class="hljs-built_in">len</span>(img)        n = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):                left_x = x-<span class="hljs-number">1</span>                left_y = y-<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:                    left_x = <span class="hljs-number">0</span>                <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span>:                    left_y = <span class="hljs-number">0</span>                rows = img[left_y: y+<span class="hljs-number">2</span>]                row_count = <span class="hljs-built_in">len</span>(rows)                col_count = <span class="hljs-built_in">len</span>(rows[<span class="hljs-number">0</span>][left_x:x+<span class="hljs-number">2</span>])                _<span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> t: <span class="hljs-built_in">sum</span>(t[left_x:x+<span class="hljs-number">2</span>]), rows))                res[y][x] = _<span class="hljs-built_in">sum</span>//(row_count*col_count)        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="最长连续递增序列">674. 最长连续递增序列</h1><p>这道题应该是双指针，不过两个指针位置是固定的，所以也可以叫滑动窗口。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLengthOfLCIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">1</span>        temp_len = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:                temp_len += <span class="hljs-number">1</span>                res = <span class="hljs-built_in">max</span>(res, temp_len)            <span class="hljs-keyword">else</span>:                temp_len = <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="验证回文串-ii">680. 验证回文串 II</h1><p>这道题可以用双指针扫描做模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>        flag = <span class="hljs-literal">True</span>        left_res = <span class="hljs-literal">True</span>        <span class="hljs-keyword">while</span> left &lt; right:            <span class="hljs-keyword">if</span> s[left] == s[right]:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> s[left+<span class="hljs-number">1</span>] == s[right] <span class="hljs-keyword">and</span> flag:                    left += <span class="hljs-number">2</span>                    right -= <span class="hljs-number">1</span>                    flag = <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> s[left] == s[right-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> flag:                    left += <span class="hljs-number">1</span>                    right -= <span class="hljs-number">2</span>                    flag = <span class="hljs-literal">False</span>                <span class="hljs-keyword">else</span>:                    left_res = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>        flag = <span class="hljs-literal">True</span>        right_res = <span class="hljs-literal">True</span>        <span class="hljs-keyword">while</span> left &lt; right:            <span class="hljs-keyword">if</span> s[left] == s[right]:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> s[left] == s[right-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> flag:                    left += <span class="hljs-number">1</span>                    right -= <span class="hljs-number">2</span>                    flag = <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> s[left+<span class="hljs-number">1</span>] == s[right] <span class="hljs-keyword">and</span> flag:                    left += <span class="hljs-number">2</span>                    right -= <span class="hljs-number">1</span>                    flag = <span class="hljs-literal">False</span>                <span class="hljs-keyword">else</span>:                    right_res = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> left_res <span class="hljs-keyword">or</span> right_res</code></pre></div><p>由于左右都要做一次所以很慢。</p><p>可以改进成只用一次，但是要注意一下切片指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt; right:            <span class="hljs-keyword">if</span> s[left] == s[right]:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> s[left+<span class="hljs-number">1</span>] == s[right] <span class="hljs-keyword">or</span> s[left] == s[right-<span class="hljs-number">1</span>]:                    <span class="hljs-keyword">return</span> s[left+<span class="hljs-number">1</span>:right+<span class="hljs-number">1</span>] == s[left+<span class="hljs-number">1</span>:right+<span class="hljs-number">1</span>][::-<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> s[left:right] == s[left:right][::-<span class="hljs-number">1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p>这题似乎还有个面向测试用例编程，就是一来先来个</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> s == s[::-<span class="hljs-number">1</span>]:<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="棒球比赛">682. 棒球比赛</h1><p>按照简单的模拟。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calPoints</span>(<span class="hljs-params">self, operations: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> operations:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;C&#x27;</span>:                <span class="hljs-keyword">del</span> res[-<span class="hljs-number">1</span>]            <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;D&#x27;</span>:                res.append(res[-<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>)            <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;+&#x27;</span>:                res.append(res[-<span class="hljs-number">1</span>]+res[-<span class="hljs-number">2</span>])            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-built_in">int</span>(i))        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(res)</code></pre></div><p>像这种多重 <code>if-else</code>语句其实可以建立映射关系，经典空间换时间，比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calPoints</span>(<span class="hljs-params">self, operations: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cal_c</span>():            <span class="hljs-keyword">return</span> res.pop(-<span class="hljs-number">1</span>)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cal_d</span>():            <span class="hljs-keyword">return</span> res.append(res[-<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cal_p</span>():            <span class="hljs-keyword">return</span> res.append(res[-<span class="hljs-number">1</span>]+res[-<span class="hljs-number">2</span>])        match_dict = &#123;            <span class="hljs-string">&#x27;C&#x27;</span>:_cal_c,            <span class="hljs-string">&#x27;D&#x27;</span>:_cal_d,            <span class="hljs-string">&#x27;+&#x27;</span>:_cal_p        &#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> operations:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> match_dict:                match_dict[i]()            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-built_in">int</span>(i))        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(res)</code></pre></div><p>也可以尝试下 Python3.10 中的新特性 <code>match case</code> 语句：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calPoints</span>(<span class="hljs-params">self, operations: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> operations:            match i:                case <span class="hljs-string">&#x27;C&#x27;</span>:                    res.pop(-<span class="hljs-number">1</span>)                case <span class="hljs-string">&#x27;D&#x27;</span>:                    res.append(res[-<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>)                case <span class="hljs-string">&#x27;+&#x27;</span>:                    res.append(res[-<span class="hljs-number">1</span>]+res[-<span class="hljs-number">2</span>])                case _:                    res.append(<span class="hljs-built_in">int</span>(i))        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(res)</code></pre></div><h1 id="交替位二进制数">693. 交替位二进制数</h1><p>最快的做法应该是空间换时间：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasAlternatingBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        res = &#123;            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1398101</span>, <span class="hljs-number">5592405</span>, <span class="hljs-number">21845</span>, <span class="hljs-number">89478485</span>, <span class="hljs-number">357913941</span>, <span class="hljs-number">1431655765</span>, <span class="hljs-number">5726623061</span>, <span class="hljs-number">22369621</span>, <span class="hljs-number">21</span>, <span class="hljs-number">341</span>, <span class="hljs-number">85</span>, <span class="hljs-number">1365</span>,            <span class="hljs-number">5461</span>, <span class="hljs-number">170</span>, <span class="hljs-number">2730</span>, <span class="hljs-number">174762</span>, <span class="hljs-number">10922</span>, <span class="hljs-number">43690</span>, <span class="hljs-number">178956970</span>, <span class="hljs-number">349525</span>, <span class="hljs-number">2863311530</span>, <span class="hljs-number">715827882</span>, <span class="hljs-number">11453246122</span>, <span class="hljs-number">44739242</span>, <span class="hljs-number">42</span>, <span class="hljs-number">682</span>,            <span class="hljs-number">699050</span>, <span class="hljs-number">2796202</span>, <span class="hljs-number">11184810</span>, <span class="hljs-number">87381</span>        &#125;        <span class="hljs-keyword">return</span> n <span class="hljs-keyword">in</span> res</code></pre></div><p>其中这个 <code>res</code> 的 <code>set</code> 是由模拟得到的：</p><div class="code-wrapper"><pre><code class="hljs python">res1 = &#123;<span class="hljs-number">1</span>&#125;x = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> x&lt;=(<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">31</span>)-<span class="hljs-number">1</span>:    x = (x&lt;&lt;<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>    res1.add(x)res2 = <span class="hljs-built_in">set</span>()<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res1:    res2.add(i*<span class="hljs-number">2</span>)res = res1|res2</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLModel</title>
    <link href="/2022/12/06/sqlmodel/"/>
    <url>/2022/12/06/sqlmodel/</url>
    
    <content type="html"><![CDATA[<p>SQLModel 是一个使用 Python 对象与 SQL 数据库交互的库。它与 FastAPI的作者是同一个人，旨在简化 FastAPI 应用程序中与数据库的交互。</p><p>本文是 SQL 官方文档的阅读笔记。用 Python 的 FastAPI 框架， MySQL提供演示。</p><h1 id="orm">ORM</h1><p>ORM 的全称为 <ahref="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">Object–RelationalMapping</a>，中文叫对象关系映射，是一种程序设计技术，用于实现面向对象编程语言与不同类型资料间的转换。经过对象关系映射这种技术后，一个类就对应着一张表，一个对象（这个类的实例）就对应着一条记录（一行数据），一个类的属性就对应着一个字段（一列）。</p><p>比如我一张表长这样：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212060551369.png" /></p><p>那么在 Python 里它的数据类是：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Boolean, Column, ForeignKey, Integer, String<span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_baseBase = declarative_base()<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):    __tablename__ = <span class="hljs-string">&quot;users&quot;</span>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)    email = Column(String(<span class="hljs-number">256</span>), unique=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)    hashed_password = Column(String(<span class="hljs-number">256</span>))    is_active = Column(Boolean, default=<span class="hljs-literal">True</span>)</code></pre></div><p>ORM 这种技术有好处也有坏处。</p><p>好处就是方便开发。举个例子，如果你在开发系统中不用 ORM，那么你后端可能需要写大量的原生 SQL 比如MySQL，然后当你需要把你的数据库换成 PostgreSQL 时，你需要重写所有的 SQL代码，这在项目大的时候是一件比较头疼的事情。</p><p>坏处是<strong>性能是不如原生 SQL</strong>的，有的复杂查询可能无法表达。</p><p>在 Python 中有很多 ORM框架，它们可以帮助开发者实现对象关系映射而不必关注细节，如 DjangoORM,SQLAlchemy 以及本文学习的 SQLModel 等。</p><p>SQLModel 的官方</p><h1 id="基础教程">基础教程</h1><h2 id="使用-sql-创建表">使用 SQL 创建表</h2><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `test` (  `id` bigint NOT NULL,  `numeric_field` int DEFAULT NULL,  `string_field` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,  PRIMARY KEY (`id`))</code></pre></div><p>可以看到表已经创建好。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212060731781.png" /></p><h2 id="使用-sqlmodel-创建表">使用 SQLModel 创建表</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><span class="hljs-keyword">from</span> sqlmodel <span class="hljs-keyword">import</span> create_engine, Field, SQLModel<span class="hljs-comment"># mysql 的数据类型，为了和上面一样所以用 mysql 的数据类型</span><span class="hljs-keyword">from</span> sqlalchemy.dialects.mysql <span class="hljs-keyword">import</span> BIGINT, VARCHAR<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(SQLModel, table=<span class="hljs-literal">True</span>):    <span class="hljs-built_in">id</span>: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = Field(BIGINT(<span class="hljs-number">19</span>), primary_key=<span class="hljs-literal">True</span>)    numeric_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>]    string_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Field(VARCHAR(<span class="hljs-number">256</span>))MYSQL_URL = <span class="hljs-string">&#x27;mysql://root:123456@localhost:3306/test&#x27;</span>engine = create_engine(MYSQL_URL, echo=<span class="hljs-literal">True</span>)SQLModel.metadata.create_all(engine)</code></pre></div><p>这样就行了。不过这个地方有个坑，如图：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212060906280.png" /></p><p>好像不能创建 BIGINT 类型的字段。然后我看了下源码。</p><p>这个 BIGINT 继承了 <code>sqlalchemy.types.BigInteger</code>这个类，在<ahref="https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.BigInteger">官方文档</a>里有一段：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212060934932.png" /></p><p>大意就是说 BIGINT这种写法实现不了它字面意思的效果，这是我没想到的。</p><p>经过搜索，发现要这样写才行：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><span class="hljs-keyword">from</span> sqlmodel <span class="hljs-keyword">import</span> create_engine, Field, SQLModel, VARCHAR<span class="hljs-keyword">from</span> sqlalchemy.dialects.mysql <span class="hljs-keyword">import</span> BIGINT<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(SQLModel, table=<span class="hljs-literal">True</span>):    <span class="hljs-comment"># primary_key=True 必须放在 Column 里面</span>    <span class="hljs-built_in">id</span>: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = Field(default=<span class="hljs-literal">None</span>, sa_column=Column(BIGINT(<span class="hljs-number">19</span>), primary_key=<span class="hljs-literal">True</span>))    numeric_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>]    string_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Field(VARCHAR(<span class="hljs-number">256</span>))MYSQL_URL = <span class="hljs-string">&#x27;mysql://root:123456@localhost:3306/test&#x27;</span>engine = create_engine(MYSQL_URL, echo=<span class="hljs-literal">True</span>)SQLModel.metadata.create_all(engine)</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212060949238.png" /></p><p>额，还是建议建表这块直接用 DDL 在数据库里建。</p><h2 id="创建行---insert">创建行 - INSERT</h2><p>SQL 创建行（插入数据）：</p><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO test(numeric_field, string_field) VALUES (1, &#x27;raw_sql&#x27;)</code></pre></div><p>用 SQLModel 插入（包含上面的创建）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><span class="hljs-keyword">from</span> sqlmodel <span class="hljs-keyword">import</span> create_engine, Field, SQLModel, Session, VARCHAR<span class="hljs-keyword">from</span> sqlalchemy.dialects.mysql <span class="hljs-keyword">import</span> BIGINT<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(SQLModel, table=<span class="hljs-literal">True</span>):    <span class="hljs-built_in">id</span>: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = Field(default=<span class="hljs-literal">None</span>, sa_column=Column(BIGINT(<span class="hljs-number">19</span>), primary_key=<span class="hljs-literal">True</span>))    numeric_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>]    string_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Field(VARCHAR(<span class="hljs-number">256</span>))MYSQL_URL = <span class="hljs-string">&#x27;mysql://root:123456@localhost:3306/test&#x27;</span>engine = create_engine(MYSQL_URL, echo=<span class="hljs-literal">True</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_table_test</span>():    SQLModel.metadata.create_all(engine)<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_test_record</span>():    test_1 = Test(numeric_field=<span class="hljs-number">2</span>, string_field=<span class="hljs-string">&#x27;sqlmodel&#x27;</span>)    <span class="hljs-comment"># 创建会话</span>    session = Session(engine)    <span class="hljs-comment"># 添加更改</span>    session.add(test_1)    <span class="hljs-comment"># 提交更改</span>    session.commit()    <span class="hljs-comment"># 关闭会话</span>    session.close()<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_test_record2</span>():    <span class="hljs-string">&#x27;&#x27;&#x27; 第二种创建行的方法 &#x27;&#x27;&#x27;</span>    test_1 = Test(numeric_field=<span class="hljs-number">2</span>, string_field=<span class="hljs-string">&#x27;sqlmodel&#x27;</span>)    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        session.add(test_1)        session.commit()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    create_table_test()    create_test_record()</code></pre></div><p>结果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061008631.png" /></p><p>从 <code>create_test_record</code> 这个函数我们可以看到添加数据分为 2步，第一步是 <code>add</code> ，第二步是 <code>commit</code>，这个有点像 <code>git</code> 。</p><h2 id="自增-id默认值与刷新数据">自增 ID、默认值与刷新数据</h2><p>在上文的代码中：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061031451.png" /></p><p>这两个框之前，我们都创建了一个 <code>test_1</code>对象，相当于数据库一条记录，并且没有在代码里写主键 <code>id</code>。我们知道主键都是非空的，所以经过打印，发现使用 SQLModel创建行之前，实际上的 <code>test_1</code> 对象的 <code>id</code> 是<code>None</code> ，类型就是 <code>NoneType</code> 而不是<code>int</code> 。但是在 Python代码里，这个值是空的，所以很显然设置了主键自增。</p><p>看源码可以发现 <code>SQLAlchemy</code> 的 <code>Column</code>有一个参数叫 <code>autoincrement</code>，所以这个字段其实就是用来控制是否自增，<ahref="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.Column.params.autoincrement">原文文档</a>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_test_record</span>():    test_2 = Test(numeric_field=<span class="hljs-number">3</span>, string_field=<span class="hljs-string">&#x27;sqlmodel&#x27;</span>)    <span class="hljs-comment"># 创建会话</span>    session = Session(engine)    <span class="hljs-comment"># 添加更改</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before add&#x27;</span>, test_2)    session.add(test_2)    <span class="hljs-comment"># 提交更改</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before commit&#x27;</span>, test_2)    session.commit()    <span class="hljs-comment"># 关闭会话</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before close&#x27;</span>, test_2)    session.close()</code></pre></div><p>把创建新的行写成这样，去观察什么时候更新的自增 <code>id</code>，可以看到：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061100119.png" /></p><p>自增是数据库的行为，发生在提交代码的 <code>commit</code> 之后。</p><p>实际上有个主动刷新的功能，代码如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_test_record</span>():    test_2 = Test(numeric_field=<span class="hljs-number">5</span>, string_field=<span class="hljs-string">&#x27;sqlmodel&#x27;</span>)    session = Session(engine)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before add&#x27;</span>, test_2)    session.add(test_2)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before commit&#x27;</span>, test_2)    session.commit()        <span class="hljs-comment"># 主动刷新</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before refresh&#x27;</span>, test_2)    session.refresh(test_2)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before close&#x27;</span>, test_2)    session.close()</code></pre></div><p>可以得到：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061105795.png" /></p><h2 id="查询---select">查询 - SELECT</h2><p>查询刚刚创建的数据，用 SQL ：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTid,numeric_field,string_fieldFROMtest;</code></pre></div><p>可以看到：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061115758.png" /></p><p>在 SQLModel 里只需要再添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlmodel <span class="hljs-keyword">import</span> select<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test_record</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        statement = select(Test)        results = session.<span class="hljs-built_in">exec</span>(statement)        <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> results:            <span class="hljs-built_in">print</span>(test)</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061121588.png" /></p><p><strong>注意这里返回的 <code>test</code> 就是一个 <code>Test</code>的实例化对象，而不是字符串。</strong></p><p>这里就完成了关系到对象的反映射。</p><p>不过一般这么写：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test_record</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        results = session.<span class="hljs-built_in">exec</span>(select(Test)).<span class="hljs-built_in">all</span>()        <span class="hljs-built_in">print</span>(results)        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(results))</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061125644.png" /></p><p>可以看到这次返回的是一个 <code>list</code> 。</p><p>这里作者专门提到了 SQLModel 与 SQLAlchemy 在这里的不同之处，意思就是SQLModel 虽然是基于 SQLAlchemy 与 Pydantic的，依然有自己的封装。除了上文里其实已经遇见的 <code>Field</code> 和<code>Column</code> ，还有就是查询的时候方法名并不一样：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># SQLAlchemy</span>session.execute(select(Test)).scalars().<span class="hljs-built_in">all</span>()<span class="hljs-comment"># SQLModel</span>session.<span class="hljs-built_in">exec</span>(select(Test)).<span class="hljs-built_in">all</span>()</code></pre></div><p>但是 SQLModel <code>Session</code> 仍然可以访问<code>session.execute()</code> 。</p><p>我的感觉就是说如果你在使用 SQLModel 中遇到一些问题，你可以直接去看SQLAlchemy的文档（我没有专门学这个框架因为它的文档实在太长了），事实上我已经这么做了（比如上面对表字段的类型定义）。</p><h2 id="过滤---where">过滤 - WHERE</h2><p>在 SQL 中，我们可以用 WHERE 来进行数据的过滤与筛选，比如：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTid,numeric_field,string_fieldFROMtestWHEREnumeric_field = 3;</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061148484.png" /></p><p>作者在这里贴心地提示了：</p><ul><li>SELECT - 用于告诉数据库返回哪些列。</li><li>WHERE - 用于告诉数据库返回哪些行。</li></ul><p>上述 SQL 用 SQLModel 实现就是：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_test_record</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        results = session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.numeric_field == <span class="hljs-number">3</span>)).<span class="hljs-built_in">all</span>()        <span class="hljs-built_in">print</span>(results)</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212061237791.png" /></p><p>对于逻辑运算符：</p><table><thead><tr class="header"><th>逻辑运算符</th><th>SQL</th><th>SQLModel</th></tr></thead><tbody><tr class="odd"><td>AND</td><td>WHRER condition1 AND condition2</td><td>where(condition1).where(condition2) 或者 where(condition1,condition2)</td></tr><tr class="even"><td>OR</td><td>WHERE condition1 OR condition2</td><td>where(or_(condition1, cindition2))</td></tr></tbody></table><p>然后作者这里提到了说 Python 解释器可能会对<code>where(Test.id &gt; 3)</code> 这种写法报错，因为在创建的时候用了<code>Optional[int]</code> 这样的声明。解决方案是写成<code>where(col(Test.id) &gt; 3)</code>。我没有遇到这个问题，这里就不作展示。</p><h2 id="索引---index">索引 - INDEX</h2><p>索引是一种加速查询的技术，优点：</p><ul><li>查询快</li></ul><p>缺点：</p><ul><li>需要额外物理空间</li><li>增删改慢</li></ul><p>在 SQL 中，如果是上面的例子，要对 <code>numeric_field</code>创建索引：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE INDEX idx_test_numeric_field ON test(numeric_field)</code></pre></div><p>在 SQLModel 中：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(SQLModel, table=<span class="hljs-literal">True</span>):    <span class="hljs-built_in">id</span>: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = Field(BIGINT(<span class="hljs-number">19</span>), primary_key=<span class="hljs-literal">True</span>)    numeric_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = Field(index=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 只需要在这里进行小的修改</span>    string_field: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Field(VARCHAR(<span class="hljs-number">256</span>))</code></pre></div><blockquote><p>数据库会为主键创建一个内部索引，因此主键不需要索引。</p></blockquote><h2 id="查询一行数据">查询一行数据</h2><p>在上文查询或过滤那里我们都查询了所有数据，这里讲如果我们只需要查询一行数据时的操作和会遇到的情况。</p><p>其实很简单，把<code>session.exec(select(Test).where(Test.id&gt;3))</code>当作一个返回结果的话，在上文调用了 <code>.all()</code> 方法返回了一个<code>list</code> ，如果不调用返回的是一个可迭代对象，这里我们可以调用<code>.first()</code> 等方法来查询一行数据，比如：</p><div class="code-wrapper"><pre><code class="hljs python">session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.<span class="hljs-built_in">id</span>&gt;<span class="hljs-number">3</span>)).first()</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212070504699.png" /></p><p>在这里也可能查询不到任何行，也就是没有满足条件的数据，比如：</p><div class="code-wrapper"><pre><code class="hljs python">session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.<span class="hljs-built_in">id</span>&lt;<span class="hljs-number">0</span>)).first()</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212070505626.png" /></p><p>除了 <code>.first()</code> ，还有一个 <code>.one()</code>也类似，这里列出它们的差异：</p><table><thead><tr class="header"><th>情况</th><th>有多行满足条件时返回</th><th>只有一行满足条件时返回</th><th>没有满足条件的数据时返回</th></tr></thead><tbody><tr class="odd"><td><code>.first()</code></td><td>一个 Test 实例对象</td><td>一个 Test 实例对象</td><td>None</td></tr><tr class="even"><td><code>.one()</code></td><td>报错 <code>MultipleResultsFound</code></td><td>一个 Test 实例对象</td><td>报错 <code>NoResultFound</code></td></tr></tbody></table><p>如果只用主键选择单行，由于主键是唯一的，还有个 <code>.get()</code>方法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># get()</span>session.get(Test, <span class="hljs-number">3</span>)<span class="hljs-comment"># first()</span>session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.<span class="hljs-built_in">id</span> == <span class="hljs-number">3</span>)).first()<span class="hljs-comment"># one()</span>session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.<span class="hljs-built_in">id</span> == <span class="hljs-number">3</span>)).one()</code></pre></div><p>上面 3 句话结果是一样的。如果用 <code>.get()</code>方法去查询一个不存在的主键，会返回 <code>None</code> 。</p><h2 id="limit-与-offset">LIMIT 与 OFFSET</h2><p>限制查询满足某种条件的数据 3 条，在 SQL 里：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT*FROMtestWHEREnumeric_field &gt;= 3LIMIT3</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212070532914.png" /></p><p>在 SQLModel 里：</p><div class="code-wrapper"><pre><code class="hljs python">session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.numeric_field &gt;= <span class="hljs-number">3</span>).limit(<span class="hljs-number">3</span>)).<span class="hljs-built_in">all</span>()</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212070532521.png" /></p><p>这个地方我个人觉得要注意的就是 <code>limit()</code> 的位置，是放在<code>exec()</code> 里面的，也就是对 <code>select().where()</code>返回的对象做了 <code>limit()</code> 操作。</p><p>增加 <code>offset</code> 偏移量也是一样，在 SQL 里：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT*FROMtestWHEREnumeric_field &gt;= 3LIMIT2OFFSET2</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212070534313.png" /></p><p>这里注意总共满足条件的数据只有 3 条，在跳过 2 条后（<code>OFFSET 2</code> ）只剩下 1 条数据可查询，所以这里即使<code>LIMIT 2</code> ，也只返回了一条数据。</p><p>在 SQLModel 里：</p><div class="code-wrapper"><pre><code class="hljs python">session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.numeric_field &gt;= <span class="hljs-number">3</span>).offset(<span class="hljs-number">2</span>).limit(<span class="hljs-number">2</span>)).<span class="hljs-built_in">all</span>()<span class="hljs-comment"># 或</span>session.<span class="hljs-built_in">exec</span>(select(Test).where(Test.numeric_field &gt;= <span class="hljs-number">3</span>).limit(<span class="hljs-number">2</span>).offset(<span class="hljs-number">2</span>)).<span class="hljs-built_in">all</span>()</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212070539528.png" /></p><p>这里 <code>offset()</code> 和 <code>limit()</code>的顺序没关系，不影响结果。</p><h2 id="更新---update">更新 - UPDATE</h2><p>在 SQL 中：</p><div class="code-wrapper"><pre><code class="hljs mysql">UPDATEtestSETstring_field = &#x27;SQL_UPDATE_ID_3&#x27;WHEREid = 3</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212071335853.png" /></p><p>在 SQLModel 中：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_test_record</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        result = session.get(Test, <span class="hljs-number">4</span>)        result.string_field = <span class="hljs-string">&#x27;SQLMODEL_UPDATE_ID_4&#x27;</span>        session.add(result)        session.commit()</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212071339300.png" /></p><p>可以看到， <code>id=4</code>这条记录的字段已经更新成功。不过这种写法与其说是更新，不如说是覆盖，因为我感觉这代码几乎和<code>INSERT</code> 操作一样。因此我做个尝试，如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_test_record</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        result = Test(<span class="hljs-built_in">id</span>=<span class="hljs-number">5</span>, numeric_field=<span class="hljs-number">5</span>, string_field=<span class="hljs-string">&#x27;CUSTOM_ID_5&#x27;</span>)        result.string_field = <span class="hljs-string">&#x27;SQLMODEL_UPDATE_ID_5&#x27;</span>        session.add(result)        session.commit()</code></pre></div><p>然而报错了，是在 <code>session.commit()</code>时出错的，错误信息如下：</p><div class="code-wrapper"><pre><code class="hljs sas">sqlalchemy.exc.IntegrityError: (MySQLdb.IntegrityError) (1062, <span class="hljs-string">&quot;Duplicate entry &#x27;5&#x27; for key &#x27;test.PRIMARY&#x27;&quot;</span>)[SQL: <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test (id, numeric_field, string_field) VALUES (<span class="hljs-title function_">%s</span>, <span class="hljs-title function_">%s</span>, <span class="hljs-title function_">%s</span>)][parameters: (5, 5, <span class="hljs-string">&#x27;CUSTOM_ID_5&#x27;</span>)](Background <span class="hljs-keyword">on</span> this <span class="hljs-keyword">error</span> at: https://sqlalche.me/e/14/gkpj)</code></pre></div><p>SQLAlchemy 与 MySQLdb 官方文档给出的解释是：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212071523782.png" /></p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212071525723.png" /></p><p>还是不太明白这里为啥会有问题。</p><p>不过如果非要做这样的操作，可以使用 <code>merge()</code> ，这样：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">custom_update</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        test = Test(<span class="hljs-built_in">id</span>=<span class="hljs-number">5</span>, numeric_field=<span class="hljs-number">5</span>, string_field=<span class="hljs-string">&#x27;CUSTOM_ID_5&#x27;</span>)        session.merge(test)        session.commit()</code></pre></div><p>这样无论是更新数据还是插入数据都可以。</p><h2 id="删除---delete">删除 - DELETE</h2><p>在 SQL 里：</p><div class="code-wrapper"><pre><code class="hljs mysql">DELETEFROMtestWHEREid = 7</code></pre></div><p>删前：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212081124913.png" /></p><p>删后：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212081125097.png" /></p><p>在 SQLModel 里：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_test_record</span>():    <span class="hljs-keyword">with</span> Session(engine) <span class="hljs-keyword">as</span> session:        result = session.get(Test, <span class="hljs-number">6</span>)        session.delete(result)        session.commit()</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212081129966.png" /></p><p>跟 <code>INSERT</code> 数据类似，这里在调用 <code>.delete()</code>后也需要 <code>commit()</code> 。</p><h2 id="连接---join">连接 - JOIN</h2><h3 id="创建连接表">创建连接表</h3><p>这里主要是讲的外键。</p><p>这里比如我需要建一张表叫 <code>test2</code> ，其中主键是<code>id</code> ，还有一个字段是 <code>test_id</code> ，但这个字段与<code>test</code> 表的字段具有外键关系。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span>(SQLModel, table=<span class="hljs-literal">True</span>):    <span class="hljs-built_in">id</span>: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = Field(default=<span class="hljs-literal">None</span>, primary_key=<span class="hljs-literal">True</span>)    test_id: <span class="hljs-built_in">int</span> = Field(foreign_key=<span class="hljs-string">&#x27;test.id&#x27;</span>)</code></pre></div><p>这样就可以了。</p><h3 id="创建">创建</h3><p>跟正常的一样。</p><h3 id="查询">查询</h3>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fastapi</tag>
      
      <tag>sqlmodel</tag>
      
      <tag>orm</tag>
      
      <tag>sqlalchemy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL 15.1</title>
    <link href="/2022/12/04/postgresql/"/>
    <url>/2022/12/04/postgresql/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.postgresql.org/docs/current/">PostgreSQL:Documentation: 15: PostgreSQL 15.1 Documentation</a></p><p><a href="http://www.postgres.cn/docs/14/index.html">PostgreSQL 14.1手册</a></p><p>以翻译总结的形式过一遍官方文档，学习 PostgreSQL 15.1版本。上面两个链接是参考。</p></blockquote><h1 id="前言">前言</h1><p>PostgreSQL 是一个基于 <ahref="https://dsf.berkeley.edu/postgres.html">POSTGRES, Version 4.2</a>的对象关系数据库管理系统 （ORDBMS），由加州大学伯克利分校计算机科学系开发。支持大部分 SQL标准并提供许多现代特性，比如：</p><ul><li>复杂查询</li><li>外键</li><li>触发器</li><li>可更新视图</li><li>事务完整性</li><li>多版本并发控制</li></ul><p>然后它可以用许多方法扩展，比如增加新的：</p><ul><li>数据类型</li><li>函数</li><li>操作符</li><li>聚集函数</li><li>索引方法</li><li>过程语言</li></ul><h1 id="教程">教程</h1><h2 id="架构基础">架构基础</h2><p>PostgreSQL 使用<strong>客户端/服务器</strong>的模型也就是<strong>C/S</strong>模型。这里主要讲服务器可以处理来自客户端的多个并发请求的逻辑，就是服务器有一个主进程称为<code>postgres</code>，它负责处理来自客户端的连接请求，为每个连接启动新的进程，本身不负责和客户传输数据。</p><p>这里的客户端指的是相对 PostgreSQL 数据库的客户端，对于一个以PostgreSQL 开发的 Web 应用程序来讲，Web 后端就是这里的客户端， Web前端不会与数据库通信。</p><h2 id="创建数据库">创建数据库</h2><div class="code-wrapper"><pre><code class="hljs postgresql"><span class="hljs-keyword">createdb</span> db_name</code></pre></div><p>这里有个小坑，我用的Windows11，如果不指定用户的话是不行的会报错，所以也许应该用：</p><div class="code-wrapper"><pre><code class="hljs postgresql">.\<span class="hljs-keyword">createdb</span>.exe -U username db_name</code></pre></div><p>这里我没有将 <code>bin</code>文件夹添加进环境变量，所以就在这里试一试。</p><p>能够看到创建数据库成功。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212041123625.png" /></p><p>创建成功了在 <code>pgAdmin4</code> 和 <code>Navicat</code>这样的工具里都可以看到。</p><h1 id="sql-语言">SQL 语言</h1><h1 id="服务端管理">服务端管理</h1><h1 id="客户端接口">客户端接口</h1><h1 id="服务端编程">服务端编程</h1><h1 id="参考">参考</h1><h1 id="内部">内部</h1><h1 id="附录">附录</h1>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>postgresql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 645 657</title>
    <link href="/2022/11/22/leetcode20221122/"/>
    <url>/2022/11/22/leetcode20221122/</url>
    
    <content type="html"><![CDATA[<h1 id="错误的集合">645. 错误的集合</h1><p>根据题目描述一个正确的集合是每个数字都出现且仅出现一次，那么我们可以用<code>dict</code>表示数字及其出现的次数。然后遍历传进来的数组，每读一个数在字典对应的值处减一，最后值为1 的就是缺失的数，值为 -1 的就是重复的数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findErrorNums</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        duplicate_num = <span class="hljs-number">0</span>        missing_num = <span class="hljs-number">0</span>        correct_map = &#123;k:<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>)&#125;        found_flag = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            correct_map[i] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> correct_map.items():            <span class="hljs-keyword">if</span> v == <span class="hljs-number">1</span>:                missing_num = k                found_flag += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> v == -<span class="hljs-number">1</span>:                duplicate_num = k                found_flag += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> found_flag == <span class="hljs-number">2</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> [duplicate_num, missing_num]</code></pre></div><h1 id="机器人能否返回原点">657. 机器人能否返回原点</h1><p>按照坐标模拟一下过程。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">judgeCircle</span>(<span class="hljs-params">self, moves: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        x,y = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> moves:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;U&#x27;</span>:                y += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;R&#x27;</span>:                x += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;D&#x27;</span>:                y -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                x -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> x==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y==<span class="hljs-number">0</span></code></pre></div><p>其实也是统计下 4 个字母的数量，需要满足 <code>U</code> 的数量等于<code>D</code> 的数量并且 <code>L</code> 的数量等于 <code>R</code>的数量。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">judgeCircle</span>(<span class="hljs-params">self, moves: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> moves.count(<span class="hljs-string">&#x27;U&#x27;</span>)==moves.count(<span class="hljs-string">&#x27;D&#x27;</span>) <span class="hljs-keyword">and</span> moves.count(<span class="hljs-string">&#x27;L&#x27;</span>)==moves.count(<span class="hljs-string">&#x27;R&#x27;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openpyxl 包的学习</title>
    <link href="/2022/11/21/openpyxl/"/>
    <url>/2022/11/21/openpyxl/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资源">学习资源</h1><p>官方文档 <ahref="https://openpyxl.readthedocs.io/en/stable/">openpyxl - A Pythonlibrary to read/write Excel 2010 xlsx/xlsm files</a></p><p>文档给出了一个简单的示例。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-comment"># 创建一个工作簿对象</span>wb = Workbook()<span class="hljs-comment"># 获取默认工作表</span>ws = wb.active<span class="hljs-comment"># 修改单元格的值</span>ws[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-number">42</span><span class="hljs-comment"># 添加行</span>ws.append([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># Python 类型会被自动转换</span><span class="hljs-keyword">import</span> datetimews[<span class="hljs-string">&#x27;A2&#x27;</span>] = datetime.datetime.now()<span class="hljs-comment"># 保存文件</span>wb.save(<span class="hljs-string">&quot;sample.xlsx&quot;</span>)</code></pre></div><p>最终得到一个这样的表格：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209052217498.png" /></p><p>接下来我跟着 OpenPyXL 的文档学习。</p><h1 id="教程">教程</h1><h2 id="创建工作簿">创建工作簿</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()</code></pre></div><p>这里的 <code>wb</code>是一个工作簿对象而不是工作表对象，一个工作簿里可能有很多工作表。所以接下来就是获取工作表对象。</p><h2 id="打开工作簿">打开工作簿</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = loan_workbook(<span class="hljs-string">r&#x27;sample.xlsx&#x27;</span>)</code></pre></div><p>打开一个已存在的工作簿用这种方式。至于用哪种方法获取工作簿对象就看需求了。</p><h2 id="获取工作表">获取工作表</h2><div class="code-wrapper"><pre><code class="hljs python">ws = wb.active</code></pre></div><p>默认获取最左边（下标为 0 ）的工作表。</p><p>当然，如果是读取一个 Excel，它可能本身就有工作表，也可以这样获取工作表对象。</p><div class="code-wrapper"><pre><code class="hljs python">ws = wb[<span class="hljs-string">&#x27;Sheet1&#x27;</span>]</code></pre></div><p>如果要获取工作簿里所有工作表的名称，则可以用工作簿对象的<code>sheetnames</code> 这个属性。</p><div class="code-wrapper"><pre><code class="hljs python">wb.sheetnames</code></pre></div><h2 id="创建工作表">创建工作表</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ws1 = wb.create_sheet(<span class="hljs-string">&quot;Mysheet&quot;</span>) <span class="hljs-comment"># 在最后的位置插入工作表，类似 list 的 append 方法</span><span class="hljs-comment"># or</span><span class="hljs-meta">&gt;&gt;&gt; </span>ws2 = wb.create_sheet(<span class="hljs-string">&quot;Mysheet&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment"># 在第一个位置插入工作表</span><span class="hljs-comment"># or</span><span class="hljs-meta">&gt;&gt;&gt; </span>ws3 = wb.create_sheet(<span class="hljs-string">&quot;Mysheet&quot;</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment"># 在倒数第二个位置插入工作表，因为不写才是在最后插入</span></code></pre></div><h2 id="复制工作表">复制工作表</h2><div class="code-wrapper"><pre><code class="hljs python">copy_sheet = wb.copy_worksheet(ws)</code></pre></div><p>得到这样的新工作表：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209052242561.png" /></p><blockquote><p>仅复制单元格（包括值、样式、超链接和注释）和某些工作表属性（包括尺寸、格式和属性）。不复制所有其他工作簿/工作表属性- 例如图像，图表。</p><p>也不能在工作簿之间复制工作表。如果工作簿以只读或只写模式打开，则无法复制工作表。</p></blockquote><h2 id="工作表的属性">工作表的属性</h2><h3 id="工作表的名称">工作表的名称</h3><div class="code-wrapper"><pre><code class="hljs python">ws.title</code></pre></div><h3 id="工作表标签的颜色">工作表标签的颜色</h3><div class="code-wrapper"><pre><code class="hljs python">ws.sheet_properties.tabColor = <span class="hljs-string">&quot;FF0000&quot;</span> <span class="hljs-comment"># 比如我用红色</span></code></pre></div><p>结果就是：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209052237731.png" /></p><p>好像也没有那么红，不过确实跟白色不同。</p><h2 id="获取单元格">获取单元格</h2><h3 id="单个单元格">单个单元格</h3><div class="code-wrapper"><pre><code class="hljs python">ws[<span class="hljs-string">&#x27;A1&#x27;</span>] <span class="hljs-comment"># 获取 A1 这个单元格</span><span class="hljs-comment"># or</span>ws.cell(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>) <span class="hljs-comment"># 获取第一行第一列这个单元格</span>ws[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-number">1</span> <span class="hljs-comment"># 更改 A1 这个表格的值</span><span class="hljs-comment"># or</span>ws.cell(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>, value=<span class="hljs-number">1</span>)</code></pre></div><p>其实就是一个是以单元格名获取单元格，另一个以行名和列名获取单元格。</p><blockquote><p>值得注意的是，单元格是在首次访问它时创建的，只要访问过了，不赋值也会创建。</p><p>这个跟表格的最大行数最大列数会有关系。</p></blockquote><h3 id="多个单元格">多个单元格</h3><div class="code-wrapper"><pre><code class="hljs python">ws[<span class="hljs-string">&#x27;A1&#x27;</span>:<span class="hljs-string">&#x27;C2&#x27;</span>] <span class="hljs-comment"># 获取 A1 到 C2 这个范围的单元格</span>ws[<span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-string">&#x27;C&#x27;</span>] <span class="hljs-comment"># 获取 A 列到 C 列的单元格</span>ws[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>] <span class="hljs-comment"># 获取 1,2 行单元格</span></code></pre></div><p>当然也可以用迭代器获取：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 行优先获取</span>ws.iter_rows(min_row, min_col, max_row, max_col)<span class="hljs-comment"># 列优先获取</span>ws.iter_rows(min_row, min_col, max_row, max_col)</code></pre></div><p>一般使用 <code>for cells in iterator</code>，返回的是行或列的元组而并非每一个格子。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> cells <span class="hljs-keyword">in</span> ws.iter_rows(min_row=<span class="hljs-number">1</span>, min_col=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">3</span>, max_col=<span class="hljs-number">3</span>):<span class="hljs-built_in">print</span>(cells)</code></pre></div><p>结果是这样的：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209052313081.png" /></p><p>如果想要直接看值，可以为生成器传入 <code>values_only=True</code>生成全是值的迭代器。</p><div class="code-wrapper"><pre><code class="hljs python">ws.iter_rows(min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>, max_row=<span class="hljs-number">2</span>, values_only=<span class="hljs-literal">True</span>)</code></pre></div><p>当然如果是想获取全部的行列也可以用：</p><div class="code-wrapper"><pre><code class="hljs python">ws.rowsws.columns</code></pre></div><h2 id="保存文件">保存文件</h2><div class="code-wrapper"><pre><code class="hljs python">wb.save(<span class="hljs-string">r&#x27;/openpyxl_sample/sample.xlsx&#x27;</span>) <span class="hljs-comment"># 保存到路径</span></code></pre></div><p>这样保存路径，我个人习惯加 <code>r</code>以免遇到反斜杠转义错误。</p><blockquote><p>此操作将覆盖现有文件而不发出警告。所以说要小心一点不要随便用，不过这个应该都会的吧，pandas 的 to_csv 这类方法也是一样的。</p></blockquote><h1 id="简单使用">简单使用</h1><h2 id="日期格式">日期格式</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()ws = wb.activews[<span class="hljs-string">&#x27;A1&#x27;</span>] = datetime.datetime(<span class="hljs-number">2022</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>)<span class="hljs-built_in">print</span>(ws[<span class="hljs-string">&#x27;A1&#x27;</span>].value)<span class="hljs-built_in">print</span>(ws[<span class="hljs-string">&#x27;A1&#x27;</span>].number_format)</code></pre></div><p>结果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209052342203.png" /></p><h2 id="公式">公式</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()ws = wb.activews[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-number">1</span>ws[<span class="hljs-string">&#x27;B1&#x27;</span>] = <span class="hljs-number">1</span>ws[<span class="hljs-string">&#x27;C1&#x27;</span>] = <span class="hljs-string">&#x27;=SUM(A1:B1)&#x27;</span><span class="hljs-built_in">print</span>(ws[<span class="hljs-string">&#x27;C1&#x27;</span>].value)</code></pre></div><p>输出如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209062142285.png" /></p><p>不过在表格中是有效的，如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209052348329.png" /></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl.utils <span class="hljs-keyword">import</span> FORMULAE<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SUM&#x27;</span> <span class="hljs-keyword">in</span> FORMULAE)</code></pre></div><p>可以用 <code>FORMULAE</code> 检验是否公式可识别。</p><h2 id="合并取消合并单元格">合并/取消合并单元格</h2><p>合并单元格时，除了左上角的所有单元格都将从工作表中删除。</p><div class="code-wrapper"><pre><code class="hljs python">ws.merge_cells(start_row, start_column, end_row, end_column)ws.unmerge_cells(start_row, start_column, end_row, end_column)<span class="hljs-comment"># or</span>ws.merge_cells(<span class="hljs-string">&#x27;A1:C3&#x27;</span>)ws.unmerge_cells(<span class="hljs-string">&#x27;A1:C3&#x27;</span>)</code></pre></div><p>取消合并的范围必须是已经合并的范围，否则会报错。</p><h2 id="插入图像">插入图像</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.drawing.image <span class="hljs-keyword">import</span> Imagewb = Workbook()ws = wb.activeimg = Image(<span class="hljs-string">&#x27;logo.jpg&#x27;</span>) <span class="hljs-comment"># 加载图像</span>ws.add_image(img, <span class="hljs-string">&#x27;A1&#x27;</span>) <span class="hljs-comment"># 插入图像至工作表</span>wb.save(<span class="hljs-string">&#x27;simple_usage.xlsx&#x27;</span>)</code></pre></div><p>我也随便插入了张图片，效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209060222333.png" /></p><p>看了下源码， openpyxl这个库本身没有提供处理图片的方法（包括调整大小这种也没有）。不过它是用的Pillow 导入的图片，应该也能用 Pillow 操作，这里暂时不研究了。</p><h2 id="折叠表格">折叠表格</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 按列折叠</span>ws.column_dimensions.group(<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>, hidden=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 按行折叠</span>ws.row_dimensions.group(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>, hidden=<span class="hljs-literal">True</span>)</code></pre></div><p>这个折叠好像跟我想的有点不太一样，我以为是隐藏那个功能但不是，结果长这样：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209060234278.png" /></p><p>可以通过图上的 <code>+</code> 与 <code>-</code> 折叠与展开。</p><p>我查了一下它是用的这个功能：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209060242781.png" /></p><h1 id="优化模式">优化模式</h1><h2 id="只读模式">只读模式</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbookwb = load_workbook(filename=<span class="hljs-string">&#x27;sample.xlsx&#x27;</span>, read_only=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 关闭工作簿</span>wb.close()</code></pre></div><blockquote><p>只读模式的工作簿必须使用 <code>close()</code>方法显式关闭工作簿。</p></blockquote><h2 id="只写模式">只写模式</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook(write_only=<span class="hljs-literal">True</span>)</code></pre></div><blockquote><ul><li>只写模式的工作簿必须使用 <code>wb.create_sheet()</code>方法创建新的工作表，而不能用 <code>wb.active</code> 。</li><li>只写模式工作簿的工作表中，只能使用 <code>append()</code>方法添加行，不能使用 <code>cell()</code> 或 <code>iter_rows()</code>操作单元格。</li><li>只写工作簿只能保存一次。之后，每次将工作簿或 <code>append()</code>保存到现有工作表的尝试都会抛出异常。</li></ul></blockquote><h1 id="插入删除行列与移动表格">插入删除行列与移动表格</h1><h2 id="插入行列">插入行列</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 插入行</span>ws.insert_rows()<span class="hljs-comment"># 插入列</span>ws.insert_cols()</code></pre></div><p>像插入删除移动这种操作需要记住的是下标这个问题。比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()ws = wb.activews[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-number">1</span><span class="hljs-comment"># ws.insert_rows(0)</span><span class="hljs-comment"># ws.insert_cols(0)</span><span class="hljs-comment"># or</span><span class="hljs-comment"># ws.insert_rows(1)</span><span class="hljs-comment"># ws.insert_cols(1)</span>wb.save(<span class="hljs-string">&#x27;insert_delete_move.xlsx&#x27;</span>)</code></pre></div><p>以上代表不管是以 0 这个位置还是 1 这个位置结果都长这样：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070009244.png" /></p><p>所以说就是在你的第 n 行/列前插入行列。 Excel的插入行或者插入列也是在选择的行列之前。</p><h2 id="删除行列">删除行列</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 删除行</span>ws.delete_rows()<span class="hljs-comment"># 删除列</span>ws.delete_cols()</code></pre></div><p>当然这个方法可以删多行或者多列，比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()ws = wb.active<span class="hljs-comment"># 每个格子填自己的单元格坐标</span><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):        ws.cell(row=row, column=col, value=<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">chr</span>(<span class="hljs-number">64</span>+col)&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&#x27;</span>)<span class="hljs-comment"># 从第 3 列开始，删除 4 列（即 3(C)、4(D)、5(E)、6(F) 列）</span>ws.delete_cols(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-built_in">print</span>(ws.max_column)wb.save(<span class="hljs-string">&#x27;insert_delete_move.xlsx&#x27;</span>)</code></pre></div><p>像这样，打印结果是 6 ，表格结果就是：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070023828.png" /></p><p>可以看到 C、D、E、F 本来的数据被删了导致后面的列放到前面来了。</p><h2 id="单元格组的移动">单元格组的移动</h2><div class="code-wrapper"><pre><code class="hljs python">ws.move_range(<span class="hljs-string">&#x27;B4:C5&#x27;</span>, rows=-<span class="hljs-number">1</span>, cols=<span class="hljs-number">1</span>)</code></pre></div><ul><li>在行这个维度上，负数代表向上移动，正数代表向下移动。</li><li>在列这个维度上，负数代表向左移动，正数代表向右移动。</li></ul><p>比如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()ws = wb.active<span class="hljs-comment"># 每个格子填自己的单元格坐标</span><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):        ws.cell(row=row, column=col, value=<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">chr</span>(<span class="hljs-number">64</span>+col)&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&#x27;</span>)<span class="hljs-comment"># B4:C5 向右下移动一格</span>ws.move_range(<span class="hljs-string">&#x27;B4:C5&#x27;</span>, rows=<span class="hljs-number">1</span>, cols=<span class="hljs-number">1</span>)wb.save(<span class="hljs-string">&#x27;insert_delete_move.xlsx&#x27;</span>)</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070030284.png" /></p><p>看，<code>B4:C5</code> 向右下移动了一位吧。</p><p>如果你不希望你的公式乱掉，你可以：</p><div class="code-wrapper"><pre><code class="hljs python">ws.move_range(<span class="hljs-string">&#x27;B4:C5&#x27;</span>, rows=<span class="hljs-number">1</span>, cols=<span class="hljs-number">1</span>, translate=<span class="hljs-literal">True</span>)</code></pre></div><h1 id="numpy-和-pandas-相关">NumPy 和 Pandas 相关</h1><p><strong>这里是非常重要的一部分</strong>。因为用 openpyxl的目的就是为了展示数据统计或分析之后的成果，在 Python里处理数据一般都是用 Pandas 或者 NumPy 。</p><h2 id="worksheet-添加-dataframe">Worksheet 添加 DataFrame</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.utils.dataframe <span class="hljs-keyword">import</span> dataframe_to_rows<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pdwb = Workbook()ws = wb.activedf = pd.DataFrame(&#123;<span class="hljs-string">&#x27;number&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;str&#x27;</span>: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]&#125;)<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> dataframe_to_rows(df, header=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">False</span>):    ws.append(r)wb.save(<span class="hljs-string">&#x27;numpy_pandas.xlsx&#x27;</span>)</code></pre></div><p>结果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070111115.png" /></p><p>其实就是利用 <code>dataframe_to_rows()</code> 这个方法逐行添加。</p><h2 id="worksheet-转换为-dataframe">Worksheet 转换为 DataFrame</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pddf = pd.DataFrame(ws.values)</code></pre></div><p>从这里我们可以看出来，取值的操作是加了 <code>values</code>的，所以如果是用 <code>cell</code> 单元格，也得是<code>cell.value</code> 才行。</p><h1 id="图表">图表</h1><p><strong>这里我认为是最重要的一部分。</strong>这里可以说是用 Excel的原因所在。</p><h2 id="作图流程示例">作图流程示例</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbookwb = Workbook()ws = wb.active<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):    ws.append([i])<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> BarChart, Reference, Seriesvalues = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">10</span>) <span class="hljs-comment"># 选择作图数据</span>chart = BarChart() <span class="hljs-comment"># 选择图表类型</span>chart.add_data(values) <span class="hljs-comment"># 关联数据与图表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;B1&#x27;</span>) <span class="hljs-comment"># 将图表添加到工作表并指定位置</span>wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>完成后的效果是这样的：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070227159.png" /></p><p>那么图表的大小也是可以修改的，比如上面所用的 <code>BarChart</code>，它实际上继承了 <code>ChartBase</code> ，这里展示一些<code>ChartBase</code> 的源码。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070157686.png" /></p><p>那很显然，这个 <code>ChartBase</code>里是有宽与高的属性的，要更深层的自定义图表的效果势必要研究这一块的源码。</p><h2 id="图表类型">图表类型</h2><h3 id="面积图---area-charts">面积图 - Area Charts</h3><h4 id="二维面积图---2d-area-charts">二维面积图 - 2D Area Charts</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    AreaChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = AreaChart()<span class="hljs-comment"># 图表标题</span>chart.title = <span class="hljs-string">&#x27;面积图&#x27;</span><span class="hljs-comment"># 图表风格</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># X 轴标题</span>chart.x_axis.title = <span class="hljs-string">&#x27;数据&#x27;</span><span class="hljs-comment"># Y 轴标题</span>chart.y_axis.title = <span class="hljs-string">&#x27;占比&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 将数据与图表关联</span>chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将 X 轴与标签关联</span>chart.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&quot;A10&quot;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070216454.png" /></p><h4 id="三维面积图---3d-area-charts">三维面积图 - 3D Area Charts</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    AreaChart3D,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = AreaChart3D()<span class="hljs-comment"># 图表标题</span>chart.title = <span class="hljs-string">&#x27;面积图&#x27;</span><span class="hljs-comment"># 图表风格</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># X 轴标题</span>chart.x_axis.title = <span class="hljs-string">&#x27;数据&#x27;</span><span class="hljs-comment"># Y 轴标题</span>chart.y_axis.title = <span class="hljs-string">&#x27;占比&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 将数据与图表关联</span>chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将 X 轴与标签关联</span>chart.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&quot;A10&quot;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209070223200.png" /></p><h3 id="柱状图与条形图---bar-and-column-charts">柱状图与条形图 - Bar andColumn Charts</h3><h4id="二维柱状图二维条形图与堆积图">二维柱状图、二维条形图与堆积图</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    BarChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart1 = BarChart()<span class="hljs-comment"># 图表标题</span>chart1.title = <span class="hljs-string">&#x27;柱状图&#x27;</span><span class="hljs-comment"># 图表风格</span>chart1.style = <span class="hljs-number">10</span><span class="hljs-comment"># X 轴标题</span>chart1.x_axis.title = <span class="hljs-string">&#x27;数据&#x27;</span><span class="hljs-comment"># Y 轴标题</span>chart1.y_axis.title = <span class="hljs-string">&#x27;占比&#x27;</span><span class="hljs-comment"># 选择柱状图的类型</span>chart1.<span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;col&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 将数据与图表关联</span>chart1.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将 X 轴与标签关联</span>chart1.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart1, <span class="hljs-string">&#x27;A10&#x27;</span>)<span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopychart2 = deepcopy(chart1)chart2.<span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;bar&#x27;</span>chart2.title = <span class="hljs-string">&#x27;条形图&#x27;</span>ws.add_chart(chart2, <span class="hljs-string">&#x27;J10&#x27;</span>)chart3 = deepcopy(chart1)chart3.grouping = <span class="hljs-string">&#x27;stacked&#x27;</span>chart3.overlap = <span class="hljs-number">100</span>chart3.title = <span class="hljs-string">&#x27;柱状堆积图&#x27;</span>ws.add_chart(chart3, <span class="hljs-string">&#x27;A27&#x27;</span>)chart4 = deepcopy(chart2)chart4.grouping = <span class="hljs-string">&#x27;percentStacked&#x27;</span>chart4.overlap = <span class="hljs-number">100</span>chart4.title = <span class="hljs-string">&#x27;百分比堆积图&#x27;</span>ws.add_chart(chart4, <span class="hljs-string">&#x27;J27&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209072331682.png" /></p><h4 id="三维柱状图">三维柱状图</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    BarChart3D,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart1 = BarChart3D()<span class="hljs-comment"># 图表标题</span>chart1.title = <span class="hljs-string">&#x27;三维柱状图&#x27;</span><span class="hljs-comment"># 图表风格</span>chart1.style = <span class="hljs-number">10</span><span class="hljs-comment"># X 轴标题</span>chart1.x_axis.title = <span class="hljs-string">&#x27;数据&#x27;</span><span class="hljs-comment"># Y 轴标题</span>chart1.y_axis.title = <span class="hljs-string">&#x27;占比&#x27;</span><span class="hljs-comment"># 选择柱状图的类型</span>chart1.<span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;col&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 将数据与图表关联</span>chart1.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将 X 轴与标签关联</span>chart1.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart1, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209072339092.png" /></p><h3 id="气泡图---bubble-charts">气泡图 - Bubble Charts</h3><blockquote><p>气泡图类似于散点图，但使用另一维数据来确定气泡的大小。图表可以包括多个系列。</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    BubbleChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = BubbleChart()chart.style = <span class="hljs-number">10</span>chart.title = <span class="hljs-string">&#x27;气泡图&#x27;</span><span class="hljs-comment"># 定义数据的坐标</span>xvalues = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">7</span>)yvalues = Reference(ws, min_col=<span class="hljs-number">3</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 定义泡泡大小</span>size = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 关联图表与数据</span>series = Series(values=yvalues, xvalues=xvalues, zvalues=size, title=<span class="hljs-string">&#x27;Number&#x27;</span>)chart.series.append(series)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209080031958.png" /></p><h3 id="折线图---line-charts">折线图 - Line Charts</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    LineChart,    Reference,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = LineChart()chart.title = <span class="hljs-string">&#x27;折线图&#x27;</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># X 轴标题</span>chart.x_axis.title = <span class="hljs-string">&#x27;数据&#x27;</span><span class="hljs-comment"># Y 轴标题</span>chart.y_axis.title = <span class="hljs-string">&#x27;占比&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 将数据与图表关联</span>chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将 X 轴与标签关联</span>chart.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209080056319.png" /></p><h3 id="散点图---scatter-charts">散点图 - Scatter Charts</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    ScatterChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;分支1&#x27;</span>, <span class="hljs-string">&#x27;分支2&#x27;</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">25</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">7</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = ScatterChart()chart.title = <span class="hljs-string">&#x27;散点图&#x27;</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># X 轴标题</span>chart.x_axis.title = <span class="hljs-string">&#x27;数据&#x27;</span><span class="hljs-comment"># Y 轴标题</span>chart.y_axis.title = <span class="hljs-string">&#x27;占比&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">7</span>)<span class="hljs-comment"># 依次添加数据</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>):    data = Reference(ws, min_col=i, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">7</span>)    series = Series(data, cats, title_from_data=<span class="hljs-literal">True</span>)    chart.series.append(series)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209090118802.png" /></p><h3 id="饼状图---pie-charts">饼状图 - Pie Charts</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    PieChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Category&#x27;</span>, <span class="hljs-string">&#x27;Percentage&#x27;</span>],    [<span class="hljs-number">1</span>, <span class="hljs-number">20</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">50</span>]]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = PieChart()chart.title = <span class="hljs-string">&#x27;饼状图&#x27;</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">4</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">4</span>)chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)chart.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209090125558.png" /></p><h3 id="圆环图---doughnut-charts">圆环图 - Doughnut Charts</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    DoughnutChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.active<span class="hljs-comment"># rows = [</span><span class="hljs-comment">#     [&#x27;Number&#x27;, &#x27;分支1&#x27;, &#x27;分支2&#x27;],</span><span class="hljs-comment">#     [2, 40, 30],</span><span class="hljs-comment">#     [3, 40, 25],</span><span class="hljs-comment">#     [4, 50, 30],</span><span class="hljs-comment">#     [5, 30, 10],</span><span class="hljs-comment">#     [6, 25, 5],</span><span class="hljs-comment">#     [7, 50, 10],</span><span class="hljs-comment"># ]</span>rows = [    [<span class="hljs-string">&#x27;Category&#x27;</span>, <span class="hljs-string">&#x27;Percentage&#x27;</span>],    [<span class="hljs-number">1</span>, <span class="hljs-number">20</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">50</span>]]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = DoughnutChart()chart.title = <span class="hljs-string">&#x27;圆环图&#x27;</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># # X 轴标题</span><span class="hljs-comment"># chart.x_axis.title = &#x27;数据&#x27;</span><span class="hljs-comment"># # Y 轴标题</span><span class="hljs-comment"># chart.y_axis.title = &#x27;占比&#x27;</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">4</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">4</span>)chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)chart.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209090127457.png" /></p><h3 id="雷达图---radar-charts">雷达图 - Radar Charts</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    RadarChart,    Reference,    Series,)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">数据层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>wb = Workbook()ws = wb.activerows = [    [<span class="hljs-string">&#x27;Category&#x27;</span>, <span class="hljs-string">&#x27;Percentage&#x27;</span>],    [<span class="hljs-number">1</span>, <span class="hljs-number">20</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">50</span>],    [<span class="hljs-number">4</span>, <span class="hljs-number">20</span>],    [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">30</span>]]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    ws.append(row)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">展示层</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment"># 定义图表类型</span>chart = RadarChart()chart.title = <span class="hljs-string">&#x27;雷达图&#x27;</span>chart.style = <span class="hljs-number">10</span><span class="hljs-comment"># 选择标签数据</span>cats = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">4</span>)<span class="hljs-comment"># 选择数据</span>data = Reference(ws, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">4</span>)chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)chart.set_categories(cats)<span class="hljs-comment"># 将图表添加进工作表</span>ws.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209090134136.png" /></p><h3 id="股票图---stock-charts">股票图 - Stock Charts</h3><p>这个暂时不用。</p><h3 id="曲面图---surface-charts">曲面图 - Surface charts</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> (    SurfaceChart,    SurfaceChart3D,    Reference,    Series,)<span class="hljs-keyword">from</span> openpyxl.chart.axis <span class="hljs-keyword">import</span> SeriesAxis<span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    数据层</span><span class="hljs-string">&quot;&quot;&quot;</span>wb = Workbook()ws = wb.activedata = [    [        <span class="hljs-literal">None</span>,        <span class="hljs-number">10</span>,        <span class="hljs-number">20</span>,        <span class="hljs-number">30</span>,        <span class="hljs-number">40</span>,        <span class="hljs-number">50</span>,    ],    [        <span class="hljs-number">0.1</span>,        <span class="hljs-number">15</span>,        <span class="hljs-number">65</span>,        <span class="hljs-number">105</span>,        <span class="hljs-number">65</span>,        <span class="hljs-number">15</span>,    ],    [        <span class="hljs-number">0.2</span>,        <span class="hljs-number">35</span>,        <span class="hljs-number">105</span>,        <span class="hljs-number">170</span>,        <span class="hljs-number">105</span>,        <span class="hljs-number">35</span>,    ],    [        <span class="hljs-number">0.3</span>,        <span class="hljs-number">55</span>,        <span class="hljs-number">135</span>,        <span class="hljs-number">215</span>,        <span class="hljs-number">135</span>,        <span class="hljs-number">55</span>,    ],    [        <span class="hljs-number">0.4</span>,        <span class="hljs-number">75</span>,        <span class="hljs-number">155</span>,        <span class="hljs-number">240</span>,        <span class="hljs-number">155</span>,        <span class="hljs-number">75</span>,    ],    [        <span class="hljs-number">0.5</span>,        <span class="hljs-number">80</span>,        <span class="hljs-number">190</span>,        <span class="hljs-number">245</span>,        <span class="hljs-number">190</span>,        <span class="hljs-number">80</span>,    ],    [        <span class="hljs-number">0.6</span>,        <span class="hljs-number">75</span>,        <span class="hljs-number">155</span>,        <span class="hljs-number">240</span>,        <span class="hljs-number">155</span>,        <span class="hljs-number">75</span>,    ],    [        <span class="hljs-number">0.7</span>,        <span class="hljs-number">55</span>,        <span class="hljs-number">135</span>,        <span class="hljs-number">215</span>,        <span class="hljs-number">135</span>,        <span class="hljs-number">55</span>,    ],    [        <span class="hljs-number">0.8</span>,        <span class="hljs-number">35</span>,        <span class="hljs-number">105</span>,        <span class="hljs-number">170</span>,        <span class="hljs-number">105</span>,        <span class="hljs-number">35</span>,    ],    [<span class="hljs-number">0.9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">65</span>, <span class="hljs-number">105</span>, <span class="hljs-number">65</span>, <span class="hljs-number">15</span>],]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> data:    ws.append(row)<span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    展示层</span><span class="hljs-string">&quot;&quot;&quot;</span>c1 = SurfaceChart()ref = Reference(ws, min_col=<span class="hljs-number">2</span>, max_col=<span class="hljs-number">6</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">10</span>)labels = Reference(ws, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">10</span>)c1.add_data(ref, titles_from_data=<span class="hljs-literal">True</span>)c1.set_categories(labels)c1.title = <span class="hljs-string">&quot;二维曲面图&quot;</span>ws.add_chart(c1, <span class="hljs-string">&quot;G1&quot;</span>)<span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy<span class="hljs-comment"># 线框</span>c2 = deepcopy(c1)c2.wireframe = <span class="hljs-literal">True</span>c2.title = <span class="hljs-string">&quot;二维框线图&quot;</span>ws.add_chart(c2, <span class="hljs-string">&quot;N1&quot;</span>)<span class="hljs-comment"># 3D 表面</span>c3 = SurfaceChart3D()c3.add_data(ref, titles_from_data=<span class="hljs-literal">True</span>)c3.set_categories(labels)c3.title = <span class="hljs-string">&quot;三维曲面图&quot;</span>ws.add_chart(c3, <span class="hljs-string">&quot;G17&quot;</span>)c4 = deepcopy(c3)c4.wireframe = <span class="hljs-literal">True</span>c4.title = <span class="hljs-string">&quot;三维框线图&quot;</span>ws.add_chart(c4, <span class="hljs-string">&quot;N17&quot;</span>)wb.save(<span class="hljs-string">&#x27;charts.xlsx&#x27;</span>)</code></pre></div><p>效果如下：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202209090140116.png" /></p><h2 id="轴的使用">轴的使用</h2><h2 id="图表布局">图表布局</h2><h2 id="图表样式">图表样式</h2><h2 id="高级图表">高级图表</h2><h2 id="图表页工作表">图表页工作表</h2><h1 id="评论">评论</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxlwb = openpyxl.Workbook()ws = wb.activews[<span class="hljs-string">&#x27;A1&#x27;</span>].comment = openpyxl.comments.Comment(<span class="hljs-string">&#x27;text&#x27;</span>,<span class="hljs-string">&#x27;author&#x27;</span>)wb.save(<span class="hljs-string">&#x27;comment.xlsx&#x27;</span>)</code></pre></div><p>可以看到，评论就被添加上了，不过似乎没有 <code>Author</code> 。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202211211220411.png" /></p><p>然后同时也可以编辑评论框的大小。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxlwb = openpyxl.Workbook()ws = wb.active<span class="hljs-comment"># 以像素为单位</span>ws[<span class="hljs-string">&#x27;A1&#x27;</span>].comment = openpyxl.comments.Comment(<span class="hljs-string">&#x27;text&#x27;</span>,<span class="hljs-string">&#x27;author&#x27;</span>)ws[<span class="hljs-string">&#x27;A1&#x27;</span>].comment.width = <span class="hljs-number">1000</span>ws[<span class="hljs-string">&#x27;A1&#x27;</span>].comment.height = <span class="hljs-number">200</span><span class="hljs-comment"># 通过其它单位转换，需要用到 utils.units</span>ws[<span class="hljs-string">&#x27;B2&#x27;</span>].comment = openpyxl.comments.Comment(<span class="hljs-string">&#x27;text2&#x27;</span>, <span class="hljs-string">&#x27;author2&#x27;</span>)ws[<span class="hljs-string">&#x27;B2&#x27;</span>].comment.width = openpyxl.utils.units.points_to_pixels(<span class="hljs-number">1000</span>)ws[<span class="hljs-string">&#x27;B2&#x27;</span>].comment.height = openpyxl.utils.units.points_to_pixels(<span class="hljs-number">200</span>)wb.save(<span class="hljs-string">&#x27;comment.xlsx&#x27;</span>)</code></pre></div><p>A1：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202211211228749.png" /></p><p>B2：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202211211229164.png" /></p>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Excel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 643</title>
    <link href="/2022/11/18/leetcode20221118/"/>
    <url>/2022/11/18/leetcode20221118/</url>
    
    <content type="html"><![CDATA[<h1 id="子数组最大平均数-i">643. 子数组最大平均数 I</h1><p>最开始看这道题的时候思路错了，以为是道双指针的题，果然还是经验不足。仔细一看可以发现其实两个指针的间隔已经给定了，所以其实就是道滑动窗口的题。一开始就可以计算<code>sum(nums[0:k])</code> 求得滑动窗口初始状态的值，那么只需滑动<code>len(nums)-k</code>次就可以求出窗口和的最大值，每次滑动窗口的时候求和不需要重新计算，直接减窗口前一个数加下一个数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaxAverage</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:        max_sum = <span class="hljs-built_in">sum</span>(nums[:k])        temp_sum = max_sum        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)-k+<span class="hljs-number">1</span>):            temp_sum = temp_sum - nums[i-<span class="hljs-number">1</span>] + nums[i+k-<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> temp_sum&gt;max_sum:                max_sum = temp_sum        <span class="hljs-keyword">return</span> max_sum/k</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>SQL</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 607 620 628</title>
    <link href="/2022/11/16/leetcode20221116/"/>
    <url>/2022/11/16/leetcode20221116/</url>
    
    <content type="html"><![CDATA[<h1 id="销售员">607. 销售员</h1><p>先找出公司名为 <code>RED</code> 的所有职员的 <code>sales_id</code>，然后用 <code>NOT IN</code> 找出剩下的职员的 <code>name</code> 。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    nameFROM    SalesPersonWHERE    sales_id NOT IN (        SELECT            o.sales_id        FROM            Orders AS o            INNER JOIN Company AS c ON o.com_id = c.com_id        WHERE            c.name = &#x27;RED&#x27;    )</code></pre></div><h1 id="有趣的电影">620. 有趣的电影</h1><p>简单查询，两个条件，<code>description</code> 不为 <code>boring</code>并且 <code>id</code> 为奇数，这里用 <code>n&amp;1==1</code>来判断一个数是否为奇数。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT    id,    movie,    description,    ratingFROM    cinemaWHERE    description != &#x27;boring&#x27;    AND id &amp; 1 = 1ORDER BY    rating DESC</code></pre></div><h1 id="三个数的最大乘积">628. 三个数的最大乘积</h1><p>首先可以将这个数组排序，这三个数的最大乘积只可能有以下 2 种情况：</p><ul><li><code>0, 1, -1</code> ，如 <code>[-1000, -900, 1, 2, 3]</code></li><li><code>-1, -2, -3</code> ，如 <code>[1, 2, 3, 4, 5]</code></li></ul><p>所以代码如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        temp_lst = <span class="hljs-built_in">sorted</span>(nums)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(            temp_lst[-<span class="hljs-number">1</span>]*temp_lst[-<span class="hljs-number">2</span>]*temp_lst[-<span class="hljs-number">3</span>],             temp_lst[-<span class="hljs-number">1</span>]*temp_lst[<span class="hljs-number">0</span>]*temp_lst[<span class="hljs-number">1</span>],             )</code></pre></div><p>因此可以看出，其实我们只需要关注 5 个数就行了，也就是 -<code>-3, -2, -1, 0, 1</code> 这排序后 5个位置的数。对于没排序的数组来讲，就是最大的 3 个数和最小的 2 个数。</p><p>所以接下来要做的就是扫描一次数组把这 5个数找出来。时间复杂度可以从大约 <code>O(NlogN)</code> 变为<code>O(N)</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        max_1, max_2, max_3, min_1, min_2 = -<span class="hljs-number">1001</span>, -<span class="hljs-number">1002</span>, -<span class="hljs-number">1003</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i &gt; max_3:                max_3 = i                <span class="hljs-keyword">if</span> max_3 &gt; max_2:                    max_2, max_3 = max_3, max_2                    <span class="hljs-keyword">if</span> max_2 &gt; max_1:                        max_1, max_2 = max_2, max_1            <span class="hljs-keyword">if</span> i &lt; min_2:                min_2 = i                <span class="hljs-keyword">if</span> min_2 &lt; min_1:                    min_1, min_2 = min_2, min_1        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(min_1*min_2*max_1, max_2*max_3*max_1)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 605</title>
    <link href="/2022/11/11/leetcode20221111/"/>
    <url>/2022/11/11/leetcode20221111/</url>
    
    <content type="html"><![CDATA[<h1 id="种花问题">605. 种花问题</h1><p>贪心，从前往后遍历，能插花就插花。<code>list</code> 首尾都填<code>0</code> 方便处理边界。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canPlaceFlowers</span>(<span class="hljs-params">self, flowerbed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        length = <span class="hljs-built_in">len</span>(flowerbed)        flowerbed = [<span class="hljs-number">0</span>] + flowerbed + [<span class="hljs-number">0</span>]        count = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length + <span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> flowerbed[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> flowerbed[i+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> flowerbed[i] == <span class="hljs-number">0</span>:                count += <span class="hljs-number">1</span>                flowerbed[i] = <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> n &lt;= count</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《信用评分工具：自动化信用管理的理论与实践》 - 读书笔记</title>
    <link href="/2022/11/08/%E3%80%8A%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E7%94%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/"/>
    <url>/2022/11/08/%E3%80%8A%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E7%94%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><p>全书共 8 个部分，分别为：</p><ul><li><p>背景设定 -讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔loan做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。</p><blockquote><ol type="1"><li>信用评分及其业务 -什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。</li><li>信用微历史 -关于信用供给、信用评分、征信机构和评级机构的简要历史。</li><li>信用评分原理 - 如何进行信用评分、怎样建立评分卡。</li></ol></blockquote></li><li><p>风险业务 -针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。</p><blockquote><ol start="4" type="1"><li>风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。</li><li>决策科学 -信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。</li><li>企业风险评估 -对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。</li></ol></blockquote></li><li><p>数学和统计 -介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。</p><blockquote><ol start="7" type="1"><li>预测统计 -因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。</li><li>区分度的测量 -用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。</li><li>零碎内容 -描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。</li><li>头脑与机器 -所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。</li></ol></blockquote></li><li><p>数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。</p><blockquote><ol start="11" type="1"><li>数据考虑 -建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。</li><li>数据来源 - 讨论从客户、内部系统和征信机构获取信息。</li><li>评分结构 -关注评分卡的定制和架设、数据整合和不同来源数据的匹配。</li><li>信息共享 -征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。</li><li>数据准备 -开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。</li></ol></blockquote></li><li><p>评分卡开发 -这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把<strong>简单、可解释性强的模型</strong>作为评分卡开发时的选择这个倾向。</p><blockquote><p>Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for PrivateCompanies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.</p></blockquote><p>作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的<code>可行性分析-&gt;需求分析-&gt;总体设计-&gt;详细设计</code>有着异曲同工之妙。作者把开发前大体的步骤划分为如下：</p><ul><li>项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。</li><li>数据收集 - 从数据来源提取大小合适的样本。</li><li>好坏定义 -不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。</li><li>样本分层 -决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）</li><li>确定模型 -开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。</li><li>决策策略 -不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。</li></ul><p>开发的完整流程如下：</p><blockquote><ol start="16" type="1"><li>变量转换 -分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。</li><li>特征选取 -确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。</li><li>样本分层 -是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。</li><li>拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。</li><li>模型校准 -用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。</li><li>检验交付 -用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。</li><li>开发管理 - 评分卡开发的流程管理和安排。</li></ol></blockquote></li><li><p>实施和使用 -遵循<strong>Wiklund提供的框架</strong>，介绍模型部署与模型监控相关内容。</p><blockquote><p>在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。</p><p>Handbook of credit scoring[M]. Global Professional Publishi,2001.</p></blockquote><blockquote><ol start="23" type="1"><li>实施安装 - 绿地开发（ Greenfield Software Development,指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield SoftwareDevelopment,指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。</li><li>管理控制 - 验证审查，保证分数合理有效。</li><li>跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。</li><li>金融财务 - 损失准备金、风险定价和利润率等问题。</li></ol></blockquote></li><li><p>信用风险管理周期 -这里提到风险管理周期可以分为五个阶段，<code>市场营销-&gt;申请审批-&gt;账户管理-&gt;催收-&gt;回收</code>。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。</p><ul><li>分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。</li><li>吸引（ solicitation ） -设计和实施营销活动，吸引潜在客户办理业务。</li><li>获取（ acquisition ） -获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。</li><li>管理（ management ） -对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。</li><li>催收（ collections ） - 重点关注早期的违约和维持客户关系。</li><li>追踪（ tracing ） -尝试联系并找到一些因没有更新住址或联系方式而失联的客户。</li><li>回收（ rehabilitation ） -处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。</li></ul><p>除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。</p><blockquote><ol start="27" type="1"><li>市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。</li><li>申请审批 - 选择客户的操作。</li><li>账户管理 -询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。</li><li>催收回收 - 违约原因和催收流程、催收时机和催收策略。</li><li>欺诈防范 - 趋势、类型和工具。</li></ol></blockquote></li><li><p>监管环境 - 介绍一些对金融机构的监管内容。</p><blockquote><ol start="32" type="1"><li>监管概念 -最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。</li><li>隐私保护 -贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。</li><li>禁止歧视 -涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。</li><li>公平信贷 -确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。</li><li>资本要求 -主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。</li><li>了解客户 -提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。</li><li>国家差异 -对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。</li></ol></blockquote></li></ul><h1 id="第一部分---背景设定">第一部分 - 背景设定</h1><h2 id="第-1-章---信用评分及其业务">第 1 章 - 信用评分及其业务</h2><h3 id="什么是信用评分">1.1 什么是信用评分</h3><ul><li><p>信用</p><ul><li>借款人需履行的三项义务<ol type="1"><li>树立可信的形象。</li><li>按照合约还款。</li><li>为违约风险支付溢价。</li></ol></li><li>信誉（ credit worthiness ） - 借款人的 <strong>还款意愿</strong> 和<strong>还款能力</strong> 。<ul><li>风险较高的人也有信誉，考虑 <strong>风险与回报</strong>的关系合理定价。</li></ul></li><li>信用风险（ credit risk ） -借款人信誉实际或可能的变动所造成的潜在经济影响。</li></ul></li><li><p>评分</p><ul><li><p>用数学工具对个体按照 <strong>真实或设定的指标</strong> 进行<strong>排序</strong> 以示区分。</p></li><li><table><thead><tr class="header"><th>赛马</th><th>信贷数据</th><th>信贷行业</th></tr></thead><tbody><tr class="odd"><td>骑师</td><td>人</td><td>分析师和决策者</td></tr><tr class="even"><td>饲料</td><td>数据</td><td>申请数据、交易历史、征信机构</td></tr><tr class="odd"><td>马匹</td><td>系统</td><td>电脑程序、评分卡、策略</td></tr><tr class="even"><td>赔率</td><td>比率</td><td>历史违约率、好坏比率</td></tr><tr class="odd"><td>训练</td><td>学习</td><td>熟悉开发模型</td></tr><tr class="even"><td>赛场</td><td>市场</td><td>潜在客户、新客户、现有客户</td></tr><tr class="odd"><td>其他马匹</td><td>竞争者</td><td>信贷市场</td></tr><tr class="even"><td>终点线</td><td>评价标准</td><td>拒绝率、违约率</td></tr><tr class="odd"><td>胜利</td><td>收益</td><td>未来收益、客户满意度、市场份额</td></tr></tbody></table></li></ul></li><li><p>信用评分</p><ul><li>信用评分是利用数学模型将相关数据转化成某个数值来<strong>指导信用决策</strong> 。</li></ul></li></ul><h3 id="在哪儿使用信用评分">1.2 在哪儿使用信用评分？</h3><table><thead><tr class="header"><th>评分种类</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>申请分数</td><td>结合客户信息、交易历史和征信记录发展业务。</td></tr><tr class="even"><td>行为分数</td><td>账户管理（ 额度设定、超限管理、支付授权），通常只关注单个账户的行为。</td></tr><tr class="odd"><td>催收分数</td><td>催收过程的一部分。贷款机构从呼叫中心提取有预测能力的信息，结合借款人行为、催收和征信数据，得到催收分数。</td></tr><tr class="even"><td>客户分数</td><td>综合多个账户的行为表现，对账户管理和交叉销售都很有用。</td></tr><tr class="odd"><td>通用分数</td><td>由征信机构综合各方信息加工而得，通常是逾期或破产的预测指标。（比如FICO 分数反映了其对象再两年内发生 90 天贷款逾期的概率。）</td></tr></tbody></table><h4 id="数据来源">1.2.1 数据来源</h4><ul><li>来源种类<ul><li>客户 - 申请表、财务报表、资产信息。</li><li>内部数据 - 历史交易记录、其他账户行为。</li><li>外部数据 - 征信机构（官方和民营）、其他贷款机构、法院判决。</li></ul></li></ul><h4 id="信用风险管理周期">1.2.2 信用风险管理周期</h4><p>整个流程从前到后分别是：</p><ul><li>市场营销 - 提前筛选目标客户。</li><li>业务审批 - 审批、定价、交叉销售。</li><li>账户管理 - 额度设定、支付兑付、客户保留。</li><li>催收回收 - 客户复原、追踪、采取法律行动。</li></ul><h4 id="行为偏好">1.2.3 行为偏好</h4><ul><li>倾向评分 - 分为 4 个粗分类与 9 个细分类。<ul><li>风险 - 客户的某些行为是否会导致财务损失？<ul><li>信用 - 是否还款？</li><li>诈骗 - 是否欺骗？</li><li>保险 - 是否索赔？</li></ul></li><li>回应 - 客户是否会对报价有回应？<ul><li>回应 - 是否申请？</li><li>交叉销售 - 是否购买其他产品？</li></ul></li><li>保留 - 客户是否继续停留，还是离开？<ul><li>变动 - 是否使用后离开？</li><li>流失 - 是否离开？</li></ul></li><li>收入 - 预期收入是多少？<ul><li>使用 - 是否使用？</li><li>利润 - 是否有利可图？</li></ul></li></ul></li><li><strong>风险</strong> -评分的最大作用是风险评估。包含损失概率也涉及损失的严重程度。<ul><li>信用评分 - 对应信用风险，主要用于预测违约行为。可根据评分结果估计<strong>违约概率（ PD ）</strong>、<strong>违约暴露（ EAD）</strong>、<strong>违约损失率（ LGD ）</strong> 等。<ul><li>申请评分</li><li>行为评分</li><li>催收评分</li><li>客户评分</li><li>征信评分</li></ul></li><li>欺诈评分 -欺诈是一种操作风险，要单独处理。主要难在诈骗并不多导致的区分<strong>“没有能力支付”</strong> 与 <strong>“故意不想支付”</strong>这两种行为非常困难。</li><li>保险评分 -与信用风险的关系是一般信用评分好的人，索赔的概率也高。</li></ul></li><li>回应 -考虑到成本问题，针对用户营销。贷款机构基于个人特征、现有账户、人口特征等信息用评分来确定用户适合哪些产品。</li><li>保留 - 也是考虑成本问题，用损耗评分（ churn scoring）预测客户是否愿意继续保持业务关系。针对账户休眠或是账户注销的客户提前设计对策使其活跃。</li><li>收入 - 利润评分是最终目标，但是影响因素太多，很难实施。</li></ul><h3 id="为什么要使用信用评分">为什么要使用信用评分？</h3><h4 id="如何影响贷款机构">1.3.1 如何影响贷款机构？</h4><ul><li>正面影响 - 信用评分的优点<ul><li>准确性 - 更好的决策减少了逆向选择。</li><li><strong>速度快</strong> - 反应和处理时间大大增加。</li><li>一致性 - 标准化服务更容易控制与调整策略。</li><li><strong>客观性</strong> -得到有根据的决策结果，虽然可能存在不公正的待遇。</li><li>时效性 - 策略可以根据新的环境和形势及时更新。</li><li>分析全 - 对业务和公司进行更全面的分析。</li><li>范围广 - 通过网点或网络渠道与客户完成远距离借贷业务。</li><li>灵活性 - 进行预报、风险定价、资产估值和债务转让。</li><li><strong>成本低</strong> -当交易数据量很大时，平均运营成本降低。</li></ul></li><li>存在的问题 - 信用评分的难处<ul><li>复杂度高 -系统极其复杂，评分卡、策略或设备中的错误很难改进且会导致巨额损失。</li><li>变更管理 - 业务操作方式变化大，需要与客户和员工进行深入交流。</li><li>数据滞后 -信用评分假设未来按照过去一样发展，用过去的数据来预测未来。</li><li>技术敏感 - 专业技术不容易掌握和传承。</li><li>竞争增加 - 如果能得到足够多的数据，市场进入壁垒将会被打破。</li></ul></li><li>局限性<ul><li>数据 - 数据获取困难，数据变化很快。</li><li>模型 - 模型有偏差，结果不符合标准（过拟合）。</li><li>策略 - 当前的策略可能不适用于现状（滞后）。</li><li>实施 - 模型的实施方法可能有误。</li><li>使用 - 建模目的和使用目的不一致。</li></ul></li></ul><h4 id="对客户的影响">1.3.2 对客户的影响</h4><h3 id="信用评分如何影响信用供给">1.4 信用评分如何影响信用供给？</h3><h3 id="小结">1.5 小结</h3><h2 id="第-2-章---信用微历史">第 2 章 - 信用微历史</h2><h3 id="信用的历史">2.1 信用的历史</h3><h4 id="古代历史">2.1.1 古代历史</h4><h4 id="中世纪到-19-世纪">2.1.2 中世纪到 19 世纪</h4><h4 id="世纪">2.1.3 20 世纪</h4><h3 id="信用评分的历史">2.2 信用评分的历史</h3><h4 id="开拓时期">2.2.1 开拓时期</h4><h4 id="自动化时期">2.2.2 自动化时期</h4><h4 id="扩张时期">2.2.3 扩张时期</h4><h3 id="征信机构的历史">2.3 征信机构的历史</h3><h4 id="世纪中期以前">2.3.1 18 世纪中期以前</h4><h4 id="世纪-90-年代以后">2.3.2 19 世纪 90 年代以后</h4><h4 id="世纪-60-年代以后">2.3.3 20 世纪 60 年代以后</h4><h4 id="国际">2.3.4 国际</h4><h3 id="评级机构的历史">2.4 评级机构的历史</h3><h3 id="小结-1">2.5 小结</h3><h2 id="第三章---评分信用原理">第三章 - 评分信用原理</h2><h3 id="评分卡是什么">3.1 评分卡是什么</h3><h4 id="评分卡的形态">3.1.1 评分卡的形态</h4><h4 id="如何开发评分卡">3.1.2 如何开发评分卡</h4><h4 id="预测能力如何评估">3.1.3 预测能力如何评估</h4><h4 id="评分卡的偏差是如何出现的">3.1.4 评分卡的偏差是如何出现的</h4><h4 id="如何应对以上问题">3.1.5 如何应对以上问题</h4><h3 id="采用何种测量方法">3.2 采用何种测量方法</h3><h4 id="流程与策略">3.2.1 流程与策略</h4><h4 id="如何开发评分卡-1">3.2.2 如何开发评分卡</h4><h4 id="违约概率和损失程度">3.2.3 违约概率和损失程度</h4><h3 id="评分卡的开发流程">3.3 评分卡的开发流程</h3><h4 id="项目准备">3.3.1 项目准备</h4><h4 id="数据准备">3.3.2 数据准备</h4><h4 id="建模分析">3.3.3 建模分析</h4><h4 id="模型确定">3.3.4 模型确定</h4><h4 id="决策制定和策略">3.3.5 决策制定和策略</h4><h4 id="安全保护">3.3.6 安全保护</h4><h3 id="什么会影响评分卡">3.4 什么会影响评分卡</h3><h4 id="经济偏移">3.4.1 经济偏移</h4><h4 id="市场偏移">3.4.2 市场偏移</h4><h4 id="操作偏移">3.4.3 操作偏移</h4><h4 id="目标偏移">3.4.4 目标偏移</h4><h4 id="不明偏移">3.4.5 不明偏移</h4><h3 id="小结-2">3.5 小结</h3><h1 id="第二部分---风险业务">第二部分 - 风险业务</h1><h2 id="第-4-章---风险理论">第 4 章 - 风险理论</h2><h3 id="风险相关术语">4.1 风险相关术语</h3><h4 id="风险关联">4.1.1 风险关联</h4><h4 id="风险环境">4.1.2 风险环境</h4><h4 id="风险类型">4.1.3 风险类型</h4><h3 id="数据与模型">4.2 数据与模型</h3><h4 id="数据类型">4.2.1 数据类型</h4><h4 id="模型类型">4.2.2 模型类型</h4><h4 id="人为判断">4.2.3 人为判断</h4><h4 id="专家系统">4.2.4 专家系统</h4><h3 id="小结-3">4.3 小结</h3><h2 id="第-5-章---决策科学">第 5 章 - 决策科学</h2><h3 id="自适应控制">5.1 自适应控制</h3><h3 id="成为主人">5.2 成为主人</h3><h4 id="冠军挑战">5.2.1 冠军挑战</h4><h4 id="优化">5.2.2 优化</h4><h4 id="策略推断">5.2.3 策略推断</h4><h3 id="小结-4">5.3 小结</h3><h2 id="第-6-章---企业风险评估">第 6 章 - 企业风险评估</h2><h3 id="风险评估基础">6.1 风险评估基础</h3><h4 id="数据来源-1">6.1.1 数据来源</h4><h4 id="风险模型">6.1.2 风险模型</h4><h4 id="风险等级">6.1.3 风险等级</h4><h3 id="中小企业贷款">6.2 中小企业贷款</h3><h4 id="关系型贷款">6.2.1 关系型贷款</h4><h4 id="交易型贷款">6.2.2 交易型贷款</h4><h3 id="财务比率评分">6.3 财务比率评分</h3><h4 id="理论先驱">6.3.1 理论先驱</h4><h4 id="预测比率">6.3.2 预测比率</h4><h4 id="限制因素">6.3.3 限制因素</h4><h4 id="评级机构">6.3.4 评级机构</h4><h4 id="内部评级">6.3.5 内部评级</h4><h3 id="信用评级机构">6.4 信用评级机构</h3><h4 id="字母等级">6.4.1 字母等级</h4><h4 id="评级类型">6.4.2 评级类型</h4><h4 id="存在问题">6.4.3 存在问题</h4><h4 id="研究重点">6.4.4 研究重点</h4><h3 id="前瞻数据建模">6.5 前瞻数据建模</h3><h4 id="历史分析">6.5.1 历史分析</h4><h4 id="结构模型">6.5.2 结构模型</h4><h4 id="简约模型">6.5.3 简约模型</h4><h3 id="小结-5">6.6 小结</h3><h1 id="第三部分---数学和统计">第三部分 - 数学和统计</h1><h2 id="第-7-章---预测统计">第 7 章 - 预测统计</h2><h3 id="模型概述">7.1 模型概述</h3><h3 id="参数模型">7.2 参数模型</h3><h4 id="线性模型">7.2.1 线性模型</h4><h4 id="判别分析">7.2.2 判别分析</h4><h4 id="逻辑回归">7.2.3 逻辑回归</h4><h3 id="非参模型">7.3 非参模型</h3><h4 id="决策树">7.3.1 决策树</h4><h4 id="神经网络">7.3.2 神经网络</h4><h4 id="遗传算法">7.3.3 遗传算法</h4><h4 id="k-近邻法">7.3.4 K 近邻法</h4><h4 id="线性规划">7.3.5 线性规划</h4><h3 id="关键假设">7.4 关键假设</h3><h4 id="数据因素">7.4.1 数据因素</h4><h4 id="统计假设">7.4.2 统计假设</h4><h4 id="解决方法">7.4.3 解决方法</h4><h3 id="结果比较">7.5 结果比较</h3><h2 id="第-8-章---区分度的测量">第 8 章 - 区分度的测量</h2><h3 id="错误的分类矩阵">8.1 错误的分类矩阵</h3><table><thead><tr class="header"><th>混淆矩阵</th><th><strong>实际好 Good</strong></th><th><strong>实际坏 Bad</strong></th></tr></thead><tbody><tr class="odd"><td><strong>预测好 Positive</strong></td><td>TP</td><td>FN</td></tr><tr class="even"><td><strong>预测坏 Negative</strong></td><td>FP</td><td>TN</td></tr></tbody></table><p>在预测不正确的情况下，分为两种错误：</p><ul><li>把实际好的预测为坏（ FN ） - FalseNegative，意为假负，也就是说实际上是正的，被称为<strong>第一类错误</strong>。</li><li>把实际坏的预测为好（ FP ） - FalseNegative，意为假正，也就是说实际上是负的，被称为<strong>第二类错误</strong>。</li></ul><h3 id="kullback-散度">8.2 Kullback 散度</h3><blockquote><p>Kullback S. Information theory and statistics[M]. CourierCorporation, 1997.</p></blockquote><p>Kullback散度用于测量两个频率分布的差异。在信用评分中，它的表现形式有两种：</p><ul><li>信息值（ Information Value, IV ）</li><li>稳定指数（ Stability Index ）</li></ul><p>他们都建立在证据权重（ Weight of Evidence, WOE ）的基础上。</p><h4 id="证据权重">8.2.1 证据权重</h4><p><span class="math display">\[WOE_i=ln(\frac{N_i}{\sum N})/(\frac{P_i}{\sumP})=ln(\frac{N_i}{P_i})-ln(\frac{\sum N}{\sum P})\]</span></p><p>其中 N 代表没有触发坏客户定义，也就是好客户。P代表触发坏客户定义，也就是坏客户。那么 <spanclass="math inline">\(\frac{N_i}{\sum N}\)</span>其实意思就是为好客户的概率，P 也一样，所以上面的公式也可以写为 <spanclass="math display">\[WOE_i=ln(\frac{P(bad)_i}{P(good)_i})\]</span>它反映了某个特征的某个值（或组）的<strong>相对风险</strong>，很明显为WOE 代表了该组的相对风险更小，为负代表该组相对分箱更大。</p><h4 id="信息值">8.2.2 信息值</h4><p><span class="math display">\[IV=\sum^{n}_{i=1}[(\frac{N_i}{\sum N}-\frac{P_i}{\sum P})\timesWOE_i]=\sum^{n}_{i=1}[\frac{count(i)}{count(n)}\times WOE_i]\]</span></p><h4 id="稳定指数">8.2.3 稳定指数</h4><h3 id="ks-统计量">8.3 KS 统计量</h3><h3 id="相关系数">8.4 相关系数</h3><h4 id="pearson-积矩">8.4.1 Pearson 积矩</h4><h4 id="spearman-秩序">8.4.2 Spearman 秩序</h4><h4 id="洛伦兹曲线">8.4.3 洛伦兹曲线</h4><h4 id="基尼系数">8.4.4 基尼系数</h4><h4 id="roc-曲线">8.4.5 ROC 曲线</h4><h3 id="卡方检验">8.5 卡方检验</h3><h3 id="准确性检验">8.6 准确性检验</h3><h4 id="概率论">8.6.1 概率论</h4><h4 id="二项分布">8.6.2 二项分布</h4><h4 id="hl统计量">8.6.3 HL统计量</h4><h4 id="对数似然">8.6.4 对数似然</h4><h3 id="小结-6">8.7 小结</h3><h2 id="第-9-章---零碎内容">第 9 章 - 零碎内容</h2><h3 id="描述方法">9.1 描述方法</h3><h4 id="聚类分析">9.1.1 聚类分析</h4><h4 id="因子分析">9.1.2 因子分析</h4><h3 id="预报方法">9.2 预报方法</h3><h4 id="马尔可夫链">9.2.1 马尔可夫链</h4><h4 id="生存分析">9.2.2 生存分析</h4><h3 id="其他概念">9.3 其他概念</h3><h4 id="相关性">9.3.1 相关性</h4><h4 id="交叉性">9.3.2 交叉性</h4><h4 id="单调性">9.3.3 单调性</h4><h4 id="标准化">9.3.4 标准化</h4><h3 id="开发报告">9.4 开发报告</h3><h4 id="特征分析报告">9.4.1 特征分析报告</h4><h4 id="分数分布报告">9.4.2 分数分布报告</h4><h4 id="新业务策略表">9.4.3 新业务策略表</h4><h3 id="小结-7">9.5 小结</h3><h2 id="第-10-章---头脑与机器">第 10 章 - 头脑与机器</h2><h3 id="人员和项目">10.1 人员和项目</h3><h4 id="评分卡开发人员">10.1.1 评分卡开发人员</h4><h4 id="外部供应商">10.1.2 外部供应商</h4><h4 id="内部资源">10.1.3 内部资源</h4><h4 id="项目组">10.1.4 项目组</h4><h4 id="指导委员会">10.1.5 指导委员会</h4><h3 id="软件">10.2 软件</h3><h4 id="评分卡开发">10.2.1 评分卡开发</h4><h4 id="决策引擎">10.2.1 决策引擎</h4><h3 id="小结-8">10.3 小结</h3><h1 id="第四部分---数据">第四部分 - 数据</h1><h2 id="第-11-章---数据考虑">第 11 章 - 数据考虑</h2><h3 id="数据透明度">11.1 数据透明度</h3><blockquote><p>数据透明度指充分评估风险所需的数据充足程度。</p></blockquote><p>建模的最终目标是获取一个信用度的测量标准，这个标准合适与否取决于借款人数据对我们的透明程度（了解借款人的信息有多全面，特征衍生前的特征）。</p><p>不透明的数据通常表现为：</p><ul><li>缺乏信用记录。</li><li>信息不友好。指结构化数据的存储结构不合理，或者数据对信用度影响的逻辑难以建立。</li><li>高度复杂。指非结构化数据，例如语音，图像等，可能有用但是我们不知道怎么用。</li></ul><p>如果数据透明度不够，贷款机构面临两种选择：</p><ol type="1"><li>提高贷款利率，作为风险溢价。</li><li>投入额外成本来确定有用信息，例如购买第三方数据源的数据。</li></ol><p>这里同时提到了在信息不透明时不同市场的客群特征可能性：</p><ul><li>微金融市场 -客户更加关心自己的<strong>负担能力</strong>，而对利率不太敏感。</li><li>中级市场 -这里指的企业贷款，需要更加关心分数无法体现的因素如市场状况、企业适应状况等。</li></ul><p>那么数据透明度是由数据的数量和质量决定的，就引入了下两章。</p><h3 id="数据数量">11.2 数据数量</h3><blockquote><p>数据的深度和广度，由可得性和同质性决定。</p></blockquote><h4 id="深度和广度">11.2.1 深度和广度</h4><blockquote><p>样本量（深度）和变量数量（广度）。</p></blockquote><p>最小样本量是 1500 个好样本、 1500 个坏样本、 1000 个拒绝样本。</p><p>最终模型一般包含 6~25 个特征。</p><h4 id="同质性">11.2.2 同质性</h4><blockquote><p>同质性决定样本是否可以合并处理。</p></blockquote><p>同质性是样本分群的问题。主要要考虑以下 3 点：</p><ol type="1"><li>目标定义</li><li>数据来源</li><li>交叉作用（指不同样本分层之间预测变量和目标变量的关系不同。）</li></ol><p>以上 3 点有问题的样本都应该分开，然后用不同的模型去处理。</p><p>有时我们会遇到在某群体的样本表现高度同质，这种时候应该去寻找新的数据源扩大数据的广度。</p><h4 id="可得性">11.2.3 可得性</h4><blockquote><p>数据获取面临的来自系统、权限或法律的限制。</p></blockquote><p>数据采集、系统升级时的数据更新（这里指丢失记录）、反歧视、数据隐私、信息共享。</p><h3 id="数据质量">11.3 数据质量</h3><blockquote><p>数据能否符合某具体需求。高质量的数据应该具备相关性、准确性、完备性、时效性和一致性。</p><p>在很多情况下，风险管理所用的信息通常只是为截然不同的目的而设计的处理系统的副产品，而且前端系统对数据质量通常缺乏具体的要求，从而虚弱了其产生信息的质量。</p></blockquote><h4 id="关联性">11.3.1 关联性</h4><blockquote><p>数据要与结果有关，能够为分数和决策提供有意义的帮助。</p></blockquote><p>首要关注的是数据的相关关系而非因果关系。</p><p>四个问题：</p><ol type="1"><li>如果特征可测量，它的预测能力怎么样？</li><li>如果特征不可测量，是否有证据证明它在其他方面有价值？</li><li>特征数据是否在需要时可获取，如果不能怎么办？</li><li>特征在逻辑上是否有意义？</li></ol><h4 id="准确性">11.3.2 准确性</h4><blockquote><p>通过正确地获取、加工和储存数据使其准确反映真实状况。</p></blockquote><p>数据不准确主要集中在两方面：</p><ol type="1"><li>流程设计不完善 - 表格设计、数据采集、系统错误和匹配等方面的问题。<ul><li>记账错误 - 数据不正确、不一致或重复。</li><li>漏账错误 - 字段为空或记录缺失。</li></ul></li><li>作弊 - 为提高申请通过的可能性，申请表答案可能被篡改。</li></ol><h4 id="完备性">11.3.3 完备性</h4><blockquote><p>数据包含所有所需信息，允许个别或整条记录有缺失。</p></blockquote><p>特征层面上的完备与样本记录层面上的完备。</p><h4 id="时效性">11.3.4 时效性</h4><blockquote><p>数据随时更新。超过一定期限后，数据就会失效。</p></blockquote><p>如 A 卡的特征年龄是基于客户申请时间的年龄，而不是现在的年龄。</p><p>对于老客户，更多地依赖行为数据而非申请数据。</p><h4 id="一致性">11.3.5 一致性</h4><blockquote><p>随时间推移数据意义保持一致。就算数据有误，也希望一致有误，这样还可以加以利用。</p></blockquote><p>主要是指系统、流程或某参数更新时造成同样的输入不同的输出问题。</p><p>重大突发事件也可能造成数据的意义不一致。</p><h4 id="对征信机构的影响">11.3.6 对征信机构的影响</h4><p>CFA 建议贷款机构在作决策时不要局限于一家征信机构的信息。</p><h3 id="数据设计">11.4 数据设计</h3><blockquote><p>定义数据的类型。从实践或统计的角度出发，考虑数据缺失、分母为零的特例和数据设计的问题，最大化数据的价值。</p></blockquote><h4 id="数据类型-1">11.4.1 数据类型</h4><blockquote><p>统计上及实践中描述数据的术语和对特殊情况的处理。</p></blockquote><p>数据的两个维度：</p><ul><li>记录（ record ） - 单个样本的细节。</li><li>字段（ field ）、特征（ characteristic ）、变量（ variable），这三者都是一个东西。</li></ul><p><strong>统计上的分类：</strong></p><table><thead><tr class="header"><th>变量类别</th><th>类别含义</th></tr></thead><tbody><tr class="odd"><td>分类变量</td><td>由定性特征确定的分组情况，例如性别（男、女）或颜色（黄、红、蓝）。没有顺序和大小。</td></tr><tr class="even"><td>二元变量</td><td>仅由两种类别构成，例如“是/否”等一对反义词。又称为二分类变量。信用评分中目标变量大多是二分类变量，例如目标客户（好、坏）。</td></tr><tr class="odd"><td>名义变量</td><td>用标签（名字）或代码（字母/数字）表示的变量。没有顺序和大小。</td></tr><tr class="even"><td>顺序变量</td><td>只表示一个序列中的相对位置，不表示相对距离的大小，通常和主观评价有关，例如优秀、良好、一般、差。有顺序没有大小。</td></tr><tr class="odd"><td>数值变量</td><td>用整数或实数表示，有顺序有大小，能进行数值运算，比如年龄（整岁）。</td></tr><tr class="even"><td>连续变量</td><td>存在于连续的序列中，可能值的数量无限，存在最大值和最小值，用实数表示，例如温度、重量、距离和时间。</td></tr><tr class="odd"><td>离散变量</td><td>分离或者不连续的变量，用实数表示。并不代表没有顺序和大小。</td></tr><tr class="even"><td>基数变量</td><td>离散的，但特指一个集合内的数量。通常等价于离散变量。</td></tr></tbody></table><p><strong>实践中的分类：</strong></p><table><thead><tr class="header"><th>变量类别</th><th>类别含义</th></tr></thead><tbody><tr class="odd"><td>编码（名义）</td><td>用符号或数字表现的类别。</td></tr><tr class="even"><td>金额（近似连续）</td><td>以货币金额表示的内容，例如余额、额度、交易额，可以计算总数、平均数、趋势、最小值、最大值、范围、极限等。</td></tr><tr class="odd"><td>次数（离散）</td><td>发生的数量，例如子女的数量（来自申请者）、逾期次数（来自贷款机构）、查询次数（来自征信机构）。</td></tr><tr class="even"><td>比率（连续）</td><td>两个数值相除的结果，最常用于按照规模对金额标准化，例如资产负债率。</td></tr><tr class="odd"><td>时间（离散）</td><td>距离某特定事件（账户开立、账户激活、某次评估）发生的时间，通常按天或月计算。</td></tr><tr class="even"><td>分数（近似连续）</td><td>表示未来某事件发生的概率（打分）。在一些情况下，一个分数可以用来计算另一个分数（比如通过第三方数据的评分卡制作内部的评分卡）。</td></tr><tr class="odd"><td>等级（序数）</td><td>和分数类似，不过它代表一个分数范围，或被主观确定。</td></tr></tbody></table><p>提到了变量处理的基础方法，主要分为两种：</p><ul><li>转换特征 - 比如 <code>birthday</code>本身可能并不能作为合适的特征使用，那么我们用某一时间（例如客户申请时间）减去出生日期换算成年就得到了<code>age</code> 这个特征。</li><li>特征生成<ul><li>多项式生成 - 生成交叉项，例如 <code>sklearn</code> 里的<code>PolynomialFeatures</code> 方法。</li><li>计算比率 - 例如计算负债比。</li></ul></li></ul><p><strong>特例（缺失值、异常值处理）：</strong></p><ul><li>数据缺失 -未找到（不清楚真实是否发生）、无记录（真实发生）、未发生（真实未发生）等。</li><li>账户状态 -同一个特征里没有用相同单位，如一部分是值，一部分是字符。</li><li>分母为零 - 除数不能为 0 ，这种情况可以用一个接近 0 的值代替。</li><li>分母为负 - 计算比率或比例时，出现了分子分母同时为负的情况。</li></ul><p>对缺失值和异常值，一般用一个特殊编号来记录。</p><h4 id="表格设计">11.4.2 表格设计</h4><blockquote><p>收集数据的表格设计。</p></blockquote><p>最大的挑战在于尽可能获取更多地相关数据，但数据又不过量。</p><p>表格的处理方式取决于表格设置的答案时定性的还是定量的。</p><p><strong>数值结果</strong></p><p>分为 3 种：</p><ol type="1"><li>数值本身。</li><li>计算输入值。</li><li>数值范围。</li></ol><p>例如不需要申请者填写年龄，直接填写年龄段和生日；金额上不填某段，填入具体的数值；负债收入比率不需要申请者计算，直接填入负债值和收入值。</p><p><strong>分类结果</strong></p><p>难点在于确定特征的选择范围。</p><p>不是直接填空，而是一个选择范围的下拉菜单。</p><p>将问题分为更多的维度，例如职业和教育的问题分为行业、工作层级、最高学历、就业现状等维度。</p><h3 id="小结-9">11.5 小结</h3><p>这章探讨了数据透明度、数据数量、数据质量和设计相关方面的问题。目的就是为了提高数据透明度，正是因为数据透明度的提高使得贷款机构对客户有更多的了解，从而可以扩大贷款规模。</p><h2 id="第-12-章---数据来源">第 12 章 - 数据来源</h2><p>数据来源包括：</p><ul><li>客户 - 客户提供的所有信息，包括申请表格、支持文件、财务报表等。</li><li>内部 - 来自申请过程、会计记录、客户交流和其他系统。</li><li>外部 -从公司外部获取的信息，包括征信机构、选民信息、电话黄页等。</li><li>环境 - 与国家、地区和行业相关的经济或聚合数据。</li><li>员工 - 员工提供的信息，如分析员的主观评价。</li></ul><p>其中客户信息、内部信息和外部信息更为重要。</p><h3 id="客户信息">12.1 客户信息</h3><h4 id="申请表">12.1.1 申请表</h4><p>以下以粗分类的形式说明：</p><table><thead><tr class="header"><th>信息类别</th><th>含义解释</th></tr></thead><tbody><tr class="odd"><td>联系信息</td><td>账单地址、还款信息、电话号码、身份证号等，用在内部或外部的信息匹配中。</td></tr><tr class="even"><td>贷款信息</td><td>贷款金额、还款期限和还款安排。有时没有具体的贷款金额，但有相关的内容。</td></tr><tr class="odd"><td>贷款目的</td><td>贷款目的或对贷款所够商品的描述。</td></tr><tr class="even"><td>担保抵押</td><td>如果贷款购买的对象不作为担保，那么客户需要提供其他资产或抵押。除住房贷款与汽车金融外，只有金额非常大的贷款才会要求抵押。</td></tr><tr class="odd"><td>稳定信息</td><td>客户当前或以前的住址及工作时间、行业和职位情况等。这些信息都能起到一定的作用，例如经常跳槽可能意味着工资较高。</td></tr><tr class="even"><td>人口资料</td><td>教育程度、年龄及居住条件等。体现申请人的未来职业状况和预期收入。</td></tr><tr class="odd"><td>财务信息</td><td>收入、开支、资产及负债，体现申请人的还款能力。</td></tr><tr class="even"><td>银行信息</td><td>用来设置每月扣款账户，但也可能包括其他银行账户、已有账户类型或持有信用卡或储蓄卡类型。</td></tr><tr class="odd"><td>信贷参考</td><td>信用卡或商场卡，及申请人的任何信用参考。</td></tr><tr class="even"><td>其他选项</td><td>信用保险等，可以由借款人选择。保险时一个利润很大的收入来源，但有信用保险需求的客户风险水平较高。</td></tr></tbody></table><p>联系信息在次级贷款及其他借方请款变化较快的情况下尤其重要，甚至要求申请人提供老板、亲戚或朋友的联系方式。</p><h4 id="财务信息">12.1.2 财务信息</h4><p>资产负债表：</p><table><thead><tr class="header"><th></th><th><strong>个人</strong></th><th><strong>企业</strong></th></tr></thead><tbody><tr class="odd"><td><strong>资产</strong></td><td>固定资产、车辆、家用电器、珠宝、信托、保险、投资</td><td>非流动资产：固定资产、移动资产、无形资产<br />流动资产：现金、库存、债权</td></tr><tr class="even"><td><strong>负债</strong></td><td>家庭贷款、车辆贷款、透支、信用卡、循环信贷</td><td>权益：股本、留存<br />非流动负债：长期债务<br />流动负债：透支、到期长期债务、短期债务</td></tr></tbody></table><p>损益表：</p><table><thead><tr class="header"><th></th><th>个人</th><th>企业</th></tr></thead><tbody><tr class="odd"><td>收入</td><td>工资、利息、分红、收租</td><td>财务收入、经营收入</td></tr><tr class="even"><td>开销</td><td>税费、租金、水电气费、学费、百货、交通、订阅、服装、娱乐</td><td>销售成本、折旧、租金、税费、分红</td></tr></tbody></table><h3 id="内部信息">12.2 内部信息</h3><p>由内部系统提供的两类重要信息：</p><ul><li>预测变量 X -这些数据直接或间接地参与决策，是分数地构成成分，它们可以单独使用，也可以在风险控制阶段与其他数据整合在一起使用。</li><li>表现结果 Y - 可以反映账户的表现情况，作为风险模型的目标变量。</li></ul><h4 id="数据类型-2">12.2.1 数据类型</h4><p>账户管理系统是信用信息的重要来源。这里提到了系统里的数据分两类：</p><ul><li>静态数据 - 几乎不会改变的数据。</li><li>动态数据 - 随时间改变的数据。</li></ul><p>可以见下表。</p><table><thead><tr class="header"><th>静态</th><th>动态</th></tr></thead><tbody><tr class="odd"><td>产品类型</td><td>未偿金额</td></tr><tr class="even"><td>开户时间</td><td>到期金额</td></tr><tr class="odd"><td>细分市场</td><td>入账/还款</td></tr><tr class="even"><td>贷款金额/额度</td><td>支出/消费</td></tr><tr class="odd"><td>贷款期限</td><td>可用信用</td></tr><tr class="even"><td>账单日</td><td>利息</td></tr><tr class="odd"><td>利率</td><td>费用</td></tr><tr class="even"><td>还款方式</td><td>上一次还款时间</td></tr><tr class="odd"><td>清算金额</td><td>上一次消费时间</td></tr><tr class="even"><td>销户时间</td><td>逾期金额</td></tr><tr class="odd"><td>催收日期</td><td>逾期月数</td></tr><tr class="even"><td>账户丢失/被盗/被骗/死亡标签</td><td>逾期时间</td></tr></tbody></table><h4 id="数据库类型">12.2.2 数据库类型</h4><p>这里的数据库类型指的是在一笔贷款不同的生命周期能够获取到与信用风险直接相关的数据的过程，数据库类型其实说的是过程类型。过程如下：</p><ul><li>客户联系 - 指与客户互动的信息。分两种方式：<ul><li>内向联系 - 指客户通过询问或投诉主动联系贷款机构。</li><li>内外联系 -贷款机构通过电话推销或直邮与客户联系，也包括贷款机构购买市场信息来决定联系哪些客户。</li></ul></li><li>获客过程 -与客户联系不同之处在于这里指获取申请表格信息及申请过程中的其他信息，特别是征信数据和账户表现情况等。</li><li>账户管理 -这里指对申请信息做统计聚合（如最大值、最小值）或分段聚合（如近一月平均账户余额）。</li><li>催收回收 - 催收回收信息是账户进入催收阶段的细节信息。</li></ul><h4 id="客户关系管理">12.2.3 客户关系管理</h4><p>除了上述与信用风险相关的信息，在账户操作管理、操作风险管理及客户关系管理中也会用到其它数据。</p><ul><li>客户管理 - 总结客户关系，制定相应的策略。</li><li>交易支付 -所有支付进出的信息，比如交易时间、交易金额、交易对象、交易目的等。</li><li>授权 -这里说的是一笔成功交易的会由一个专门存放交易的表转到另一张记录成功的表，未成功或授权失败则会留在原表中。这时需要去原表获取数据的情况。</li><li>个体了解 -这里讲对客户关系的了解，通常采用知识图谱，通过图技术构建客户的社交关系网。</li><li>财务状况 - 存在的问题主要涉及：<ul><li>数据获取</li><li>数据质量</li><li>数据一致性</li></ul></li><li>安全 - 这里主要指担保和抵押品。</li><li>欺诈 - 这里指黑名单的数据。</li></ul><h3 id="征信数据">12.3 征信数据</h3><p>征信机构提供的征信数据分为以下几种类型：</p><ul><li>公共信息 - 法院判决、选民名单。</li><li>查询检索 - 历史查询记录。</li><li>共享信息 - 不同贷款机构的整合数据。</li><li>聚合数据 - 按邮编整合的数据。</li><li>欺诈预警 - 无效的地址或身份证号。</li><li>附加价值 - 征信机构通用分数。</li></ul><table><thead><tr class="header"><th>类型</th><th>数据目的</th><th>数据来源</th><th>风险产生的环节</th><th>征信机构的作用</th></tr></thead><tbody><tr class="odd"><td>法院判决</td><td>信贷</td><td>公开</td><td>法律</td><td>采集</td></tr><tr class="even"><td>选民名单</td><td>信贷</td><td>公开</td><td>无</td><td>采集</td></tr><tr class="odd"><td>查询检索</td><td>信贷</td><td>内部</td><td>获客</td><td>增值</td></tr><tr class="even"><td>共享数据</td><td>信贷</td><td>会员</td><td>管理</td><td>共享</td></tr><tr class="odd"><td>聚合数据</td><td>信贷</td><td>会员</td><td>管理</td><td>增值</td></tr><tr class="even"><td>征信分数</td><td>信贷</td><td>整合</td><td>整合</td><td>增值</td></tr><tr class="odd"><td>个人身份</td><td>身份验证</td><td>内部/公开</td><td>获客</td><td>采集/共享</td></tr><tr class="even"><td>申请审批</td><td>身份验证/反欺诈</td><td>公开</td><td>获客</td><td>共享</td></tr><tr class="odd"><td>欺诈预警</td><td>反欺诈</td><td>公开</td><td>获客/管理</td><td>共享</td></tr></tbody></table><h4 id="查询检索">12.3.1 查询检索</h4><ul><li>查询目的<ul><li>市场营销 - 贷款机构在定价前对客户进行预筛。</li><li>申请审批 - 由于申请贷款时需要查询征信记录。</li><li>账户管理 -对现有账户进行管理，为了风险管理、催收或反欺诈进行查询。</li><li>评分分析 -不针对单一客户查询，而是为建立评分卡或分析贷款组合的表现。</li></ul></li><li>查询方式<ul><li>电话查询</li><li>人工在线</li><li>自动在线 - 系统直接连接，系统反应时间很重要。</li><li>批量查询 - 同时处理一批查询，通常用于市场营销或账户管理。</li><li>批量回溯 -跟批量查询不同之处在于获取的是用户在特定时间的记录，通常用于评分卡开发。</li></ul></li></ul><h4 id="公共信息">12.3.2 公共信息</h4><ul><li>法院判决 -主要涉及法律诉讼的两种类型，<strong>破产</strong>和<strong>判决</strong>。</li><li>选民名单 - 个人对债务的态度可能于公民责任心有一定的关系。</li></ul><h4 id="共享数据">12.3.3 共享数据</h4><p>共享数据由征信机构会员（我觉得是指贷方）提供的各类与个人和法人相关的交易数据构成，核心信息包括但不限于：</p><ul><li>余额信息 - 未偿债务和额度。这里牵涉到负债比和额度使用比的概念。</li><li>账户类型 -循环贷款、分期贷款、信用卡等，大量的无担保债务会增加风险。</li><li>逾期状态</li><li>活跃程度 - 开户时间，销户时间或上次交易时间。</li><li>关系信息 - 账户持有人、联合账户、担保人等信息。</li></ul><h4 id="欺诈预警">12.3.4 欺诈预警</h4><ul><li>已知欺诈 - 会员单位的黑名单。</li><li>第三方信息 -这里指与政府部门、选民登记、通信、邮局、财产登记等数据是否匹配。这里主要的限制来自于技术水平与监管要求这两方面。</li><li>申请数据共享 - 这里指与申请人在其它地方申请输入的信息。</li></ul><h4 id="征信分数">12.3.5 征信分数</h4><p>FICO分数区间划分：500， 560， 620， 675， 700，720。指的是申请人在两年内任何贷款或账户出现 90 天逾期的可能性。</p><h4 id="地理指标">12.3.6 地理指标</h4><ul><li>地理统计<ul><li>直接使用邮编作为变量。</li><li>分类或对计算地理聚合数据（此地区失业率、GDP、GDP增长率、司法判决的比例）。</li></ul></li><li>生活方式指标<ul><li>聚类分析，如贵族、中产阶级这种。</li></ul></li></ul><h4 id="其他来源">12.3.7 其他来源</h4><ul><li>机动车登记。</li><li>城市电话黄页。</li><li>房地产服务。</li></ul><h3 id="小结-10">12.4 小结</h3><p>数据来源分为：</p><ul><li>客户提供。</li><li>内部系统。</li><li>外部机构。</li></ul><p>从客户那里获取信息有客户关系的隐患并且信息容易过时不方便贷中贷后管理。因此，贷款机构在努力降低从客户那获取的信息比例，优化对其它数据源的使用。</p><p>内部数据库的优势在于廉价，但是如果内部系统出 Bug时（某些数据出错）会造成不可挽回的危害（对 A卡来讲就是因为钱已经借出去了）。</p><p>外部机构的劣势在于需要有一定成本。</p><h2 id="第-13-章---评分机构">第 13 章 - 评分机构</h2><h3 id="定制服务">13.1 定制服务</h3><h4 id="通用评分卡">13.1.1 通用评分卡</h4><h4 id="定制评分卡">13.1.2 定制评分卡</h4><h4 id="专家模型">13.1.3 专家模型</h4><h3 id="系统架设">13.2 系统架设</h3><h3 id="数据整合">13.3 数据整合</h3><h4 id="独立分数">13.3.1 独立分数</h4><h4 id="离散分数">13.3.2 离散分数</h4><h4 id="合并分数">13.3.3 合并分数</h4><h4 id="决策矩阵">13.3.4 决策矩阵</h4><h3 id="信用评分">13.4 信用评分</h3><h3 id="数据匹配">13.5 数据匹配</h3><h3 id="小结-11">13.6 小结</h3><h2 id="第-14-章---信息共享">第 14 章 - 信息共享</h2><h3 id="征信机构">14.1 征信机构</h3><h4 id="公共与民营">14.1.1 公共与民营</h4><h4 id="正面信息与负面信息">14.1.2 正面信息与负面信息</h4><h3 id="参与合作">14.2 参与合作</h3><h4 id="互惠原则">14.2.1 互惠原则</h4><h4 id="促进因素">14.2.2 促进因素</h4><h4 id="阻碍因素">14.2.3 阻碍因素</h4><h3 id="小结-12">14.3 小结</h3><h2 id="第-15-章---数据准备">第 15 章 - 数据准备</h2><h3 id="数据获取">15.1 数据获取</h3><h4 id="申请数据">15.1.1 申请数据</h4><h4 id="征信数据-1">15.1.2 征信数据</h4><h4 id="观测数据">15.1.3 观测数据</h4><h4 id="表现数据">15.1.4 表现数据</h4><h4 id="数据整合-1">15.1.5 数据整合</h4><h3 id="好坏定义">15.2 好坏定义</h3><p>作者强调了好坏定义的重要性，提到了<strong>好坏定义是建模过程中仅次于数据的重要因素，用来设定目标变量。</strong></p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206201247059.png"alt="好坏定义" /><figcaption aria-hidden="true">好坏定义</figcaption></figure><h4 id="选择状态">15.2.1 选择状态</h4><p>指观测期的状态，分为以下4类：</p><ul><li>排除 -如果某个子群体的分数不影响对其决策，作者建议排除。和拒绝不一样的地方是这类样本不需要做拒绝推断。</li><li>拒绝 - 出于政策规则或者决策规则的样本不需要做拒绝推断。</li><li>未采用 -客户没有接受贷款机构提供的贷款合同，也就是准入了但未做成。可能是价格、利率、合同条款让客户觉得不适。</li><li>双方接受 - 只有这类样本会有真实的表现。</li></ul><h4 id="表现状态">15.2.2 表现状态</h4><p>指表现期的状态，分为以下4类：</p><ul><li><p>排除 -评分卡计划目标之外的结果，比如申请评分卡中出现了欺诈行为或客户去世。这类占比不宜超过总体的3%。</p></li><li><p>不定 - 指灰样本，申请评分卡的不定率应设定在5%~15%，行为评分卡的不定率设定在 10%~20%。这里提到设定灰样本有 3个理由。</p><ul><li>技术逾期造成的疑似不良行为 - 我觉得应该是指像美国 ACH那样的延时得知交易结果的支付方式对标签定义的影响。</li><li>公司策略</li><li>使好坏定义更加清晰。</li></ul><p>这里也讨论了关于提前还款的人是好样本还是不定样本。这类人是可以当作好样本建模的。</p></li><li><p>好样本 - 我们表示欢迎的样本。</p></li><li><p>坏样本 - 我们表示回避的样本。</p></li></ul><h4 id="当前状态和最坏状态">15.2.3 当前状态和最坏状态</h4><p>当前状态和最坏状态是指用结果时点的状态（当前状态）还是整个结果期最坏的状态（最坏状态）来确定“不可恢复点”（point of no return ），也就是去找出账户不会再从坏变好的时间点。</p><p>行为评分中，巴塞尔协议 II 要求使用 90天内最坏最坏状态的定义。申请评分中两种方式都可以。使用当前状态可以确保误判和由坏变好的账户不会被误判，使用最坏状态则对可能是坏的账户更加敏感。</p><p>一般情况下，当前状态的常见定义是逾期 60 天，最坏状态的定义是逾期 90天。</p><h4 id="定义设定">15.2.4 定义设定</h4><p>定义有 3 种方式：</p><ul><li>共识 - 内部专家经验判断。</li><li>规定 -由外部机构设定，确保一致性。（这个主要是方便供别人参考吧）</li><li>经验（原文应该是 experience，我个人觉得翻译成<strong>历史</strong>更合适） -根据自身的历史数据实证分析。提到了滚动率分析，不过并没有讲具体怎么做。</li></ul><h4 id="好坏定义标准">15.2.5 好坏定义标准</h4><p>讲到好坏定义需要符合 3个特点：<strong>相关、充足、透明。</strong></p><h3 id="时间窗口">15.3 时间窗口</h3><p>时间窗口组成有一些相关概念，这里讲到了：</p><ul><li>观测（ observation ） - 指对数据进行观测，作为预测变量。</li><li>结果（ outcome ） - 指分析数据观测的结果，确定目标。</li><li>日期/月份 - 指信息采集的时间。</li><li>窗口（ window ） - 指一段时间。</li></ul><p>这些概念的组合就跟时间窗口有很密切的关系了：</p><ul><li><p>观测期（ observation window ） -也叫观察期，指观测点之前的一段时间。</p></li><li><p>观测日期（ observation date ） -也叫观测点，位于观测期与表现期之间，指采集数据的日期。</p></li><li><p>结果期 （ outcome window ） -也叫表现期，客户表现趋于成熟的时间段。</p></li><li><p>结果日期（ outcome date ） - 指同一样本表现结果的日期。</p></li></ul><p>这两个窗口非常重要，<strong>观测期用于收集用户数据</strong>，例如银行流水等信息，<strong>观测期太短可能会导致变量预测效果不佳</strong>；<strong>表现期用于评价模型的标签（Y）多久之后趋于稳定</strong>，随着时间的累加，违约率会增加但是边际增长率降低，<strong>表现期太短可能会存在坏客户风险暴露不充分这样的情况</strong>。在选择合适的观测期与表现期时，需要考虑<strong>账户成熟、样本信息缺失、数据老化</strong>三个因素。</p><h3 id="样本设计">15.4 样本设计</h3><h4 id="样本类型">15.4.1 样本类型</h4><h4 id="最大和最小样本量">15.4.2 最大和最小样本量</h4><h4 id="分层随机抽样">15.4.3 分层随机抽样</h4><h3 id="小结-13">15.5 小结</h3><h1 id="第五部分---评分卡开发">第五部分 - 评分卡开发</h1><h2 id="第-16-章---变量转换">第 16 章 - 变量转换</h2><h3 id="转换方法">16.1 转换方法</h3><h4 id="虚拟变量">16.1.1 虚拟变量</h4><h4 id="风险变量">16.1.2 风险变量</h4><h4 id="方法选择">16.1.3 方法选择</h4><h3 id="粗细分类">16.2 粗细分类</h3><h4 id="特征分析报告-1">16.2.1 特征分析报告</h4><h4 id="细分类">16.2.2 细分类</h4><h4 id="粗分类">16.2.3 粗分类</h4><h3 id="统计量的应用">16.3 统计量的应用</h3><h4 id="预测能力测度">16.3.1 预测能力测度</h4><h4 id="粗分类例子">16.3.2 粗分类例子</h4><h3 id="池化算法">16.4 池化算法</h3><h4 id="非邻池化">16.4.1 非邻池化</h4><h4 id="相邻池化">16.4.2 相邻池化</h4><h4 id="单调相邻池化">16.4.3 单调相邻池化</h4><h3 id="实际案例">16.5 实际案例</h3><h4 id="法院判决">16.5.1 法院判决</h4><h4 id="行业种类">16.5.2 行业种类</h4><h4 id="职业种类">16.5.3 职业种类</h4><h3 id="小结-14">16.6 小结</h3><h2 id="第-17-章---特征选取">第 17 章 - 特征选取</h2><h3 id="参考因素">17.1 参考因素</h3><h3 id="预测能力">17.2 预测能力</h3><h3 id="降维方法">17.3 降维方法</h3><h4 id="建模处理">17.3.1 建模处理</h4><h4 id="相关矩阵">17.3.2 相关矩阵</h4><h4 id="因子分析-1">17.3.3 因子分析</h4><h3 id="变量输入">17.4 变量输入</h3><h4 id="分步">17.4.1 分步</h4><h4 id="分块">17.4.2 分块</h4><h3 id="小结-15">17.5 小结</h3><h2 id="第-18-章---样本分层">第 18 章 - 样本分层</h2><h3 id="驱动因素">18.1 驱动因素</h3><h3 id="识别交叉的作用">18.2 识别交叉的作用</h3><h3 id="处理交叉的作用">18.3 处理交叉的作用</h3><h3 id="小结-16">18.4 小结</h3><h2 id="第-19-章---拒绝推断">第 19 章 - 拒绝推断</h2><h3 id="推断原理">19.1 推断原理</h3><h3 id="总体流动">19.2 总体流动</h3><h3 id="表现赋值">19.3 表现赋值</h3><h3 id="特殊类别">19.4 特殊类别</h3><h3 id="推断方法">19.5 推断方法</h3><h4 id="随机补充">19.5.1 随机补充</h4><h4 id="展开法">19.5.2 展开法</h4><h4 id="外推法">19.5.3 外推法</h4><h4 id="同生表现法">19.5.4 同生表现法</h4><h3 id="小结-17">19.6 小结</h3><h2 id="第-20-章---模型校准">第 20 章 - 模型校准</h2><h3 id="分数分段">20.1 分数分段</h3><h4 id="ch-统计量">20.1.1 CH 统计量</h4><h4 id="基准方法">20.1.2 基准方法</h4><h4 id="边际风险边界">20.1.3 边际风险边界</h4><h3 id="线性变换">20.2 线性变换</h3><h4 id="线性变动">20.2.1 线性变动</h4><h4 id="比率缩放">20.2.2 比率缩放</h4><h3 id="线性规划重构">20.3 线性规划重构</h3><h3 id="小结-18">20.4 小结</h3><h2 id="第-21-章---检验交付">第 21 章 - 检验交付</h2><h3 id="组成成分">21.1 组成成分</h3><h4 id="开发依据">21.1.1 开发依据</h4><h4 id="持续检验">21.1.2 持续检验</h4><h4 id="回溯测试">21.1.3 回溯测试</h4><h3 id="差别效果">21.2 差别效果</h3><h3 id="小结-19">21.3 小结</h3><h2 id="第-22-章---开发管理">第 22 章 - 开发管理</h2><h3 id="进程安排">22.1 进程安排</h3><h3 id="高效操作">22.2 高效操作</h3><h4 id="重复利用">22.2.1 重复利用</h4><h4 id="重新建模">22.2.2 重新建模</h4><h3 id="小结-20">22.3 小结</h3><h1 id="第六部分---实施和使用">第六部分 - 实施和使用</h1><h2 id="第-23-章---实施安装">第 23 章 - 实施安装</h2><h3 id="自动化决策">23.1 自动化决策</h3><h4 id="自动化程度">23.1.1 自动化程度</h4><h4 id="职责">23.1.2 职责</h4><h4 id="员工沟通">23.1.3 员工沟通</h4><h4 id="客户教育">23.1.4 客户教育</h4><h3 id="安装和测试">23.2 安装和测试</h3><h4 id="数据资源和切换">23.2.1 数据、资源和切换</h4><h4 id="测试">23.2.2 测试</h4><h3 id="小结-21">23.3 小结</h3><h2 id="第-24-章---管理控制">第 24 章 - 管理控制</h2><h3 id="政策规则">24.1 政策规则</h3><h3 id="撤销">24.2 撤销</h3><h3 id="移交">24.3 移交</h3><h4 id="信息验证">24.3.1 信息验证</h4><h4 id="账户情况">24.3.2 账户情况</h4><h3 id="控制">24.4 控制</h3><h4 id="竞争环境">24.4.1 竞争环境</h4><h4 id="评分及策略控制">24.4.2 评分及策略控制</h4><h4 id="撤销控制">24.4.3 撤销控制</h4><h3 id="小结-22">24.5 小结</h3><h2 id="第-25-章---跟踪监控">第 25 章 - 跟踪监控</h2><h3 id="组合分析">25.1 组合分析</h3><h4 id="逾期分布">25.1.1 逾期分布</h4><h4 id="转移矩阵">25.1.2 转移矩阵</h4><h3 id="表现跟踪">25.2 表现跟踪</h3><h4 id="模型表现">25.2.1 模型表现</h4><h4 id="账龄分析">25.2.2 账龄分析</h4><h4 id="分数错配">25.2.3 分数错配</h4><h3 id="偏移报告">25.3 偏移报告</h3><h4 id="总体稳定性报告">25.3.1 总体稳定性报告</h4><h4 id="分数偏移报告">25.3.2 分数偏移报告</h4><h4 id="特征分析">25.3.3 特征分析</h4><h3 id="选择过程">25.4 选择过程</h3><h4 id="决策过程">25.4.1 决策过程</h4><h4 id="分数决策">25.4.2 分数决策</h4><h4 id="政策规则-1">25.4.3 政策规则</h4><h4 id="人为撤销">25.4.4 人为撤销</h4><h3 id="小结-23">25.5 小结</h3><h2 id="第-26-章---金融财务">第 26 章 - 金融财务</h2><h3 id="坏账准备">26.1 坏账准备</h3><h3 id="直接损失估计">26.2 直接损失估计</h3><h4 id="净流量法">26.2.1 净流量法</h4><h4 id="转移矩阵法">26.2.2 转移矩阵法</h4><h3 id="损失估计">26.3 损失估计</h3><h4 id="损失概率">26.3.1 损失概率</h4><h4 id="损失程度">26.3.2 损失程度</h4><h4 id="预测分析">26.3.3 预测分析</h4><h3 id="利润模型">26.4 利润模型</h3><h4 id="利润来源">26.4.1 利润来源</h4><h4 id="利润决策">26.4.2 利润决策</h4><h4 id="利润评分">26.4.3 利润评分</h4><h3 id="风险定价">26.5 风险定价</h3><h4 id="理论实践">26.5.1 理论实践</h4><h4 id="行为变化">26.5.2 行为变化</h4><h4 id="战略考虑">26.5.3 战略考虑</h4><h4 id="客户影响">26.5.4 客户影响</h4><h3 id="小结-24">26.6 小结</h3><h1 id="第七部分---信用风险管理周期">第七部分 - 信用风险管理周期</h1><h2 id="第-27-章---市场营销">第 27 章 - 市场营销</h2><h3 id="广告媒体">27.1 广告媒体</h3><h3 id="数量与质量">27.2 数量与质量</h3><h3 id="初步筛选">27.3 初步筛选</h3><h3 id="市场数据">27.4 市场数据</h3><h3 id="小结-25">27.5 小结</h3><h2 id="第-28-章---申请审批">第 28 章 - 申请审批</h2><h3 id="收集潜在客户信息">28.1 收集潜在客户信息</h3><h4 id="获取申请信息">28.1.1 获取申请信息</h4><h4 id="纸质数据采集">28.1.2 纸质数据采集</h4><h4 id="初筛和清洗">28.1.3 初筛和清洗</h4><h3 id="策略分类">28.2 策略分类</h3><h3 id="决策执行">28.3 决策执行</h3><h4 id="拒绝">28.3.1 拒绝</h4><h4 id="接受">28.3.2 接受</h4><h3 id="小结-26">28.4 小结</h3><h2 id="第-29-章---账户管理">第 29 章 - 账户管理</h2><h3 id="额度类型">29.1 额度类型</h3><h3 id="超额管理">29.2 超额管理</h3><h4 id="支票账户">29.2.1 支票账户</h4><h4 id="信用卡授权">29.2.2 信用卡授权</h4><h4 id="客户知情效应">29.2.3 客户知情效应</h4><h3 id="更多限额和其他功能">29.3 更多限额和其他功能</h3><h4 id="提额请求">29.3.1 提额请求</h4><h4 id="提高额度">29.3.2 提高额度</h4><h4 id="额度复核">29.3.3 额度复核</h4><h4 id="交叉销售">29.3.4 交叉销售</h4><h4 id="重获客户">29.3.5 重获客户</h4><h3 id="小结-27">29.4 小结</h3><h2 id="第-30-章---催收回收">第 30 章 - 催收回收</h2><h3 id="概述">30.1 概述</h3><h3 id="时机策略">30.2 时机策略</h3><h3 id="催收评分">30.3 催收评分</h3><h3 id="小结-28">30.4 小结</h3><h2 id="第-31-章---欺诈防范">第 31 章 - 欺诈防范</h2><h3 id="欺诈类型">31.1 欺诈类型</h3><h3 id="欺诈侦测工具">31.2 欺诈侦测工具</h3><h3 id="欺诈防范策略">31.3 欺诈防范策略</h3><h3 id="欺诈评分">31.4 欺诈评分</h3><h3 id="小结-29">31.5 小结</h3><h1 id="第八部分---监管环境">第八部分 - 监管环境</h1><h2 id="第-32-章---监管理念">第 32 章 - 监管理念</h2><h3 id="最佳实践">32.1 最佳实践</h3><h3 id="善良治理">32.2 善良治理</h3><h3 id="商业道德和社会责任">32.3 商业道德和社会责任</h3><h3 id="合规等级">32.4 合规等级</h3><h3 id="小结-30">32.5 小结</h3><h2 id="第-33-章---隐私保护">第 33 章 - 隐私保护</h2><h3 id="背景">33.1 背景</h3><h4 id="历史概况">33.1.1 历史概况</h4><h4 id="tournier-案件">33.1.2 Tournier 案件</h4><h4 id="oecd-数据隐私指引">33.1.3 OECD 数据隐私指引</h4><h4 id="欧洲理事会公约">33.1.4 欧洲理事会公约</h4><h4 id="欧盟数据保护指令">33.1.5 欧盟数据保护指令</h4><h4 id="特殊情况">33.1.6 特殊情况</h4><h3 id="原则">33.2 原则</h3><h4 id="收集方式">33.2.1 收集方式</h4><h4 id="合理目的">33.2.2 合理目的</h4><h4 id="信息质量">33.2.3 信息质量</h4><h4 id="信息使用">33.2.4 信息使用</h4><h4 id="信息披露">33.2.5 信息披露</h4><h4 id="主体权利">33.2.6 主体权利</h4><h4 id="信息安全">33.2.7 信息安全</h4><h3 id="小结-31">33.3 小结</h3><h2 id="第-34-章---禁止歧视">第 34 章 - 禁止歧视</h2><h3 id="何为歧视">34.1 何为歧视</h3><h3 id="存疑特征">34.2 存疑特征</h3><h3 id="小结-32">34.3 小结</h3><h2 id="第-35-章---公平信贷">第 35 章 - 公平信贷</h2><h3 id="掠夺性放贷">35.1 掠夺性放贷</h3><h3 id="不负责放贷">35.2 不负责放贷</h3><h3 id="负责任放贷">35.3 负责任放贷</h3><h3 id="小结-33">35.4 小结</h3><h2 id="第-36-章---资本要求">第 36 章 - 资本要求</h2><h3 id="巴塞尔协议-i">36.1 巴塞尔协议 I</h3><h3 id="巴塞尔协议-ii">36.2 巴塞尔协议 II</h3><h4 id="标准法">36.2.1 标准法</h4><h4 id="内部评级法">36.2.2 内部评级法</h4><h4 id="风险暴露类别">36.2.3 风险暴露类别</h4><h4 id="违约定义">36.2.4 违约定义</h4><h4 id="评级意义">36.2.5 评级意义</h4><h4 id="执行问题">36.2.6 执行问题</h4><h3 id="风险加权资产的计算">36.3 风险加权资产的计算</h3><h3 id="小结-34">36.4 小结</h3><h2 id="第-37-章---了解客户">第 37 章 - 了解客户</h2><h3 id="尽职调查要求">37.1 尽职调查要求</h3><h3 id="客户身份识别要求">37.2 客户身份识别要求</h3><h2 id="第-38-章---国家差异">第 38 章 - 国家差异</h2><p>国家差异汇总表：</p><table style="width:100%;"><thead><tr class="header"><th></th><th>美国</th><th>加拿大</th><th>英国</th><th>澳大利亚</th><th>南非</th></tr></thead><tbody><tr class="odd"><td>背景情况</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>个人识别码</td><td>SSN</td><td>SIN</td><td>无</td><td>SSN</td><td>ID</td></tr><tr class="odd"><td>支付档案名称</td><td>共享信息</td><td>正面信息</td><td>白色数据 /CAIS</td><td>无</td><td>支付档案</td></tr><tr class="even"><td>负债占国民净生产总值的比例（1999）</td><td>16.1</td><td>14.4</td><td>5.7</td><td>7.7</td><td>未知</td></tr><tr class="odd"><td>征信机构</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>民营征信机构（1999）</td><td>19 世纪 90 年代</td><td>1919 年</td><td>20 世纪 60 年代</td><td>20 世纪 30 年代</td><td>1901年</td></tr><tr class="odd"><td>TransUnion</td><td>有</td><td>有</td><td>无</td><td>其他机构</td><td>有</td></tr><tr class="even"><td>Equifax</td><td>有</td><td>有</td><td>有</td><td>其他机构</td><td>无</td></tr><tr class="odd"><td>Experian</td><td>有</td><td>无</td><td>有</td><td>其他机构</td><td>有</td></tr></tbody></table><h3 id="美国">38.1 美国</h3><p>美国是最早设立法律影响信用评分的国家。</p><p><ahref="https://www.ftc.gov/legal-library/browse/statutes/fair-credit-reporting-act">《公平信用报告法》（Fair Credit Reporting Act ）</a></p><p>保证了数据的隐私和准确，限制征信机构只能用与信用相关的信息，包括正面信息。</p><p><ahref="https://www.ftc.gov/legal-library/browse/statutes/equal-credit-opportunity-act">《平等信贷机会法》（EqualCredit Opportunity Act）</a></p><p>反对消费信贷歧视，包括申请者的种族、肤色、信仰、国籍、性别、婚姻、年龄或接受公共援助资助信息。</p><p>对于年龄这个特征，只要不歧视老年人就可以使用。</p><p>贷款机构需要向被拒的申请人提供拒绝的明确原因。</p><h3 id="加拿大">38.2 加拿大</h3><h3 id="英国">38.3 英国</h3><h3 id="澳大利亚">38.4 澳大利亚</h3><h3 id="南非">38.5 南非</h3>]]></content>
    
    
    <categories>
      
      <category>Economics&amp;Finance</category>
      
      <category>RiskControl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>credit</tag>
      
      <tag>scorecard</tag>
      
      <tag>risk control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 594 595 598 599</title>
    <link href="/2022/10/21/leetcode20221021/"/>
    <url>/2022/10/21/leetcode20221021/</url>
    
    <content type="html"><![CDATA[<h1 id="最长和谐子序列">594. 最长和谐子序列</h1><p>这道题实际上是一个对元素的计数问题，可以用一个 <code>dict</code>对每个元素进行计数，如果两个 <code>key</code> 差值为 1 ，那么它们的<code>value</code>和可以成为和谐子序列。求出和谐子序列的最大值就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLHS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        counter = &#123;&#125;        lst = []        max_sub = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> counter:                counter[i] = <span class="hljs-number">1</span>                lst.append(i)            <span class="hljs-keyword">else</span>:                counter[i] += <span class="hljs-number">1</span>        lst.sort()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lst)-<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> lst[i]+<span class="hljs-number">1</span> == lst[i+<span class="hljs-number">1</span>]:                max_sub = <span class="hljs-built_in">max</span>(counter[lst[i]]+counter[lst[i+<span class="hljs-number">1</span>]], max_sub)        <span class="hljs-keyword">return</span> max_sub</code></pre></div><h1 id="大的国家">595. 大的国家</h1><div class="code-wrapper"><pre><code class="hljs sql"># Write your MySQL query statement below<span class="hljs-keyword">SELECT</span>    name,    population,    area<span class="hljs-keyword">FROM</span>    WORLD<span class="hljs-keyword">WHERE</span>    area <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3000000</span>    <span class="hljs-keyword">OR</span> population <span class="hljs-operator">&gt;=</span> <span class="hljs-number">25000000</span></code></pre></div><h1 id="范围求和-ii">598. 范围求和 II</h1><p>这道题误区就在于专门去复现了过程。实际上没有必要计算矩阵，注意题目中<code>1 &lt;= ai &lt;= m</code> 和 <code>1 &lt;= bi &lt;= n</code>这两个条件，这也就是说矩阵 <code>[0][0]</code>左上角这个位置一定会是最大值，那么问题就变成了有多少个和它一样的值。所以就可以想到去找<code>ops</code> 里对应 <code>row</code> 的最小值和 <code>column</code>的最小值，两个相乘就是答案了，另外注意处理下 <code>ops</code>为空的特殊情况就可以了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxCount</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span>, ops: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        min_row = <span class="hljs-number">40000</span>        min_col = <span class="hljs-number">40000</span>        <span class="hljs-keyword">for</span> op <span class="hljs-keyword">in</span> ops:            min_row = <span class="hljs-built_in">min</span>(min_row, op[<span class="hljs-number">0</span>])            min_col = <span class="hljs-built_in">min</span>(min_col, op[<span class="hljs-number">1</span>])        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(min_row*min_col, m*n)</code></pre></div><h1 id="两个列表的最小索引总和">599. 两个列表的最小索引总和</h1><p>这里思路就是找到两个人共同喜爱的餐厅之后再看下哪家餐厅索引和最小。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRestaurant</span>(<span class="hljs-params">self, list1: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], list2: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        both_like = <span class="hljs-built_in">set</span>(list1)&amp;<span class="hljs-built_in">set</span>(list2)        res = []        min_index = <span class="hljs-number">2000</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> both_like:            temp_index = list1.index(i) + list2.index(i)            <span class="hljs-keyword">if</span> temp_index &lt; min_index:                res = [i]                min_index = temp_index            <span class="hljs-keyword">elif</span> temp_index == min_index:                res.append(i)        <span class="hljs-keyword">return</span> res</code></pre></div><p>从结果表明这里有点慢，那很明显 <code>list.index()</code>这里复杂度是有点高的，毕竟最差情况是 <code>O(n)</code>了，所以我们可以在最开始找共同喜爱的餐厅的时候用 <code>dict</code>记录餐厅的 <code>index</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRestaurant</span>(<span class="hljs-params">self, list1: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], list2: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        index1 = &#123;&#125;        index2 = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list1):            index1[v] = i        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list2):            index2[v] = i        res = []        min_index = <span class="hljs-number">2000</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (index1.keys()&amp;index2.keys()):            temp_index = index1[i] + index2[i]            <span class="hljs-keyword">if</span> temp_index &lt; min_index:                res = [i]                min_index = temp_index            <span class="hljs-keyword">elif</span> temp_index == min_index:                res.append(i)        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>SQL</tag>
      
      <tag>logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 575 584 586</title>
    <link href="/2022/10/04/leetcode20221004/"/>
    <url>/2022/10/04/leetcode20221004/</url>
    
    <content type="html"><![CDATA[<h1 id="分糖果">575. 分糖果</h1><p>首先我想到的是用 <code>hashmap</code> 来解决这个问题，我们用一个<code>dict</code> 存储糖果的种类和此类数量。接着根据 <code>values</code>将这个 <code>dict</code> 排序。也就是这样：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCandies</span>(<span class="hljs-params">self, candyType: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        candy_map = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> candyType:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> candy_map:                candy_map[i]=<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                candy_map[i] += <span class="hljs-number">1</span>        candy_map = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">sorted</span>(candy_map.items(), key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>]))        max_num = <span class="hljs-built_in">len</span>(candyType)/<span class="hljs-number">2</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> candy_map.values():            res += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> res &gt;= max_num:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>但是非常慢，后来发现需要的只是糖果的种类数，然后求糖果的种类数和<code>n/2</code> 更小的那一个值，也就是：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCandies</span>(<span class="hljs-params">self, candyType: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        candy_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        category_count = <span class="hljs-number">0</span>        max_num = <span class="hljs-built_in">len</span>(candyType)/<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> candyType:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> candy_set:                category_count += <span class="hljs-number">1</span>                candy_set.add(i)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(category_count, max_num)</code></pre></div><p>还是挺慢的，发现上面的其实就是做这件事，没有必要用循环加条件判断：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCandies</span>(<span class="hljs-params">self, candyType: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(candyType)/<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(candyType)))</code></pre></div><h1 id="寻找用户推荐人">584. 寻找用户推荐人</h1><p>这题就是 <code>NULL</code> 不能和值进行比较：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>    name<span class="hljs-keyword">FROM</span>    customer<span class="hljs-keyword">WHERE</span>    referee_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-keyword">OR</span> referee_id <span class="hljs-operator">!=</span> <span class="hljs-number">2</span></code></pre></div><h1 id="订单最多的客户">586. 订单最多的客户</h1><p>按 customer_number 从大到小排列取第一个。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>    customer_number<span class="hljs-keyword">FROM</span>    Orders<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>    customer_number<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>    <span class="hljs-built_in">COUNT</span>(customer_number) <span class="hljs-keyword">DESC</span>LIMIT <span class="hljs-number">1</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>greedy</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 工作流的使用</title>
    <link href="/2022/10/04/git-workflow/"/>
    <url>/2022/10/04/git-workflow/</url>
    
    <content type="html"><![CDATA[<h1 id="git-三个组成部分">Git 三个组成部分</h1><ul><li>Remote(repository) - 远程代码仓库。</li><li>Local Git - 本地的 git 仓库。有所有本机告诉 git的信息。分为本地代码仓库和暂存区。<ul><li>本地仓库 - 区分分支。</li><li>暂存区 - 不区分分支。</li></ul></li><li>Disk - 本地磁盘。</li></ul><h1 id="工作流">工作流</h1><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202210041528216.png" /></p><blockquote><p>以下的 source 指的是源分支。一般来讲是 develop 分支，也可能是master(main) 分支，以下用 source 代替。</p></blockquote><h3 id="clone">clone</h3><div class="code-wrapper"><pre><code class="hljs shell">git clone xxx.git</code></pre></div><p>在本地复制一个跟远程仓库一模一样的代码仓库。</p><h3 id="branch-and-checkout">branch and checkout</h3><div class="code-wrapper"><pre><code class="hljs shell">git checkout -b feature</code></pre></div><p>创建并切换到一个 feature 的分支，这样不会影响主分支。</p><p>等同于：</p><div class="code-wrapper"><pre><code class="hljs shell">git branch feature # 创建git checkout feature # 切换</code></pre></div><p>这样做了之后 Local Git 里存有两个分支的文件，而 Disk里存的是当前分支的文件。</p><h3 id="code-changes">code changes</h3><p>修改代码。这里修改的只是 Disk 里的文件，即使是相同分支的 Local Git里文件依然没有修改。</p><h3 id="diff">diff</h3><div class="code-wrapper"><pre><code class="hljs shell">git diff</code></pre></div><p>这个命令是修改完代码后，可以查看 Disk 与同分支 Local Git暂存区里文件的差异。</p><h3 id="add">add</h3><div class="code-wrapper"><pre><code class="hljs shell">git add file</code></pre></div><p>将 Disk 里修改的某文件添加到 Local Git暂存区里（而不是本地仓库）。</p><p>如果要将所有有改动的文件都添加，可以使用：</p><div class="code-wrapper"><pre><code class="hljs shell">git add .</code></pre></div><h3 id="commit">commit</h3><div class="code-wrapper"><pre><code class="hljs shell">git commit -m &quot;xxx&quot;</code></pre></div><p>将这次改动内容及备注从 Local Git 暂存区提交到 Local Git本地仓库中。</p><p>如果备注不一样可以：</p><div class="code-wrapper"><pre><code class="hljs shell">git commit file1 -m &quot;xxx1&quot;git commit file2 -m &quot;xxx2&quot;</code></pre></div><h3 id="push">push</h3><div class="code-wrapper"><pre><code class="hljs shell">git push origin feature</code></pre></div><p>将 Local Git 本地仓库的新分支 <code>xxx</code>推送到远程代码仓库中。</p><h3 id="pull-request">pull request</h3><p>将 feature branch 的改动更新到 source branch 里，这里的 pull 是针对source branch 来讲的。</p><p>这里会经历合并和删分支的过程。</p><h4 id="squash-and-merge">squash and merge</h4><p>squash 是指 commit 的数量和名字有所变动。比如针对 feature来说可能有很多的 commit ，但是针对 project 来说一个 feature 就是一个commit 。 merge 是指将 feature branch的代码改动合并到 source branch里。</p><h4 id="delete-branch">delete branch</h4><p>将 feature branch 删掉。但是这时没结束因为本地的 feature branch并没有删。接下来：</p><div class="code-wrapper"><pre><code class="hljs shell">git checkout source # 切换到 sourcegit branch -D feature # 删除 Local Git 的 featuregit pull origin source</code></pre></div><h1 id="协同处理">协同处理</h1><h2 id="推送新的-feature-branch-后发现源-branch-有更新">推送新的 featurebranch 后发现源 branch 有更新</h2><p>这时需要测试一下这个新的 feature 在源 branch的更新之下是否正常，相当于需要把源 branch 的更新同步到新的 featurebranch 里。</p><h3 id="checkout---source">checkout - source</h3><div class="code-wrapper"><pre><code class="hljs shell">git checkout source</code></pre></div><p>切换到源 branch 上。</p><h3 id="pull">pull</h3><div class="code-wrapper"><pre><code class="hljs shell">git pull origin source</code></pre></div><p>将远程仓库源 branch 的更新拉取到本地。</p><h3 id="checkout---feature">checkout - feature</h3><div class="code-wrapper"><pre><code class="hljs shell">git checkout feature</code></pre></div><p>回到新分支 feature 上，这时 feature 有我们上面 code changes的改动但是没有 source 的更新。</p><h3 id="rebase">rebase</h3><div class="code-wrapper"><pre><code class="hljs shell">git rebase source # 注意这时的分支已经在 feature 上了</code></pre></div><p>先将 code changes 扔到一边，将 source 的更新弄上，再尝试将 codechanges 放到更新后的 feature 上。</p><p>这时可能出现的情况是有冲突 <code>rebase conflict</code>，需要手动选择需要哪一段代码。</p><p>这个步骤结束后 Disk 的 commit 应该是先是 source 的更新 commit ，再是code change 的 commit 。</p><h3 id="force-push">force push</h3><div class="code-wrapper"><pre><code class="hljs shell">git push -f origin feature</code></pre></div><p>由于做了 <code>rebase</code> ，所以在将 Local Git本地仓库里的代码推送到远程仓库要使用 <code>force</code> ，也就是<code>-f</code> 。</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 551 557 561 566</title>
    <link href="/2022/10/03/leetcode20221003/"/>
    <url>/2022/10/03/leetcode20221003/</url>
    
    <content type="html"><![CDATA[<h1 id="学生出勤记录-i">551. 学生出勤记录 I</h1><p>用两个计数器，一个用于记录 Absent 的总次数，另一个用于记录连续 Late的次数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkRecord</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        a_count = <span class="hljs-number">0</span>        ctl_count = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;A&#x27;</span>:                a_count += <span class="hljs-number">1</span>                ctl_count = <span class="hljs-number">0</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;L&#x27;</span>:                ctl_count += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                ctl_count = <span class="hljs-number">0</span>            <span class="hljs-keyword">if</span> a_count &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> ctl_count &gt;= <span class="hljs-number">3</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="反转字符串中的单词-iii">557. 反转字符串中的单词 III</h1><p>按空格分割将字符串分割为数组，对数组里存放的每个值反转，再进行拼接就可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s_arr = s.split(<span class="hljs-string">&#x27; &#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s_arr)):            s_arr[i] = s_arr[i][::-<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(s_arr)</code></pre></div><h1 id="数组拆分">561. 数组拆分</h1><p>这是一个求局部最小值与总体最大值的问题。</p><p>首先我们要求局部最小值，那与它成对的另一个值无论是多少最终都不会被计算，我们把这个不被计算的数称为牺牲数。</p><p>为了使总体值最大，那么牺牲的数应该尽可能小。那么跟全局最小值成为一对的牺牲数应该是全局第二小值，跟全局第三小值成为一对的牺牲数应该是全局第二小值。</p><p>递推之后就可以发现实际上就是将数组排序之后取第奇个值做累加。</p><p>方式多种多样，对我来讲这道题的意义在于它向我说明了切片的优秀。</p><p>不用切片：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrayPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        sorted_nums = <span class="hljs-built_in">sorted</span>(nums)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(sorted_nums[i] <span class="hljs-keyword">if</span> i&amp;<span class="hljs-number">1</span>!=<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sorted_nums)))</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202210031131283.png" /></p><p>切片：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrayPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">sorted</span>(nums)[::<span class="hljs-number">2</span>])</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202210031132956.png" /></p><h1 id="重塑矩阵">566. 重塑矩阵</h1><p>看到矩阵，就想到了大名鼎鼎的 <code>NumPy</code> 包。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mat)*<span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>]) == r*c:            <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np            <span class="hljs-keyword">return</span> np.array(mat).reshape(r,c).tolist()        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> mat</code></pre></div><p>但是很慢，可能是 <code>import</code> 包进来太慢了。所以就自己改写下<code>if</code> 语句的部分。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrixReshape</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        r_len = <span class="hljs-built_in">len</span>(mat)        c_len = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        <span class="hljs-keyword">if</span> r_len*c_len == r*c:            res = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r)]            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r*c):                res[i//c].append(mat[i//c_len][i%c_len])            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> mat</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>string</tag>
      
      <tag>slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 521 541</title>
    <link href="/2022/08/14/leetcode20220814/"/>
    <url>/2022/08/14/leetcode20220814/</url>
    
    <content type="html"><![CDATA[<h1 id="最长特殊序列-ⅰ">521. 最长特殊序列 Ⅰ</h1><p>读了题之后我猜想是不是我想得太简单了，如果两个字符串不相同，那么更长那个字符串肯定就是最长的特殊序列（一样的话任取一个都可以）；如果相同的话就没有子序列。但是事实竟是如此。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLUSlength</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> a==b <span class="hljs-keyword">else</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b))</code></pre></div><h1 id="反转字符串-ii">541. 反转字符串 II</h1><p>暴力写了一遍逻辑。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseStr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = []        s = <span class="hljs-built_in">list</span>(s)        s_len = <span class="hljs-built_in">len</span>(s)        flag = s_len//(<span class="hljs-number">2</span>*k)*(<span class="hljs-number">2</span>*k)        rev_lst = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):            <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>)%(<span class="hljs-number">2</span>*k) == <span class="hljs-number">0</span>:                rev_lst.append((i+<span class="hljs-number">1</span>-<span class="hljs-number">2</span>*k, i-k))            <span class="hljs-keyword">elif</span> k &lt;= s_len-i &lt; <span class="hljs-number">2</span>*k <span class="hljs-keyword">and</span> i &gt;= flag:                rev_lst.append((i, i+k-<span class="hljs-number">1</span>))                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">elif</span> s_len-i &lt; k <span class="hljs-keyword">and</span> i &gt;= flag:                rev_lst.append((i, s_len-<span class="hljs-number">1</span>))                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">for</span> start,end <span class="hljs-keyword">in</span> rev_lst:            a,b = start, end            <span class="hljs-keyword">while</span> a&lt;b:                s[a],s[b] = s[b],s[a]                a += <span class="hljs-number">1</span>                b -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(s)</code></pre></div><p>不出意外，很慢。然后观察上面的思路，每次找反转位置时其实可以按<code>2k</code>个长度跳跃寻找，这是一个可以优化的地方。第二个就是如果能不考虑越界的问题，就不用进行分类讨论，于是就可以考虑切片。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseStr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s = <span class="hljs-built_in">list</span>(s)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">2</span>*k):            s[i:i+k] = <span class="hljs-built_in">reversed</span>(s[i:i+k])        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(s)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 506 509 520</title>
    <link href="/2022/08/12/leetcode20220812/"/>
    <url>/2022/08/12/leetcode20220812/</url>
    
    <content type="html"><![CDATA[<h1 id="相对名次">506. 相对名次</h1><p>先按逆序排序，排序后用 <code>dict</code>建立分数与名次的对应关系，最后按原分数顺序将名次返回为一个列表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRelativeRanks</span>(<span class="hljs-params">self, score: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        rank_lst = <span class="hljs-built_in">sorted</span>(score, reverse=<span class="hljs-literal">True</span>)        rank_dict = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rank_lst)):            <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:                rank_dict[rank_lst[i]] = <span class="hljs-string">&#x27;Gold Medal&#x27;</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-number">1</span>:                rank_dict[rank_lst[i]] = <span class="hljs-string">&#x27;Silver Medal&#x27;</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-number">2</span>:                rank_dict[rank_lst[i]] = <span class="hljs-string">&#x27;Bronze Medal&#x27;</span>            <span class="hljs-keyword">else</span>:                rank_dict[rank_lst[i]] = <span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> [rank_dict[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> score]</code></pre></div><h1 id="斐波那契数">509. 斐波那契数</h1><p>先来个经典的递归算法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>)+fibonacci(n-<span class="hljs-number">2</span>)        <span class="hljs-keyword">return</span> fibonacci(n)</code></pre></div><p>有点慢。因此我们把中间的值放进一个 <code>list</code>，以空间换时间。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        lst = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]        i = <span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> i&lt;=n:            lst.append(lst[i-<span class="hljs-number">1</span>]+lst[i-<span class="hljs-number">2</span>])            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> lst[n]</code></pre></div><h1 id="检测大写字母">520. 检测大写字母</h1><p>把这个问题转换为一个状态转换问题，如果当前状态不能兼容上个状态，直接报错。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCapitalUse</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        mode = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word:            <span class="hljs-keyword">if</span> mode == <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> <span class="hljs-number">97</span>&lt;=<span class="hljs-built_in">ord</span>(i)&lt;=<span class="hljs-number">122</span>:                    mode = <span class="hljs-number">2</span>                <span class="hljs-keyword">else</span>:                    mode = <span class="hljs-number">4</span>            <span class="hljs-keyword">elif</span> mode == <span class="hljs-number">4</span>:                <span class="hljs-keyword">if</span> <span class="hljs-number">97</span>&lt;=<span class="hljs-built_in">ord</span>(i)&lt;=<span class="hljs-number">122</span>:                    mode = <span class="hljs-number">3</span>                <span class="hljs-keyword">else</span>:                    mode = <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> mode == <span class="hljs-number">1</span>:                <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(i) &gt; <span class="hljs-number">90</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> mode == <span class="hljs-number">2</span>:                <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(i) &lt; <span class="hljs-number">97</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> mode == <span class="hljs-number">3</span>:                <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(i) &lt; <span class="hljs-number">97</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>dp</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 504</title>
    <link href="/2022/08/11/leetcode20220811/"/>
    <url>/2022/08/11/leetcode20220811/</url>
    
    <content type="html"><![CDATA[<h1 id="七进制数">504. 七进制数</h1><p>暴力法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convertToBase7</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>:            neg = <span class="hljs-literal">False</span>        <span class="hljs-keyword">elif</span> num &lt; <span class="hljs-number">0</span>:            neg = <span class="hljs-literal">True</span>            num = -num        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>        n = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> <span class="hljs-number">7</span>**n &lt;= num:            n += <span class="hljs-number">1</span>        n -= <span class="hljs-number">1</span>        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">while</span> n&gt;=<span class="hljs-number">0</span>:            i = num//(<span class="hljs-number">7</span>**n)            res += <span class="hljs-built_in">str</span>(i)            num -= (<span class="hljs-number">7</span>**n)*i            n -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;-<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span> <span class="hljs-keyword">if</span> neg <span class="hljs-keyword">else</span> res</code></pre></div><p>然而，将返回结果的字符串换成整数之后，速度提升了很多。这里可以看出字符串连接比整数相加效率要低。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convertToBase7</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">if</span> num &gt;= <span class="hljs-number">0</span>:            neg = <span class="hljs-literal">False</span>        <span class="hljs-keyword">else</span>:            neg = <span class="hljs-literal">True</span>            num = -num        n = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> <span class="hljs-number">7</span>**n &lt;= num:            n += <span class="hljs-number">1</span>        n -= <span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n&gt;=<span class="hljs-number">0</span>:            i = num//(<span class="hljs-number">7</span>**n)            res += (<span class="hljs-number">10</span>**n)*i            num -= (<span class="hljs-number">7</span>**n)*i            n -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>+<span class="hljs-built_in">str</span>(res) <span class="hljs-keyword">if</span> neg <span class="hljs-keyword">else</span> <span class="hljs-built_in">str</span>(res)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 496 500</title>
    <link href="/2022/08/09/leetcode20220809/"/>
    <url>/2022/08/09/leetcode20220809/</url>
    
    <content type="html"><![CDATA[<h1 id="下一个更大元素-i">496. 下一个更大元素 I</h1><p>首先很容易想到暴力法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        nums2_len = <span class="hljs-built_in">len</span>(nums2)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:            j = nums2.index(i)+<span class="hljs-number">1</span>            flag = <span class="hljs-literal">False</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, nums2_len):                <span class="hljs-keyword">if</span> nums2[v] &gt; i:                    res.append(nums2[v])                    flag = <span class="hljs-literal">True</span>                    <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:                res.append(-<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><p>不过很慢。很明显，从慢的时间上来讲，肯定是算法不够好而不是没有优化。然后观察上面的算法可以发现，其实慢就慢在<code>j = nums2.index(i)+1</code>这里。每次都得重新去寻找元素的下标，这个时候就会想到空间换时间这种方法，就会想到<code>dict</code> ，也就是哈希：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        hashmap = &#123;&#125;        nums2_len = <span class="hljs-built_in">len</span>(nums2)        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums2):            hashmap[v] = i        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:            j = hashmap[i]+<span class="hljs-number">1</span>            flag = <span class="hljs-literal">False</span>            <span class="hljs-keyword">while</span> j&lt;nums2_len:                <span class="hljs-keyword">if</span> nums2[j] &gt; i:                    res.append(nums2[j])                    flag = <span class="hljs-literal">True</span>                    <span class="hljs-keyword">break</span>                j += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:                res.append(-<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="键盘行">500. 键盘行</h1><p>用 <code>dict</code> 记录字母所在行，然后暴力解法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findWords</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []        hashmap = &#123;            <span class="hljs-string">&#x27;q&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;w&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;r&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;t&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;u&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;i&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;o&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;p&#x27;</span>:<span class="hljs-number">1</span>,            <span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;f&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;g&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;h&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;j&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;k&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;l&#x27;</span>:<span class="hljs-number">2</span>,            <span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;v&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;n&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;m&#x27;</span>:<span class="hljs-number">3</span>        &#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(words)):            flag = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> words[i].lower():                <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>:                    flag = hashmap[v]                <span class="hljs-keyword">elif</span> flag != hashmap[v]:                    flag = -<span class="hljs-number">1</span>                    <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> flag != -<span class="hljs-number">1</span>:                res.append(words[i])        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Core</title>
    <link href="/2022/08/04/python-core/"/>
    <url>/2022/08/04/python-core/</url>
    
    <content type="html"><![CDATA[<h1 id="模块">模块</h1><h2 id="模块编写规范">模块编写规范</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python # 通常只在 unix 环境有效，作用是指定解释器路径，然后可以直接使用脚本名来执行，不需要在前面调用解释器</span><span class="hljs-comment"># coding: utf-8</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">模块文档描述</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入模块</span>global_var = <span class="hljs-built_in">object</span>() <span class="hljs-comment"># 定义全局变量；如果不是必须，最好使用局部变量，这样可以提高代码的维护性，同时节省内存提高性能</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span>: <span class="hljs-comment"># 定义类</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    类的注释</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(): <span class="hljs-comment"># 定义函数</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    函数注释</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-comment"># 主程序，在被当作脚本执行时，执行下面的代码</span>    func()</code></pre></div><h2 id="软件目录规范">软件目录规范</h2><div class="code-wrapper"><pre><code class="hljs stylus">│  README<span class="hljs-selector-class">.md</span>│  requirements<span class="hljs-selector-class">.txt</span>│├─api├─bin│      run<span class="hljs-selector-class">.py</span>│      setup<span class="hljs-selector-class">.py</span>│├─conf│      settings<span class="hljs-selector-class">.py</span>│├─core├─db│      db_handle<span class="hljs-selector-class">.py</span>│├─lib└─log</code></pre></div><ul><li>bin - 放程序可执行文件夹，也可把执行文件放根目录下。<ul><li>run.py - 启动文件。</li><li>setup.py - 安装、部署、打包的脚本。</li></ul></li><li>conf - 放用户自定义配置的文件夹。<ul><li>settings.py - 用户自定义配置。</li></ul></li><li>lib - 程序常用的模块集合文件夹，包括模块、包。</li><li>core - 核心代码逻辑文件夹。</li><li>log - 存放项目日志。</li><li>db - 数据库相关文件夹。</li><li>api - 用户接口文件夹。</li><li>requirement.txt - 第三方模块依赖文件。</li><li>README.md - 项目简介。</li></ul>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础</title>
    <link href="/2022/08/04/sql/"/>
    <url>/2022/08/04/sql/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><p><a href="https://www.sololearn.com/learning/1060">Learn SQL |Sololearn</a></p><p>《SQL 必知必会》（第 5 版）</p><p>本文主要指 MySQL 。</p></blockquote><h1 id="基础概念">基础概念</h1><h2 id="数据库介绍">数据库介绍</h2><p>数据库是一个以便于访问、高效管理与更新的方式组织起来的数据集合。</p><p>数据库由存储相关信息的表组成。</p><p>表以行和列的格式存储并展示信息，就像 Excel 表格一样。</p><p>数据库通常包含多个表，每个表都因特定的目的而设计。</p><p><strong>表可拥有任意数量的行，但只能拥有一定数量的列。</strong></p><blockquote><p>MySQL Server 最多只允许 4096 个字段</p><p>InnoDB 最多只能有 1017 个字段</p><p><ahref="https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html">MySQL:: MySQL 8.0 Reference Manual :: 8.4.7 Limits on Table Column Count andRow Size</a></p></blockquote><h2 id="主键---primary-keys">主键 - Primary Keys</h2><p>主键是表中唯一标识表记录的字段。它关键的两个特点：</p><ul><li>每行值唯一。</li><li>非空。</li></ul><p>每张表最多只能有一个主键（也可以没有）。</p><h2 id="sql---structured-query-language">SQL - Structured QueryLanguage</h2><p>SQL 中文叫结构化查询语言。</p><p>它用于访问和操作数据库。</p><blockquote><p>SQL 是 ANSI（美国国家标准协会）标准，但 SQL 语言有不同的版本。</p><p>除了 SQL 标准之外，大多数 SQL数据库程序都有自己的专有扩展，但它们都支持主要命令。</p><p>MySQL 是其中的一种。</p></blockquote><p>最主要的 4 大功能：<strong>增删查改</strong>。</p><h2 id="基础-sql-命令">基础 SQL 命令</h2><h3 id="show-databases">SHOW DATABASES</h3><div class="code-wrapper"><pre><code class="hljs mysql">SHOW DATABASES</code></pre></div><p>列出了服务器管理的数据库。</p><h3 id="show-tables">SHOW TABLES</h3><div class="code-wrapper"><pre><code class="hljs mysql">SHOW TABLES</code></pre></div><p>列出当前数据库里所有表。</p><h3 id="show-columns-from">SHOW COLUMNS FROM</h3><div class="code-wrapper"><pre><code class="hljs mysql">SHOW COLUMNS FROM 表名</code></pre></div><p>列出表里的所有字段的详细信息。</p><p>如结果可能是</p><table><thead><tr class="header"><th>Field</th><th>Type</th><th>Null</th><th>Key</th><th>Default</th><th>Extra</th></tr></thead><tbody><tr class="odd"><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>NULL</td><td>auto_increment</td></tr><tr class="even"><td>name</td><td>varchar(30)</td><td>YES</td><td></td><td>NULL</td><td></td></tr></tbody></table><ul><li>Field - 列名，字段名。</li><li>Type - 列数据类型。</li><li>Null - 字段可否是空值。</li><li>Key - 指示列是否被索引。</li><li>Default - 分配给该列的默认值。</li><li>Extra - 可能包含有关给定列的任何其他可用信息。</li></ul><h1 id="查询">查询</h1><h3 id="select">SELECT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT 列名 FROM 表名;</code></pre></div><p>从一个表中查询指定的列。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT 列名1, 列名2 FROM 表名;</code></pre></div><p>从一个表里查询多列的数据，列名之间用 <code>,</code> 分隔。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM 表名;</code></pre></div><p>如果要查询所有列的数据，可以用 <code>*</code> 。</p><ul><li>对于多条 SQL ，每条后需要添加 <code>;</code> 。</li><li>SQL 语言不区分大小写。</li><li>SQL 中忽略空格和多行。<ul><li>结合适当的间距和缩进，将命令分成逻辑行将使 SQL语句更易于阅读和维护。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs mysql">SELECT 表名.列名 FROM 表名;</code></pre></div><p>同样也可以指定查询某张表的某一列，在表名和列名之间加上 <code>.</code>，当处理可能共享相同列名的多个表时，这种书写形式特别有用。</p><h3 id="distinct">DISTINCT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT列名FROM表名;</code></pre></div><p>DISTINCT 关键字可以达到去重的效果。</p><h3 id="limit">LIMIT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名LIMIT 数量;</code></pre></div><p>LIMIT 关键字可以指定返回结果的数量。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名OFFSET 数量LIMIT 数量;</code></pre></div><p>可以使用 OFFSET 关键字对所取结果中作筛选偏移，可以理解为 OFFSET几条就是前几条不要。</p><h3 id="order-by">ORDER BY</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名ORDER BY列名;</code></pre></div><p>ORDER BY 关键字可以将结果排序后再返回。</p><p>如果是数值型列，默认返回从小到大；如果是字符型列，默认返回字母顺序升序。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT*FROM表名ORDER BY列名1, 列名2;</code></pre></div><p>ORDER BY 后可以跟两列，像这句一样。这样首先满足 <code>列名1</code>的顺序，再满足 <code>列名2</code> 的顺序。</p><ul><li><p>ASC - 升序。</p></li><li><p>DESC - 降序。</p></li></ul><h1 id="筛选">筛选</h1><h3 id="where">WHERE</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT表名FROM列名WHERE条件;</code></pre></div><p>WHERE 语句可用于按条件筛选返回结果。</p><p>使用文本列时，用单引号 <code>'</code>将语句中出现的任何文本括起来。</p><p>并且如果字符串内部有单引号，可以使用单引号来转义。例如：</p><p>我有一个查询条件 <code>值 = I'm</code> ，写成：</p><div class="code-wrapper"><pre><code class="hljs mysql">WHERE列名 = &#x27;I&#x27;&#x27;m&#x27;</code></pre></div><p>使用比较运算符和逻辑运算符来过滤要选择的数据。</p><table><thead><tr class="header"><th>比较运算符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>=</td><td>等于</td></tr><tr class="even"><td>!=</td><td>不等于</td></tr><tr class="odd"><td>&gt;</td><td>大于</td></tr><tr class="even"><td>&lt;</td><td>小于</td></tr><tr class="odd"><td>&gt;=</td><td>大于等于</td></tr><tr class="even"><td>&lt;=</td><td>小于等于</td></tr><tr class="odd"><td>BETWEEN</td><td>和 AND 一起筛选一个范围</td></tr></tbody></table><h3 id="between">BETWEEN</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名WHERE列名 BETWEEN 值1 AND 值2;</code></pre></div><p>BETWEEN运算符选择范围内的值。第一个值必须是下限，第二个值必须是上限。<strong>这两个值都会被包括进去。</strong></p><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr class="header"><th>逻辑运算符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>AND</td><td>返回左右两个条件的交集</td></tr><tr class="even"><td>OR</td><td>返回左右两个条件的并集</td></tr><tr class="odd"><td>IN</td><td>返回值在后面跟的括号里的结果</td></tr><tr class="even"><td>NOT</td><td>对条件取反</td></tr></tbody></table><p>在上述逻辑运算符中，<code>AND</code> 优先级是要比 <code>OR</code>高的。</p><p>所以 如果要同时用 <code>AND</code> 和 <code>OR</code> ，最好用括号<code>()</code> 把 <code>OR</code> 的括起来以免出错。</p><h3 id="in">IN</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名WHERE列名 IN (值1， 值2);</code></pre></div><p>比较一个列与多个值时，使用 IN 运算符。其效果等同于：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名WHERE列名=值1 OR 列名=值2;</code></pre></div><h3 id="as">AS</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名 AS 新列名FROM表名;</code></pre></div><p>用 AS 关键字能够将列名的结果以新列名的标题返回。</p><h3 id="算术运算符">算术运算符</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名+值 AS 列名FROM表名;</code></pre></div><p>可以使用算术运算符将每列的值都做运算。</p><p>包括四则运算 <code>+-*/</code>和括号，括号可用于强制操作优先于任何其他运算符，还用于提高代码的可读性。</p><table><thead><tr class="header"><th>操作符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>+</td><td>加</td></tr><tr class="even"><td>-</td><td>减</td></tr><tr class="odd"><td>*</td><td>乘</td></tr><tr class="even"><td>/</td><td>除</td></tr></tbody></table><h3 id="like">LIKE</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名WHERE列名 LIKE 搜索条件;</code></pre></div><p>使用 <code>_</code> 匹配任何单个字符，使用 <code>%</code>匹配任意数量的字符（包括零个字符）。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li></ul><h1 id="函数">函数</h1><blockquote><p>SELECT 语句为测试、检验函数和计算提供了很好的方法。</p><p>虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM子句后就是简单地访问和 处理表达式，例如 ：</p><p>SELECT 3 * 2;将返回 6，</p><p>SELECT Trim(' abc '); 将返回 abc，</p><p>SELECT Curdate();使用 Curdate()函数返回当前日期和时间。</p><p>可以根据需要使用 SELECT 语句进行检验。</p></blockquote><h2 id="文本处理函数">文本处理函数</h2><h3 id="concat">CONCAT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTCONCAT(列名1, &#x27;,&#x27;, 列名2)FROM表名;</code></pre></div><p>CONCAT 函数用于连接两个或多个文本值并返回连接的字符串。</p><h3 id="rtrim">RTRIM</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTRTRIM(列名)FROM表名;</code></pre></div><p>RTRIM 函数用于去除所取列的值右边所有的空格。</p><h3 id="ltrim">LTRIM</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTLTRIM(列名)FROM表名;</code></pre></div><p>RTRIM 函数用于去除所取列的值<strong>左边</strong>所有的空格。</p><h3 id="trim">TRIM</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTTRIM(列名)FROM表名;</code></pre></div><p>RTRIM 函数用于去除所取列的值<strong>左右两边</strong>所有的空格。</p><h3 id="upper"><strong>UPPER</strong></h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTUPPER(列名)FROM表名;</code></pre></div><p>UPPER 函数将指定字符串中的所有字母转换为大写。</p><h3 id="lower">LOWER</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTLOWER(列名)FROM表名;</code></pre></div><p>LOWER 函数将字符串转换为小写。</p><blockquote><p>如果字符串中有不是字母的字符，这个函数对它们不起作用。</p></blockquote><h3 id="left">LEFT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTLEFT(列名, 数字)FROM表名</code></pre></div><p>LEFT 函数将取到该列中值的前 n 个字符。</p><h3 id="right">RIGHT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTRIGHT(列名, 数字)FROM表名</code></pre></div><p>RIGHT 函数将取到该列中值的后 n 个字符。</p><h3 id="substring">SUBSTRING</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTSUBSTRING(列名 FROM 数字1 FOR 数字2)FROM表名</code></pre></div><p>从 <code>数字1</code> 开始（字符串下标从 1 开始而不是 0），取<code>数字2</code> 个数字。</p><h3 id="soundex">SOUNDEX</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名WHERESOUNDEX(列名) = SOUNDEX(字符串)</code></pre></div><p>返回与字符串发音相同的列名里的值。</p><h2 id="数值处理函数">数值处理函数</h2><h3 id="sqrt">SQRT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTSQRT(列名)FROM表名;</code></pre></div><p>SQRT 函数返回该列中给定值的平方根。</p><h3 id="abs">ABS</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTABS(列名)FROM表名;</code></pre></div><p>ABS 函数返回该列中给定值的绝对值。</p><h3 id="sincostanpiexp">SIN、COS、TAN、PI、EXP</h3><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>SIN</td><td>返回一个角度的正弦</td></tr><tr class="even"><td>COS</td><td>返回一个角度的余弦</td></tr><tr class="odd"><td>TAN</td><td>返回一个角度的正切</td></tr><tr class="even"><td>PI</td><td>返回圆周率 <span class="math inline">\(\pi\)</span> 的值</td></tr><tr class="odd"><td>EXP</td><td>返回一个数的指数值 <span class="math inline">\(e^{x}\)</span></td></tr></tbody></table><h2 id="聚集函数">聚集函数</h2><p><strong>这种函数只会返回一个值，此所谓聚集的意思。</strong></p><h3 id="avg">AVG</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTAVG(列名)FROM表名;</code></pre></div><p>AVG 函数返回该列的平均值。</p><blockquote><p>AVG 函数忽略列值为 NULL 的行。</p></blockquote><h3 id="count">COUNT</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTCOUNT(列名)FROM表名;</code></pre></div><p>COUNT 函数返回该列的行数。</p><blockquote><p>如果指定列名，则 COUNT 函数会忽略指定列的值为 NULL 的行，但 如果COUNT 函数中用的是星号 <code>*</code> ，则不忽略。DISTINCT 不能用于COUNT(*) 。</p></blockquote><h3 id="max">MAX</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTMAX(列名)FROM表名;</code></pre></div><p>MAX 函数返回该列的最大值。</p><blockquote><p>MAX 函数忽略列值为 NULL 的行。</p></blockquote><h3 id="min">MIN</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTMIN(列名)FROM表名;</code></pre></div><p>MIN 函数返回该列的最小值。</p><blockquote><p>MIN 函数忽略列值为 NULL 的行。</p></blockquote><h3 id="sum">SUM</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECTSUM(列名)FROM表名;</code></pre></div><p>SUM 函数返回该列的和。</p><blockquote><p>SUM 函数忽略列值为 NULL 的行。</p></blockquote><h1 id="分组数据">分组数据</h1><p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p><h2 id="group-by">GROUP BY</h2><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名, 聚集函数(*)FROM表名GROUP BY列名;</code></pre></div><p>GROUP BY 子句指示 DBMS分组数据，然后对每个组而不是整个结果集进行聚集。</p><h2 id="having">HAVING</h2><h1 id="子查询">子查询</h1><p>子查询是另一个查询中的查询。它的末尾没有分号。</p><blockquote><p>作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回错误。</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">SELECT(子查询)FROM表名;</code></pre></div><p>子查询作为查询结果。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名WHERE列名 in (子查询);</code></pre></div><p>子查询作为筛选条件。</p><h1 id="连接">连接</h1><p><strong>在引用的列可能出现歧义时，必须使用完全限定列名（用一个句点分隔表名和列名，<code>表名.列名</code>的形式）。如果引用一个没有用表名限制的具有歧义的列名，数据库会报错。</strong></p><blockquote><p>DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害。</p></blockquote><h2 id="等值连接">等值连接</h2><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名1, 列名2FROM表名1, 表名2WHERE表名1.列名1 = 表名2.列名2;</code></pre></div><p>这样会返回两个表的笛卡尔积，使用 WHERE 语句。</p><h2 id="内连接">内连接</h2><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名1, 列名2FROM表名1INNER JOIN 表名2 ON 表名1.列名1=表名2.列名2;</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081810684.png" /></p><h2 id="自连接">自连接</h2><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名 AS 别名1, 表名 AS 别名2WHERE别名1.列名 = 别名2.列名;</code></pre></div><p>或</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名 AS 别名1INNER JOIN 表名 AS 别名2 ON 别名1.列名=别名2.列名;</code></pre></div><blockquote><p>自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。</p><p>虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。</p><p>应该试一下两种方法，以确定哪一种的性能更好。</p></blockquote><h2 id="自然连接">自然连接</h2><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名FROM表名1NATURAL JOIN 表名2;</code></pre></div><p>自然连接是一种特殊的内连接，它不需要指定连接条件，重复的列会被去掉。</p><h2 id="外连接">外连接</h2><p>许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行。</p><h3 id="左连接">左连接</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名1, 列名2FROM左表名LEFT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081845615.png" /></p><h3 id="右连接">右连接</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名1, 列名2FROM左表名RIGHT OUTER JOIN 右表名 ON 左表名.列名1 = 右表名.列名2;</code></pre></div><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202208081847770.png" /></p><h1 id="组合查询">组合查询</h1><blockquote><p>多数 SQL查询只包含从一个或多个表中返回数据的单条 SELECT语句。但是，SQL也允许执行多个查询（多条 SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（ union）或复合查询（ compound query ）。</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">查询1UNION查询2;</code></pre></div><p>UNION 返回的结果已经是去重了的，如果不需要去重，用 UNION ALL ，并且UNION ALL 也更快</p><div class="code-wrapper"><pre><code class="hljs mysql">查询1UNION ALL查询2;</code></pre></div><ul><li><p>在用 UNION 组合查询时，只能使用一条 <strong>ORDER BY</strong>子句，它必须位于最后一条 SELECT 语句之后。</p></li><li><p>如果列在所有查询中不完全匹配，可以使用NULL（或任何其他）值（<strong>说明组合查询要求列的数量完全匹配，最终列名会按第一个查询的列名来展示结果</strong>），例如：</p></li></ul><div class="code-wrapper"><pre><code class="hljs mysql">SELECT列名1, 列名2FROM表名1UNIONSELECT列名1, NULLFROM表名2;</code></pre></div><h1 id="插入数据">插入数据</h1><h2 id="插入完整的行">插入完整的行</h2><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO表名VALUES(值1, 值2);</code></pre></div><p>这种写法能够实现插入功能，但是依赖列的顺序，很不安全，不推荐使用。</p><p>推荐使用下面的写法：</p><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO表名(列名1, 列名2)VALUES(值1, 值2);</code></pre></div><h2 id="插入部分行">插入部分行</h2><p>其实就是使用写列名加值的写法。但是省略的列必须满足以下两个条件之一：</p><ul><li>该列定义允许 NULL 值。</li><li>该列在表定义种给出默认值。</li></ul><h2 id="插入检索出的数据">插入检索出的数据</h2><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO表名1(列名)SELECT列名FROM表名2;</code></pre></div><p>一般用于表的迁移或合并。<strong>并不要求插入的列名和查询的列名一致，DBMS使用列的位置来插入。</strong></p><h2 id="复制表">复制表</h2><p>当然对于迁移到全新的表，也可以选择复制表。</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE新表名 ASSELECT*FROM旧表名;</code></pre></div><h1 id="修改数据">修改数据</h1><div class="code-wrapper"><pre><code class="hljs mysql">UPDATE表名SET列名1=值名1, 列名2=值名2WHERE条件;</code></pre></div><p><strong>如果不加 WHERE 条件的话，就会更新所有行。</strong></p><h1 id="删除数据">删除数据</h1><div class="code-wrapper"><pre><code class="hljs mysql">DELETE FROM表名WHERE条件;</code></pre></div><p>与更新数据一样，<strong>如果不加 WHERE条件的话，就会删除所有行。</strong></p><h1 id="创建表">创建表</h1><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE表名(列名1 数据类型 NOT NULL DEFAULT 默认值,列名2 数据类型 NULL,    列名3 INT NOT NULL AUTO_INCREMENT,    PRIMARY KET(列名));</code></pre></div><h2 id="数据类型">数据类型</h2><p>常用数据类型如下：</p><table><thead><tr class="header"><th>列种类</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>数值型</td><td>INT</td><td>有符号或无符号的正常大小的整数。</td></tr><tr class="even"><td></td><td>FLOAT(M, D)</td><td>有符号的浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。</td></tr><tr class="odd"><td></td><td>DOUBLE(M, D)</td><td>有符号的双精度浮点数。可以选择定义显示长度 (M) 和小数位数 (D)。</td></tr><tr class="even"><td>日期与时间</td><td>DATE</td><td>YYYY-MM-DD 格式的日期。</td></tr><tr class="odd"><td></td><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS 格式的日期和时间组合。</td></tr><tr class="even"><td></td><td>TIMESTAMP</td><td>时间戳，从 1970 年 1 月 1 日午夜开始计算。</td></tr><tr class="odd"><td></td><td>TIME</td><td>以 HH:MM:SS 格式存储时间。</td></tr><tr class="even"><td>字符型</td><td>CHAR(M)</td><td>定长字符串。大小在括号中指定。最大 255 字节。</td></tr><tr class="odd"><td></td><td>VARCHAR(M)</td><td>变长字符串。最大尺寸在括号中指定。</td></tr><tr class="even"><td></td><td>BLOB</td><td>“二进制大对象”，用于存储大量二进制数据，例如图像或其他类型的文件。</td></tr><tr class="odd"><td></td><td>TEXT</td><td>大量的文本数据。</td></tr></tbody></table><h2 id="约束">约束</h2><p>常用约束如下：</p><table><thead><tr class="header"><th>约束</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>NOT NULL</td><td>指示列不能包含任何 NULL 值。</td></tr><tr class="even"><td>UNIQUE</td><td>不允许在列中插入重复值。 UNIQUE约束保持表中列的唯一性。一个表中可以使用多个 UNIQUE 列。</td></tr><tr class="odd"><td>PRIMARY KEY</td><td>强制表接受特定列的唯一数据，并且此约束创建唯一索引以更快地访问表。</td></tr><tr class="even"><td>CHECK</td><td>根据逻辑表达式确定值是否有效。</td></tr><tr class="odd"><td>DEFAULT</td><td>在向表中插入数据时，如果没有为列提供值，则该列将获取设置为 DEFAULT的值。</td></tr><tr class="even"><td><strong>AUTO_INCREMENT</strong></td><td>自增。</td></tr></tbody></table><h1 id="更新表">更新表</h1><h2 id="增加列">增加列</h2><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE表名ADD COLUMN列名 数据类型;</code></pre></div><h2 id="删除列">删除列</h2><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE表名DROP COLUMN列名;</code></pre></div><h2 id="重命名">重命名</h2><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE表名RENAME旧列名TO新列名;</code></pre></div><p>重命名列。</p><div class="code-wrapper"><pre><code class="hljs mysql">RENAME TABLE旧表名TO新表名;</code></pre></div><p>重命名表。</p><h1 id="删除表">删除表</h1><div class="code-wrapper"><pre><code class="hljs mysql">DROP TABLE表名;</code></pre></div><h1 id="视图">视图</h1><p>在 SQL 中，视图是一个基于 SQL语句结果集的虚拟表。每次访问视图都会重新查询，因此视图其实可能会导致性能下降得特别厉害。它的优点在于封装了底层查询，同时也可用作权限的管理。</p><h2 id="创建视图">创建视图</h2><div class="code-wrapper"><pre><code class="hljs mysql">CREATE VIEW视图名 AS查询;</code></pre></div><h2 id="更新视图">更新视图</h2><div class="code-wrapper"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW视图名 AS查询;</code></pre></div><p>不太推荐，直接删掉重新创建就行了。</p><h2 id="删除视图">删除视图</h2><div class="code-wrapper"><pre><code class="hljs mysql">DROP VIEW视图名;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 492 495</title>
    <link href="/2022/08/02/leetcode20220802-2/"/>
    <url>/2022/08/02/leetcode20220802-2/</url>
    
    <content type="html"><![CDATA[<h1 id="构造矩形">492. 构造矩形</h1><p>先获取面积的算术平方根的整数部分 <code>square_root</code> ，宽一定在[1, square_root]里，所以开始递减找长就行了，当面积能够整除宽的时候，就找到了长，直接返回。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">constructRectangle</span>(<span class="hljs-params">self, area: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        s_root = <span class="hljs-built_in">round</span>(area**<span class="hljs-number">0.5</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_root, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> area%i == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> (area//i, i)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h1 id="提莫攻击">495. 提莫攻击</h1><p>前探指针，遍历整个数组，做一下条件判断。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPoisonedDuration</span>(<span class="hljs-params">self, timeSeries: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], duration: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        length = <span class="hljs-built_in">len</span>(timeSeries)        res = <span class="hljs-number">0</span>        cur = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> cur&lt;length:            pre = cur+<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> pre&lt;length:                temp = timeSeries[cur]+duration-timeSeries[pre]                <span class="hljs-keyword">if</span> temp &lt;= <span class="hljs-number">0</span>:                    res += duration                <span class="hljs-keyword">else</span>:                    res += duration-temp            <span class="hljs-keyword">else</span>:                res += duration            cur = pre        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 461 463 476 482 485</title>
    <link href="/2022/08/02/leetcode20220802/"/>
    <url>/2022/08/02/leetcode20220802/</url>
    
    <content type="html"><![CDATA[<h1 id="汉明距离">461. 汉明距离</h1><p>那这道题，很明显需要一个异或 <code>^</code>的运算，那异或完了之后所有二进制不同的位会变成 1， 之前的题里学到了<code>n&amp;(n-1)</code> 可以消除最后一个 1，那么我们做一个循环消除的操作，直到这个异或结果为 0就可以，用一个计数器来统计循环的次数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingDistance</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = x^y        count = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> res:            res &amp;= res-<span class="hljs-number">1</span>            count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> count</code></pre></div><h1 id="岛屿的周长">463. 岛屿的周长</h1><p>把格子的点看作一个坐标，那么我们从左上建立坐标系。用一个元组<code>(x1, y1, x2, y2)</code> 来表示一条边。用一个 <code>set</code>来记录存放的边。然后遍历整个数组，当一个新的 <code>1</code>被找到时，看一下它四条边是否在 <code>set</code>里，在就删除，不在就添加。最后集合的长度就是周长。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">islandPerimeter</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[i])):                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:                    <span class="hljs-keyword">if</span> (i, j, i+<span class="hljs-number">1</span>, j) <span class="hljs-keyword">in</span> hashset:                        hashset.remove((i, j, i+<span class="hljs-number">1</span>, j))                    <span class="hljs-keyword">else</span>:                        hashset.add((i, j, i+<span class="hljs-number">1</span>, j))                    <span class="hljs-keyword">if</span> (i, j, i, j+<span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> hashset:                        hashset.remove((i, j, i, j+<span class="hljs-number">1</span>))                    <span class="hljs-keyword">else</span>:                        hashset.add((i, j, i, j+<span class="hljs-number">1</span>))                    <span class="hljs-keyword">if</span> (i, j+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> hashset:                        hashset.remove((i, j+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>))                    <span class="hljs-keyword">else</span>:                        hashset.add((i, j+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>))                    <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>, j, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> hashset:                        hashset.remove((i+<span class="hljs-number">1</span>, j, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>))                    <span class="hljs-keyword">else</span>:                        hashset.add((i+<span class="hljs-number">1</span>, j, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>))        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(hashset)</code></pre></div><h1 id="数字的补数">476. 数字的补数</h1><p>转成字符串取反了之后再转回来。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findComplement</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        str_num = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(num)).replace(<span class="hljs-string">&#x27;0b&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str_num:            <span class="hljs-keyword">if</span> i==<span class="hljs-string">&#x27;1&#x27;</span>:                res+=<span class="hljs-string">&#x27;0&#x27;</span>            <span class="hljs-keyword">else</span>:                res+=<span class="hljs-string">&#x27;1&#x27;</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(res,<span class="hljs-number">2</span>)</code></pre></div><h1 id="密钥格式化">482. 密钥格式化</h1><p>从后往前添加格式化结果，注意异常情况的处理就行。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">licenseKeyFormatting</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s = s.replace(<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).upper()        count = <span class="hljs-built_in">len</span>(s)//k        other = <span class="hljs-built_in">len</span>(s)%k        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, -count*k, -k):            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:                res = s[i-k:]            <span class="hljs-keyword">else</span>:                res = s[i-k:i]+<span class="hljs-string">&#x27;-&#x27;</span>+res        <span class="hljs-keyword">if</span> other == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> s[:other]+<span class="hljs-string">&#x27;-&#x27;</span>+res            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> s[:other]</code></pre></div><h1 id="最大连续-1-的个数">485. 最大连续 1 的个数</h1><p>前探指针探寻 <code>1</code> 的位置，计数器计数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        count = <span class="hljs-number">0</span>        cur = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> cur&lt;length:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums[cur]:                cur += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                pre = cur+<span class="hljs-number">1</span>                <span class="hljs-keyword">while</span> pre&lt;length <span class="hljs-keyword">and</span> nums[pre]:                    pre += <span class="hljs-number">1</span>                count = <span class="hljs-built_in">max</span>(count, pre-cur)                cur = pre+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> count</code></pre></div><p>或者设置一个 <code>flag</code>来判断是否开始计数了，并用一个结果计数器和中间计数器控制整个遍历：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        flag = <span class="hljs-literal">False</span>        res = <span class="hljs-number">0</span>        count = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span>:                <span class="hljs-keyword">if</span> flag:                    count+=<span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    flag = <span class="hljs-literal">True</span>                    count += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> flag:                    flag = <span class="hljs-literal">False</span>                    res = <span class="hljs-built_in">max</span>(res, count)                    count = <span class="hljs-number">0</span>        res = <span class="hljs-built_in">max</span>(res, count)        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
      <tag>string</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《敏捷实战指南》 - 读书笔记</title>
    <link href="/2022/07/25/%E3%80%8A%E6%95%8F%E6%8D%B7%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    <url>/2022/07/25/%E3%80%8A%E6%95%8F%E6%8D%B7%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="引论">1. 引论</h1><p>这里用了一个叫做预测法的东西作为对比。作者提到，本书适用于：</p><ul><li>对于预测法与敏捷方法难以取舍的项目团队。</li><li>试图解决快速创新和复杂性问题的项目团队。</li><li>致力于团队改进的项目团队。</li></ul><p>本书的目的是：</p><ul><li>帮助项目取得成功。</li><li>帮助项目团队顺利交付商业价值。</li><li>满足客户的期望和需求。</li></ul><p>看第一章所述内容似乎是解决新技术应用到现有的项目上，但寻求不降低项目开发效率的项目管理思路，称之为敏捷思维模式。</p><h1 id="敏捷概述">2. 敏捷概述</h1><h2 id="可确定的工作与高度不确定的工作">2.1可确定的工作与高度不确定的工作</h2><p>项目工作包括两种不同类型：</p><ul><li>可确定的工作 - 执行的不确定性和风险通常较低，归宿是自动化。</li><li>高度不确定的工作 - 探索性工作，项目变化速度快，复杂性和风险高。</li></ul><p>这里提到了<strong>预测法</strong>，其实就是传统开发过程，大概类似可行性分析、需求分析、总体设计、详细设计、编码、测试、部署上线的软件开发流程。这种流程应对变更的能力稍微有点弱（其实就是每一个阶段的质量都必须充分的保证，给人犯错的空间比较小），所以这个时候需要一种在短时间内探讨可行性，根据评估和反馈快速调整的开发过程（给试错的空间，这里跟高度不确定性相呼应），也就是敏捷方法。</p><h2 id="敏捷宣言及思维模式">2.2 《敏捷宣言》及思维模式</h2><ul><li>四大价值观<ul><li><p>重视个体以及互动而不是过程和工具。</p><blockquote><p>这个应该是为了发掘更多可改善的地方。</p></blockquote></li><li><p>可用的软件而不是完整的文档。</p><blockquote><p>这个大概是讲软件比较完善的时候再沉淀一下弄文档？不然对项目专家的依赖度也太高了。</p></blockquote></li><li><p>客户合作而不是合同谈判。</p><blockquote><p>这个应该是针对深入业务这一点所说的吧。但是感觉这两个并没有对立关系。</p></blockquote></li><li><p>应对变更而不是遵循计划。</p><blockquote><p>个人觉得这点恐怕对团队的能力要求有点高。</p></blockquote></li></ul></li></ul><blockquote><p>上面所说的是敏捷开发的一个价值观，总体来讲我觉得对整个团队里每个人能力的要求都要比传统的高一点，这个不太好做其实。</p></blockquote><ul><li>十二大原则<ul><li><p>最高目标，通过尽早持续交付有价值的软件来满足客户的需求。</p><blockquote><p>比起传统方法多了个快。</p></blockquote></li><li><p>欢迎对需求提出变更，善于利用变更，以帮助客户获得竞争优势。</p><blockquote><p>其实需求变更这个东西怎么说呢，软件开发者不太想要。至少能不停变更需求的软件与定好需求的软件不是一个价格，基于需求要变更这个前提，敏捷开发会比传统方法舒服。</p></blockquote></li><li><p>要经常交付可用的软件。</p><blockquote><p>这里应该是指局部交付，以避免所有东西都做出来结果发现不尽人意这种情况，通过这种方式尽快找出错误。</p></blockquote></li><li><p>项目实施过程中，业务人员与开发人员必须始终通力合作。</p><blockquote><p>这一点我个人是非常赞同的。很多时候，开发人员从技术上提升的代价比更深入理解业务大很多。</p></blockquote></li><li><p>善于激励项目人员，给予他们所需的环境和支持，并相信他们能够完成任务。</p><blockquote><p>我觉得看人。</p></blockquote></li><li><p>无论是对开发团队还是团队内部，信息传达最有效的方法都是面对面交谈。</p><blockquote><p>确实。</p></blockquote></li><li><p>可用的软件是衡量进度的首要衡量标准。</p><blockquote><p>类似于 Talk is cheap, show me your code.</p></blockquote></li><li><p>敏捷过程提倡可持续的开发。项目发起人、开发人员和用户应该都能够始终保证持续步调稳定性。</p><blockquote><p>对开发人员的状态是个考验。</p></blockquote></li><li><p>对技术的精益求精以及对设计的不断完善将提高敏捷性。</p><blockquote><p>其实这点是不是敏捷开发都一样的。</p></blockquote></li><li><p>简洁，即尽最大可能减少不必要的工作。</p><blockquote><p>这点对管理者是个考验。</p></blockquote></li><li><p>最佳的架构、需求和设计将出自组织团队。</p><blockquote><p>对组织团队有点依赖，不过要敏捷的话确实只有这样。</p></blockquote></li><li><p>团队定期反省怎样做才能更有效，并相应地调整团队地行为。</p><blockquote><p>这点讲究开发过程的变化。</p></blockquote></li></ul></li></ul><h2 id="精益与看板方法">2.3 精益与看板方法</h2><p>重点在于：</p><ul><li><p>交付价值</p><blockquote><p>我觉得是指客户满意度这方面来讲。</p></blockquote></li><li><p>尊重人</p><blockquote><p>对客户来讲确实尊重，对开发者来讲其实有点压榨的意思，当然也可以说是信任开发者，这个恐怕得看人。</p></blockquote></li><li><p>减少浪费</p><blockquote><p>这点对项目经理（专家）要求会高一点。</p></blockquote></li><li><p>透明化</p><blockquote><p>这个确实是优点，可以看到每个人在干嘛。</p></blockquote></li><li><p>适应变更</p><blockquote><p>这个有点像是附加价值。</p></blockquote></li><li><p>持续改善</p><blockquote><p>比起改善更强调持续。这种对项目发起人的要求会高一点，可能会出现一种情况，就是项目发起人指负责规划并不参与做项目，由开发技术员做，感觉提供价值方面不太好说。</p></blockquote></li></ul><h2 id="不确定性风险和生命周期选择">2.4不确定性、风险和生命周期选择</h2><p>这里不确定性指需求的不确定性与技术的不确定性两方面，风险指返工的风险。</p><p>这里提倡用较小的工作增量验证自身的工作，相当于是每做一个模块的东西，就去汇报验证看是否满足需求，即使返工也只是很小的返工这种方式。</p><ul><li>非常短的反馈循环。</li><li>频繁调整过程。</li><li>重新进行优先级排序。</li><li>定期更新计划。</li><li>频繁交付。</li></ul><p>但是这里也明确说了并不是什么都适合敏捷开发，如果一项任务没有中间成果，或者没有原型的时候，比较适合主用预测法去开发，用敏捷方法去管理新的迭代需求和增量交付成果。</p><p>当技术和需求的不确定性都很高的时候，为了使项目可靠，需要先遏制其中一个不确定性的变量。</p><blockquote><p>从这一节开始，我觉得他讲得有点道理。</p></blockquote><h1 id="生命周期选择">3. 生命周期选择</h1><p>这里详细说明了 4 种生命周期的定义：</p><ul><li>预测型生命周期 -提前进行大量的计划工作，然后一次性执行；执行时一个连续的过程。</li><li>迭代型生命周期 -这种方法允许对未完成的工作进行反馈，从而改进和修改该工作。</li><li>增量型生命周期 -这种方法向客户提供各个已完成的，可能立即使用的可交付成果。</li><li>敏捷型生命周期 -这种方法既有迭代，也有增量，便于完善工作，频繁交付。</li></ul><h2 id="项目生命周期的特征">3.1 项目生命周期的特征</h2><table><thead><tr class="header"><th>方法</th><th>需求</th><th>活动</th><th>交付</th><th>目标</th></tr></thead><tbody><tr class="odd"><td>预测型</td><td>固定</td><td>整个项目仅执行一次</td><td>一次交付</td><td>管理成本</td></tr><tr class="even"><td>迭代型</td><td>动态</td><td>反复执行直至修正</td><td>一次交付</td><td>解决方案的正确性</td></tr><tr class="odd"><td>增量型</td><td>动态</td><td>对给定增量执行一次</td><td>频繁更小规模交付</td><td>速度</td></tr><tr class="even"><td>敏捷型</td><td>动态</td><td>反复执行直至修正</td><td>频繁小规模交付</td><td>通过频繁小规模交付和反馈实现的客户价值</td></tr></tbody></table><p>选择哪一个生命周期取决于需求的变更程度与交付频率。</p><table><thead><tr class="header"><th></th><th>需求变更低</th><th>需求变更高</th></tr></thead><tbody><tr class="odd"><td><strong>交付频率高</strong></td><td>增量型</td><td>敏捷型</td></tr><tr class="even"><td><strong>交付频率低</strong></td><td>预测型</td><td>迭代型</td></tr></tbody></table><h3 id="预测型生命周期的特征">3.1.1 预测型生命周期的特征</h3><pre><code class=" mermaid">graph LRdemand(需求)--&gt;analysisanalysis(分析)--&gt;designdesign(设计)--&gt;codecode(构建)--&gt;testtest(测试)--&gt;deploy(交付)</code></pre><p>强调部门划分、有效、顺序的工作。有点谋定而后动的意思，好处自然就是计划非常清晰明了，文档也易构建。坏处就是可能在开发之前就得确定好明确的需求，除此之外还需要对技术有充分的了解，应对需求不确定性和技术不确定性的能力太弱。</p><h3 id="迭代型生命周期的特征">3.1.2 迭代型生命周期的特征</h3><pre><code class=" mermaid">graph LRanalysis(需求)--&gt;phase2(分析与设计)phase2--&gt;|概念验证| phase2phase2--&gt;phase3(构建与测试)phase3--&gt;|改善| phase3phase3--&gt;deploy(交付)</code></pre><p>有点类似与一个学习的开发过程。通过连续的原型或概念验证来改进产品或成果。在同一个时间盒内可能涉及到长达数周时间的迭代。生命周期可能会很长，因为它是为了学习而优化，而不是为交付速度而优化。</p><h3 id="增量型生命周期的特征">3.1.3 增量型生命周期的特征</h3><pre><code class=" mermaid">graph LRdemand(需求) --&gt; phase1phase1(分析-设计-构建-测试-交付) --&gt; phase2(分析-设计-构建-测试-交付)phase2 --&gt; phase3(分析-设计-构建-测试-交付)</code></pre><p>一点一点的交付，突出交付速度快，减少潜在返工。</p><h3 id="敏捷生命周期的特征">3.1.4 敏捷生命周期的特征</h3><pre><code class=" mermaid">graph LRphase1(需求-分析-设计-构建-测试) --&gt; phase2(需求-分析-设计-构建-测试)phase2 --&gt; deploy1(交付)deploy1(交付) --&gt; phase3(需求-分析-设计-构建-测试)phase3 --&gt; phase4(需求-分析-设计-构建-测试)phase4 --&gt; phase5(需求-分析-设计-构建-测试)phase5 --&gt; deploy2(交付)</code></pre><p>类似增量型和迭代型的结合体。</p><h3 id="敏捷适用性筛选器">3.1.5 敏捷适用性筛选器</h3><h3 id="混合生命周期的特征">3.1.6 混合生命周期的特征</h3><p>依据不同的目标在项目不同的模块选择不同的开发方法。</p><h3 id="结合了敏捷和预测的方法">3.1.7 结合了敏捷和预测的方法</h3><h3 id="以预测法为主敏捷方法为辅的方法">3.1.8以预测法为主、敏捷方法为辅的方法</h3><h3 id="以敏捷方法为主预测法为辅的方法">3.1.9以敏捷方法为主、预测法为辅的方法</h3><h3 id="符合目的的混合生命周期">3.1.10 符合目的的混合生命周期</h3><p>要根据目的去选择开发方法。</p><h3 id="混合型生命周期作为过渡策略">3.1.11混合型生命周期作为过渡策略</h3><p>在预测法的项目上去使用敏捷方法作为过渡而不是一开始就在大项目上使用敏捷方法。</p><h2 id="混合敏捷方法">3.2 混合敏捷方法</h2><p>敏捷方法有很多，根据需要进行组合。</p><h2 id="影响裁剪的项目因素">3.3 影响裁剪的项目因素</h2><table><thead><tr class="header"><th>项目因素</th><th>裁剪方案</th></tr></thead><tbody><tr class="odd"><td>对不稳定需求的适应</td><td>使用节奏（定期时间盒）帮助团队进行演示、回顾与理解新任务。</td></tr><tr class="even"><td>改进速度不够快</td><td>更频繁地回归并选择改进措施。</td></tr><tr class="odd"><td>工作流容易被打断</td><td>利用看板让工作可见，分配任务优先级。</td></tr><tr class="even"><td>产品增量质量不佳</td><td>以测试为重点。</td></tr><tr class="odd"><td>多团队协同</td><td>精心制定一种符合项目背景的方法。</td></tr><tr class="even"><td>团队成员缺乏敏捷经验</td><td>培养敏捷思维模式和敏捷原则的基本原理。使用特定敏捷方法前开研讨会。</td></tr></tbody></table><h1 id="实施敏捷创建敏捷环境">4. 实施敏捷：创建敏捷环境</h1><h2 id="从敏捷思维模式开始">4.1 从敏捷思维模式开始</h2><p>从几个问题开始：</p><ul><li>项目团队如何以敏捷方式行动？</li><li>为了使下一交付周期受益，团队需要快速交付哪些成果并获得早期反馈？</li><li>团队如何以一种透明的方式行动？</li><li>为了专注于高优先级的目标，可以避免哪些工作？</li><li>仆人式领导对团队达成目标有何益处？</li></ul><h2 id="仆人式领导为团队赋权">4.2 仆人式领导为团队赋权</h2><p>仆人式领导使通过对团队服务来领导团队的实践，它注重理解和关注团队成员的需要和发展，旨在使团队尽可能达到最高成绩。</p><h3 id="仆人式领导的职责">4.2.1 仆人式领导的职责</h3><ul><li>促进合作。</li><li>审视阻碍敏捷的过程，努力使其合理化。</li><li>鼓励团队成员，让人尽其才。</li><li>培养团队发展。</li></ul><h3 id="项目经理在敏捷环境中的角色">4.2.2项目经理在敏捷环境中的角色</h3><p>项目经理作为技术人员的服务者而不是管理者。</p><h3 id="项目经理应用仆人式领导">4.2.3 项目经理应用仆人式领导</h3><p>要把责任分配给有能力的人。</p><h2 id="团队构成">4.3 团队构成</h2><h3 id="敏捷团队">4.3.1 敏捷团队</h3><table><thead><tr class="header"><th>属性</th><th>目标</th></tr></thead><tbody><tr class="odd"><td>专门人团</td><td>专心，提高工作效率；少于十人的小型团队。</td></tr><tr class="even"><td>跨职能团队成员</td><td>频繁开发交付；作为独立团队交付；整合工作；向团队内部外部提供反馈。</td></tr><tr class="odd"><td>集中办公或有能力应对办公地点不同</td><td>改善沟通；挺高团队动力；知识共享；降低学习成本；合作。</td></tr><tr class="even"><td>通才和专家组成的混合团队</td><td>专家提供专门技能，通才提供从事不同工作的灵活性；团队具有专业能力，体现在都称为通才型专家。</td></tr><tr class="odd"><td>稳定的工作环境</td><td>彼此依赖；对工作方法相互认同；简化团队成本；知识资本的保证和发展。</td></tr></tbody></table><blockquote><p>这，感觉对技术人员的要求也太高了。感觉不太可行。</p></blockquote><h3 id="敏捷的角色">4.3.2 敏捷的角色</h3><ul><li><p>跨职能团队成员</p></li><li><p>产品负责人</p><blockquote><p>我感觉这个才是真正的大佬。</p></blockquote></li><li><p>团队促进者</p><blockquote><p>听起来有点玄乎。Scrum Master 居然是这个，我说实话不能接受。</p></blockquote></li></ul><h3 id="通才型专家">4.3.3 通才型专家</h3><p>知识广度够，也有专攻的 T 字型人才。</p><h3 id="团队结构">4.3.4 团队结构</h3><p>以产品为主，将人员组织到跨职能的团队中。</p><blockquote><p>做东西来讲这点挺好，问题就是这个知识和技术积累有点困难。</p></blockquote><h3 id="专职小组成员">4.3.5 专职小组成员</h3><p>这里阐述在这个团队里专职工作的小组成员比较重要。分散尽力去做多个项目会造成切换时的效率浪费。</p><h3 id="团队工作场所">4.3.6 团队工作场所</h3><p>独立的私人办公区域与定期开会合作交流。</p><h3 id="克服组织孤岛">4.3.7 克服组织孤岛</h3><p>平等的话语权，意见都能被听到并得到考虑。</p><blockquote><p>前提是有话语权的人有足够水平的见解和技术吧。</p></blockquote><h1 id="实施敏捷在敏捷环境中交付">5. 实施敏捷：在敏捷环境中交付</h1><h2 id="项目章程和团队章程">5.1 项目章程和团队章程</h2><p>章程：</p><ul><li>项目重要的原因</li><li>团队前景方向</li><li>项目目标</li></ul><p>敏捷项目章程：</p><ul><li>项目愿景 - 我们为什么要做这个项目？</li><li>项目远景或项目目标的一部分 - 谁会从中受益？如何受益？</li><li>项目的发布标准 - 达到哪些条件才意味着项目完成？</li><li>预期的工作流 - 我们将怎样合作？</li></ul><p>团队章程：</p><ul><li>团队价值观。</li><li>工作协议，“就绪”如何定义，这是团队可以接受工作的前提；“完成”如何定义，达成一致；考虑时间盒，使用工作过程限制。</li><li>基本规则，有关一个人在会议发言上的规定。</li><li>团队规范，团队如何对待会议时间。</li></ul><h2 id="常见敏捷实践">5.2 常见敏捷实践</h2><h3 id="回顾">5.2.1 回顾</h3><p>团队定期反省如何能够做到更加有效，并相应地调整团队的行为。</p><h3 id="待办事项列表编制">5.2.2 待办事项列表编制</h3><p>所有工作的有序列表，故事。</p><h3 id="待办事项列表的细化">5.2.3 待办事项列表的细化</h3><p>任务，可能是即时制定的，也可能是迭代会上制定的，也可以是多次会议讨论（比较陌生的项目）。</p><h3 id="每日站会">5.2.4 每日站会</h3><p>过一下看板和任务盒。回答以下问题：</p><ul><li><p>基于迭代的敏捷</p><ul><li><p>上次站会以来我都完成了什么？</p></li><li><p>从现在到下一次站会，我计划完成什么？</p></li><li><p>我的障碍是什么？</p></li></ul></li><li><p>基于流程的敏捷</p><ul><li>我们还需要做些什么来推进这一工作？</li><li>有人在做看板上没有的事情吗？</li><li>作为一个团队，我们需要完成什么？</li><li>工作流程是否存在瓶颈或障碍？</li></ul></li></ul><h3 id="展示评审">5.2.5 展示/评审</h3><p>故事完成后，展示时，产品负责人接受或拒绝故事。</p><h3 id="规划基于迭代的敏捷">5.2.6 规划基于迭代的敏捷</h3><p>反复计划与学习。</p><blockquote><p>这块我感觉是为了敏捷而敏捷。</p></blockquote><h3 id="帮助团队交付价值的执行实践">5.2.7帮助团队交付价值的执行实践</h3><ul><li>持续集成</li><li>在不同层面测试</li><li>验收测试驱动开发</li><li>测试驱动开发</li><li>刺探（时间盒研究或实验）</li></ul><h3 id="迭代和增量如何帮助交付工作产品">5.2.8迭代和增量如何帮助交付工作产品</h3><p>迭代帮助团队为交付和多种反馈创建一个节奏。</p><p>增量帮助团队频繁交付。</p><h2 id="解决敏捷项目的挑战">5.3 解决敏捷项目的挑战</h2><table><thead><tr class="header"><th>痛点</th><th>解决</th></tr></thead><tbody><tr class="odd"><td>目标或任务不明确</td><td>愿景、使命。</td></tr><tr class="even"><td>工作协议不明确</td><td>价值观、原则和工作协议。</td></tr><tr class="odd"><td>团队环境不明确</td><td>边界、承诺资产和前瞻性分析。</td></tr><tr class="even"><td>需求不明确</td><td>帮助发起人和相关方制定产品愿景。</td></tr><tr class="odd"><td>用户体验不佳</td><td>设计实践早期让用户参与。</td></tr><tr class="even"><td>估算不准确</td><td>分解故事。进一步细估。</td></tr><tr class="odd"><td>工作分配或进展不明确</td><td>自我管理工作。看板，每日站会。</td></tr><tr class="even"><td>团队面临障碍</td><td>仆人式领导消除，消除不了就上报。</td></tr><tr class="odd"><td>产品待办事项不完善导致工作延误、超时</td><td>产品负责人和团队一起研讨故事。“就绪”的定义。</td></tr><tr class="even"><td>缺陷</td><td>完成工作的定义。</td></tr><tr class="odd"><td>工作未完成</td><td>为完成工作定义。</td></tr><tr class="even"><td>技术债务</td><td>重构，测试。</td></tr><tr class="odd"><td>产品复杂性过高</td><td>提倡简单，思考简单。</td></tr><tr class="even"><td>合作进展缓慢</td><td>仆人式领导负责协调。</td></tr><tr class="odd"><td>前期工作过多导致返工</td><td>不要做过多的工作，通过刺探来学习。</td></tr><tr class="even"><td>错误的开始</td><td>产品负责人的重要性。</td></tr><tr class="odd"><td>待办事项无序</td><td>创建不同优先级。</td></tr><tr class="even"><td>不均匀的工作流程</td><td>计划对应团队的能力。</td></tr><tr class="odd"><td>相关方要求无法满足</td><td>仆人式领导与产品负责人一起工作。</td></tr><tr class="even"><td>意想不到或不可预见的延误</td><td>团队更频繁地检查工作流。</td></tr><tr class="odd"><td>孤立的团队，而不是跨职能团队</td><td>讲明是以产品为主的团队而不是以职能。</td></tr></tbody></table><h2 id="敏捷项目的衡量指标">5.4 敏捷项目的衡量指标</h2><p>定义完成和拒绝。</p><h3 id="敏捷团队的衡量结果">5.4.1 敏捷团队的衡量结果</h3><p>倾向使用基于经验和价值的衡量指标，而不是预测型衡量指标。</p><h1 id="关于项目敏捷性的组织考虑因素">6.关于项目敏捷性的组织考虑因素</h1><h2 id="组织变革管理">6.1 组织变革管理</h2><h3 id="变革管理驱动因素">6.1.1 变革管理驱动因素</h3><ul><li>与加速交付相关的变革。</li><li>与敏捷方法相关的变革。</li></ul><h3 id="变革就绪情况">6.1.2 变革就绪情况</h3><p>变革友好型特征：</p><ul><li>管理层的变革意愿。</li><li>组织在员工认知、审核和评估方式上做出改变的意愿。</li><li>集中或分散项目、项目于集和项目组合管理职能。</li><li>专注于短期预算和指标而不是长期目标。</li><li>人才管理成熟度和能力。</li></ul><h2 id="组织文化">6.2 组织文化</h2><h3 id="创建安全环境">6.2.1 创建安全环境</h3><p>安全、诚实、透明。</p><h3 id="评估文化">6.2.2 评估文化</h3><ul><li>探索 or 执行</li><li>速度 or 稳定性</li><li>数量 or 质量</li><li>灵活性 or 可预测性</li></ul><h2 id="采购和合同">6.3 采购和合同</h2><ul><li>多层结构。</li><li>强调价值交付。</li><li>总价增量。</li><li>固定时间和材料。</li><li>累进的时间和材料。</li><li>提前取消方案。</li><li>动态范围方案。</li><li>团队扩充。</li><li>支持全方位供应商。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Management</category>
      
    </categories>
    
    
    <tags>
      
      <tag>management</tag>
      
      <tag>develop</tag>
      
      <tag>scrum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 455 459</title>
    <link href="/2022/07/25/leetcode20220725/"/>
    <url>/2022/07/25/leetcode20220725/</url>
    
    <content type="html"><![CDATA[<h1 id="分发饼干">455. 分发饼干</h1><p>首先可以排序之后贪心算法解决。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findContentChildren</span>(<span class="hljs-params">self, g: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], s: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        g.sort()        s.sort()        left = <span class="hljs-number">0</span>        right = <span class="hljs-number">0</span>        res = <span class="hljs-number">0</span>        len_g = <span class="hljs-built_in">len</span>(g)        len_s = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">while</span> left&lt;len_g <span class="hljs-keyword">and</span> right&lt;len_s:            <span class="hljs-keyword">if</span> g[left] &lt;= s[right]:                left += <span class="hljs-number">1</span>                res += <span class="hljs-number">1</span>            right += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="重复的子字符串">459. 重复的子字符串</h1><p>双指针。思路是如果字符串有子字符串长度为m 重复 n 次构成，那么它前 m个字符与后 m 个字符是一样的，并且 m 重复 n 次与它本身也是一样的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatedSubstringPattern</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        length = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">if</span> length == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        left = <span class="hljs-number">1</span>        right = length-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;=right:            <span class="hljs-keyword">if</span> length%left == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[:left] == s[right:]:                <span class="hljs-keyword">if</span> s[:left]*(length//left) == s:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            left += <span class="hljs-number">1</span>            right -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 441 448 453</title>
    <link href="/2022/07/19/leetcode20220719/"/>
    <url>/2022/07/19/leetcode20220719/</url>
    
    <content type="html"><![CDATA[<h1 id="排列硬币">441. 排列硬币</h1><p>首先是基本的累加。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrangeCoins</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        x = <span class="hljs-number">0</span>        total = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> total&lt;n:            x+=<span class="hljs-number">1</span>            total +=x           <span class="hljs-keyword">return</span> x-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> total!=n <span class="hljs-keyword">else</span> x</code></pre></div><p>然后其实可以看出这道题是一道求解不等式的问题，问题为： <spanclass="math display">\[\frac{x(x-1)}{2}\le n\lt\frac{x(x+1)}{2}\]</span> 当 <code>n</code> 确定时，求解 <code>x</code>的值。而且是顺序的，所以很自然想到了二分法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrangeCoins</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        l = <span class="hljs-number">0</span>        r = n        <span class="hljs-keyword">while</span> l&lt;=r:            mid = (l+r)//<span class="hljs-number">2</span>            s = mid*(mid-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>            b = mid*(mid+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> s&lt;=n&lt;b:                <span class="hljs-keyword">return</span> mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n&gt;=b:                l=mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r=mid-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> l-<span class="hljs-number">1</span></code></pre></div><h1 id="找到所有数组中消失的数字">448. 找到所有数组中消失的数字</h1><p>集合的差集运算。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDisappearedNumbers</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        set_all = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>))        set_nums = <span class="hljs-built_in">set</span>(nums)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(set_all-set_nums)</code></pre></div><h1 id="最小操作次数使数组元素相等">453. 最小操作次数使数组元素相等</h1><p>说句实话感觉这题应该不算简单题。</p><p>这题最核心的是 <code>n-1</code> 个数都加一等价于<code>1</code>个数减1。所以最后结果应该是 <span class="math display">\[result=\sum^{len(nums)-1}_{i=0}(nums[i]-min(nums))\]</span> 把<code>min(nums)</code>提出来就是 <spanclass="math display">\[result = \sum nums-n\times min(nums)\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMoves</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(nums)-<span class="hljs-built_in">len</span>(nums)*<span class="hljs-built_in">min</span>(nums)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>enumerate</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 409 412 414 415 434</title>
    <link href="/2022/07/15/leetcode20220715/"/>
    <url>/2022/07/15/leetcode20220715/</url>
    
    <content type="html"><![CDATA[<h1 id="最长回文串">409. 最长回文串</h1><p>贪心法。回文串要满足的条件就是出现奇数次的字符数量要小于等于1。所以，对于每个字符来讲，如果它出现为奇数次，就可以用<code>n-1</code>次；如果它出现为偶数次，就可以用<code>n</code>次。如果有出现奇数次的字符，最后结果再加1，没有就不管了。按照这种思路用一个<code>flag</code>记录是否有出现过奇数次的字符。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        hashmap = &#123;&#125;        flag = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> value%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                res += value            <span class="hljs-keyword">else</span>:                res += value -<span class="hljs-number">1</span>                flag = <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> res</code></pre></div><h1 id="fizz-buzz">412. Fizz Buzz</h1><p>感觉就是一个穷举。</p><p>看了一下讨论，好像这道题背后有故事，就是来筛选不会编程的人。</p><blockquote><p><ahref="https://blog.codinghorror.com/why-cant-programmers-program/">WhyCan't Programmers.. Program?</a></p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fizzBuzz</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i%<span class="hljs-number">15</span> == <span class="hljs-number">0</span>:                res.append(<span class="hljs-string">&#x27;FizzBuzz&#x27;</span>)            <span class="hljs-keyword">elif</span> i%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:                res.append(<span class="hljs-string">&#x27;Buzz&#x27;</span>)            <span class="hljs-keyword">elif</span> i%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>:                res.append(<span class="hljs-string">&#x27;Fizz&#x27;</span>)            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-built_in">str</span>(i))        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="第三大的数">414. 第三大的数</h1><p>先去重再排除两次最大值是可以的。而且也不慢。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">thirdMax</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        lst = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums))        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst) &lt; <span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lst)        lst.remove(<span class="hljs-built_in">max</span>(lst))        lst.remove(<span class="hljs-built_in">max</span>(lst))        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lst)</code></pre></div><p>排序也试了下，稍微慢点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">thirdMax</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        lst = <span class="hljs-built_in">sorted</span>(nums, reverse = <span class="hljs-literal">True</span>)        count = <span class="hljs-number">1</span>        temp = lst[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lst:            <span class="hljs-keyword">if</span> i != temp:                count += <span class="hljs-number">1</span>                temp = i            <span class="hljs-keyword">if</span> count == <span class="hljs-number">3</span>:                <span class="hljs-keyword">return</span> i        <span class="hljs-keyword">return</span> lst[<span class="hljs-number">0</span>]</code></pre></div><h1 id="字符串相加">415. 字符串相加</h1><p>从一个数的后面加到前面。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addStrings</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        carry = <span class="hljs-literal">False</span>        res = <span class="hljs-string">&#x27;&#x27;</span>        len_1 = <span class="hljs-built_in">len</span>(num1)        len_2 = <span class="hljs-built_in">len</span>(num2)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-<span class="hljs-number">1</span>, -<span class="hljs-built_in">max</span>(len_1,len_2)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i&lt;-len_1:                temp = <span class="hljs-built_in">int</span>(num2[i])            <span class="hljs-keyword">elif</span> i&lt;-len_2:                temp = <span class="hljs-built_in">int</span>(num1[i])            <span class="hljs-keyword">else</span>:                temp = <span class="hljs-built_in">int</span>(num1[i])+<span class="hljs-built_in">int</span>(num2[i])            <span class="hljs-keyword">if</span> carry:                temp += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> temp &gt;= <span class="hljs-number">10</span>:                temp -= <span class="hljs-number">10</span>                carry = <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                carry = <span class="hljs-literal">False</span>            res = <span class="hljs-built_in">str</span>(temp)+res        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1&#x27;</span>+res <span class="hljs-keyword">if</span> carry <span class="hljs-keyword">else</span> res</code></pre></div><h1 id="字符串中的单词数">434. 字符串中的单词数</h1><p>循环搜索。在没有计数的情况下，遇到非空格开始计数。在计数的情况下，遇到空格停止计数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countSegments</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        counting = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i != <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> counting:                counting = <span class="hljs-literal">True</span>                res += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> counting:                counting = <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>enumerate</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 401</title>
    <link href="/2022/07/10/leetcode20220710/"/>
    <url>/2022/07/10/leetcode20220710/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制手表">401. 二进制手表</h1><p>枚举法，枚举时和分，如果满足就添加进列表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">readBinaryWatch</span>(<span class="hljs-params">self, turnedOn: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">12</span>):            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):               <span class="hljs-keyword">if</span> <span class="hljs-built_in">bin</span>(h).count(<span class="hljs-string">&#x27;1&#x27;</span>)+<span class="hljs-built_in">bin</span>(m).count(<span class="hljs-string">&#x27;1&#x27;</span>) == turnedOn:                   res.append(<span class="hljs-string">&#x27;%d:%.2d&#x27;</span> % (h,m))        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>enumerate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 389</title>
    <link href="/2022/06/30/leetcode20220630/"/>
    <url>/2022/06/30/leetcode20220630/</url>
    
    <content type="html"><![CDATA[<h1 id="找不同">389. 找不同</h1><p>用 <code>dict</code> 对字符串 <code>s</code> 进行计数，然后遍历<code>t</code> 用 <code>dict</code> 进行检索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheDifference</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> i            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> hashmap[i] == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">return</span> i                <span class="hljs-keyword">else</span>:                    hashmap[i] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>当然 <code>t</code> 只是在 <code>s</code>打乱顺序的基础上随机添加了一个字母，所以那个随机添加的字母的 ascii码其实就是两个字符串 ascii 码和的差值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheDifference</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        ascii_s = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">ord</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s])        ascii_t = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">ord</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t])        <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(ascii_t-ascii_s)</code></pre></div><h1 id="判断子序列">392. 判断子序列</h1><blockquote><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。</p></blockquote><p>这个题目不仅要保证 <code>s</code> 的字符在 <code>t</code>中有，还要有序。在遍历两个字符串的过程中，指针移动速度不一定一样，所以很容易想到了双指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubsequence</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-number">0</span>        len_s = <span class="hljs-built_in">len</span>(s)        len_t = <span class="hljs-built_in">len</span>(t)        <span class="hljs-keyword">while</span> left&lt;len_s <span class="hljs-keyword">and</span> right&lt;len_t:            <span class="hljs-keyword">if</span> s[left] == t[right]:                left += <span class="hljs-number">1</span>                right += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                right += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> left == len_s</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>ascii</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 387</title>
    <link href="/2022/06/29/leetcode20220629/"/>
    <url>/2022/06/29/leetcode20220629/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串中的第一个唯一字符">387. 字符串中的第一个唯一字符</h1><p>先想到的一种思路就是用双<code>set</code>，一个<code>set</code>用来存储字符串每个字符，作用时校验是否重复，另一个<code>set</code>用来存储重复的字符。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        hashset1 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        hashset2 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset1:                hashset1.add(value)            <span class="hljs-keyword">else</span>:                hashset2.add(value)        <span class="hljs-keyword">for</span> index,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset2:                <span class="hljs-keyword">return</span> index        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><p>当然用字典也可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> index,key_char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):            <span class="hljs-keyword">if</span> hashmap[key_char] == <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> index        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 383</title>
    <link href="/2022/06/28/leetcode20220628/"/>
    <url>/2022/06/28/leetcode20220628/</url>
    
    <content type="html"><![CDATA[<h1 id="赎金信">383. 赎金信</h1><p>采用字典方式对两个字符串计数，一旦<code>ransomNote</code>里的字符没有出现在<code>magazine</code>里或是比<code>magazine</code>里出现的次数多时，返回<code>False</code>，否则返回<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote: <span class="hljs-built_in">str</span>, magazine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        magazine_dict = &#123;&#125;        ransomNote_dict = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> magazine:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> magazine_dict:                magazine_dict[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                magazine_dict[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ransomNote:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ransomNote_dict:                ransomNote_dict[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                ransomNote_dict[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> ransomNote_dict.items():            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> magazine_dict:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> v &gt; magazine_dict[k]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 326 344 349</title>
    <link href="/2022/06/27/leetcode20220627/"/>
    <url>/2022/06/27/leetcode20220627/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的完全平方数">367. 有效的完全平方数</h1><blockquote><p><ahref="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">完全平方数- 百度百科</a></p></blockquote><p>这道题不禁让我想到了之前求算术平方根的题，看起来好像要更简单一点，那么直接用二分搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPerfectSquare</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        left = <span class="hljs-number">1</span>        right = num        <span class="hljs-keyword">while</span> left&lt;=right:            mid = (left+right)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid*mid == num:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">elif</span> mid*mid &lt; num:                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                right = mid-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="猜数字大小">374. 猜数字大小</h1><p>这道题和上道题几乎完全一样的思路，不同之处在于这道题更直白地说明了二分法的可行性。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">guessNumber</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">1</span>        right = n        <span class="hljs-keyword">while</span> left&lt;=right:            mid = (left+right)//<span class="hljs-number">2</span>            res = guess(mid)            <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> res == -<span class="hljs-number">1</span>:                right = mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                left = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 326 344 349</title>
    <link href="/2022/06/25/leetcode20220625/"/>
    <url>/2022/06/25/leetcode20220625/</url>
    
    <content type="html"><![CDATA[<h1 id="的幂">326. 3 的幂</h1><p>还是经典的是否是最大值的约数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfThree</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">3</span>**<span class="hljs-number">20</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="的幂-1">342. 4 的幂</h1><p>这题不同于 2 和 3 的幂，因为 4 = 2$$2，所以如果按 2 的幂和 3的幂的解法会识别不了是 2 的幂但是不是 4的幂的数这种情况，不过可以转换为求解 2 的幂，如果一个数是 4的幂，那它的算术平方根肯定是 2 的幂就可解得正确答案。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfFour</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>**<span class="hljs-number">30</span>)%(n**<span class="hljs-number">0.5</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="两个数组的交集">349. 两个数组的交集</h1><p>其实就是两个 <code>list</code> 转 <code>set</code> 后求交集再返回<code>list</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1)&amp;<span class="hljs-built_in">set</span>(nums2))</code></pre></div><h1 id="两个数组的交集-ii">350. 两个数组的交集 II</h1><p>比上个题要难一点，需要对字符出现次数进行一个统计，所以用了<code>dict</code> 而不是 <code>set</code>，在往结果列表里添加值时取最小的次数就可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersect</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        dict1 = &#123;&#125;        dict2 = &#123;&#125;        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict1:                dict1[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                dict1[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict2:                dict2[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                dict2[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dict1.items():            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> dict2:                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(value,dict2[key])):                    res.append(key)        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH Tunnel 实现 BI 工具连接数据库</title>
    <link href="/2022/06/19/sshtunnel_database/"/>
    <url>/2022/06/19/sshtunnel_database/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>最近项目需要 BI工具看板做一个数据可视化的模块，服务器和数据库都是在云端的，每次访问数据库通过Navicat 、Python 等工具去访问，但是很可惜，power BI 和 tableau 并没有ssh 访问的入口（ Navicat是有的）。关于如何通过这种方式访问数据库在网上没有符合预期的解答，后来经过研究，发现了答案。</p><h1 id="原理">原理</h1><p>SSH 的理论在此不多赘述。整个连接过程分为两部分：</p><ul><li>服务器/远程主机某端口与本机某端口通过 ssh tunnel连接，连接建立后我去访问本机某端口时，相当于访问服务器/远程主机对应端口。</li><li>在 BI 工具（其实 Navicat也可以，稍有不同）上访问本机的这个端口，而不是访问之前的 3306（ Mysql默认的）端口。</li></ul><h1 id="实操过程">实操过程</h1><h2 id="隧道搭建">隧道搭建</h2><p>我的系统时 Windows 11，系统本身没有命令直接搭建 ssh隧道。所以需要选择一款 ssh 客户端软件，我用的是 PuTTY （ 0.77 release64-bit x86 ），下载地址如下：</p><p><ahref="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p><p>下载完了之后，我们打开 PuTTY，首先是主页面，也就是左侧<code>Session</code> 的页面，这里有个 Host Name (or IP address) 和Port。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192238821.png"alt="配置 Session" /><figcaption aria-hidden="true">配置 Session</figcaption></figure><p>这里的 <strong>Host Name 与 Port 是指的 ssh 服务器的 IP地址与端口</strong>，对应着 Navicat 如下位置：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192244406.png"alt="对应的 ssh 服务器" /><figcaption aria-hidden="true">对应的 ssh 服务器</figcaption></figure><p>接着在左侧<code>Connection -&gt; SSH -&gt; Tunnels</code>这个界面，输入Source port 与 Destination，输入完之后，点击 Add 添加。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192255705.png"alt="配置单向隧道的源端口和目的端口" /><figcaptionaria-hidden="true">配置单向隧道的源端口和目的端口</figcaption></figure><p>这里的 <strong>Source port是指本机要用来建立隧道通信的端口</strong>，我的建议是不要选太怪的数字，最好10000 以上，65535以下，也没有太大讲究，最好别和其它服务重合了。<strong>Destination则是远程主机/服务器的 IP 和端口</strong>，我在 Google里其实搜索到过搭隧道 tableau连接远程主机的，它在演示的时候，自己跟自己建立的隧道，稍微不太方便理解这里的意思。Destination对应着 Navicat 如下位置：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192305530.png"alt="对应的目的端口" /><figcaption aria-hidden="true">对应的目的端口</figcaption></figure><p>然后在 PuTTY 里还需要配置一个地方，它位于<code>Connection -&gt; SSH -&gt; Auth</code>，这个地方是添加私钥的地方，如下：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192309718.png"alt="配置私钥" /><figcaption aria-hidden="true">配置私钥</figcaption></figure><p>它对应着 Navicat 里的：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192310985.png"alt="对应私钥位置" /><figcaption aria-hidden="true">对应私钥位置</figcaption></figure><p><strong>但是其实并不能直接添加 <code>pem</code>文件</strong>，这个时候我们需要打开 PuTTYgen，点击load，弹出文件选择页面时选择你的 pem 文件，然后点击 Save private key保存一个 <code>ppk</code> 格式的文件。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192315126.png"alt="私钥格式转换" /><figcaption aria-hidden="true">私钥格式转换</figcaption></figure><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192317180.png"alt="image-20220619231701159" /><figcaption aria-hidden="true">image-20220619231701159</figcaption></figure><p>这个时候就可以在 PuTTY 的页面添加这个 <code>ppk</code>格式文件了，如图：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192318792.png"alt="成功配置私钥" /><figcaption aria-hidden="true">成功配置私钥</figcaption></figure><p>回到 <code>Session</code> 点击 <code>Save</code>保存一下以免之后重新配（只用一次当我没说），配置方面就完成了。点击<code>Open</code> 测试一波：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192321988.png"alt="建立连接，登录账户" /><figcaption aria-hidden="true">建立连接，登录账户</figcaption></figure><p>输入用户名，这个用户名是 ssh 的用户名，对应着 Navicat 如下位置：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192322747.png"alt="对应的 ssh 账户名" /><figcaption aria-hidden="true">对应的 ssh 账户名</figcaption></figure><p>然后其实就连上了。注意连上了之后不要关闭 PuTTY，关了隧道就断开了。</p><p>有时可能会突然挂掉，我采用了每隔一段时间发送空包的方式维持隧道。在<code>Connection</code> 里，我把如下位置的值改成了 10：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192328488.png"alt="保持隧道连接" /><figcaption aria-hidden="true">保持隧道连接</figcaption></figure><p>至此，ssh 客户端（ PuTTY ）这边的工作就结束了，下一步就是测试。</p><h2 id="连接测试">连接测试</h2><p>因为我用 Navicat 是可以连接上的，所以我的选择是先用 Navicat测试。有过 Navicat 通过 ssh连接数据库经验的同学应该都知道，用这种方式连接数据库时，需要在<code>常规</code> 和 <code>SSH</code>两个页面分别配置，搭建隧道之后，只用配置 <code>常规</code>页面就可以了。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349956.png"alt="Navicat 测试" /><figcaption aria-hidden="true">Navicat 测试</figcaption></figure><p>这里：</p><ul><li>主机填写 <code>localhost</code> 或是 <code>127.0.0.1</code>都可以。</li><li>端口填写之前<strong>在 PuTTY 里填写的 Source port</strong>。</li><li>用户名填写目的主机/服务器的用户名。</li><li>密码填写目的主机/服务器的密码。</li></ul><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349512.png"alt="连接成功" /><figcaption aria-hidden="true">连接成功</figcaption></figure><p>接着在 power BI 上也测试一下。选择 MySQL 数据库。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192355774.png"alt="power BI 选择数据库" /><figcaption aria-hidden="true">power BI 选择数据库</figcaption></figure><p><strong>服务器填写 <code>127.0.0.1:xxxx</code>，就是本机的 IP地址加用于搭隧道的端口，也就是 PuTTY 里配置的 Source port。</strong>数据库填写你要连接的库名。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192357463.png"alt="power BI 连接数据库" /><figcaption aria-hidden="true">power BI 连接数据库</figcaption></figure><p>高级选项下可以写 SQL 查询语句。然后在下一步选择<code>数据库</code>，用户名填写目的主机/服务器的用户名，密码填写目的主机/服务器的密码，如下：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206200000501.png"alt="power BI 登录数据库账户" /><figcaption aria-hidden="true">power BI 登录数据库账户</figcaption></figure><p>点击连接就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>DataScience</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>ssh tunnel</tag>
      
      <tag>powerbi</tag>
      
      <tag>tableau</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 344 345</title>
    <link href="/2022/06/17/leetcode20220617/"/>
    <url>/2022/06/17/leetcode20220617/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串">344. 反转字符串</h1><p>简单交换。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        length = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(length/<span class="hljs-number">2</span>)):            temp = s[i]            s[i] = s[length-i-<span class="hljs-number">1</span>]            s[length-i-<span class="hljs-number">1</span>] = temp</code></pre></div><h1 id="反转字符串中的元音字母">345. 反转字符串中的元音字母</h1><p>首先我们需要用<code>set</code>存储元音字母表（这里有个坑就是大写小写都要写进去），然后通过双指针，首尾指针一起往中间遍历。如果同时遇到或者同时没有遇到元音就交换并且都移动，否则只移动没有遇到元音的指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseVowels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        vovel = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;        res = <span class="hljs-built_in">list</span>(s)        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            <span class="hljs-keyword">if</span> res[left] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel <span class="hljs-keyword">and</span> res[right] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> res[left] <span class="hljs-keyword">in</span> vovel <span class="hljs-keyword">and</span> res[right] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel:                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> res[left] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel <span class="hljs-keyword">and</span> res[right] <span class="hljs-keyword">in</span> vovel:                left += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                temp = res[left]                res[left] = res[right]                res[right] = temp                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
      <tag>bubble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 283 290 292</title>
    <link href="/2022/06/07/leetcode20220607/"/>
    <url>/2022/06/07/leetcode20220607/</url>
    
    <content type="html"><![CDATA[<h1 id="移动零">283. 移动零</h1><p>第一种就是想办法绕过测试。其实还是复制数组而非原地算法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        array = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:                array.append(i)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array)):            nums[i] = array[i]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array),<span class="hljs-built_in">len</span>(nums)):            nums[i] = <span class="hljs-number">0</span></code></pre></div><p>第二种，快慢双指针。用快指针遍历整个数组，慢指针记录不为0的元素并更改数组中此位置的值。最后在快指针遍历完后，慢指针到数组末端都是0，再填充。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        slow = <span class="hljs-number">0</span>        fast = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> fast&lt;length:            <span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span>:                nums[slow] = nums[fast]                fast += <span class="hljs-number">1</span>                slow += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                fast += <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> slow&lt;length:            nums[slow] = <span class="hljs-number">0</span>            slow += <span class="hljs-number">1</span></code></pre></div><h1 id="单词规律">290. 单词规律</h1><p>双哈希表，分为正向哈希记录<code>(pattern, string)</code>与逆向哈希记录<code>(string, pattern)</code>。值得注意的点有两个：一是正向哈希记录第一次看到的键值对，逆向哈希记录最后一次看到的键值对；二是正向哈希与逆向哈希的键值对数量应该是一样的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        dict_pos = &#123;&#125;        dict_nag = &#123;&#125;        lst_ptn = <span class="hljs-built_in">list</span>(pattern)        lst_s = s.split()        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst_ptn) != <span class="hljs-built_in">len</span>(lst_s):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(lst_ptn, lst_s):            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_pos:                dict_pos[k] = v            dict_nag[v] = k        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_pos) != <span class="hljs-built_in">len</span>(dict_nag):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_pos.items():            <span class="hljs-keyword">if</span> k != dict_nag[v]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="nim-游戏">292. Nim 游戏</h1><p>这是一个简单的博弈，在此模拟下博弈的过程。</p><div class="code-wrapper"><pre><code class="hljs text">1：自己拿走1块，赢。2：自己拿走2块，赢。3：自己拿走3块，赢。4：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是1、2、3中的一种。5：自己拿走1块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。6：自己拿走2块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。7：自己拿走3块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。8：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是5、6、7中的一种。9：自己拿走1块，赢。构建对方8的局面，因为8时拿无论怎么都会输所以只要构造出来就赢。</code></pre></div><p>所以可以发现，当桌上还剩4的倍数的石头数目时，拿的那一方一定会输。所以一开始的时候，我先手的话只要桌上石头是4的倍数就一定会输。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canWinNim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> n%<span class="hljs-number">4</span> != <span class="hljs-number">0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 278</title>
    <link href="/2022/06/06/leetcode20220606/"/>
    <url>/2022/06/06/leetcode20220606/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个错误的版本">278. 第一个错误的版本</h1><p>二分查找可以解决，左指针<code>left</code>记录当前正确的版本，右指针<code>right</code>记录当前错误的版本，所以当<code>right-left=1</code>时，<code>right</code>所指的就是第一个错误的版本，也就是结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">self, n</span>):        left = <span class="hljs-number">0</span>        right = n        mid = (<span class="hljs-number">1</span>+n)//<span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> right-left&gt;<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> isBadVersion(mid):                right = mid            <span class="hljs-keyword">else</span>:                left = mid            mid = (left+right)//<span class="hljs-number">2</span>        <span class="hljs-keyword">return</span> right</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 263 268</title>
    <link href="/2022/06/05/leetcode20220605/"/>
    <url>/2022/06/05/leetcode20220605/</url>
    
    <content type="html"><![CDATA[<h1 id="丑数">263. 丑数</h1><p>根据丑数的定义，1是第一个丑数，而且质因数只有2、3、5，就有如下代码。优化的地方就是除2可以用位运算。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isUgly</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">while</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> n%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>:            n /= <span class="hljs-number">3</span>        <span class="hljs-keyword">while</span> n%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:            n /= <span class="hljs-number">5</span>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span></code></pre></div><h1 id="丢失的数字">268. 丢失的数字</h1><p>读题可以知道要找的那个数是在<code>[0, len(nums)]</code>里的，所以可以用<code>range</code>生成器生成一个未丢失的数组来遍历查找是否在<code>nums</code>里面确定那个丢失的数。然后发现很慢，很容易可以想到用<code>set</code>替代查找范围<code>list</code>会快一点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">missingNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_set = <span class="hljs-built_in">set</span>(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nums_set:                <span class="hljs-keyword">return</span> i</code></pre></div><p>当然像这种对应关系很容易想到<code>enumerate</code>这个<code>python</code>内置的函数，也就是用排序的方法解决。值得注意的就是，如果恰好是<code>n</code>是丢失的数字，需要最后返回一下<code>n</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">missingNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums.sort()        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> i != v:                <span class="hljs-keyword">return</span> i        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>math</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 258</title>
    <link href="/2022/06/04/leetcode20220603/"/>
    <url>/2022/06/04/leetcode20220603/</url>
    
    <content type="html"><![CDATA[<h1 id="各位相加">258. 各位相加</h1><p>简单循环，模拟题目中描述的过程逐位相加直到<code>num</code>小于10。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">while</span> num &gt;= <span class="hljs-number">10</span>:            num_str = <span class="hljs-built_in">str</span>(num)            num = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num_str])        <span class="hljs-keyword">return</span> num</code></pre></div><p>但是题目中提到了有<code>O(1)</code>时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：</p><div class="code-wrapper"><pre><code class="hljs text">9-&gt;999-&gt;18-&gt;9999-&gt;27-&gt;9...假设9...9(n位)-&gt;9那么9...9(n+1位)-&gt;9(n+1)=9*n+9=18-&gt;9所以假设成立</code></pre></div><p>通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：<span class="math display">\[\begin{cases}    result=0,\ when\ n=0 \\    result=9,\ when\ n\%9=0\ and\ n\neq 0 \\    result=n\%9,\ when\ n\%9\neq0\\\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> num==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">9</span> <span class="hljs-keyword">if</span> num%<span class="hljs-number">9</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> num%<span class="hljs-number">9</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>recursion</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 242</title>
    <link href="/2022/06/01/leetcode20220601/"/>
    <url>/2022/06/01/leetcode20220601/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词">242. 有效的字母异位词</h1><p>排序，比较两个字符串排序后是否相同。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">import</span> operator        <span class="hljs-keyword">return</span> operator.eq(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(s)), <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(t)))</code></pre></div><p>哈希，用<code>dict</code>进行计数。比上一种快。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashmap[i] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 228 231</title>
    <link href="/2022/05/29/leetcode20220529/"/>
    <url>/2022/05/29/leetcode20220529/</url>
    
    <content type="html"><![CDATA[<h1 id="汇总区间">228. 汇总区间</h1><p>双指针 <code>start</code> 和 <code>end</code>，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []        start = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> start &lt; length:            end = start            <span class="hljs-keyword">while</span> end &lt; length-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (nums[end+<span class="hljs-number">1</span>]-nums[end])==<span class="hljs-number">1</span>:                end += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> start == end:                res.append(<span class="hljs-built_in">str</span>(nums[start]))            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-built_in">str</span>(nums[start])+<span class="hljs-string">&#x27;-&gt;&#x27;</span>+<span class="hljs-built_in">str</span>(nums[end]))            start = end+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="的幂">231. 2 的幂</h1><p>先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c的幂的最大值设为 <span class="math inline">\(x\)</span> ，必有 <spanclass="math inline">\(x\%c=0\)</span>，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是<code>2&lt;&lt;30</code> ，就可以写成如下代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">30</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><p>当然正规军的做法是位运算。首先 2的幂的二进制表示有个规律就是所有位只有一个 1，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2的幂。这里有个小技巧<ahref="https://movisli.github.io/posts/2022/05/19/Solution.html">LeetCode191</a> ，<code>n &amp; (n - 1)</code> 可以将最后一个 1去掉，既然只有一个 1 所以去掉之后就没有了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &amp; (n - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 217 219</title>
    <link href="/2022/05/27/leetcode20220527/"/>
    <url>/2022/05/27/leetcode20220527/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素">217. 存在重复元素</h1><p>简单<code>hash</code>，建立一个<code>set</code>，遍历数组，如果元素不在里面就添加，如果在里面就返回<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="存在重复元素-ii">219. 存在重复元素 II</h1><p>这次涉及到元素还有它的下标，也是简单<code>hash</code>，不过要建立的是<code>dict</code>，<code>dict</code>的<code>key</code>是元素值，<code>dict</code>的<code>value</code>是元素下标。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> n,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[v] = n            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> n-hashmap[v] &lt;= k:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    hashmap[v] = n        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 206</title>
    <link href="/2022/05/26/leetcode20220526/"/>
    <url>/2022/05/26/leetcode20220526/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表">206. 反转链表</h1><p>常见的用栈反转。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:        stack = []        node = head        <span class="hljs-keyword">while</span> node:            stack.append(node.val)            node = node.<span class="hljs-built_in">next</span>        res = ListNode()        node = res        <span class="hljs-keyword">while</span> stack:            node.<span class="hljs-built_in">next</span> = ListNode(stack.pop())            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 203 205</title>
    <link href="/2022/05/25/leetcode20220525/"/>
    <url>/2022/05/25/leetcode20220525/</url>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素">203. 移除链表元素</h1><p>一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:        res = ListNode()        res.<span class="hljs-built_in">next</span> = head        node = res        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>.val == val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div><p>也可以先对头节点进行处理，先保证头节点不是要删除的节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.val == val:            head = head.<span class="hljs-built_in">next</span>        node = head        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>.val == val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h1 id="同构字符串">205. 同构字符串</h1><p>分别建立正向映射关系<code>dict_forward</code>和逆向映射关系<code>dict_backward</code>，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：</p><blockquote><p>"bbbaaaba"</p><p>"aaabbbba"</p></blockquote><p>这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        dict_forward = &#123;&#125;        dict_backward = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_forward:                dict_forward[s[i]] = t[i]            dict_backward[t[i]] = s[i]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_forward) != <span class="hljs-built_in">len</span>(dict_backward):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_forward.items():            <span class="hljs-keyword">if</span> dict_backward[v] != k:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>linked list</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 202</title>
    <link href="/2022/05/24/leetcode20220524/"/>
    <url>/2022/05/24/leetcode20220524/</url>
    
    <content type="html"><![CDATA[<h1 id="快乐数">202. 快乐数</h1><p>首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是<code>False</code>，否则就是<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">7</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        res = n        <span class="hljs-keyword">while</span> res&gt;=<span class="hljs-number">10</span>:            temp = <span class="hljs-built_in">str</span>(res)            res = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:                res += <span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> res == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> res == <span class="hljs-number">7</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了<code>hashset</code>，当这次运算结果出现在<code>set</code>里时，说明循环已经开始了，否则我们把这次结果加入<code>set</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = &#123;n&#125;        <span class="hljs-keyword">while</span> n!=<span class="hljs-number">1</span>:            temp = <span class="hljs-built_in">str</span>(n)            n = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:                n += <span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashset.add(n)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 191</title>
    <link href="/2022/05/19/leetcode20220519/"/>
    <url>/2022/05/19/leetcode20220519/</url>
    
    <content type="html"><![CDATA[<h1 id="位1的个数">191. 位1的个数</h1><p>首先来个循环检查每一位是否为1。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        bin_str = <span class="hljs-built_in">bin</span>(n)[<span class="hljs-number">2</span>:]        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> bin_str:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;1&#x27;</span>:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1，python的右移运算符<code>&gt;&gt;</code>就是高位补0，低位舍去。所以移动32次，就可以得到结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += n&amp;<span class="hljs-number">1</span>            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>但是在位运算里，还有个神奇的做法，可以通过<code>n&amp;(n-1)</code>把二进制中最后一个1改写成0。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += <span class="hljs-number">1</span>            n &amp;= n-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>参考<ahref="https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/">【负雪明烛】详解位运算，附本题躲坑指南- 位1的个数 - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 190</title>
    <link href="/2022/05/18/leetcode20220518/"/>
    <url>/2022/05/18/leetcode20220518/</url>
    
    <content type="html"><![CDATA[<h1 id="颠倒二进制位">190. 颠倒二进制位</h1><p>注意下题目中的32位无符号整数。暴力解：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;0&#x27;</span>*(<span class="hljs-number">32</span>-<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))[<span class="hljs-number">2</span>:]))+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))[<span class="hljs-number">2</span>:])[::-<span class="hljs-number">1</span>], <span class="hljs-number">2</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 168 171 175 181 182 183</title>
    <link href="/2022/05/16/leetcode20220516/"/>
    <url>/2022/05/16/leetcode20220516/</url>
    
    <content type="html"><![CDATA[<h1 id="excel表列名称">168. Excel表列名称</h1><p>此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面<code>temp = (columnNumber-1)%26+1</code>这行代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convertToTitle</span>(<span class="hljs-params">self, columnNumber: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">while</span> columnNumber != <span class="hljs-number">0</span>:            temp = (columnNumber-<span class="hljs-number">1</span>)%<span class="hljs-number">26</span>+<span class="hljs-number">1</span>            res += <span class="hljs-built_in">chr</span>(temp+<span class="hljs-number">64</span>)            columnNumber = (columnNumber-temp)//<span class="hljs-number">26</span>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]</code></pre></div><h1 id="excel-表列序号">171. Excel 表列序号</h1><p>与上题差不多，上题的逆向。本质上还是个进制转换。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">titleToNumber</span>(<span class="hljs-params">self, columnTitle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        n = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> columnTitle[::-<span class="hljs-number">1</span>]:            res += (<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">64</span>)*n            n *= <span class="hljs-number">26</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="组合两个表">175. 组合两个表</h1><p>依题意做一个简单左链接就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTt1.firstName,t1.lastName,t2.city,t2.state FROMPerson t1LEFT JOIN Address t2 ON t1.personId = t2.personId</code></pre></div><h1 id="超过经理收入的员工">181. 超过经理收入的员工</h1><p>表自链接就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTl.NAME AS Employee FROMEmployee lINNER JOIN Employee r ON l.managerId = r.id WHEREl.salary &gt; r.salary</code></pre></div><h1 id="查找重复的电子邮箱">182. 查找重复的电子邮箱</h1><p>自链接</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCTt1.Email FROMPerson t1JOIN Person t2 ON t1.Email = t2.Email AND t1.Id != t2.Id</code></pre></div><p>子表查询</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTEmail FROM( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec WHEREtec.ec &gt; 1</code></pre></div><h1 id="从不订购的客户">183. 从不订购的客户</h1><p>子表查询</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTn.NAME AS Customers FROM( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n WHEREn.id IS NULL</code></pre></div><p>子表查询和<code>NOT IN</code>语句</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTCustomers.Name AS Customers FROMCustomers WHERECustomers.Id NOT IN ( SELECT CustomerId FROM Orders )</code></pre></div><p>右链接</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTa.NAME AS Customers FROMCustomers aLEFT JOIN Orders b ON a.Id = b.CustomerId WHEREb.CustomerId IS NULL</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>sql</tag>
      
      <tag>ascii</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 121 125 136 169</title>
    <link href="/2022/05/15/leetcode20220515/"/>
    <url>/2022/05/15/leetcode20220515/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p>遍历一次数组，更新数组的最小值<code>min_pcp</code>与当前值与数组最小值差的最大值<code>max_pft</code>。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    max_pft = <span class="hljs-number">0</span>    min_pcp = prices[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:      <span class="hljs-keyword">if</span> i &lt; min_pcp:        min_pcp = i        <span class="hljs-keyword">continue</span>      <span class="hljs-keyword">if</span> (i-min_pcp)&gt;max_pft:        max_pft = i-min_pcp    <span class="hljs-keyword">return</span> max_pft</code></pre></div></p><h1 id="验证回文串">125. 验证回文串</h1><p>先进行数据清洗再比较。 <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    washed = <span class="hljs-string">&#x27;&#x27;</span>.join(ch.lower() <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> ch.isalnum())    <span class="hljs-keyword">return</span> washed == washed[::-<span class="hljs-number">1</span>]</code></pre></div></p><h1 id="只出现一次的数字">136. 只出现一次的数字</h1><p>蠢蠢hashset。 <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                res.append(i)                hashset.add(i)            <span class="hljs-keyword">else</span>:                res.remove(i)        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]</code></pre></div>题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x^y, nums)</code></pre></div></p><h1 id="多数元素">169. 多数元素</h1><p>简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        feq = <span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> hashmap.items():            <span class="hljs-keyword">if</span> v &gt; feq:                <span class="hljs-keyword">return</span> k</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>string</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 83 88 94 118 119</title>
    <link href="/2022/05/13/leetcode20220513/"/>
    <url>/2022/05/13/leetcode20220513/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h1><p>基本链表操作。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> head        node = head        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.val == node.<span class="hljs-built_in">next</span>.val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h1 id="合并两个有序数组">88. 合并两个有序数组</h1><p>本题要求<code>inplace</code>，但是我们仍然可以用<code>不inplace</code>的思想做<code>inplace</code>的事情。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-number">0</span>        res = []        <span class="hljs-keyword">while</span> (left+right)&lt;(m+n):            <span class="hljs-keyword">if</span> left&gt;=m:                res.append(nums2[right])                right += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> right&gt;=n:                res.append(nums1[left])                left += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> nums1[left] &lt;= nums2[right]:                res.append(nums1[left])                left += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                res.append(nums2[right])                right += <span class="hljs-number">1</span>        nums1[:]=res</code></pre></div><p>当然我们也可以逆向开始放数，空间复杂度会更低。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        tail = m+n-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> m&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n&gt;=<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> m&lt;<span class="hljs-number">1</span>:                nums1[tail] = nums2[n-<span class="hljs-number">1</span>]                tail -= <span class="hljs-number">1</span>                n -= <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">1</span>:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> nums1[m-<span class="hljs-number">1</span>] &gt;= nums2[n-<span class="hljs-number">1</span>]:                nums1[tail] = nums1[m-<span class="hljs-number">1</span>]                m -= <span class="hljs-number">1</span>                tail -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                nums1[tail] = nums2[n-<span class="hljs-number">1</span>]                n -= <span class="hljs-number">1</span>                tail -= <span class="hljs-number">1</span></code></pre></div><h1 id="二叉树的中序遍历">94. 二叉树的中序遍历</h1><p>递归：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> root:            res.extend(self.inorderTraversal(root.left))            res.append(root.val)            res.extend(self.inorderTraversal(root.right))        <span class="hljs-keyword">return</span> res</code></pre></div><p>非递归：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        node = root        stack = []        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">or</span> stack:            <span class="hljs-keyword">if</span> node:                stack.append(node)                node = node.left            <span class="hljs-keyword">else</span>:                node = stack.pop()                res.append(node.val)                node = node.right        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="杨辉三角">118. 杨辉三角</h1><p>就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]        res = [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]        curRow = <span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> curRow&lt;numRows:            temp = [<span class="hljs-number">1</span>]            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res[curRow-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>):                temp.append(res[curRow-<span class="hljs-number">1</span>][i]+res[curRow-<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>])            temp.append(<span class="hljs-number">1</span>)            res.append(temp)            curRow += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="杨辉三角-ii">119. 杨辉三角 II</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRow</span>(<span class="hljs-params">self, rowIndex: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = [<span class="hljs-number">1</span>]        cal_num = (rowIndex)//<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, cal_num+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            res.append(<span class="hljs-built_in">int</span>(res[i-<span class="hljs-number">1</span>]*(rowIndex-i+<span class="hljs-number">1</span>)/i))        <span class="hljs-keyword">if</span> rowIndex%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cal_num,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):                res.append(res[i])        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cal_num-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):                res.append(res[i])        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>linked list</tag>
      
      <tag>array</tag>
      
      <tag>binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 70</title>
    <link href="/2022/05/11/leetcode20220511/"/>
    <url>/2022/05/11/leetcode20220511/</url>
    
    <content type="html"><![CDATA[<h1 id="爬楼梯">70. 爬楼梯</h1><p>斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        lst = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>):            lst.append(lst[i]+lst[i+<span class="hljs-number">1</span>])        <span class="hljs-keyword">return</span> lst[n]</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 66 67 69</title>
    <link href="/2022/05/10/leetcode20220510/"/>
    <url>/2022/05/10/leetcode20220510/</url>
    
    <content type="html"><![CDATA[<h1 id="加一">66. 加一</h1><p>从后往前加就行了，需要用一个<code>carry flag</code>控制是否进位，加一对末位来说就是进位的，所以当<code>carry flag</code>变为<code>False</code>时，跳出循环。如果循环走完还需进位，则需要在<code>list</code>第0个位置增添个元素1。但是实际上因为<code>return</code>的位置可以放得巧妙点，所以可以省略<code>flag</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plusOne</span>(<span class="hljs-params">self, digits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(digits)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            digits[i] += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> digits[i] &gt;= <span class="hljs-number">10</span>:                digits[i] -= <span class="hljs-number">10</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> digits        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>] + digits</code></pre></div><h1 id="二进制求和">67.二进制求和</h1><p>直接用内置函数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(a,<span class="hljs-number">2</span>)+<span class="hljs-built_in">int</span>(b,<span class="hljs-number">2</span>)))[<span class="hljs-number">2</span>:]</code></pre></div><h1 id="x-的平方根">69. x 的平方根</h1><p>牛顿迭代法：</p><p>为了方便区别问题写为求n的平方根，即 <span class="math display">\[x^2=n\\f(x)=x^2-n\]</span> 相当于求函数<spanclass="math inline">\(f(x)\)</span>的根，关于牛顿迭代的原理参照</p><blockquote><p><ahref="https://www.zhihu.com/question/20690553/answer/146104283">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p></blockquote><p>对<span class="math inline">\(x_0\)</span>点的切线为： <spanclass="math display">\[y = f(x_0)-2x_0(x-x0)\]</span> 令<span class="math inline">\(y=0\)</span>，迭代后的<spanclass="math inline">\(x_1\)</span>点值可算得： <spanclass="math display">\[x_1=x_0-\frac{x_0}{2}+\frac{n}{2x_0}\]</span> 每次迭代的误差为： <span class="math display">\[\varepsilon = |x0-x1|\]</span> 当误差小于0.1时跳出就行了。</p><p><strong>初值不能为0。</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            last = res            res = res - res/<span class="hljs-number">2</span> + x/<span class="hljs-number">2</span>/res            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(last-res) &lt; <span class="hljs-number">1</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(res)</code></pre></div><p>二分查找：</p><p><span class="math inline">\(x\)</span>的平方根整数部分是满足<spanclass="math inline">\(k^2\leq x\)</span>的最大<spanclass="math inline">\(k\)</span>值，所以只要保证这个条件可以进行赋值。经典二分查找代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left, right, res = <span class="hljs-number">0</span>, x, -<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left+right)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid*mid &lt;= x:                res = mid                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                right = mid-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>binary search</tag>
      
      <tag>loop</tag>
      
      <tag>Newton&#39;s method</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 58</title>
    <link href="/2022/05/09/leetcode20220509/"/>
    <url>/2022/05/09/leetcode20220509/</url>
    
    <content type="html"><![CDATA[<h1 id="最后一个单词的长度">58. 最后一个单词的长度</h1><p>反向遍历，用一个<code>flag</code>稍微控制下流程就行了，注意几个<code>if</code>的顺序。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLastWord</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        start = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> s[i] != <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> start:                start = <span class="hljs-literal">True</span>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> start:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> start:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 27 28 35 53</title>
    <link href="/2022/05/07/leetcode20220507/"/>
    <url>/2022/05/07/leetcode20220507/</url>
    
    <content type="html"><![CDATA[<h1 id="移除元素">27. 移除元素</h1><p>双指针，一个指针<code>index</code>控制循环遍历，另一个指针<code>k</code>控制将正确的数填到正确的位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        index = <span class="hljs-number">0</span>        k = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> index&lt;length:            <span class="hljs-keyword">if</span> nums[index] != val:                nums[k] = nums[index]                k+=<span class="hljs-number">1</span>            index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> k</code></pre></div><h1 id="实现strstr">28. 实现strStr()</h1><p>只是用的话，调用python字符串的find函数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> haystack.find(needle)</code></pre></div><p>思路就是逐位比较。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        length = <span class="hljs-built_in">len</span>(needle)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)-length+<span class="hljs-number">1</span>):            j = i            k = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> k&lt;length <span class="hljs-keyword">and</span> haystack[j] == needle[k]:                j += <span class="hljs-number">1</span>                k += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> j-i == length:                <span class="hljs-keyword">return</span> i                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h1 id="搜索插入位置">35. 搜索插入位置</h1><p>时间复杂度<code>O(log n)</code>，经典二分查找。但是这题如果没找到要返回插入的位置，当<span class="math inline">\(left&lt;x&lt;right\)</span>时，很明显该插入的位置是<code>right_index</code>，然后看一下经典二分查找代码，因为没找到的话<code>left</code>还是会加1，所以其实没找到的话<code>left</code>就是<code>right_index</code>，所以没找到返回<code>left</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;=right:            mid = (right+left)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> mid                <span class="hljs-keyword">return</span> left</code></pre></div><h1 id="最大子数组和">53. 最大子数组和</h1><p>动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于<code>nums[0]</code>，然后从左往右遍历，创建一个变量<code>temp_sum</code>用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个<code>temp_sum</code>了。每找出一段<code>temp_sum</code>都与<code>result</code>比较取大的作为新的<code>result</code>。遍历完成后，就可以得到最大的<code>result</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = nums[<span class="hljs-number">0</span>]        temp_sum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            temp_sum += i            <span class="hljs-keyword">if</span> temp_sum &gt; res:                res = temp_sum            <span class="hljs-keyword">if</span> temp_sum &lt; <span class="hljs-number">0</span>:                temp_sum = <span class="hljs-number">0</span>                <span class="hljs-keyword">return</span> res</code></pre></div><blockquote><p>时间复杂度 O(n)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>binary search</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 26</title>
    <link href="/2022/05/06/leetcode20220506/"/>
    <url>/2022/05/06/leetcode20220506/</url>
    
    <content type="html"><![CDATA[<h1 id="删除有序数组中的重复项">26. 删除有序数组中的重复项</h1><p>暴力解法，创建<code>set</code>用于记录出现过的唯一元素，创建<code>drop_lst</code>用于记录要删的位置，删元素的时候注意下<code>python</code>的<code>del</code>会更改后续元素的下标，所以建立一个<code>k</code>辅助找到真正的下标再删。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        drop_lst = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(nums[i])            <span class="hljs-keyword">else</span>:                drop_lst.append(i)        k = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> drop_lst:            <span class="hljs-keyword">del</span> nums[i-k]            k += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(hashset)</code></pre></div><blockquote><p>1068 ms</p></blockquote><p>核心在于前探指针，每次循环时生成一个前探指针<code>next_index</code>找寻下一个不重复的元素的<code>index</code>，用指针<code>k</code>代表下一个不重复元素（假如有）正确的位置，所以在找到正确的<code>next_index</code>后，将其赋值给<code>k</code>就行了，同时将<code>index</code>变为<code>next_index</code>，最后返回<code>k-1</code>因为多算了一次<code>k</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        index = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        k = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> index &lt; length:            next_index = index+<span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> next_index&lt;length:                <span class="hljs-keyword">if</span> nums[next_index] != nums[index]:                    <span class="hljs-keyword">break</span>                next_index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> next_index != length:                nums[k] = nums[next_index]            k += <span class="hljs-number">1</span>            index = next_index        <span class="hljs-keyword">return</span> k-<span class="hljs-number">1</span></code></pre></div><blockquote><p>28 ms</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 13</title>
    <link href="/2022/05/05/leetcode20220505/"/>
    <url>/2022/05/05/leetcode20220505/</url>
    
    <content type="html"><![CDATA[<h1 id="罗马数字转整数">13. 罗马数字转整数</h1><p>比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        s_len = <span class="hljs-built_in">len</span>(s)        index = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> index&lt;s_len:            <span class="hljs-keyword">if</span> s[index] == <span class="hljs-string">&#x27;I&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;V&#x27;</span>:                        res += <span class="hljs-number">4</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;X&#x27;</span>:                        res += <span class="hljs-number">9</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">1</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">1</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;X&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;L&#x27;</span>:                        res += <span class="hljs-number">40</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;C&#x27;</span>:                        res += <span class="hljs-number">90</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">10</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">10</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;C&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;D&#x27;</span>:                        res += <span class="hljs-number">400</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;M&#x27;</span>:                        res += <span class="hljs-number">900</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">100</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">100</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;V&#x27;</span>:                res += <span class="hljs-number">5</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;L&#x27;</span>:                res += <span class="hljs-number">50</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;D&#x27;</span>:                res += <span class="hljs-number">500</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;M&#x27;</span>:                res += <span class="hljs-number">1000</span>                index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 14 20 21</title>
    <link href="/2022/05/04/leetcode20220504/"/>
    <url>/2022/05/04/leetcode20220504/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共前缀">14. 最长公共前缀</h1><p>首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&quot;&quot;</span>        min_len = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:            min_len = <span class="hljs-built_in">min</span>(min_len, <span class="hljs-built_in">len</span>(i))        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_len):            tmp_target = strs[<span class="hljs-number">0</span>][i]            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:                <span class="hljs-keyword">if</span> s[i] != tmp_target:                    <span class="hljs-keyword">return</span> res            res += tmp_target                <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="有效的括号">20. 有效的括号</h1><p>有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回<code>False</code>，二是后括号是否对应出栈的前括号，不对应也返回<code>False</code>。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回<code>False</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;&#123;&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;[&#x27;</span>:                stack.append(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;]&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> stack:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="合并两个有序链表">21. 合并两个有序链表</h1><p>迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        res = ListNode(<span class="hljs-number">0</span>)        tmp = res        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:                tmp.<span class="hljs-built_in">next</span> = list1                tmp = tmp.<span class="hljs-built_in">next</span>                list1 = list1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                tmp.<span class="hljs-built_in">next</span> = list2                tmp = tmp.<span class="hljs-built_in">next</span>                list2 = list2.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> list1:            tmp.<span class="hljs-built_in">next</span> = list1        <span class="hljs-keyword">elif</span> list2:            tmp.<span class="hljs-built_in">next</span> = list2        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1 9</title>
    <link href="/2022/05/03/leetcode20220503/"/>
    <url>/2022/05/03/leetcode20220503/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和">1. 两数之和</h1><p>建立一个<code>dict</code>(map)，遍历一次数组，判断<code>目标值-当前值</code>是否在<code>dict</code>的<code>key</code>里，在就输出对应的<code>value</code>(index)与当前的<code>index</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            temp_target = target - nums[i]            <span class="hljs-keyword">if</span> temp_target <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> [hashmap[temp_target], i]            <span class="hljs-keyword">else</span>:                hashmap[nums[i]] = i        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h1 id="回文数">9. 回文数</h1><p>转字符串判断正序和逆序是否相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(x)[::-<span class="hljs-number">1</span>]==<span class="hljs-built_in">str</span>(x)</code></pre></div><p> 左右指针逐步向中间移动判断每一步是否相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        string = <span class="hljs-built_in">str</span>(x)        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(string)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;right:            <span class="hljs-keyword">if</span> string[left] != string[right]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「算法」 - 学习计划</title>
    <link href="/2022/02/16/leetcode%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/16/leetcode%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法入门">算法入门</h1><h2 id="二分查找">二分查找</h2><h3 id="二分查找-1">704. 二分查找</h3><p>经典二分查找。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left + right) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == target:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid - <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                left = mid + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h3 id="第一个错误的版本">278. 第一个错误的版本</h3><p>第一个错误的版本就是左边是正确的版本，右边是错误的版本时的右边的版本，也就是满足这个条件的时候就该跳出循环。</p><p>因此我们可以二分去查找，但是注意如果 <code>mid</code>是错误的版本，<code>right</code> 等于它，反之 <code>left</code>等于它。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = n        <span class="hljs-keyword">while</span> right-left != <span class="hljs-number">1</span>:            mid = (left+right) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> isBadVersion(mid):                right = mid            <span class="hljs-keyword">else</span>:                left = mid        <span class="hljs-keyword">return</span> right</code></pre></div><h3 id="搜索插入位置">35. 搜索插入位置</h3><p>经典二分法，搜不到的时候左指针就是该插入的位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left+right) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == target:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid - <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                left = mid + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> left</code></pre></div><h2 id="双指针">双指针</h2><h3 id="有序数组的平方">977. 有序数组的平方</h3><p>这道题在解释里面是先平方再排序，也就是 <code>O(NlogN)</code>的时间复杂度。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x*x, nums))</code></pre></div><p>这里我就不展开写排序算法了因为 <code>Python</code>有的时候算法比内置函数慢在内置是用 <code>C</code> 写的。</p><p>也可以像二分查找的一样类似每遍历一个元素，平方，再搜索插入位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:            left = <span class="hljs-number">0</span>            right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> left &lt;= right:                mid = (left+right) // <span class="hljs-number">2</span>                <span class="hljs-keyword">if</span> nums[mid] == target:                    <span class="hljs-keyword">return</span> mid                <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                    right = mid - <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    left = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> left                res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            temp = i*i            res.insert(searchInsert(res, temp), temp)        <span class="hljs-keyword">return</span> res</code></pre></div><p>然而这个时间真的是慢得不行。</p><h3 id="轮转数组">189. 轮转数组</h3><p>在我的印象里这道题就是反转三次解决的题：</p><ol type="1"><li>反转素有元素</li><li>(0, k-1) 反转</li><li>(k, n-1) 反转</li></ol><p>此外我们需要考虑下 <code>k &gt;= n</code> ：</p><ul><li>k = n 时 - 结果和不移动一样。</li><li>k &gt; n 时 - 结果和 <code>k%n</code> 一样。</li></ul><p>因此：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        n = <span class="hljs-built_in">len</span>(nums)        k %= n        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n//<span class="hljs-number">2</span>):            nums[i], nums[n-i-<span class="hljs-number">1</span>] = nums[n-i-<span class="hljs-number">1</span>], nums[i]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k//<span class="hljs-number">2</span>):            nums[i], nums[k-i-<span class="hljs-number">1</span>] = nums[k-i-<span class="hljs-number">1</span>], nums[i]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k, (k+n)//<span class="hljs-number">2</span>):            nums[i], nums[n-i-<span class="hljs-number">1</span>+k] = nums[n-i-<span class="hljs-number">1</span>+k], nums[i]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>但是这道题对 Python 的意义应该是深入理解切片的使用。</p><ul><li><code>[start:stop：step]</code><ul><li>表示从下标 <code>start</code> 开始取到 <code>stop</code>为止（不包括下标 <code>stop</code> 的值）的值，也就是前闭后开。</li><li><code>step</code> 为正代表向右取数，<code>step</code>为负代表向左取数，如果取不到结果就返回空子集（字符串是 <code>''</code>，列表是 <code>[]</code>，元组是 <code>()</code> ），举个例子，字符串<code>temp = "string"</code> ：<ul><li><code>temp[-1:1]</code> - 1 元素在 -1 元素右边，取不到。</li><li><code>temp[-2:4]</code> - 等同于 <code>temp[4:4]</code>，取不到因为不包括右边的值。</li></ul></li><li><code>step</code> 为 1 时可以省略 <code>step</code> 。对于<code>start</code> 和 <code>stop</code>来讲，省略相当于在这个方向上无限取数，这个方向和 <code>step</code>有关。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        k %= <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        nums[::] = nums[::-<span class="hljs-number">1</span>]        nums[k::] = nums[:k-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]        nums[:k:] = nums[k-<span class="hljs-number">1</span>::-<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>不过对于切片来讲，这道题其实可以一次切完。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        n = <span class="hljs-built_in">len</span>(nums)        k %= n        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        nums[:k], nums[k:] = nums[n-k:], nums[:n-k]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="移动零">283. 移动零</h3><p>快慢指针问题，分两步：</p><ol type="1"><li>填非零值，快指针负责遍历数组找到非零值，填入慢指针指向位置，然而慢指针前进一位，否则不处理。</li><li>填零值，从慢指针开始移动到数组尾端都填 0 。</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        slow = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> fast, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> value:                nums[slow] = value                slow += <span class="hljs-number">1</span>        nums[slow::] = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(slow, <span class="hljs-built_in">len</span>(nums))]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="两数之和-ii---输入有序数组">167. 两数之和 II - 输入有序数组</h3><p>其实和第一题 <code>两数之和</code> 还是挺像的，依然是用<code>dict</code> 记录是否存在满足条件的数。两个小坑，第一个 index 从 1开始，第二个说不能使用重复的元素是指不能用同一个数而不是同一个值（如果数组里有两个一样的依然可以用）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numbers):            <span class="hljs-keyword">if</span> target-v <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> [hashmap[target-v]+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>]            <span class="hljs-keyword">else</span>:                hashmap[v] = i        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="反转字符串">344. 反转字符串</h3><p>这是真的经典双指针，一个指向头一个指向尾，然后交换值再都向对方移动一位，直到相遇。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;right:            s[left], s[right] = s[right], s[left]            left += <span class="hljs-number">1</span>            right -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>或者用 <code>for</code> 循环。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        s_len = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len//<span class="hljs-number">2</span>):            s[i], s[s_len-i-<span class="hljs-number">1</span>] = s[s_len-i-<span class="hljs-number">1</span>], s[i]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>当然 Python 里面用切片是最方便的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        s[:] = s[::-<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h3 id="反转字符串中的单词-iii">557. 反转字符串中的单词 III</h3><p><code>join()</code> 加列表生成式加切片。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s_lst = s.split()        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join([i[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s_lst])</code></pre></div><h3 id="链表的中间结点">876. 链表的中间结点</h3><p>这道题被归到双指针题目里面，显然就是一道快慢指针的问题，逻辑很简单，快指针走两次，慢指针走一次。最后慢指针的位置就是中间结点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        slow = head        fast = head        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:            slow = slow.<span class="hljs-built_in">next</span>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> slow</code></pre></div><h3 id="删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</h3><p>第一种思路，一次扫描，之后再删。注意要删一个结点需要找到的是它的前序结点（而不是它自己）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        counter = <span class="hljs-number">0</span>        node = head        <span class="hljs-keyword">while</span> node:            node = node.<span class="hljs-built_in">next</span>            counter += <span class="hljs-number">1</span>        dummy = ListNode(<span class="hljs-number">0</span>, head)        node = dummy        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter-n):            node = node.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>这里我感觉有个坑就是测试用例好像是异步跑的 。我曾经想过用：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        counter = <span class="hljs-number">0</span>        node = head        <span class="hljs-keyword">while</span> node:            node = node.<span class="hljs-built_in">next</span>            counter += <span class="hljs-number">1</span>        node = head        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter-n-<span class="hljs-number">1</span>):            node = node.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><p>会得到如下报错，假如你打印错误的话你会很迷，其实这是第二个测试用例的错误。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212171014954.png" /></p><p>应该写成：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        counter = <span class="hljs-number">0</span>        node = head        <span class="hljs-keyword">while</span> node:            node = node.<span class="hljs-built_in">next</span>            counter += <span class="hljs-number">1</span>        node = head        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(counter-n-<span class="hljs-number">1</span>):            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span>        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><p>第二种是快慢指针的方式：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode(<span class="hljs-number">0</span>, head)        fast = head        slow = dummy        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            fast = fast.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> fast:            fast = fast.<span class="hljs-built_in">next</span>            slow = slow.<span class="hljs-built_in">next</span>        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h2 id="滑动窗口">滑动窗口</h2><h3 id="无重复字符的最长子串">3. 无重复字符的最长子串</h3><p>我们采用队列来实现滑动窗口，遍历字符串，当队里没有当前字符时，当前字符入队；当队里有当前字符时，先统计队列长度进而看情况更新最大子字符串，出队直到队里没有当前字符，再添加当前字符到队尾。考虑到字符串字符都不一样的情况，也就是没有更新最大子字符串长度，遍历完之后还应该更新一次。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        queue = []        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> queue:                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">len</span>(queue))                <span class="hljs-keyword">while</span> queue[<span class="hljs-number">0</span>] != i:                    <span class="hljs-keyword">del</span> queue[<span class="hljs-number">0</span>]                <span class="hljs-keyword">del</span> queue[<span class="hljs-number">0</span>]            queue.append(i)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">len</span>(queue))</code></pre></div><h3 id="字符串的排列">567. 字符串的排列</h3><p><code>s1</code> 排列之一是 <code>s2</code> 的字串，这句话的意思就是<code>s1</code> 的 <code>dict</code> 计数结果和 <code>s2</code> 的某字串<code>dict</code> 计数结果是一样的，那么显然 <code>s2</code>这个字串长度和 <code>s1</code>也就一样了。所以我们可以模拟这个计数过程。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        s1_dict = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s1:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1_dict:                s1_dict[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                s1_dict[i] += <span class="hljs-number">1</span>        s1_len = <span class="hljs-built_in">len</span>(s1)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s2)-s1_len+<span class="hljs-number">1</span>):            subs = s2[i:i+s1_len]            subs_dict = &#123;&#125;            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> subs:                <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> subs_dict:                    subs_dict[v] = <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    subs_dict[v] += <span class="hljs-number">1</span>            flag = <span class="hljs-literal">True</span>            <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> subs_dict.items():                <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1_dict <span class="hljs-keyword">or</span> v != s1_dict[k]:                    flag = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> flag:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>那么上面的代码是很慢的，我们可以发现根本没有必要每次创建<code>dict</code> ，维护一个 <code>dict</code> 就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        s1_len = <span class="hljs-built_in">len</span>(s1)        s2_len = <span class="hljs-built_in">len</span>(s2)        <span class="hljs-keyword">if</span> s1_len &gt; s2_len:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        s1_dict = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s1:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1_dict:                s1_dict[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                s1_dict[i] += <span class="hljs-number">1</span>        s2_dict = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s1_len):            <span class="hljs-keyword">if</span> s2[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict:                s2_dict[s2[i]] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                s2_dict[s2[i]] += <span class="hljs-number">1</span>        flag = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> s1_dict.items():            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict <span class="hljs-keyword">or</span> v != s2_dict[k]:                flag = <span class="hljs-literal">False</span>                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">if</span> flag:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s1_len, s2_len):            s2_dict[s2[i-s1_len]] -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> s2[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict:                s2_dict[s2[i]] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                s2_dict[s2[i]] += <span class="hljs-number">1</span>            flag = <span class="hljs-literal">True</span>            <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> s1_dict.items():                <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s2_dict <span class="hljs-keyword">or</span> v != s2_dict[k]:                    flag = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> flag:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>如果用 collections 的 Counter 看起来就很简洁，但是似乎变慢了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        s1_len = <span class="hljs-built_in">len</span>(s1)        s1_dict = collections.Counter(s1)        s2_dict = collections.Counter(s2[:s1_len])        <span class="hljs-keyword">if</span> s1_dict == s2_dict:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s1_len, <span class="hljs-built_in">len</span>(s2)):            s2_dict[s2[i-s1_len]] -= <span class="hljs-number">1</span>            s2_dict.update(&#123;s2[i]:<span class="hljs-number">1</span>&#125;)            <span class="hljs-keyword">if</span> s1_dict == s2_dict:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h2 id="广度优先搜索-深度优先搜索">广度优先搜索 / 深度优先搜索</h2><h3 id="图像渲染">733. 图像渲染</h3><p>深度优先搜索的递归解法。为了防止无限循环，我们需要一个<code>record</code> 数组来记录已经遍历过的点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">floodFill</span>(<span class="hljs-params">self, image: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sr: <span class="hljs-built_in">int</span>, sc: <span class="hljs-built_in">int</span>, color: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m = <span class="hljs-built_in">len</span>(image)        n = <span class="hljs-built_in">len</span>(image[<span class="hljs-number">0</span>])        record = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_floodFill</span>(<span class="hljs-params">image, sr, sc</span>):            <span class="hljs-keyword">if</span> record[sr][sc]:                temp, image[sr][sc], record[sr][sc] = image[sr][sc], color, <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> image            <span class="hljs-keyword">if</span> sr&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[sr-<span class="hljs-number">1</span>][sc]==temp:                image = _floodFill(image, sr-<span class="hljs-number">1</span>, sc)            <span class="hljs-keyword">if</span> sr+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> image[sr+<span class="hljs-number">1</span>][sc]==temp:                image = _floodFill(image, sr+<span class="hljs-number">1</span>, sc)            <span class="hljs-keyword">if</span> sc&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[sr][sc-<span class="hljs-number">1</span>]==temp:                image = _floodFill(image, sr, sc-<span class="hljs-number">1</span>)            <span class="hljs-keyword">if</span> sc+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> image[sr][sc+<span class="hljs-number">1</span>]==temp:                image = _floodFill(image, sr, sc+<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> image        image = _floodFill(image, sr, sc)        <span class="hljs-keyword">return</span> image</code></pre></div><p>当然我们也可以用栈来实现非递归算法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">floodFill</span>(<span class="hljs-params">self, image: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sr: <span class="hljs-built_in">int</span>, sc: <span class="hljs-built_in">int</span>, color: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m = <span class="hljs-built_in">len</span>(image)        n = <span class="hljs-built_in">len</span>(image[<span class="hljs-number">0</span>])        record = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        stack = [(sr,sc)]        <span class="hljs-keyword">while</span> stack:            i,j = stack.pop()            <span class="hljs-keyword">if</span> record[i][j]:                temp, image[i][j], record[i][j] = image[i][j], color, <span class="hljs-number">0</span>                <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> image[i][j+<span class="hljs-number">1</span>] == temp:                    stack.append((i, j+<span class="hljs-number">1</span>))                <span class="hljs-keyword">if</span> j&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[i][j-<span class="hljs-number">1</span>] == temp:                    stack.append((i, j-<span class="hljs-number">1</span>))                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> image[i+<span class="hljs-number">1</span>][j] == temp:                    stack.append((i+<span class="hljs-number">1</span>, j))                <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> image[i-<span class="hljs-number">1</span>][j] == temp:                    stack.append((i-<span class="hljs-number">1</span>, j))        <span class="hljs-keyword">return</span> image</code></pre></div><h3 id="岛屿的最大面积">695. 岛屿的最大面积</h3><p>与上题相似，我们需要一个 <code>record</code>来记录某个点是否被算过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxAreaOfIsland</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        m = <span class="hljs-built_in">len</span>(grid)        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])        record = [[<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        max_count = <span class="hljs-number">0</span>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):            stack = [(i, j)]            res = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> stack:                i,j = stack.pop()                <span class="hljs-keyword">if</span> record[i][j]:                    record[i][j] = <span class="hljs-number">0</span>                    res += <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> grid[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>:                        stack.append((i, j+<span class="hljs-number">1</span>))                    <span class="hljs-keyword">if</span> j&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> grid[i][j-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>:                        stack.append((i, j-<span class="hljs-number">1</span>))                    <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> grid[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>:                        stack.append((i+<span class="hljs-number">1</span>, j))                    <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> grid[i-<span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>:                        stack.append((i-<span class="hljs-number">1</span>, j))            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:                    max_count = <span class="hljs-built_in">max</span>(max_count, dfs(i, j))        <span class="hljs-keyword">return</span> max_count</code></pre></div><h3 id="合并二叉树">617. 合并二叉树</h3><p>深度优先搜索，递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1: <span class="hljs-type">Optional</span>[TreeNode], root2: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">and</span> root2:            root1.val += root2.val            root1.left = self.mergeTrees(root1.left, root2.left)            root1.right = self.mergeTrees(root1.right, root2.right)            <span class="hljs-keyword">return</span> root1        <span class="hljs-keyword">return</span> root1 <span class="hljs-keyword">or</span> root2</code></pre></div><p>也可以不用递归，这时我们需要栈。假设我们的目的是把 <code>root2</code>合并到 <code>root1</code> 里，我们会有如下情况：</p><ul><li>首先我们需要出栈拿到 <code>root1</code> , <code>root2</code>的节点。</li><li>将 <code>root1</code> 和 <code>root2</code>的值相加，这里我们需要保证除非根节点是空的，否则不会遇到<code>root1</code> 或 <code>root2</code> 为空的情况。</li><li>如果 <code>root1</code> 和 <code>root2</code>都有右子树或都有左子树，则我们按顺序进行压栈。</li><li>如果 <code>root1</code> 没有右子树或者没有左子树而<code>root2</code> 有，只需要把 <code>root2</code>的接过来，不需要进栈操作。</li><li>剩余情况我们都不用做处理。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1: <span class="hljs-type">Optional</span>[TreeNode], root2: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> root1 <span class="hljs-keyword">or</span> root2        stack = [(root1, root2)]        <span class="hljs-keyword">while</span> stack:            t1, t2 = stack.pop()            <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">and</span> t2:                t1.val += t2.val            <span class="hljs-keyword">if</span> t1.right <span class="hljs-keyword">and</span> t2.right:                stack.append((t1.right, t2.right))            <span class="hljs-keyword">elif</span> t1.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:                t1.right = t2.right            <span class="hljs-keyword">if</span> t1.left <span class="hljs-keyword">and</span> t2.left:                stack.append((t1.left, t2.left))            <span class="hljs-keyword">elif</span> t1.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:                t1.left = t2.left        <span class="hljs-keyword">return</span> root1</code></pre></div><p>广度优先搜索。其实改动非常小，因为这道题本身就跟顺序没什么关系。把上面代码的<code>pop()</code> （出栈）换成 <code>pop(0)</code>（出队）就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1: <span class="hljs-type">Optional</span>[TreeNode], root2: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> root1 <span class="hljs-keyword">or</span> root2        queue = [(root1, root2)]        <span class="hljs-keyword">while</span> queue:            t1, t2 = queue.pop(<span class="hljs-number">0</span>)            <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">and</span> t2:                t1.val += t2.val            <span class="hljs-keyword">if</span> t1.right <span class="hljs-keyword">and</span> t2.right:                queue.append((t1.right, t2.right))            <span class="hljs-keyword">elif</span> t1.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:                t1.right = t2.right            <span class="hljs-keyword">if</span> t1.left <span class="hljs-keyword">and</span> t2.left:                queue.append((t1.left, t2.left))            <span class="hljs-keyword">elif</span> t1.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:                t1.left = t2.left        <span class="hljs-keyword">return</span> root1</code></pre></div><h3 id="填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针</h3><p>这个填充其实是父节点在填充子节点的指针。分为左右子节点两种情况：</p><ul><li>左子节点，<code>next</code>指针指向位置其实就是右子节点的位置。</li><li>右子节点，<code>next</code> 指针指向位置是此节点 <code>next</code>指针指向节点的左子节点。</li></ul><p>想明白这个，用递归实现就很简单了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[Node]</span>) -&gt; <span class="hljs-type">Optional</span>[Node]:        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">and</span> root.left <span class="hljs-keyword">and</span> root.right:            root.left.<span class="hljs-built_in">next</span> = root.right            <span class="hljs-keyword">if</span> root.<span class="hljs-built_in">next</span>:                root.right.<span class="hljs-built_in">next</span> = root.<span class="hljs-built_in">next</span>.left            root.left = self.connect(root.left)            root.right = self.connect(root.right)        <span class="hljs-keyword">return</span> root</code></pre></div><p>对于非递归来讲，采用广度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[Node]</span>) -&gt; <span class="hljs-type">Optional</span>[Node]:        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> root        queue = [root]        <span class="hljs-keyword">while</span> queue:            t = queue.pop(<span class="hljs-number">0</span>)            <span class="hljs-keyword">if</span> t.left <span class="hljs-keyword">and</span> t.right:                t.left.<span class="hljs-built_in">next</span> = t.right                <span class="hljs-keyword">if</span> t.<span class="hljs-built_in">next</span>:                    t.right.<span class="hljs-built_in">next</span> = t.<span class="hljs-built_in">next</span>.left                queue.append(t.left)                queue.append(t.right)        <span class="hljs-keyword">return</span> root</code></pre></div><p>也可以一直找最左节点与 <code>next</code> 指针：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[Node]</span>) -&gt; <span class="hljs-type">Optional</span>[Node]:        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> root        leftmost = root        <span class="hljs-keyword">while</span> leftmost.left:            node = leftmost            <span class="hljs-keyword">while</span> node:                node.left.<span class="hljs-built_in">next</span> = node.right                <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>:                    node.right.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.left                node = node.<span class="hljs-built_in">next</span>            leftmost = leftmost.left        <span class="hljs-keyword">return</span> root</code></pre></div><h3 id="矩阵">542. 01 矩阵</h3><p>这道题第一眼应该是一道广度优先搜索的题目，然而居然超时了。</p><p>然后又想到一招，先记录 0 的位置，之后直接遍历距离 0的最小值，毕竟这个距离可以用 <code>abs(x1-x0)+abs(y1-y0)</code>得到，比上一个好像快了一点，但是依然超时。</p><p>然后可以转换一下，从找每个点到 0 的距离变成 0到每个点的距离，也就是所谓的多源广度优先搜索，把 0看作一个整体，首先找距它们 0 个位置的点（自身），再找距它们 1个位置的点，以此类推直到找到所有点。然后我成功 AC 了一次。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m = <span class="hljs-built_in">len</span>(mat)        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        res = [[-<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        queue = []        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mat[r][c]:                    queue.append((r, c, <span class="hljs-number">0</span>))        <span class="hljs-keyword">while</span> queue:            i, j, count = queue.pop(<span class="hljs-number">0</span>)            <span class="hljs-keyword">if</span> res[i][j] == -<span class="hljs-number">1</span>:                res[i][j] = count                <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> res[ni][nj] == -<span class="hljs-number">1</span>:                        queue.append((ni, nj, count+<span class="hljs-number">1</span>))        <span class="hljs-keyword">return</span> res</code></pre></div><p>这个通过时间显然是哪里有问题。然后打印了一下循环的信息，我发现这里有个问题，我用<code>res</code> 去分辨哪些点的值被搜索过，而 <code>res</code>是在出队的时候更改搜索信息的，因此，同一层（离多个 0同一距离）的点可能会被重复添加，也就是说除了 <code>res</code>之外，我们最好再来一个记录值是否被搜索过的，比如 <code>set</code> ？</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m = <span class="hljs-built_in">len</span>(mat)        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        queue = []        searched = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mat[r][c]:                    queue.append((r, c, <span class="hljs-number">0</span>))                    searched.add((r,c))        <span class="hljs-keyword">while</span> queue:            i, j, count = queue.pop(<span class="hljs-number">0</span>)            <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> (ni, nj) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:                    res[ni][nj] = count+<span class="hljs-number">1</span>                    queue.append((ni, nj, count+<span class="hljs-number">1</span>))                    searched.add((ni, nj))        <span class="hljs-keyword">return</span> res</code></pre></div><p>优化一下代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m = <span class="hljs-built_in">len</span>(mat)        n = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        queue = [(r,c) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> mat[r][c]==<span class="hljs-number">0</span>]        searched = <span class="hljs-built_in">set</span>(queue)        <span class="hljs-keyword">while</span> queue:            i, j = queue.pop(<span class="hljs-number">0</span>)            <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> (ni, nj) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:                    res[ni][nj] = res[i][j]+<span class="hljs-number">1</span>                    queue.append((ni, nj))                    searched.add((ni, nj))        <span class="hljs-keyword">return</span> res</code></pre></div><p>仍然很慢，难道是 <code>list</code> 的问题？数据量大之后<code>list</code> 不够高效？把 <code>list</code> 换成<code>collections.deque()</code> 双端队列。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m, n = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        queue = collections.deque()        searched = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        res = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:                    queue.append((i, j))                    searched[i][j] = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> queue:            i, j = queue.popleft()            <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[ni][nj]:                    res[ni][nj] = res[i][j]+<span class="hljs-number">1</span>                    queue.append((ni, nj))                    searched[ni][nj] = <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>还真是，应该是 <code>list.pop(0)</code> 这个方法的事件复杂度是<code>O(n)</code> 。</p><p>看了一下官解里提的动态规划方法，原理。</p><p>状态转移方程： <span class="math display">\[f(i,j)=\begin{cases}1+min(f(i-1,j), f(i+1,j), f(i,j-1),f(i,j+1))\ \ \ \ if\ (i,j)=1\\0\ \ \ \ if\ (i,j)=0\end{cases}\]</span> 这个是很好理解的，毕竟一个点可以由他上下左右四个点离 0最近的位置决定。</p><p>但是 <code>for i in range(m) for j in range(n)</code>这个循环相当于是从左上开始往右下遍历，也就是说这次遍历只会包含<code>f(i-1,j), f(i,j-1)</code>两个点的真实值，所以还需要一次从右下角开始的遍历，稍有不同的是右下角遍历的时候还可以同时处理下左上角遍历时的结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        m, n = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])        res = [[<span class="hljs-number">2e4</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:                    res[i][j] = <span class="hljs-number">0</span>                <span class="hljs-keyword">else</span>:                    top, left = <span class="hljs-number">1e4</span>, <span class="hljs-number">1e4</span>                    <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span>: top = res[i-<span class="hljs-number">1</span>][j]                    <span class="hljs-keyword">if</span> j&gt;<span class="hljs-number">0</span>: left = res[i][j-<span class="hljs-number">1</span>]                    res[i][j] = <span class="hljs-built_in">min</span>(top+<span class="hljs-number">1</span>, left+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:                    res[i][j] = <span class="hljs-number">0</span>                <span class="hljs-keyword">else</span>:                    bottom, right = <span class="hljs-number">1e4</span>, <span class="hljs-number">1e4</span>                    <span class="hljs-keyword">if</span> i&lt;m-<span class="hljs-number">1</span>: bottom = res[i+<span class="hljs-number">1</span>][j]                    <span class="hljs-keyword">if</span> j&lt;n-<span class="hljs-number">1</span>: right = res[i][j+<span class="hljs-number">1</span>]                    res[i][j] = <span class="hljs-built_in">min</span>(res[i][j], bottom+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="腐烂的橘子">994. 腐烂的橘子</h3><p>方法一，模拟橘子腐烂的过程，每分钟遍历一次，这里要注意在这分钟腐烂的橘子这分钟不会影响到其他橘子。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orangesRotting</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])        fresh = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:                    fresh += <span class="hljs-number">1</span>        minute = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> fresh != <span class="hljs-number">0</span>:            minute += <span class="hljs-number">1</span>            temp_set = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                    <span class="hljs-keyword">if</span> grid[i][j] &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (i,j) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> temp_set:                        <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>, j), (i+<span class="hljs-number">1</span>, j), (i, j-<span class="hljs-number">1</span>), (i, j+<span class="hljs-number">1</span>)):                            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=ni&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=nj&lt;n <span class="hljs-keyword">and</span> grid[ni][nj] == <span class="hljs-number">1</span>:                                grid[ni][nj] = <span class="hljs-number">2</span>                                temp_set.add((ni,nj))                                fresh -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp_set)==<span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> minute</code></pre></div><p>方法二，腐烂橘子的广度优先搜索，这里需要注意的是这分钟能感染的橘子下分钟不能再感染了（因为周围被感染过）。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orangesRotting</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])        fresh = <span class="hljs-number">0</span>        queue = collections.deque()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:                    fresh += <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> grid[i][j] == <span class="hljs-number">2</span>:                    queue.append((i,j))        minute = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> fresh != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> queue:            minute += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                i, j = queue.popleft()                <span class="hljs-keyword">for</span> ni, nj <span class="hljs-keyword">in</span> ((i-<span class="hljs-number">1</span>,j), (i+<span class="hljs-number">1</span>,j), (i,j-<span class="hljs-number">1</span>), (i,j+<span class="hljs-number">1</span>)):                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; n <span class="hljs-keyword">and</span> grid[ni][nj] == <span class="hljs-number">1</span>:                        grid[ni][nj] = <span class="hljs-number">2</span>                        queue.append((ni, nj))                        fresh -= <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> fresh != <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> minute</code></pre></div><h2 id="递归-回溯">递归 / 回溯</h2><h3 id="合并两个有序链表">21. 合并两个有序链表</h3><p>这道题用递归其实就 4 种情况：</p><ul><li><code>list1</code> 节点为空 - 返回 <code>list2</code></li><li><code>list2</code> 节点为空 - 返回 <code>list1</code></li><li>都非空 <code>list1</code> 节点值小于等于 <code>list2</code> -递归，返回 <code>list1</code> 。</li><li>都非空 <code>list2</code> 节点值小于 <code>list1</code> - 递归，返回<code>list2</code> 。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> list2        <span class="hljs-keyword">elif</span> list2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> list1        <span class="hljs-keyword">elif</span> list1.val &lt;= list2.val:            list1.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1.<span class="hljs-built_in">next</span>, list2)            <span class="hljs-keyword">return</span> list1        <span class="hljs-keyword">else</span>:            list2.<span class="hljs-built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="hljs-built_in">next</span>)            <span class="hljs-keyword">return</span> list2</code></pre></div><p>非递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        pre = dummy        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:                pre.<span class="hljs-built_in">next</span> = list1                list1 = list1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                pre.<span class="hljs-built_in">next</span> = list2                list2 = list2.<span class="hljs-built_in">next</span>            pre = pre.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list1:            pre.<span class="hljs-built_in">next</span> = list2        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list2:            pre.<span class="hljs-built_in">next</span> = list1        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="反转链表">206. 反转链表</h3><p>递归。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> head        cur = self.reverseList(head.<span class="hljs-built_in">next</span>)        head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> cur</code></pre></div><p>非递归。可以用栈去遍历节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        stack = []        <span class="hljs-keyword">while</span> head:            temp = head.<span class="hljs-built_in">next</span>            head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>            stack.append(head)            head = temp        pre = dummy        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            pre.<span class="hljs-built_in">next</span> = node            pre = pre.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><p>非递归，也能用三指针去遍历，因为对一个节点的 <code>next</code>指针逆序与他前后节点和自身都有关系。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        pre = <span class="hljs-literal">None</span>        dummy = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> head:            temp = head.<span class="hljs-built_in">next</span>            dummy = head            head.<span class="hljs-built_in">next</span> = pre            head = temp            pre = dummy        <span class="hljs-keyword">return</span> dummy</code></pre></div><h3 id="组合">77. 组合</h3><p>Python 里的 <code>itertools.combinations()</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(itertools.combinations(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>), k))</code></pre></div><p>从 <ahref="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录- 回溯算法</a> 前辈这里学习的回溯算法。</p><p>相当于把从 n 个数里找满足条件的 k 个数分解成 <code>for</code>循环（横向遍历 n ）与递归（纵向遍历 <code>k</code> ）这样的结构。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        path = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinations</span>(<span class="hljs-params">n, k, i</span>):            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:                res.append(path[:])                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n+<span class="hljs-number">1</span>):                path.append(j)                combinations(n, k, j+<span class="hljs-number">1</span>)                path.pop()        combinations(n, k, <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><p>上面的代码并不快，这就引申出了剪枝这个概念。</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212230903768.png" /></p><p>有的步骤是多余的，在于取完 x 个数之后，剩下数量必须大于等于 k-x个，否则没有意义。</p><p>这个 x 就是 path 的元素个数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        path = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinations</span>(<span class="hljs-params">n, k, i</span>):            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:                res.append(path[:])                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n-(k-<span class="hljs-built_in">len</span>(path))+<span class="hljs-number">2</span>):                path.append(j)                combinations(n, k, j+<span class="hljs-number">1</span>)                path.pop()        combinations(n, k, <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><p>其实这个这个递归函数不需要传 n，k，我们稍微简化一下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        path = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinations</span>(<span class="hljs-params">i</span>):            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:                res.append(path[:])                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n-(k-<span class="hljs-built_in">len</span>(path))+<span class="hljs-number">2</span>):                path.append(j)                combinations(j+<span class="hljs-number">1</span>)                path.pop()        combinations(<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="全排列">46. 全排列</h3><p>Python 里的 <code>itertools.permutations()</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(itertools.permutations(nums, <span class="hljs-built_in">len</span>(nums)))</code></pre></div><p>这道题的树图我们可以画出：</p><p><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202212230951840.png" /></p><p>我们可以用一个 <code>used</code>数组来记录哪些元素被使用过，但其实，使用过的元素已经在 <code>path</code>里了，因此也不需要记录。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        path = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">permutations</span>():            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums):                res.append(path[:])                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> path:                    path.append(i)                    permutations()                    path.pop()                permutations()        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="字母大小写全排列">784. 字母大小写全排列</h3><p>这道题其实是求 0（设为小写），1（设为大写）可重复取数共取 k（ k为字符串种字母的数量）个数的全排列。</p><p>我们可以按照上面的老套路，不过既然可以重复取数就没有限制条件了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        s_lst = <span class="hljs-built_in">list</span>(s)        letter_index = []        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s_lst):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v.isdigit():                letter_index.append(i)        res = []        path = []        <span class="hljs-keyword">def</span> <span class="hljs-title function_">permutations</span>():            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(letter_index):                res.append(path[:])                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>):                path.append(i)                permutation()                path.pop()        permutation()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(res[i], letter_index):                <span class="hljs-keyword">if</span> j[<span class="hljs-number">0</span>]:                    s_lst[j[<span class="hljs-number">1</span>]] = s_lst[j[<span class="hljs-number">1</span>]].upper()                <span class="hljs-keyword">else</span>:                    s_lst[j[<span class="hljs-number">1</span>]] = s_lst[j[<span class="hljs-number">1</span>]].lower()            res[i] = <span class="hljs-string">&#x27;&#x27;</span>.join(s_lst)        <span class="hljs-keyword">return</span> res</code></pre></div><p>Python 的一行代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-string">&#x27;&#x27;</span>.join, itertools.product(*<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:(x.lower(), x.upper()) <span class="hljs-keyword">if</span> x.isalpha() <span class="hljs-keyword">else</span> x, s))))</code></pre></div><h2 id="动态规划">动态规划</h2><h3 id="爬楼梯">70. 爬楼梯</h3><p>状态转移方程： <span class="math display">\[dp[i]=\begin{cases}dp[i-1]+dp[i-2]\ \ \ \ if\ i&gt;2\\i\ \ \ \ if\ i=1\or i=2\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>        dp = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n):            dp.append(dp[i-<span class="hljs-number">1</span>]+dp[i-<span class="hljs-number">2</span>])        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="打家劫舍">198. 打家劫舍</h3><p>状态转移方程： <span class="math display">\[dp[i]=\begin{cases}max(dp[i-2]+nums[i], dp[i-1])\ \ \ \ if\ i&gt;2\\max(nums[i], nums[i-1])\ \ \ \ if\ i=2\\nums[i]\ \ \ \ if\ i=1\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        n = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp = [nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):            dp.append(<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">2</span>]+nums[i], dp[i-<span class="hljs-number">1</span>]))        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="三角形最小路径和">120. 三角形最小路径和</h3><p>状态转移方程 <span class="math display">\[\begin{cases}min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]\ \ \ \ if\ i&gt;=1\ and\i&gt;j&gt;=1\\dp[i-1][j]+triangle[i][j]\ \ \ \ if\ i&gt;=1\ and\ j=0\\dp[i-1][j-1]+triangle[i][j]\ \ \ \ if\ i&gt;=1\ and\ i=j\\triangle[i][j]\ \ \ \ if\ i=0\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotal</span>(<span class="hljs-params">self, triangle: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        n = <span class="hljs-built_in">len</span>(triangle)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]        dp = [[triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):            temp = []            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> j==<span class="hljs-number">0</span>:                    temp.append(dp[i-<span class="hljs-number">1</span>][j]+triangle[i][j])                <span class="hljs-keyword">elif</span> j==i:                    temp.append(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+triangle[i][j])                <span class="hljs-keyword">else</span>:                    temp.append(<span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])+triangle[i][j])            dp.append(temp)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[-<span class="hljs-number">1</span>])</code></pre></div><h2 id="位运算">位运算</h2><h3 id="的幂">231. 2 的幂</h3><p>2 的幂首先是大于 0 的，其次在二进制表示中只有 1 个 1 ，所以我们可以用<code>n&amp;(n-1)</code> 把最后一个 1 消去看是否结果为 0 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n&amp;(n-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div><p>另外 <span class="math inline">\(2^{31}\)</span> 去取余任何 2的幂结果应该都为 0 ，所以也可以利用这个性质。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">31</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="位1的个数">191. 位1的个数</h3><p>跟上题一样，用 <code>n&amp;(n-1)</code> 的方式统计计数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            n &amp;= n-<span class="hljs-number">1</span>            res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="颠倒二进制位">190. 颠倒二进制位</h3><p>使用字符串去操作。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>(n)[:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;0&#x27;</span>), <span class="hljs-number">2</span>))</code></pre></div><p>逐位颠倒累加。原理有点类似与比如一个字符串 <code>1234</code> ，要转成10 进制数，如果要从前往后遍历的话，每一步都是<code>res = res*10 + string[i]</code> ，相当于经历 0+1， 10+2， 120+3，1230+4 这个过程。这里可以累加 32 次。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):            res = (res&lt;&lt;<span class="hljs-number">1</span>)|(n&amp;<span class="hljs-number">1</span>)            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="只出现一次的数字">136. 只出现一次的数字</h3><p>这道题主要是位运算 异或这个操作的理解，将所有元素做异或运算，出现两次的元素异或结果为 0，最后得到的就是只出现一次的数字。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            res = res^i        <span class="hljs-keyword">return</span> res</code></pre></div><p>或者用 <code>reduce</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y:x^y, nums)</code></pre></div><h1 id="算法基础">算法基础</h1><h2 id="二分查找-2">二分查找</h2><h3 id="在排序数组中查找元素的第一个和最后一个位置">34.在排序数组中查找元素的第一个和最后一个位置</h3><p>用二分法模拟过程就行。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        nums_len = <span class="hljs-built_in">len</span>(nums)        left = <span class="hljs-number">0</span>        right = nums_len - <span class="hljs-number">1</span>        start = -<span class="hljs-number">1</span>        end = -<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left+right) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == target:                t_s = mid                t_e = mid                <span class="hljs-keyword">while</span> t_s&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[t_s] == target:                    t_s -= <span class="hljs-number">1</span>                <span class="hljs-keyword">while</span> t_e&lt;nums_len <span class="hljs-keyword">and</span> nums[t_e] == target:                    t_e += <span class="hljs-number">1</span>                start = t_s + <span class="hljs-number">1</span>                end = t_e - <span class="hljs-number">1</span>                <span class="hljs-keyword">return</span> [start, end]            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid - <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                left = mid + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> [start, end]</code></pre></div><h3 id="搜索旋转排序数组">33. 搜索旋转排序数组</h3><p>第一种解法是暴力。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = -<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> v == target:                res = i                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>第二种解法，先用二分法找出 <code>k</code> 值，再用二分法找出<code>target</code> 目标值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>        k = <span class="hljs-number">0</span>        nums_len = <span class="hljs-built_in">len</span>(nums)        l = <span class="hljs-number">0</span>        r = nums_len - <span class="hljs-number">1</span>        lv = nums[l]        rv = nums[r]        <span class="hljs-keyword">while</span> r != l+<span class="hljs-number">1</span>:            mid = (l+r) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &gt; lv:                l = mid            <span class="hljs-keyword">elif</span> nums[mid] &lt; rv:                r = mid        k = r <span class="hljs-keyword">if</span> nums[r]&lt;nums[l] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        nums = nums[k:]+nums[:k] <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> nums        l = <span class="hljs-number">0</span>        r = nums_len - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l&lt;=r:            mid = (l+r) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == target:                res = mid + k <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> mid                <span class="hljs-keyword">if</span> res &gt;= nums_len:                    res -= nums_len                <span class="hljs-keyword">return</span> res            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                r = mid - <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                l = mid + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h3 id="搜索二维矩阵">74. 搜索二维矩阵</h3><p>矩阵的二分法，重点在于建立 <code>row, col</code> 与<code>index</code> 的对应关系。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        m = <span class="hljs-built_in">len</span>(matrix)        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        l = <span class="hljs-number">0</span>        r = m*n-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l &lt;= r:            mid = (l+r) // <span class="hljs-number">2</span>            row = mid//n            col = mid%n            <span class="hljs-keyword">if</span> matrix[row][col] == target:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">elif</span> matrix[row][col] &gt; target:                r = mid - <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                l = mid + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h3><p>其实相当于 <a href="###33.%20搜索旋转排序数组">33.搜索旋转排序数组</a> 的寻找 <code>k</code> 值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        k = <span class="hljs-number">0</span>        nums_len = <span class="hljs-built_in">len</span>(nums)        l = <span class="hljs-number">0</span>        r = nums_len - <span class="hljs-number">1</span>        lv = nums[l]        rv = nums[r]        <span class="hljs-keyword">while</span> r != l+<span class="hljs-number">1</span>:            mid = (l+r) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &gt; lv:                l = mid            <span class="hljs-keyword">elif</span> nums[mid] &lt; rv:                r = mid        k = r <span class="hljs-keyword">if</span> nums[r]&lt;nums[l] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> nums[k]</code></pre></div><h3 id="寻找峰值">162. 寻找峰值</h3><p>可以理解为找函数 <code>y=nums[x]</code>的极值点。我们采用二分搜索的策略，为了避免极值点在边界，我们左右两端各添加一个<code>float('-inf')</code>负无穷。我们可以通过左右指针循环查找，这里的重点是控制指针的变化。</p><ul><li>当 <code>mid</code> 比 <code>mid-1</code> , <code>mid+1</code>都大时，返回它（当然由于预处理，应该返回 <code>mid-1</code> ）。</li><li>如果 <code>mid-1</code> , <code>mid</code> , <code>mid+1</code>呈现单调递增趋势，说明极值点在右边。</li><li>否则说明极值点在左边。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)] + nums + [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)]        l, r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l&lt;=r:            mid = (l+r) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid]&gt;nums[mid-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>]:                <span class="hljs-keyword">return</span> mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums[mid+<span class="hljs-number">1</span>]&gt;=nums[mid]&gt;=nums[mid-<span class="hljs-number">1</span>]:                l = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r = mid - <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h2 id="双指针-1">双指针</h2><h3 id="删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素II</h3><p>数据结构里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        dummy = ListNode()        node = dummy        <span class="hljs-keyword">while</span> head:            temp = head.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp <span class="hljs-keyword">or</span> temp.val != head.val:                node.<span class="hljs-built_in">next</span> = head                head = head.<span class="hljs-built_in">next</span>                node = node.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">while</span> temp <span class="hljs-keyword">and</span> temp.val == head.val:                    temp = temp.<span class="hljs-built_in">next</span>                head = temp        node.<span class="hljs-built_in">next</span> = head        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span></code></pre></div><h3 id="三数之和">15. 三数之和</h3><p>数据结构里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        nums = <span class="hljs-built_in">sorted</span>(nums)        nums_len = <span class="hljs-built_in">len</span>(nums)        res = []        <span class="hljs-keyword">if</span> nums_len &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums[-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len-<span class="hljs-number">2</span>):            <span class="hljs-keyword">if</span> nums[i]&gt;<span class="hljs-number">0</span>:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:                <span class="hljs-keyword">continue</span>            left = i+<span class="hljs-number">1</span>            right = nums_len-<span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> left&lt;right:                temp_sum = nums[i]+nums[left]+nums[right]                <span class="hljs-keyword">if</span> temp_sum &gt; <span class="hljs-number">0</span>:                    right -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> temp_sum &lt; <span class="hljs-number">0</span>:                    left += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res.append([nums[i], nums[left], nums[right]])                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[left] == nums[left+<span class="hljs-number">1</span>]: left += <span class="hljs-number">1</span>                    <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> nums[right] == nums[right-<span class="hljs-number">1</span>]: right -= <span class="hljs-number">1</span>                    left += <span class="hljs-number">1</span>                    right -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="比较含退格的字符串">844. 比较含退格的字符串</h3><p>用栈模拟整个过程，遇到 <code>#</code>时，如果栈非空就出栈，否则不管，如果遇到其它字符则进栈。最后比较两个栈是否一致。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backspaceCompare</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        stack_s = []        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:                <span class="hljs-keyword">if</span> stack_s:                    stack_s.pop()            <span class="hljs-keyword">else</span>:                stack_s.append(c)        stack_t = []        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:                <span class="hljs-keyword">if</span> stack_t:                    stack_t.pop()            <span class="hljs-keyword">else</span>:                stack_t.append(c)        <span class="hljs-keyword">return</span> stack_s == stack_t</code></pre></div><h3 id="区间列表的交集">986. 区间列表的交集</h3><p>用双指针分别控制当前遍历的 A、B两个列表的区间。如果区间不相交，将靠后区间的指针移到下个区间。如果区间相交，那么相交起始位置就是更大的<code>start</code> ，结束位置是更小的 <code>end</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intervalIntersection</span>(<span class="hljs-params">self, firstList: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], secondList: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        firstList_len = <span class="hljs-built_in">len</span>(firstList)        secondList_len = <span class="hljs-built_in">len</span>(secondList)        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        res = []        <span class="hljs-keyword">while</span> l&lt;firstList_len <span class="hljs-keyword">and</span> r&lt;secondList_len:            <span class="hljs-keyword">if</span> firstList[l][<span class="hljs-number">0</span>] &gt; secondList[r][<span class="hljs-number">1</span>]:                r += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> secondList[r][<span class="hljs-number">0</span>] &gt; firstList[l][<span class="hljs-number">1</span>]:                l += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            start = <span class="hljs-built_in">max</span>(firstList[l][<span class="hljs-number">0</span>], secondList[r][<span class="hljs-number">0</span>])            <span class="hljs-keyword">if</span> firstList[l][<span class="hljs-number">1</span>] &lt; secondList[r][<span class="hljs-number">1</span>]:                end = firstList[l][<span class="hljs-number">1</span>]                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                end = secondList[r][<span class="hljs-number">1</span>]                r += <span class="hljs-number">1</span>            res.append([start, end])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="盛最多水的容器">11. 盛最多水的容器</h3><p>双指针逐渐向中间移动，优先移动高度更低的指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        height_len = <span class="hljs-built_in">len</span>(height)        l, r = <span class="hljs-number">0</span>, height_len-<span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l&lt;r:            <span class="hljs-keyword">if</span> height[l] &lt;= height[r]:                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[l])                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[r])                r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>这道题其实有一个可以优化的地方，当移动到某个程度时就不需要移动了，因为有个理论最大值，面积等于两个线中短线的高度乘两线距离，如果当前面积比理论最大高度乘两线距离还大，就可以直接返回结果了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        height_len = <span class="hljs-built_in">len</span>(height)        height_max = <span class="hljs-built_in">max</span>(height)        l, r = <span class="hljs-number">0</span>, height_len-<span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l&lt;r:            <span class="hljs-keyword">if</span> height[l] &lt;= height[r]:                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[l])                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                res = <span class="hljs-built_in">max</span>(res, (r-l)*height[r])                r -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> res &gt;= height_max*(r-l):<span class="hljs-comment"># 剪枝</span>                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="滑动窗口-1">滑动窗口</h2><h3 id="找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h3><p>在编程能力里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        s_len = <span class="hljs-built_in">len</span>(s)        l, r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(p)        p_count = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> p:            p_count[<span class="hljs-built_in">ord</span>(t)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>        count = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> s[l:r]:            count[<span class="hljs-built_in">ord</span>(t)-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>        res = []        <span class="hljs-keyword">while</span> r&lt;s_len+<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> count == p_count:                res.append(l)            <span class="hljs-keyword">if</span> r&lt;s_len:                count[<span class="hljs-built_in">ord</span>(s[l])-<span class="hljs-number">97</span>] -= <span class="hljs-number">1</span>                count[<span class="hljs-built_in">ord</span>(s[r])-<span class="hljs-number">97</span>] += <span class="hljs-number">1</span>            l += <span class="hljs-number">1</span>            r += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="乘积小于-k-的子数组">713. 乘积小于 K 的子数组</h3><p>在编程能力里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSubarrayProductLessThanK</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        res, left, temp = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> right, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            temp *= value            <span class="hljs-keyword">while</span> temp&gt;=k:                temp //= nums[left]                left += <span class="hljs-number">1</span>            res += right-left+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="长度最小的子数组">209. 长度最小的子数组</h3><p>与上题有点相似，总的来说也属于双指针问题。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_sum = nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> nums_sum &gt;= target:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        res, nums_len = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>), <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> r&lt;nums_len:            <span class="hljs-keyword">if</span> nums_sum&lt;target:                r += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> r&lt;nums_len:                    nums_sum += nums[r]            <span class="hljs-keyword">else</span>:                res = <span class="hljs-built_in">min</span>(res, r-l+<span class="hljs-number">1</span>)                nums_sum -= nums[l]                l += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></code></pre></div><p>或者更 Pythonic 一点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res, left, temp_sum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> right, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            temp_sum += value            <span class="hljs-keyword">while</span> temp_sum &gt;= target:                temp_sum -= nums[left]                res = <span class="hljs-built_in">min</span>(res, right-left+<span class="hljs-number">1</span>)                left += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></code></pre></div><h2 id="广度优先搜索-深度优先搜索-1">广度优先搜索 / 深度优先搜索</h2><h3 id="岛屿数量">200. 岛屿数量</h3><p>这道题这个字符串是真有点坑，实际是个简单的搜索，深度优先搜索或广度优先搜索都可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        m = <span class="hljs-built_in">len</span>(grid)        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])        searched = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> grid[row][col]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[row][col]:                    res += <span class="hljs-number">1</span>                    stack = [(row, col)]                    <span class="hljs-keyword">while</span> stack:                        r, c = stack.pop()                        searched[r][c] = <span class="hljs-number">1</span>                        <span class="hljs-keyword">if</span> r&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> grid[r-<span class="hljs-number">1</span>][c]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r-<span class="hljs-number">1</span>][c]: stack.append((r-<span class="hljs-number">1</span>, c))                        <span class="hljs-keyword">if</span> r+<span class="hljs-number">1</span>&lt;m <span class="hljs-keyword">and</span> grid[r+<span class="hljs-number">1</span>][c]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r+<span class="hljs-number">1</span>][c]: stack.append((r+<span class="hljs-number">1</span>, c))                        <span class="hljs-keyword">if</span> c&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> grid[r][c-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r][c-<span class="hljs-number">1</span>]: stack.append((r, c-<span class="hljs-number">1</span>))                        <span class="hljs-keyword">if</span> c+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> grid[r][c+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r][c+<span class="hljs-number">1</span>]: stack.append((r, c+<span class="hljs-number">1</span>))        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="省份数量">547. 省份数量</h3><p>这个属于是换了一种图存储方式的搜索，本质还是深度优先搜索或广度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        n = <span class="hljs-built_in">len</span>(isConnected)        searched = [<span class="hljs-number">0</span>]*n        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">if</span> searched[l]:                <span class="hljs-keyword">continue</span>            res += <span class="hljs-number">1</span>            searched[l] = <span class="hljs-number">1</span>            stack = [l]            <span class="hljs-keyword">while</span> stack:                left = stack.pop()                <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                    <span class="hljs-keyword">if</span> isConnected[left][right] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[right]:                        searched[right] = <span class="hljs-number">1</span>                        stack.append(right)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="填充每个节点的下一个右侧节点指针-ii">117.填充每个节点的下一个右侧节点指针 II</h3><p>二叉树的层次遍历思想，首先想到的是用一个 <code>list</code>来存储每一层的节点，第一个节点指向第二个节点，第二个节点指向第三个节点，依次类推，最后一个节点指向<code>None</code> 不用管。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> root        queue = [root]        <span class="hljs-keyword">while</span> queue:            temp = []            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.pop(<span class="hljs-number">0</span>)                temp.append(node)                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp)-<span class="hljs-number">1</span>):                temp[i].<span class="hljs-built_in">next</span> = temp[i+<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> root</code></pre></div><p>上面是很有优化空间的，实际上在出队的时候就可以判断有没有节点的<code>next</code> 指向出队那个节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> root        queue = [root]        <span class="hljs-keyword">while</span> queue:            temp = <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):                node = queue.pop(<span class="hljs-number">0</span>)                <span class="hljs-keyword">if</span> temp:                    temp.<span class="hljs-built_in">next</span> = node                temp = node                <span class="hljs-keyword">if</span> node.left: queue.append(node.left)                <span class="hljs-keyword">if</span> node.right: queue.append(node.right)        <span class="hljs-keyword">return</span> root</code></pre></div><h3 id="另一棵树的子树">572. 另一棵树的子树</h3><p>一棵树是另一棵树的子树，满足以下三种情况之一：</p><ul><li>两棵树相同。</li><li>这棵树是另一棵树左子树的子树。</li><li>这棵树是另一棵树右子树的子树。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubtree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], subRoot: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSametree</span>(<span class="hljs-params">roota, rootb</span>):            <span class="hljs-keyword">if</span> roota <span class="hljs-keyword">and</span> rootb:                <span class="hljs-keyword">return</span> roota.val == rootb.val <span class="hljs-keyword">and</span> isSametree(roota.left, rootb.left) <span class="hljs-keyword">and</span> isSametree(roota.right, rootb.right)            <span class="hljs-keyword">if</span> roota <span class="hljs-keyword">or</span> rootb:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (root <span class="hljs-keyword">or</span> subRoot):            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">and</span> subRoot:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> isSametree(root, subRoot) <span class="hljs-keyword">or</span> self.isSubtree(root.left, subRoot) <span class="hljs-keyword">or</span> self.isSubtree(root.right, subRoot)</code></pre></div><p>其实这个很类似字符串匹配，因为我们显然也可以通过稍加修改的遍历去转换成一个字符串匹配的问题，这个稍加修改就是空节点的值要记为空。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubtree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], subRoot: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">root</span>):            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;()&#x27;</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;(<span class="hljs-subst">&#123;serialize(root.left)&#125;</span><span class="hljs-subst">&#123;root.val&#125;</span><span class="hljs-subst">&#123;serialize(root.right)&#125;</span>)&#x27;</span>                <span class="hljs-keyword">return</span> serialize(subRoot) <span class="hljs-keyword">in</span> serialize(root)</code></pre></div><h3 id="二进制矩阵中的最短路径">1091. 二进制矩阵中的最短路径</h3><p>广度优先搜索，不过这道题让我印象更深刻的不是广搜。而是可变类型与不可变类型，这道题我建立<code>visited</code> 时最开始用的 <code>[[0]*n]*n</code>发现怎么也不对。因为这里内层 <code>n</code> 个列表都是同一个列表。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> grid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]:            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        queue = collections.deque()        queue.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))        direction = ((-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))        n = <span class="hljs-built_in">len</span>(grid)        visited = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> queue:            r, c, count = queue.popleft()            <span class="hljs-keyword">if</span> r==n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c==n-<span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> count            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> direction:                x = r+dx                y = c+dy                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=x&lt;n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=y&lt;n <span class="hljs-keyword">and</span> grid[x][y]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> visited[x][y]==<span class="hljs-number">0</span>:                    queue.append((x, y, count+<span class="hljs-number">1</span>))                    visited[x][y] = <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h3 id="被围绕的区域">130. 被围绕的区域</h3><p>从边框上的 <code>O</code> 点开始广度优先搜索， 4个方向上下左右，能搜索到的 <code>O</code> 点记录下来，其它点改为<code>X</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])        direction = ((-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))        border = [(i,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]+[(i,n-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]+[(<span class="hljs-number">0</span>,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]+[(m-<span class="hljs-number">1</span>,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]        <span class="hljs-keyword">for</span> r,c <span class="hljs-keyword">in</span> border:            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-keyword">and</span> (r,c) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                queue = collections.deque()                queue.append((r,c))                hashset.add((r,c))                <span class="hljs-keyword">while</span> queue:                    row, col = queue.popleft()                    <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> direction:                        x = row+dx                        y = col+dy                        <span class="hljs-keyword">if</span> -<span class="hljs-number">1</span>&lt;x&lt;m <span class="hljs-keyword">and</span> -<span class="hljs-number">1</span>&lt;y&lt;n <span class="hljs-keyword">and</span> board[x][y]==<span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-keyword">and</span> (x,y) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                            queue.append((x,y))                            hashset.add((x,y))        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> (r,c) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                    board[r][c] = <span class="hljs-string">&#x27;X&#x27;</span></code></pre></div><h3 id="所有可能的路径">797. 所有可能的路径</h3><p>广度优先搜索并记录。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allPathsSourceTarget</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        queue = collections.deque()        queue.append((<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]))        n = <span class="hljs-built_in">len</span>(graph)        res = []        <span class="hljs-keyword">while</span> queue:            node, path = queue.popleft()            <span class="hljs-keyword">for</span> _<span class="hljs-built_in">next</span> <span class="hljs-keyword">in</span> graph[node]:                <span class="hljs-keyword">if</span> _<span class="hljs-built_in">next</span> == n-<span class="hljs-number">1</span>:                    res.append(path+[n-<span class="hljs-number">1</span>])                <span class="hljs-keyword">else</span>:                    queue.append((_<span class="hljs-built_in">next</span>, path+[_<span class="hljs-built_in">next</span>]))        <span class="hljs-keyword">return</span> res</code></pre></div><p>深度优先搜索。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allPathsSourceTarget</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        n = <span class="hljs-built_in">len</span>(graph)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):            <span class="hljs-keyword">if</span> node == n-<span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> [[node]]            res = []            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> graph[node]:                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dfs(t):                    res.append([node]+i)            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>)</code></pre></div><h2 id="递归-回溯-1">递归 / 回溯</h2><h3 id="子集">78. 子集</h3><p>求出所有可能长度的组合，因此可以使用<code>itertools.combinations</code> 来根据不同长度求出组合。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = [[]]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>):            temp = itertools.combinations(nums, i)            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> temp:                res.append(<span class="hljs-built_in">list</span>(t))        <span class="hljs-keyword">return</span> res</code></pre></div><p>回溯。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        n = <span class="hljs-built_in">len</span>(nums)                <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path</span>):            res.append(path)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):                backtrack(i+<span class="hljs-number">1</span>, path+[nums[i]])                        backtrack(<span class="hljs-number">0</span>, [])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="子集-ii">90. 子集 II</h3><p>与上题不一样之处在于通过排序达到去重效果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsetsWithDup</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        n = <span class="hljs-built_in">len</span>(nums)        nums = <span class="hljs-built_in">sorted</span>(nums)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path</span>):            res.append(path)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):                <span class="hljs-keyword">if</span> i &gt; start <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:                    <span class="hljs-keyword">continue</span>                backtracking(i+<span class="hljs-number">1</span>, path+[nums[i]])        backtracking(<span class="hljs-number">0</span>, [])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="全排列-ii">47. 全排列 II</h3><p>调用 <code>itertools.permutations</code>函数，如果不重复就添加到结果里。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> itertools.permutations(nums):            temp = <span class="hljs-built_in">list</span>(t)            <span class="hljs-keyword">if</span> temp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:                res.append(temp)        <span class="hljs-keyword">return</span> res</code></pre></div><p>添加一个 <code>used</code>数组记录此次递归元素是否被使用，进而保证没有重复的全排列。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        n = <span class="hljs-built_in">len</span>(nums)        used = [<span class="hljs-number">0</span>]*n        nums = <span class="hljs-built_in">sorted</span>(nums)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">used, path</span>):            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == n:                res.append(path)                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> used[i]:                    <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> used[i-<span class="hljs-number">1</span>]:                        <span class="hljs-keyword">continue</span>                    used[i] = <span class="hljs-number">1</span>                    backtracking(used, path+[nums[i]])                    used[i] = <span class="hljs-number">0</span>                backtracking(used, [])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="组合总和">39. 组合总和</h3><p>回溯的时候可以重复取数，如果当前和大于目标值就进行剪枝。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        n = <span class="hljs-built_in">len</span>(candidates)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path, temp_sum</span>):            <span class="hljs-keyword">if</span> temp_sum == target:                res.append(path)            <span class="hljs-keyword">if</span> temp_sum &gt; target:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):                backtracking(i, path+[candidates[i]], temp_sum+candidates[i])        backtracking(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="组合总和-ii">40. 组合总和 II</h3><p>与上题不一样的地方在于针对重复情况做特殊处理。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum2</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        res = []        n = <span class="hljs-built_in">len</span>(candidates)        candidates = <span class="hljs-built_in">sorted</span>(candidates)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bcaktracking</span>(<span class="hljs-params">start, path, temp_sum</span>):            <span class="hljs-keyword">if</span> temp_sum == target:                res.append(path)            <span class="hljs-keyword">if</span> temp_sum &gt; target:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):                <span class="hljs-keyword">if</span> i&gt;start <span class="hljs-keyword">and</span> candidates[i] == candidates[i-<span class="hljs-number">1</span>]:                    <span class="hljs-keyword">continue</span>                bcaktracking(i+<span class="hljs-number">1</span>, path+[candidates[i]], temp_sum+candidates[i])        bcaktracking(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="电话号码的字母组合">17. 电话号码的字母组合</h3><p>回溯的实际应用。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        hashmap = &#123;            <span class="hljs-string">&#x27;2&#x27;</span>: (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>),            <span class="hljs-string">&#x27;3&#x27;</span>: (<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>),            <span class="hljs-string">&#x27;4&#x27;</span>: (<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>),            <span class="hljs-string">&#x27;5&#x27;</span>: (<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>),            <span class="hljs-string">&#x27;6&#x27;</span>: (<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>),            <span class="hljs-string">&#x27;7&#x27;</span>: (<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>),            <span class="hljs-string">&#x27;8&#x27;</span>: (<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>),            <span class="hljs-string">&#x27;9&#x27;</span>: (<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>)        &#125;        res = []        n = <span class="hljs-built_in">len</span>(digits)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">start, path</span>):            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == n:                res.append(<span class="hljs-string">&#x27;&#x27;</span>.join(path))            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n):                <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> hashmap[digits[i]]:                    backtracking(i+<span class="hljs-number">1</span>, path+[t])                backtracking(<span class="hljs-number">0</span>, [])        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="括号生成">22. 括号生成</h3><p>这次递归点在于去生成左括号还是右括号，而不是一对括号。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []                <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">l_count, r_count, path</span>):            <span class="hljs-keyword">if</span> l_count&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r_count&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r_count&lt;l_count:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            <span class="hljs-keyword">if</span> l_count == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r_count == <span class="hljs-number">0</span>:                res.append(path)                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            backtracking(l_count-<span class="hljs-number">1</span>, r_count, path+<span class="hljs-string">&#x27;(&#x27;</span>)            backtracking(l_count, r_count-<span class="hljs-number">1</span>, path+<span class="hljs-string">&#x27;)&#x27;</span>)        backtracking(n, n, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="单词搜索">79. 单词搜索</h3><p>对每个点递归搜索，对特定情况进行剪枝。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        m = <span class="hljs-built_in">len</span>(board)        n = <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])        word_len = <span class="hljs-built_in">len</span>(word)        searched = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">r, c, loc</span>):            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=r&lt;m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;=c&lt;n <span class="hljs-keyword">and</span> loc&lt;word_len <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> searched[r][c] <span class="hljs-keyword">and</span> board[r][c]==word[loc]:                <span class="hljs-keyword">if</span> loc == word_len-<span class="hljs-number">1</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    loc += <span class="hljs-number">1</span>                    searched[r][c] = <span class="hljs-number">1</span>                    res = backtracking(r-<span class="hljs-number">1</span>, c, loc) <span class="hljs-keyword">or</span> backtracking(r+<span class="hljs-number">1</span>, c, loc) <span class="hljs-keyword">or</span> backtracking(r, c-<span class="hljs-number">1</span>, loc) <span class="hljs-keyword">or</span> backtracking(r, c+<span class="hljs-number">1</span>, loc)                    searched[r][c] = <span class="hljs-number">0</span>                    <span class="hljs-keyword">return</span> res            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):                <span class="hljs-keyword">if</span> backtracking(r, c, <span class="hljs-number">0</span>):                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h2 id="动态规划-1">动态规划</h2><h3 id="打家劫舍-ii">213. 打家劫舍 II</h3><p>分两种情况讨论。分别是取头不取尾和取尾不取头这两种情况。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)                <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob1</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:            n = <span class="hljs-built_in">len</span>(nums)            <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])            dp = [nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])]            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):                dp.append(<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">2</span>]+nums[i], dp[i-<span class="hljs-number">1</span>]))            <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]               <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(rob1(nums[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>]), rob1(nums[<span class="hljs-number">1</span>:]))</code></pre></div><h3 id="跳跃游戏">55. 跳跃游戏</h3><p>动态更新当前位置能够到达的最远位置，然后移动当前位置，但是当前位置有一个条件就是要小于上一个当前位置能够到达的最远位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canJump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        n = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        max_len = nums[<span class="hljs-number">0</span>]        i = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i &lt;= max_len:            <span class="hljs-keyword">if</span> i+nums[i] &gt; max_len:                max_len = i+nums[i]            <span class="hljs-keyword">if</span> max_len &gt;= n-<span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h3 id="跳跃游戏-ii">45. 跳跃游戏 II</h3><p>将步数和覆盖范围联系起来，求相同覆盖范围覆盖当前位置的最小步数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        n = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        max_len = <span class="hljs-number">0</span>        cur_len = <span class="hljs-number">0</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            max_len = <span class="hljs-built_in">max</span>(max_len, i+nums[i])            <span class="hljs-keyword">if</span> i == cur_len:                <span class="hljs-keyword">if</span> cur_len != n-<span class="hljs-number">1</span>:                    res += <span class="hljs-number">1</span>                    cur_len = max_len                    <span class="hljs-keyword">if</span> cur_len &gt;= n-<span class="hljs-number">1</span>:                        <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="不同路径">62. 不同路径</h3><p>最开始尝试了下深度优先搜索，超时了。</p><p>很显然这道题不需要搜索，而是一道动态规划，状态转移方程如下： <spanclass="math display">\[dp[i][j]=\begin{cases}dp[i-1][j]+dp[i][j-1]\ \ \ \i&gt;0\&amp;j&gt;0\\1\ \ \ \ i=0|j=0\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        dp = [[<span class="hljs-number">1</span>]*n] + [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-<span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m): dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):                dp[r][c] = dp[r-<span class="hljs-number">1</span>][c]+dp[r][c-<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div><h3 id="最长回文子串">5. 最长回文子串</h3><p>数据结构里做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        s_len = <span class="hljs-built_in">len</span>(s)        dp = [[<span class="hljs-literal">False</span>]*s_len <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):            dp[i][i] = <span class="hljs-literal">True</span>        start, max_len = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> c_len <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,s_len+<span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len-c_len+<span class="hljs-number">1</span>):                j = i+c_len-<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> s[i] != s[j]:                    dp[i][j] = <span class="hljs-literal">False</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">if</span> j&gt;i+<span class="hljs-number">1</span>:                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]                    <span class="hljs-keyword">else</span>:                        dp[i][j] = <span class="hljs-literal">True</span>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> c_len&gt;max_len:                    start = i                    max_len = c_len        <span class="hljs-keyword">return</span> s[start:start+max_len]</code></pre></div><h3 id="等差数列划分">413. 等差数列划分</h3><p>假设一个数组为等差数列的数组，那么它的等差数列子数组的个数等于 <spanclass="math inline">\(\sum_{1}^{nums\_len-3}\)</span>。对于一个不是等差数列的数组，这个数组等差数列子数组则等于其中所有最长等差数列子数组的等差数列子数组个数的和，可能有点难理解，举例，<code>[1,3,5,10,12,13,14]</code>这个数组的等差数列子数组和是等于 <code>[1,3,5]</code> 的等差数列子数组 1加上 <code>[12,13,14]</code> 的等差数列子数组 1 等于 2 的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfArithmeticSlices</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_len = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">if</span> nums_len &lt; <span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        temp = <span class="hljs-number">0</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,nums_len):            <span class="hljs-keyword">if</span> nums[i]+nums[i-<span class="hljs-number">2</span>] == nums[i-<span class="hljs-number">1</span>]+nums[i-<span class="hljs-number">1</span>]:                temp += <span class="hljs-number">1</span>                res += temp            <span class="hljs-keyword">else</span>:                    temp = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="解码方法">91. 解码方法</h3><p>需要对 5 种情况进行处理：</p><ul><li>当前字符是 1 或 2 ，此时有点像是斐波那契数列。</li><li>当前字符是 0 ，前面字符是 1 或 2，会导致前面那个字符衍生的结果被影响。</li><li>当前字符是 0 ，前面字符不是 1 或 2 ，解码不了。</li><li>当前字符是其他数字，如果这一位和上一位的组合起来比 26大，那么这一位相当于是独立的，不会有衍生结果。</li><li>当前字符是其他数字，并且不是上面那种情况，这一位参与斐波那契式计算并添加至结果。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numDecodings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        s_len = <span class="hljs-built_in">len</span>(s)        temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]        res = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> s[i] == <span class="hljs-string">&#x27;2&#x27;</span>:                temp.append(temp[-<span class="hljs-number">1</span>]+temp[-<span class="hljs-number">2</span>])            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;0&#x27;</span>:                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>&#125;:                    res *= temp[-<span class="hljs-number">2</span>]                    temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">and</span> s[i] &gt; <span class="hljs-string">&#x27;6&#x27;</span>:                    res *= temp[-<span class="hljs-number">1</span>]                    temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]                <span class="hljs-keyword">else</span>:                    res *= temp[-<span class="hljs-number">1</span>]+temp[-<span class="hljs-number">2</span>]                    temp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> temp[-<span class="hljs-number">1</span>] != <span class="hljs-number">1</span>:            res *= temp[-<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="单词拆分">139. 单词拆分</h3><p>状态转移方程，dp[i] 代表字符串第 i 位及之前能够由字典的单词拼接成：<span class="math display">\[dp[j]=\begin{cases}True\ \ \ \ if\ dp[i]\&amp;s[i:j]\inwordDict\\False\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        s_len = <span class="hljs-built_in">len</span>(s)        dp=[<span class="hljs-literal">True</span>]+[<span class="hljs-literal">False</span>]*s_len        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, s_len+<span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> dp[i] <span class="hljs-keyword">and</span> s[i:j] <span class="hljs-keyword">in</span> wordDict:                    dp[j] = <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="最长递增子序列">300. 最长递增子序列</h3><p>状态转移方程为，这里 dp[i] 指的是包含第 i 个元素的状态： <spanclass="math display">\[dp[i]=\begin{cases}max(dp[x],x\in[0,i-1]\&amp;nums[x]&lt;nums[i])+1\\1\\ \ \ if\ i=0\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_len = <span class="hljs-built_in">len</span>(nums)        dp = [<span class="hljs-number">1</span>]*nums_len        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,nums_len):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):                <span class="hljs-keyword">if</span> nums[j]&lt;nums[i]:                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)</code></pre></div><h3 id="最长递增子序列的个数">673. 最长递增子序列的个数</h3><p>相对于上道题，这道题多了一个计数，每次增长序列时，需要重置计数，每次遇到另一组当前最长序列时，需要累加计数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findNumberOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_len = <span class="hljs-built_in">len</span>(nums)        dp = [<span class="hljs-number">1</span>]*nums_len        count = [<span class="hljs-number">1</span>]*nums_len        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,nums_len):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):                <span class="hljs-keyword">if</span> nums[j]&lt;nums[i]:                    <span class="hljs-keyword">if</span> dp[j]+<span class="hljs-number">1</span>&gt;dp[i]:                        dp[i] = dp[j]+<span class="hljs-number">1</span>                        count[i] = count[j]                    <span class="hljs-keyword">elif</span> dp[j]+<span class="hljs-number">1</span>==dp[i]:                        count[i] += count[j]        max_seq = <span class="hljs-built_in">max</span>(dp)        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len):            <span class="hljs-keyword">if</span> max_seq == dp[i]:                res += count[i]        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="最长公共子序列">1143. 最长公共子序列</h3><p>动态规划，二维状态转移方程： <span class="math display">\[dp[i][j]=\begin{cases}max(dp[i][j-1],dp[i-1][j],dp[i-1][j-1]+1\ \ when\text_i=text_j)\ \ \ \ if\ i&gt;0\&amp;j&gt;0\\dp[i-1][j]\ or\ dp[i][j-1]\ \ \ \ if\ i=0|j=0\ \&amp;text_i\ne text_j\\dp[i-1][j]+1\ or\ dp[i][j-1]+1\ \ \ \ if\ i=0|j=0\ \&amp;text_i=text_j\\1 or 0\ if\ i=0\&amp;j=0\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        len1 = <span class="hljs-built_in">len</span>(text1)        len2 = <span class="hljs-built_in">len</span>(text2)        dp = [[<span class="hljs-number">0</span>]*(len2+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2):                <span class="hljs-keyword">if</span> text1[i] == text2[j]:                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]+<span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])          <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div><h3 id="两个字符串的删除操作">583. 两个字符串的删除操作</h3><p>跟上题基本一样，重点就在于找到最长公共子序列。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        len1 = <span class="hljs-built_in">len</span>(word1)        len2 = <span class="hljs-built_in">len</span>(word2)        dp = [[<span class="hljs-number">0</span>]*(len2+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2):                <span class="hljs-keyword">if</span> word1[i] == word2[j]:                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]+<span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])          <span class="hljs-keyword">return</span> len1+len2-<span class="hljs-number">2</span>*dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div><h3 id="编辑距离">72. 编辑距离</h3><p>状态转移方程： <span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j-1]，此时两个字母相同所以不用操作\\min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1，此时两个字母不同，选择增删改里最优方式执行\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        len1 = <span class="hljs-built_in">len</span>(word1)        len2 = <span class="hljs-built_in">len</span>(word2)        dp = [[<span class="hljs-number">0</span>]*(len2+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1+<span class="hljs-number">1</span>): dp[i][<span class="hljs-number">0</span>] = i        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2+<span class="hljs-number">1</span>): dp[<span class="hljs-number">0</span>][j] = j        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len1):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len2):                <span class="hljs-keyword">if</span> word1[i] == word2[j]:                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]                <span class="hljs-keyword">else</span>:                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j], dp[i][j])+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]</code></pre></div><h3 id="零钱兑换">322. 零钱兑换</h3><p>做过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], amount: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        dp = [-<span class="hljs-number">1</span>]*(amount+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, amount+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> coins:                dp[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                temp = []                <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:                    <span class="hljs-keyword">if</span> i-coin&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dp[i-coin] != -<span class="hljs-number">1</span>:                        temp.append(dp[i-coin])                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp) != <span class="hljs-number">0</span>:                    dp[i] = <span class="hljs-built_in">min</span>(temp)+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]</code></pre></div><h3 id="整数拆分">343. 整数拆分</h3><p>我感觉这道题是在做数学题，找规律，找到 10 左右应该能发现规律。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">integerBreak</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        dp=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">6</span>):            dp.append(<span class="hljs-number">3</span>*dp[-<span class="hljs-number">3</span>])        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">2</span>]</code></pre></div><h2 id="位运算-1">位运算</h2><h3 id="数字范围按位与">201. 数字范围按位与</h3><p>问题的本质在于找最长公共前缀。所以假设两个数位长度不一样显然公共前缀都为0 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(left)) != <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(right)):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        res = left        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>):            res &amp;= i        <span class="hljs-keyword">return</span> res</code></pre></div><p>正常找最长前缀当然也可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        shift = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> left != right:            left &gt;&gt;= <span class="hljs-number">1</span>            right &gt;&gt;= <span class="hljs-number">1</span>            shift += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> right&lt;&lt;shift</code></pre></div><p>或者利用 Brian Kernighan 算法，一直消去 <code>right</code> 的最后一个1 使 <code>right</code> 小于等于 <code>left</code> ，此时<code>right</code> 就是答案。</p><blockquote><p>Brian Kernighan's Algorithm</p><p>通过 n&amp;(n-1) 可以使 n 最后一位上的 1 变成 0 。</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">while</span> left&lt;right:            right = right&amp;(right-<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> right</code></pre></div><h2 id="其他">其他</h2><h3 id="打乱数组">384. 打乱数组</h3><p><code>random</code> 类里 <code>sample</code> 和 <code>shuffle</code>方法的使用。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):        <span class="hljs-keyword">import</span> random        self.nums = nums    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">return</span> self.nums    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">return</span> random.sample(self.nums, <span class="hljs-built_in">len</span>(self.nums))</code></pre></div><p>或是</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):        <span class="hljs-keyword">import</span> random        self.nums = nums    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">return</span> self.nums    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = self.nums.copy()        random.shuffle(res)        <span class="hljs-keyword">return</span> res</code></pre></div><h3 id="快乐数">202. 快乐数</h3><p>找规律题。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        num_set = &#123;n&#125;        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span>:            temp = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> n!=<span class="hljs-number">0</span>:                temp += (n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>)                n //= <span class="hljs-number">10</span>            n = temp            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> num_set:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                num_set.add(n)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h3 id="直线上最多的点数">149. 直线上最多的点数</h3><p>暴力。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPoints</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:        points_len = <span class="hljs-built_in">len</span>(points)        <span class="hljs-keyword">if</span> points_len &lt;= <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> points_len        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(points_len):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, points_len):                x1,y1,x2,y2 = points[i][<span class="hljs-number">0</span>],points[i][<span class="hljs-number">1</span>],points[j][<span class="hljs-number">0</span>],points[j][<span class="hljs-number">1</span>]                count = <span class="hljs-number">2</span>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j+<span class="hljs-number">1</span>, points_len):                    x,y = points[k][<span class="hljs-number">0</span>], points[k][<span class="hljs-number">1</span>]                    <span class="hljs-keyword">if</span> (y-y1)*(x2-x1) == (y2-y1)*(x-x1): count+=<span class="hljs-number">1</span>                res = <span class="hljs-built_in">max</span>(res, count)        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

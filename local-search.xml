<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 326 344 349</title>
    <link href="/2022/06/25/leetcode20220625/"/>
    <url>/2022/06/25/leetcode20220625/</url>
    
    <content type="html"><![CDATA[<h1 id="的幂">326. 3 的幂</h1><p>还是经典的是否是最大值的约数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfThree</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">3</span>**<span class="hljs-number">20</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="的幂-1">342. 4 的幂</h1><p>这题不同于 2 和 3 的幂，因为 4 = 2$$2，所以如果按 2 的幂和 3的幂的解法会识别不了是 2 的幂但是不是 4的幂的数这种情况，不过可以转换为求解 2 的幂，如果一个数是 4的幂，那它的算术平方根肯定是 2 的幂就可解得正确答案。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfFour</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>**<span class="hljs-number">30</span>)%(n**<span class="hljs-number">0.5</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="两个数组的交集">349. 两个数组的交集</h1><p>其实就是两个 <code>list</code> 转 <code>set</code> 后求交集再返回<code>list</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1)&amp;<span class="hljs-built_in">set</span>(nums2))</code></pre></div><h1 id="两个数组的交集-ii">350. 两个数组的交集 II</h1><p>比上个题要难一点，需要对字符出现次数进行一个统计，所以用了<code>dict</code> 而不是 <code>set</code>，在往结果列表里添加值时取最小的次数就可以。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersect</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        dict1 = &#123;&#125;        dict2 = &#123;&#125;        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict1:                dict1[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                dict1[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict2:                dict2[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                dict2[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dict1.items():            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> dict2:                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(value,dict2[key])):                    res.append(key)        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH Tunnel 实现 BI 工具连接数据库</title>
    <link href="/2022/06/19/ssh%E9%9A%A7%E9%81%93%E5%AE%9E%E7%8E%B0bi%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/06/19/ssh%E9%9A%A7%E9%81%93%E5%AE%9E%E7%8E%B0bi%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>最近项目需要 BI工具看板做一个数据可视化的模块，服务器和数据库都是在云端的，每次访问数据库通过Navicat 、Python 等工具去访问，但是很可惜，power BI 和 tableau 并没有ssh 访问的入口（ Navicat是有的）。关于如何通过这种方式访问数据库在网上没有符合预期的解答，后来经过研究，发现了答案。</p><h1 id="原理">原理</h1><p>SSH 的理论在此不多赘述。整个连接过程分为两部分：</p><ul><li>服务器/远程主机某端口与本机某端口通过 ssh tunnel连接，连接建立后我去访问本机某端口时，相当于访问服务器/远程主机对应端口。</li><li>在 BI 工具（其实 Navicat也可以，稍有不同）上访问本机的这个端口，而不是访问之前的 3306（ Mysql默认的）端口。</li></ul><h1 id="实操过程">实操过程</h1><h2 id="隧道搭建">隧道搭建</h2><p>我的系统时 Windows 11，系统本身没有命令直接搭建 ssh隧道。所以需要选择一款 ssh 客户端软件，我用的是 PuTTY （ 0.77 release64-bit x86 ），下载地址如下：</p><p><ahref="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p><p>下载完了之后，我们打开 PuTTY，首先是主页面，也就是左侧<code>Session</code> 的页面，这里有个 Host Name (or IP address) 和Port。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192238821.png"alt="配置 Session" /><figcaption aria-hidden="true">配置 Session</figcaption></figure><p>这里的 <strong>Host Name 与 Port 是指的 ssh 服务器的 IP地址与端口</strong>，对应着 Navicat 如下位置：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192244406.png"alt="对应的 ssh 服务器" /><figcaption aria-hidden="true">对应的 ssh 服务器</figcaption></figure><p>接着在左侧<code>Connection -&gt; SSH -&gt; Tunnels</code>这个界面，输入Source port 与 Destination，输入完之后，点击 Add 添加。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192255705.png"alt="配置单向隧道的源端口和目的端口" /><figcaptionaria-hidden="true">配置单向隧道的源端口和目的端口</figcaption></figure><p>这里的 <strong>Source port是指本机要用来建立隧道通信的端口</strong>，我的建议是不要选太怪的数字，最好10000 以上，65535以下，也没有太大讲究，最好别和其它服务重合了。<strong>Destination则是远程主机/服务器的 IP 和端口</strong>，我在 Google里其实搜索到过搭隧道 tableau连接远程主机的，它在演示的时候，自己跟自己建立的隧道，稍微不太方便理解这里的意思。Destination对应着 Navicat 如下位置：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192305530.png"alt="对应的目的端口" /><figcaption aria-hidden="true">对应的目的端口</figcaption></figure><p>然后在 PuTTY 里还需要配置一个地方，它位于<code>Connection -&gt; SSH -&gt; Auth</code>，这个地方是添加私钥的地方，如下：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192309718.png"alt="配置私钥" /><figcaption aria-hidden="true">配置私钥</figcaption></figure><p>它对应着 Navicat 里的：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192310985.png"alt="对应私钥位置" /><figcaption aria-hidden="true">对应私钥位置</figcaption></figure><p><strong>但是其实并不能直接添加 <code>pem</code>文件</strong>，这个时候我们需要打开 PuTTYgen，点击load，弹出文件选择页面时选择你的 pem 文件，然后点击 Save private key保存一个 <code>ppk</code> 格式的文件。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192315126.png"alt="私钥格式转换" /><figcaption aria-hidden="true">私钥格式转换</figcaption></figure><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192317180.png"alt="image-20220619231701159" /><figcaption aria-hidden="true">image-20220619231701159</figcaption></figure><p>这个时候就可以在 PuTTY 的页面添加这个 <code>ppk</code>格式文件了，如图：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192318792.png"alt="成功配置私钥" /><figcaption aria-hidden="true">成功配置私钥</figcaption></figure><p>回到 <code>Session</code> 点击 <code>Save</code>保存一下以免之后重新配（只用一次当我没说），配置方面就完成了。点击<code>Open</code> 测试一波：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192321988.png"alt="建立连接，登录账户" /><figcaption aria-hidden="true">建立连接，登录账户</figcaption></figure><p>输入用户名，这个用户名是 ssh 的用户名，对应着 Navicat 如下位置：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192322747.png"alt="对应的 ssh 账户名" /><figcaption aria-hidden="true">对应的 ssh 账户名</figcaption></figure><p>然后其实就连上了。注意连上了之后不要关闭 PuTTY，关了隧道就断开了。</p><p>有时可能会突然挂掉，我采用了每隔一段时间发送空包的方式维持隧道。在<code>Connection</code> 里，我把如下位置的值改成了 10：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192328488.png"alt="保持隧道连接" /><figcaption aria-hidden="true">保持隧道连接</figcaption></figure><p>至此，ssh 客户端（ PuTTY ）这边的工作就结束了，下一步就是测试。</p><h2 id="连接测试">连接测试</h2><p>因为我用 Navicat 是可以连接上的，所以我的选择是先用 Navicat测试。有过 Navicat 通过 ssh连接数据库经验的同学应该都知道，用这种方式连接数据库时，需要在<code>常规</code> 和 <code>SSH</code>两个页面分别配置，搭建隧道之后，只用配置 <code>常规</code>页面就可以了。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349956.png"alt="Navicat 测试" /><figcaption aria-hidden="true">Navicat 测试</figcaption></figure><p>这里：</p><ul><li>主机填写 <code>localhost</code> 或是 <code>127.0.0.1</code>都可以。</li><li>端口填写之前<strong>在 PuTTY 里填写的 Source port</strong>。</li><li>用户名填写目的主机/服务器的用户名。</li><li>密码填写目的主机/服务器的密码。</li></ul><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192349512.png"alt="连接成功" /><figcaption aria-hidden="true">连接成功</figcaption></figure><p>接着在 power BI 上也测试一下。选择 MySQL 数据库。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192355774.png"alt="power BI 选择数据库" /><figcaption aria-hidden="true">power BI 选择数据库</figcaption></figure><p><strong>服务器填写 <code>127.0.0.1:xxxx</code>，就是本机的 IP地址加用于搭隧道的端口，也就是 PuTTY 里配置的 Source port。</strong>数据库填写你要连接的库名。</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206192357463.png"alt="power BI 连接数据库" /><figcaption aria-hidden="true">power BI 连接数据库</figcaption></figure><p>高级选项下可以写 SQL 查询语句。然后在下一步选择<code>数据库</code>，用户名填写目的主机/服务器的用户名，密码填写目的主机/服务器的密码，如下：</p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206200000501.png"alt="power BI 登录数据库账户" /><figcaption aria-hidden="true">power BI 登录数据库账户</figcaption></figure><p>点击连接就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>data analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh tunnel</tag>
      
      <tag>mysql</tag>
      
      <tag>powerbi</tag>
      
      <tag>tableau</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《信用评分工具：自动化信用管理的理论与实践》 - 读书笔记</title>
    <link href="/2022/06/19/%E3%80%8A%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E7%94%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/"/>
    <url>/2022/06/19/%E3%80%8A%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E7%94%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><p>全书共 8 个部分，分别为：</p><ul><li><p>背景设定 -讲述信用评分的定义及业务、历史背景、原理。明确提到了申请贷款会有一个回复“通过”或“拒绝”，如果“通过”，会进一步知道“贷款额度”与“还款条件”。这体现了一笔loan做成必经准入或是拦截的过程，在准入之后，还有一个差异化定价的过程。</p><blockquote><ol type="1"><li>信用评分及其业务 -什么是信用评分、它适用于哪些经济和业务领域、它如何影响我们。</li><li>信用微历史 -关于信用供给、信用评分、征信机构和评级机构的简要历史。</li><li>信用评分原理 - 如何进行信用评分、怎样建立评分卡。</li></ol></blockquote></li><li><p>风险业务 -针对不同业务的风险管理有不同的决策评估方法，要建立风险管理框架，对企业和个体也要做不同的风险评估。</p><blockquote><ol start="4" type="1"><li>风险理论 - 管理层要考虑的风险管理框架，信用风险只是其中之一。</li><li>决策科学 -信用评分是对个体风险的评估，但使用科学的方法能挖掘出更大的价值。</li><li>企业风险评估 -对不同规模的企业贷款的评估，既有传统的理论方法，也有近期的发展。</li></ol></blockquote></li><li><p>数学和统计 -介绍传统统计方法，包括一些机器学习的模型、算法的原理和适用范围。</p><blockquote><ol start="7" type="1"><li>预测统计 -因为成本高或者代价大，对未来事件或结果的未知答案的估计方法很难确定。</li><li>区分度的测量 -用于对预测变量和预测能力的稳定性以及预测的准确性进行判定。</li><li>零碎内容 -描述性分析、预测工具、一些统计概念以及基本的评分卡开发报告。</li><li>头脑与机器 -所需的人员（开发人员、项目组、委员会）和软件（评分卡开发、决策引擎）。</li></ol></blockquote></li><li><p>数据 - 讲述数据本身的重要性以及如何提高数据的数量与质量。</p><blockquote><ol start="11" type="1"><li>数据考虑 -建立评分卡之前要考虑的一些必要因素，主要涉及特征变量。</li><li>数据来源 - 讨论从客户、内部系统和征信机构获取信息。</li><li>评分结构 -关注评分卡的定制和架设、数据整合和不同来源数据的匹配。</li><li>信息共享 -征信机构的类型、存在的原因、如何运作以及如何鼓励或约束贷款机构。</li><li>数据准备 -开发评分卡流程的第一阶段，包括数据整合、好坏定义、采样窗口以及样本选择。</li></ol></blockquote></li><li><p>评分卡开发 -这里提到了分离开发时去理解业务与开发过程这个概念，也讲述到了应把<strong>简单、可解释性强的模型</strong>作为评分卡开发时的选择这个倾向。</p><blockquote><p>Falkenstein E G , Boral A , Ca Rty L V . RiskCalc for PrivateCompanies: Moody's Default Model[J]. SSRN Electronic Journal, 2000.</p></blockquote><p>作者认为理解业务应当在开发时那个节点，在这一步需要与业务人员，决策者进行互动，所谓“谋定而后动”，这点与软件工程中的<code>可行性分析-&gt;需求分析-&gt;总体设计-&gt;详细设计</code>有着异曲同工之妙。作者把开发前大体的步骤划分为如下：</p><ul><li>项目启动 - 最开始的会议决定责任、项目内容、数据来源和潜在问题。</li><li>数据收集 - 从数据来源提取大小合适的样本。</li><li>好坏定义 -不仅要区别好坏、不确定样本，还要剔除任何不该用来建模的样本（灰样本）。</li><li>样本分层 -决定是否要细分样本并分别对待，要参考之前的分层方法和业务信息。（也可以用决策树辅助。）</li><li>确定模型 -开发完毕，交付结果，包括每个特征的权重，还有评分卡的验证结果。</li><li>决策策略 -不同情境下的决策，分数本身也是策略的一部分。分数可以被简单设置成一个临界分数（准入与拦截），但也可能会更复杂。</li></ul><p>开发的完整流程如下：</p><blockquote><ol start="16" type="1"><li>变量转换 -分析可得数据并将其转换为可用数据，传统上包括细分类、粗分类、转换。</li><li>特征选取 -确定哪些特征作为备选变量，它们最好是有预测能力、符合逻辑、稳定可得、合规、与客户有关并且相互独立的。</li><li>样本分层 -是否细分样本并分别建立评分卡取决于市场、客户、数据、过程、建模等因素。</li><li>拒绝推断 - 开发申请评分卡时对被拒绝的申请者的表现进行推断。</li><li>模型校准 -用分数分段或缩放来确保分数在不同评分卡中有相同的含义，反映相应的违约概率。</li><li>检验交付 -用保留样本和近期样本检验模型是否过度拟合或不稳定，然后准备投入使用。</li><li>开发管理 - 评分卡开发的流程管理和安排。</li></ol></blockquote></li><li><p>实施和使用 -遵循<strong>Wiklund提供的框架</strong>，介绍模型部署与模型监控相关内容。</p><blockquote><p>在信用评分中有三个重要的程序系统：（1）评分卡安装；（2）与信用信息的连接；（3）安装完成后的监控。</p><p>Handbook of credit scoring[M]. Global Professional Publishi,2001.</p></blockquote><blockquote><ol start="23" type="1"><li>实施安装 - 绿地开发（ Greenfield Software Development,指为全新环境开发系统）相关问题，以及棕地开发（ Brownfield SoftwareDevelopment,指在现有或遗留软件系统存在的情况下开发和部署新的软件系统）涉及的数据、资源和转换问题。</li><li>管理控制 - 验证审查，保证分数合理有效。</li><li>跟踪监控 - 记录事件的报告，有前端报告和后端报告之分。</li><li>金融财务 - 损失准备金、风险定价和利润率等问题。</li></ol></blockquote></li><li><p>信用风险管理周期 -这里提到风险管理周期可以分为五个阶段，<code>市场营销-&gt;申请审批-&gt;账户管理-&gt;催收-&gt;回收</code>。其中市场营销可以细分为分层（为了精准营销）和吸引客户。回收可以细分为追踪和回收（观察和表现）。</p><ul><li>分层（ segmentation ） - 确定目标客户、客户需求和适合的产品。</li><li>吸引（ solicitation ） -设计和实施营销活动，吸引潜在客户办理业务。</li><li>获取（ acquisition ） -获取并处理新业务申请，如果审批通过则交付产品，否则还要与客户沟通并处理疑问。</li><li>管理（ management ） -对一般账户进行日常管理，主要是额度管理，但也包括还款、账单、咨询等。</li><li>催收（ collections ） - 重点关注早期的违约和维持客户关系。</li><li>追踪（ tracing ） -尝试联系并找到一些因没有更新住址或联系方式而失联的客户。</li><li>回收（ rehabilitation ） -处理后期的违约，尽可能地收回资金，其中可能采取法律手段并破坏客户关系。</li></ul><p>除此之外，还有一个欺诈风险。作者认为欺诈属于操作风险中的一种，并不属于信用风险的范畴，但必须在信用管理周期中考虑。</p><blockquote><ol start="27" type="1"><li>市场营销 - 广告媒体、质量与数量、初步筛选和使用的数据。</li><li>申请审批 - 选择客户的操作。</li><li>账户管理 -询问贷款的人、获得贷款的人、接受贷款的人、重复贷款的人和关闭账户的人。</li><li>催收回收 - 违约原因和催收流程、催收时机和催收策略。</li><li>欺诈防范 - 趋势、类型和工具。</li></ol></blockquote></li><li><p>监管环境 - 介绍一些对金融机构的监管内容。</p><blockquote><ol start="32" type="1"><li>监管概念 -最佳实践、善良治理、商业道德、社会责任、合规等级、判例制度、行业规范、政策程序，以及不成文规定。</li><li>隐私保护 -贷款机构之间的数据共享、上传征信机构的内容、必须告知客户的信息等。</li><li>禁止歧视 -涉及借贷决策中可能会使用的信息，禁止使用带有歧视的信息（种族、宗教等），或者与潜在客户不同群体的信息。</li><li>公平信贷 -确保贷款机构采取足够措施，保证借款人能负担贷款，以及贷款条款的公平。</li><li>资本要求 -主要针对银行的巴塞尔协议，它允许使用内部评级法计算资本金要求。</li><li>了解客户 -提高身份识别要求，主要用于防止洗钱和犯罪活动，还有阻止恐怖活动。</li><li>国家差异 -对一些英语国家的法律作出概述，包括美国、英国、澳大利亚、加拿大和南非。</li></ol></blockquote></li></ul><h1 id="第一部分---背景设定">第一部分 - 背景设定</h1><h2 id="第-1-章---信用评分及其业务">第 1 章 - 信用评分及其业务</h2><h3 id="什么是信用评分">1.1 什么是信用评分</h3><h3 id="在哪儿使用信用评分">1.2 在哪儿使用信用评分？</h3><h4 id="数据来源">1.2.1 数据来源</h4><h4 id="信用风险管理周期">1.2.2 信用风险管理周期</h4><h4 id="行为偏好">1.2.3 行为偏好</h4><h3 id="为什么要使用信用评分">为什么要使用信用评分？</h3><h4 id="如何影响贷款机构">1.3.1 如何影响贷款机构？</h4><h4 id="对客户的影响">1.3.2 对客户的影响</h4><h3 id="信用评分如何影响信用供给">1.4 信用评分如何影响信用供给？</h3><h3 id="小结">1.5 小结</h3><h2 id="第-2-章---信用微历史">第 2 章 - 信用微历史</h2><h3 id="信用的历史">2.1 信用的历史</h3><h4 id="古代历史">2.1.1 古代历史</h4><h4 id="中世纪到-19-世纪">2.1.2 中世纪到 19 世纪</h4><h4 id="世纪">2.1.3 20 世纪</h4><h3 id="信用评分的历史">2.2 信用评分的历史</h3><h4 id="开拓时期">2.2.1 开拓时期</h4><h4 id="自动化时期">2.2.2 自动化时期</h4><h4 id="扩张时期">2.2.3 扩张时期</h4><h3 id="征信机构的历史">2.3 征信机构的历史</h3><h4 id="世纪中期以前">2.3.1 18 世纪中期以前</h4><h4 id="世纪-90-年代以后">2.3.2 19 世纪 90 年代以后</h4><h4 id="世纪-60-年代以后">2.3.3 20 世纪 60 年代以后</h4><h4 id="国际">2.3.4 国际</h4><h3 id="评级机构的历史">2.4 评级机构的历史</h3><h3 id="小结-1">2.5 小结</h3><h2 id="第三章---评分信用原理">第三章 - 评分信用原理</h2><h3 id="评分卡是什么">3.1 评分卡是什么</h3><h4 id="评分卡的形态">3.1.1 评分卡的形态</h4><h4 id="如何开发评分卡">3.1.2 如何开发评分卡</h4><h4 id="预测能力如何评估">3.1.3 预测能力如何评估</h4><h4 id="评分卡的偏差是如何出现的">3.1.4 评分卡的偏差是如何出现的</h4><h4 id="如何应对以上问题">3.1.5 如何应对以上问题</h4><h3 id="采用何种测量方法">3.2 采用何种测量方法</h3><h4 id="流程与策略">3.2.1 流程与策略</h4><h4 id="如何开发评分卡-1">3.2.2 如何开发评分卡</h4><h4 id="违约概率和损失程度">3.2.3 违约概率和损失程度</h4><h3 id="评分卡的开发流程">3.3 评分卡的开发流程</h3><h4 id="项目准备">3.3.1 项目准备</h4><h4 id="数据准备">3.3.2 数据准备</h4><h4 id="建模分析">3.3.3 建模分析</h4><h4 id="模型确定">3.3.4 模型确定</h4><h4 id="决策制定和策略">3.3.5 决策制定和策略</h4><h4 id="安全保护">3.3.6 安全保护</h4><h3 id="什么会影响评分卡">3.4 什么会影响评分卡</h3><h4 id="经济偏移">3.4.1 经济偏移</h4><h4 id="市场偏移">3.4.2 市场偏移</h4><h4 id="操作偏移">3.4.3 操作偏移</h4><h4 id="目标偏移">3.4.4 目标偏移</h4><h4 id="不明偏移">3.4.5 不明偏移</h4><h3 id="小结-2">3.5 小结</h3><h1 id="第二部分---风险业务">第二部分 - 风险业务</h1><h2 id="第-4-章---风险理论">第 4 章 - 风险理论</h2><h3 id="风险相关术语">4.1 风险相关术语</h3><h4 id="风险关联">4.1.1 风险关联</h4><h4 id="风险环境">4.1.2 风险环境</h4><h4 id="风险类型">4.1.3 风险类型</h4><h3 id="数据与模型">4.2 数据与模型</h3><h4 id="数据类型">4.2.1 数据类型</h4><h4 id="模型类型">4.2.2 模型类型</h4><h4 id="人为判断">4.2.3 人为判断</h4><h4 id="专家系统">4.2.4 专家系统</h4><h3 id="小结-3">4.3 小结</h3><h2 id="第-5-章---决策科学">第 5 章 - 决策科学</h2><h3 id="自适应控制">5.1 自适应控制</h3><h3 id="成为主人">5.2 成为主人</h3><h4 id="冠军挑战">5.2.1 冠军挑战</h4><h4 id="优化">5.2.2 优化</h4><h4 id="策略推断">5.2.3 策略推断</h4><h3 id="小结-4">5.3 小结</h3><h2 id="第-6-章---企业风险评估">第 6 章 - 企业风险评估</h2><h3 id="风险评估基础">6.1 风险评估基础</h3><h4 id="数据来源-1">6.1.1 数据来源</h4><h4 id="风险模型">6.1.2 风险模型</h4><h4 id="风险等级">6.1.3 风险等级</h4><h3 id="中小企业贷款">6.2 中小企业贷款</h3><h4 id="关系型贷款">6.2.1 关系型贷款</h4><h4 id="交易型贷款">6.2.2 交易型贷款</h4><h3 id="财务比率评分">6.3 财务比率评分</h3><h4 id="理论先驱">6.3.1 理论先驱</h4><h4 id="预测比率">6.3.2 预测比率</h4><h4 id="限制因素">6.3.3 限制因素</h4><h4 id="评级机构">6.3.4 评级机构</h4><h4 id="内部评级">6.3.5 内部评级</h4><h3 id="信用评级机构">6.4 信用评级机构</h3><h4 id="字母等级">6.4.1 字母等级</h4><h4 id="评级类型">6.4.2 评级类型</h4><h4 id="存在问题">6.4.3 存在问题</h4><h4 id="研究重点">6.4.4 研究重点</h4><h3 id="前瞻数据建模">6.5 前瞻数据建模</h3><h4 id="历史分析">6.5.1 历史分析</h4><h4 id="结构模型">6.5.2 结构模型</h4><h4 id="简约模型">6.5.3 简约模型</h4><h3 id="小结-5">6.6 小结</h3><h1 id="第三部分---数学和统计">第三部分 - 数学和统计</h1><h2 id="第-7-章---预测统计">第 7 章 - 预测统计</h2><h3 id="模型概述">7.1 模型概述</h3><h3 id="参数模型">7.2 参数模型</h3><h4 id="线性模型">7.2.1 线性模型</h4><h4 id="判别分析">7.2.2 判别分析</h4><h4 id="逻辑回归">7.2.3 逻辑回归</h4><h3 id="非参模型">7.3 非参模型</h3><h4 id="决策树">7.3.1 决策树</h4><h4 id="神经网络">7.3.2 神经网络</h4><h4 id="遗传算法">7.3.3 遗传算法</h4><h4 id="k-近邻法">7.3.4 K 近邻法</h4><h4 id="线性规划">7.3.5 线性规划</h4><h3 id="关键假设">7.4 关键假设</h3><h4 id="数据因素">7.4.1 数据因素</h4><h4 id="统计假设">7.4.2 统计假设</h4><h4 id="解决方法">7.4.3 解决方法</h4><h3 id="结果比较">7.5 结果比较</h3><h2 id="第-8-章---区分度的测量">第 8 章 - 区分度的测量</h2><h3 id="错误的分类矩阵">8.1 错误的分类矩阵</h3><h3 id="kullback-散度">8.2 Kullback 散度</h3><h4 id="证据权重">8.2.1 证据权重</h4><h4 id="信息值">8.2.2 信息值</h4><h4 id="稳定指数">8.2.3 稳定指数</h4><h3 id="ks-统计量">8.3 KS 统计量</h3><h3 id="相关系数">8.4 相关系数</h3><h4 id="pearson-积矩">8.4.1 Pearson 积矩</h4><h4 id="spearman-秩序">8.4.2 Spearman 秩序</h4><h4 id="洛伦兹曲线">8.4.3 洛伦兹曲线</h4><h4 id="基尼系数">8.4.4 基尼系数</h4><h4 id="roc-曲线">8.4.5 ROC 曲线</h4><h3 id="卡方检验">8.5 卡方检验</h3><h3 id="准确性检验">8.6 准确性检验</h3><h4 id="概率论">8.6.1 概率论</h4><h4 id="二项分布">8.6.2 二项分布</h4><h4 id="hl统计量">8.6.3 HL统计量</h4><h4 id="对数似然">8.6.4 对数似然</h4><h3 id="小结-6">8.7 小结</h3><h2 id="第-9-章---零碎内容">第 9 章 - 零碎内容</h2><h3 id="描述方法">9.1 描述方法</h3><h4 id="聚类分析">9.1.1 聚类分析</h4><h4 id="因子分析">9.1.2 因子分析</h4><h3 id="预报方法">9.2 预报方法</h3><h4 id="马尔可夫链">9.2.1 马尔可夫链</h4><h4 id="生存分析">9.2.2 生存分析</h4><h3 id="其他概念">9.3 其他概念</h3><h4 id="相关性">9.3.1 相关性</h4><h4 id="交叉性">9.3.2 交叉性</h4><h4 id="单调性">9.3.3 单调性</h4><h4 id="标准化">9.3.4 标准化</h4><h3 id="开发报告">9.4 开发报告</h3><h4 id="特征分析报告">9.4.1 特征分析报告</h4><h4 id="分数分布报告">9.4.2 分数分布报告</h4><h4 id="新业务策略表">9.4.3 新业务策略表</h4><h3 id="小结-7">9.5 小结</h3><h2 id="第-10-章---头脑与机器">第 10 章 - 头脑与机器</h2><h3 id="人员和项目">10.1 人员和项目</h3><h4 id="评分卡开发人员">10.1.1 评分卡开发人员</h4><h4 id="外部供应商">10.1.2 外部供应商</h4><h4 id="内部资源">10.1.3 内部资源</h4><h4 id="项目组">10.1.4 项目组</h4><h4 id="指导委员会">10.1.5 指导委员会</h4><h3 id="软件">10.2 软件</h3><h4 id="评分卡开发">10.2.1 评分卡开发</h4><h4 id="决策引擎">10.2.1 决策引擎</h4><h3 id="小结-8">10.3 小结</h3><h1 id="第四部分---数据">第四部分 - 数据</h1><h2 id="第-11-章---数据考虑">第 11 章 - 数据考虑</h2><h3 id="数据透明度">11.1 数据透明度</h3><h3 id="数据数量">11.2 数据数量</h3><h4 id="深度和广度">11.2.1 深度和广度</h4><h4 id="同质性">11.2.2 同质性</h4><h4 id="可得性">11.2.3 可得性</h4><h3 id="数据质量">11.3 数据质量</h3><h4 id="关联性">11.3.1 关联性</h4><h4 id="准确性">11.3.2 准确性</h4><h4 id="完备性">11.3.3 完备性</h4><h4 id="时效性">11.3.4 时效性</h4><h4 id="一致性">11.3.5 一致性</h4><h4 id="对征信机构的影响">11.3.6 对征信机构的影响</h4><h3 id="数据设计">11.4 数据设计</h3><h4 id="数据类型-1">11.4.1 数据类型</h4><h4 id="表格设计">11.4.2 表格设计</h4><h3 id="小结-9">11.5 小结</h3><h2 id="第-12-章---数据来源">第 12 章 - 数据来源</h2><h3 id="客户信息">12.1 客户信息</h3><h4 id="申请表">12.1.1 申请表</h4><h4 id="财务信息">12.1.2 财务信息</h4><h3 id="内部信息">12.2 内部信息</h3><h4 id="数据类型-2">12.2.1 数据类型</h4><h4 id="数据库类型">12.2.2 数据库类型</h4><h4 id="客户关系管理">12.2.3 客户关系管理</h4><h3 id="征信数据">12.3 征信数据</h3><h4 id="查询检索">12.3.1 查询检索</h4><h4 id="公共信息">12.3.2 公共信息</h4><h4 id="共享数据">12.3.3 共享数据</h4><h4 id="欺诈预警">12.3.4 欺诈预警</h4><h4 id="征信分数">12.3.5 征信分数</h4><h4 id="地理指标">12.3.6 地理指标</h4><h4 id="其他来源">12.3.7 其他来源</h4><h3 id="小结-10">12.4 小结</h3><h2 id="第-13-章---评分机构">第 13 章 - 评分机构</h2><h3 id="定制服务">13.1 定制服务</h3><h4 id="通用评分卡">13.1.1 通用评分卡</h4><h4 id="定制评分卡">13.1.2 定制评分卡</h4><h4 id="专家模型">13.1.3 专家模型</h4><h3 id="系统架设">13.2 系统架设</h3><h3 id="数据整合">13.3 数据整合</h3><h4 id="独立分数">13.3.1 独立分数</h4><h4 id="离散分数">13.3.2 离散分数</h4><h4 id="合并分数">13.3.3 合并分数</h4><h4 id="决策矩阵">13.3.4 决策矩阵</h4><h3 id="信用评分">13.4 信用评分</h3><h3 id="数据匹配">13.5 数据匹配</h3><h3 id="小结-11">13.6 小结</h3><h2 id="第-14-章---信息共享">第 14 章 - 信息共享</h2><h3 id="征信机构">14.1 征信机构</h3><h4 id="公共与民营">14.1.1 公共与民营</h4><h4 id="正面信息与负面信息">14.1.2 正面信息与负面信息</h4><h3 id="参与合作">14.2 参与合作</h3><h4 id="互惠原则">14.2.1 互惠原则</h4><h4 id="促进因素">14.2.2 促进因素</h4><h4 id="阻碍因素">14.2.3 阻碍因素</h4><h3 id="小结-12">14.3 小结</h3><h2 id="第-15-章---数据准备">第 15 章 - 数据准备</h2><h3 id="数据获取">15.1 数据获取</h3><h4 id="申请数据">15.1.1 申请数据</h4><h4 id="征信数据-1">15.1.2 征信数据</h4><h4 id="观测数据">15.1.3 观测数据</h4><h4 id="表现数据">15.1.4 表现数据</h4><h4 id="数据整合-1">15.1.5 数据整合</h4><h3 id="好坏定义">15.2 好坏定义</h3><p>作者强调了好坏定义的重要性，提到了<strong>好坏定义是建模过程中仅次于数据的重要因素，用来设定目标变量。</strong></p><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/202206201247059.png"alt="好坏定义" /><figcaption aria-hidden="true">好坏定义</figcaption></figure><h4 id="选择状态">15.2.1 选择状态</h4><p>指观测期的状态，分为以下4类：</p><ul><li>排除 -如果某个子群体的分数不影响对其决策，作者建议排除。和拒绝不一样的地方是这类样本不需要做拒绝推断。</li><li>拒绝 - 出于政策规则或者决策规则的样本不需要做拒绝推断。</li><li>未采用 -客户没有接受贷款机构提供的贷款合同，也就是准入了但未做成。可能是价格、利率、合同条款让客户觉得不适。</li><li>双方接受 - 只有这类样本会有真实的表现。</li></ul><h4 id="表现状态">15.2.2 表现状态</h4><p>指表现期的状态，分为以下4类：</p><ul><li><p>排除 -评分卡计划目标之外的结果，比如申请评分卡中出现了欺诈行为或客户去世。这类占比不宜超过总体的3%。</p></li><li><p>不定 - 指灰样本，申请评分卡的不定率应设定在5%~15%，行为评分卡的不定率设定在 10%~20%。这里提到设定灰样本有 3个理由。</p><ul><li>技术逾期造成的疑似不良行为 - 我觉得应该是指像美国 ACH那样的延时得知交易结果的支付方式对标签定义的影响。</li><li>公司策略</li><li>使好坏定义更加清晰。</li></ul><p>这里也讨论了关于提前还款的人是好样本还是不定样本。这类人是可以当作好样本建模的。</p></li><li><p>好样本 - 我们表示欢迎的样本。</p></li><li><p>坏样本 - 我们表示回避的样本。</p></li></ul><h4 id="当前状态和最坏状态">15.2.3 当前状态和最坏状态</h4><p>当前状态和最坏状态是指用结果时点的状态（当前状态）还是整个结果期最坏的状态（最坏状态）来确定“不可恢复点”（point of no return ），也就是去找出账户不会再从坏变好的时间点。</p><p>行为评分中，巴塞尔协议 II 要求使用 90天内最坏最坏状态的定义。申请评分中两种方式都可以。使用当前状态可以确保误判和由坏变好的账户不会被误判，使用最坏状态则对可能是坏的账户更加敏感。</p><p>一般情况下，当前状态的常见定义是逾期 60 天，最坏状态的定义是逾期 90天。</p><h4 id="定义设定">15.2.4 定义设定</h4><p>定义有 3 种方式：</p><ul><li>共识 - 内部专家经验判断。</li><li>规定 -由外部机构设定，确保一致性。（这个主要是方便供别人参考吧）</li><li>经验（原文应该是 experience，我个人觉得翻译成<strong>历史</strong>更合适） -根据自身的历史数据实证分析。提到了滚动率分析，不过并没有讲具体怎么做。</li></ul><h4 id="好坏定义标准">15.2.5 好坏定义标准</h4><p>讲到好坏定义需要符合 3个特点：<strong>相关、充足、透明。</strong></p><h3 id="时间窗口">15.3 时间窗口</h3><p>时间窗口组成有一些相关概念，这里讲到了：</p><ul><li>观测（ observation ） - 指对数据进行观测，作为预测变量。</li><li>结果（ outcome ） - 指分析数据观测的结果，确定目标。</li><li>日期/月份 - 指信息采集的时间。</li><li>窗口（ window ） - 指一段时间。</li></ul><p>这些概念的组合就跟时间窗口有很密切的关系了：</p><ul><li><p>观测期（ observation window ） -也叫观察期，指观测点之前的一段时间。</p></li><li><p>观测日期（ observation date ） -也叫观测点，位于观测期与表现期之间，指采集数据的日期。</p></li><li><p>结果期 （ outcome window ） -也叫表现期，客户表现趋于成熟的时间段。</p></li><li><p>结果日期（ outcome date ） - 指同一样本表现结果的日期。</p></li></ul><p>这两个窗口非常重要，<strong>观测期用于收集用户数据</strong>，例如银行流水等信息，<strong>观测期太短可能会导致变量预测效果不佳</strong>；<strong>表现期用于评价模型的标签（Y）多久之后趋于稳定</strong>，随着时间的累加，违约率会增加但是边际增长率降低，<strong>表现期太短可能会存在坏客户风险暴露不充分这样的情况</strong>。在选择合适的观测期与表现期时，需要考虑<strong>账户成熟、样本信息缺失、数据老化</strong>三个因素。</p><h3 id="样本设计">15.4 样本设计</h3><h4 id="样本类型">15.4.1 样本类型</h4><h4 id="最大和最小样本量">15.4.2 最大和最小样本量</h4><h4 id="分层随机抽样">15.4.3 分层随机抽样</h4><h3 id="小结-13">15.5 小结</h3><h1 id="第五部分---评分卡开发">第五部分 - 评分卡开发</h1><h2 id="第-16-章---变量转换">第 16 章 - 变量转换</h2><h3 id="转换方法">16.1 转换方法</h3><h4 id="虚拟变量">16.1.1 虚拟变量</h4><h4 id="风险变量">16.1.2 风险变量</h4><h4 id="方法选择">16.1.3 方法选择</h4><h3 id="粗细分类">16.2 粗细分类</h3><h4 id="特征分析报告-1">16.2.1 特征分析报告</h4><h4 id="细分类">16.2.2 细分类</h4><h4 id="粗分类">16.2.3 粗分类</h4><h3 id="统计量的应用">16.3 统计量的应用</h3><h4 id="预测能力测度">16.3.1 预测能力测度</h4><h4 id="粗分类例子">16.3.2 粗分类例子</h4><h3 id="池化算法">16.4 池化算法</h3><h4 id="非邻池化">16.4.1 非邻池化</h4><h4 id="相邻池化">16.4.2 相邻池化</h4><h4 id="单调相邻池化">16.4.3 单调相邻池化</h4><h3 id="实际案例">16.5 实际案例</h3><h4 id="法院判决">16.5.1 法院判决</h4><h4 id="行业种类">16.5.2 行业种类</h4><h4 id="职业种类">16.5.3 职业种类</h4><h3 id="小结-14">16.6 小结</h3><h2 id="第-17-章---特征选取">第 17 章 - 特征选取</h2><h3 id="参考因素">17.1 参考因素</h3><h3 id="预测能力">17.2 预测能力</h3><h3 id="降维方法">17.3 降维方法</h3><h4 id="建模处理">17.3.1 建模处理</h4><h4 id="相关矩阵">17.3.2 相关矩阵</h4><h4 id="因子分析-1">17.3.3 因子分析</h4><h3 id="变量输入">17.4 变量输入</h3><h4 id="分步">17.4.1 分步</h4><h4 id="分块">17.4.2 分块</h4><h3 id="小结-15">17.5 小结</h3><h2 id="第-18-章---样本分层">第 18 章 - 样本分层</h2><h3 id="驱动因素">18.1 驱动因素</h3><h3 id="识别交叉的作用">18.2 识别交叉的作用</h3><h3 id="处理交叉的作用">18.3 处理交叉的作用</h3><h3 id="小结-16">18.4 小结</h3><h2 id="第-19-章---拒绝推断">第 19 章 - 拒绝推断</h2><h3 id="推断原理">19.1 推断原理</h3><h3 id="总体流动">19.2 总体流动</h3><h3 id="表现赋值">19.3 表现赋值</h3><h3 id="特殊类别">19.4 特殊类别</h3><h3 id="推断方法">19.5 推断方法</h3><h4 id="随机补充">19.5.1 随机补充</h4><h4 id="展开法">19.5.2 展开法</h4><h4 id="外推法">19.5.3 外推法</h4><h4 id="同生表现法">19.5.4 同生表现法</h4><h3 id="小结-17">19.6 小结</h3><h2 id="第-20-章---模型校准">第 20 章 - 模型校准</h2><h3 id="分数分段">20.1 分数分段</h3><h4 id="ch-统计量">20.1.1 CH 统计量</h4><h4 id="基准方法">20.1.2 基准方法</h4><h4 id="边际风险边界">20.1.3 边际风险边界</h4><h3 id="线性变换">20.2 线性变换</h3><h4 id="线性变动">20.2.1 线性变动</h4><h4 id="比率缩放">20.2.2 比率缩放</h4><h3 id="线性规划重构">20.3 线性规划重构</h3><h3 id="小结-18">20.4 小结</h3><h2 id="第-21-章---检验交付">第 21 章 - 检验交付</h2><h3 id="组成成分">21.1 组成成分</h3><h4 id="开发依据">21.1.1 开发依据</h4><h4 id="持续检验">21.1.2 持续检验</h4><h4 id="回溯测试">21.1.3 回溯测试</h4><h3 id="差别效果">21.2 差别效果</h3><h3 id="小结-19">21.3 小结</h3><h2 id="第-22-章---开发管理">第 22 章 - 开发管理</h2><h3 id="进程安排">22.1 进程安排</h3><h3 id="高效操作">22.2 高效操作</h3><h4 id="重复利用">22.2.1 重复利用</h4><h4 id="重新建模">22.2.2 重新建模</h4><h3 id="小结-20">22.3 小结</h3><h1 id="第六部分---实施和使用">第六部分 - 实施和使用</h1><h2 id="第-23-章---实施安装">第 23 章 - 实施安装</h2><h3 id="自动化决策">23.1 自动化决策</h3><h4 id="自动化程度">23.1.1 自动化程度</h4><h4 id="职责">23.1.2 职责</h4><h4 id="员工沟通">23.1.3 员工沟通</h4><h4 id="客户教育">23.1.4 客户教育</h4><h3 id="安装和测试">23.2 安装和测试</h3><h4 id="数据资源和切换">23.2.1 数据、资源和切换</h4><h4 id="测试">23.2.2 测试</h4><h3 id="小结-21">23.3 小结</h3><h2 id="第-24-章---管理控制">第 24 章 - 管理控制</h2><h3 id="政策规则">24.1 政策规则</h3><h3 id="撤销">24.2 撤销</h3><h3 id="移交">24.3 移交</h3><h4 id="信息验证">24.3.1 信息验证</h4><h4 id="账户情况">24.3.2 账户情况</h4><h3 id="控制">24.4 控制</h3><h4 id="竞争环境">24.4.1 竞争环境</h4><h4 id="评分及策略控制">24.4.2 评分及策略控制</h4><h4 id="撤销控制">24.4.3 撤销控制</h4><h3 id="小结-22">24.5 小结</h3><h2 id="第-25-章---跟踪监控">第 25 章 - 跟踪监控</h2><h3 id="组合分析">25.1 组合分析</h3><h4 id="逾期分布">25.1.1 逾期分布</h4><h4 id="转移矩阵">25.1.2 转移矩阵</h4><h3 id="表现跟踪">25.2 表现跟踪</h3><h4 id="模型表现">25.2.1 模型表现</h4><h4 id="账龄分析">25.2.2 账龄分析</h4><h4 id="分数错配">25.2.3 分数错配</h4><h3 id="偏移报告">25.3 偏移报告</h3><h4 id="总体稳定性报告">25.3.1 总体稳定性报告</h4><h4 id="分数偏移报告">25.3.2 分数偏移报告</h4><h4 id="特征分析">25.3.3 特征分析</h4><h3 id="选择过程">25.4 选择过程</h3><h4 id="决策过程">25.4.1 决策过程</h4><h4 id="分数决策">25.4.2 分数决策</h4><h4 id="政策规则-1">25.4.3 政策规则</h4><h4 id="人为撤销">25.4.4 人为撤销</h4><h3 id="小结-23">25.5 小结</h3><h2 id="第-26-章---金融财务">第 26 章 - 金融财务</h2><h3 id="坏账准备">26.1 坏账准备</h3><h3 id="直接损失估计">26.2 直接损失估计</h3><h4 id="净流量法">26.2.1 净流量法</h4><h4 id="转移矩阵法">26.2.2 转移矩阵法</h4><h3 id="损失估计">26.3 损失估计</h3><h4 id="损失概率">26.3.1 损失概率</h4><h4 id="损失程度">26.3.2 损失程度</h4><h4 id="预测分析">26.3.3 预测分析</h4><h3 id="利润模型">26.4 利润模型</h3><h4 id="利润来源">26.4.1 利润来源</h4><h4 id="利润决策">26.4.2 利润决策</h4><h4 id="利润评分">26.4.3 利润评分</h4><h3 id="风险定价">26.5 风险定价</h3><h4 id="理论实践">26.5.1 理论实践</h4><h4 id="行为变化">26.5.2 行为变化</h4><h4 id="战略考虑">26.5.3 战略考虑</h4><h4 id="客户影响">26.5.4 客户影响</h4><h3 id="小结-24">26.6 小结</h3><h1 id="第七部分---信用风险管理周期">第七部分 - 信用风险管理周期</h1><h2 id="第-27-章---市场营销">第 27 章 - 市场营销</h2><h3 id="广告媒体">27.1 广告媒体</h3><h3 id="数量与质量">27.2 数量与质量</h3><h3 id="初步筛选">27.3 初步筛选</h3><h3 id="市场数据">27.4 市场数据</h3><h3 id="小结-25">27.5 小结</h3><h2 id="第-28-章---申请审批">第 28 章 - 申请审批</h2><h3 id="收集潜在客户信息">28.1 收集潜在客户信息</h3><h4 id="获取申请信息">28.1.1 获取申请信息</h4><h4 id="纸质数据采集">28.1.2 纸质数据采集</h4><h4 id="初筛和清洗">28.1.3 初筛和清洗</h4><h3 id="策略分类">28.2 策略分类</h3><h3 id="决策执行">28.3 决策执行</h3><h4 id="拒绝">28.3.1 拒绝</h4><h4 id="接受">28.3.2 接受</h4><h3 id="小结-26">28.4 小结</h3><h2 id="第-29-章---账户管理">第 29 章 - 账户管理</h2><h3 id="额度类型">29.1 额度类型</h3><h3 id="超额管理">29.2 超额管理</h3><h4 id="支票账户">29.2.1 支票账户</h4><h4 id="信用卡授权">29.2.2 信用卡授权</h4><h4 id="客户知情效应">29.2.3 客户知情效应</h4><h3 id="更多限额和其他功能">29.3 更多限额和其他功能</h3><h4 id="提额请求">29.3.1 提额请求</h4><h4 id="提高额度">29.3.2 提高额度</h4><h4 id="额度复核">29.3.3 额度复核</h4><h4 id="交叉销售">29.3.4 交叉销售</h4><h4 id="重获客户">29.3.5 重获客户</h4><h3 id="小结-27">29.4 小结</h3><h2 id="第-30-章---催收回收">第 30 章 - 催收回收</h2><h3 id="概述">30.1 概述</h3><h3 id="时机策略">30.2 时机策略</h3><h3 id="催收评分">30.3 催收评分</h3><h3 id="小结-28">30.4 小结</h3><h2 id="第-31-章---欺诈防范">第 31 章 - 欺诈防范</h2><h3 id="欺诈类型">31.1 欺诈类型</h3><h3 id="欺诈侦测工具">31.2 欺诈侦测工具</h3><h3 id="欺诈防范策略">31.3 欺诈防范策略</h3><h3 id="欺诈评分">31.4 欺诈评分</h3><h3 id="小结-29">31.5 小结</h3><h1 id="第八部分---监管环境">第八部分 - 监管环境</h1><h2 id="第-32-章---监管理念">第 32 章 - 监管理念</h2><h3 id="最佳实践">32.1 最佳实践</h3><h3 id="善良治理">32.2 善良治理</h3><h3 id="商业道德和社会责任">32.3 商业道德和社会责任</h3><h3 id="合规等级">32.4 合规等级</h3><h3 id="小结-30">32.5 小结</h3><h2 id="第-33-章---隐私保护">第 33 章 - 隐私保护</h2><h3 id="背景">33.1 背景</h3><h4 id="历史概况">33.1.1 历史概况</h4><h4 id="tournier-案件">33.1.2 Tournier 案件</h4><h4 id="oecd-数据隐私指引">33.1.3 OECD 数据隐私指引</h4><h4 id="欧洲理事会公约">33.1.4 欧洲理事会公约</h4><h4 id="欧盟数据保护指令">33.1.5 欧盟数据保护指令</h4><h4 id="特殊情况">33.1.6 特殊情况</h4><h3 id="原则">33.2 原则</h3><h4 id="收集方式">33.2.1 收集方式</h4><h4 id="合理目的">33.2.2 合理目的</h4><h4 id="信息质量">33.2.3 信息质量</h4><h4 id="信息使用">33.2.4 信息使用</h4><h4 id="信息披露">33.2.5 信息披露</h4><h4 id="主体权利">33.2.6 主体权利</h4><h4 id="信息安全">33.2.7 信息安全</h4><h3 id="小结-31">33.3 小结</h3><h2 id="第-34-章---禁止歧视">第 34 章 - 禁止歧视</h2><h3 id="何为歧视">34.1 何为歧视</h3><h3 id="存疑特征">34.2 存疑特征</h3><h3 id="小结-32">34.3 小结</h3><h2 id="第-35-章---公平信贷">第 35 章 - 公平信贷</h2><h3 id="掠夺性放贷">35.1 掠夺性放贷</h3><h3 id="不负责放贷">35.2 不负责放贷</h3><h3 id="负责任放贷">35.3 负责任放贷</h3><h3 id="小结-33">35.4 小结</h3><h2 id="第-36-章---资本要求">第 36 章 - 资本要求</h2><h3 id="巴塞尔协议-i">36.1 巴塞尔协议 I</h3><h3 id="巴塞尔协议-ii">36.2 巴塞尔协议 II</h3><h4 id="标准法">36.2.1 标准法</h4><h4 id="内部评级法">36.2.2 内部评级法</h4><h4 id="风险暴露类别">36.2.3 风险暴露类别</h4><h4 id="违约定义">36.2.4 违约定义</h4><h4 id="评级意义">36.2.5 评级意义</h4><h4 id="执行问题">36.2.6 执行问题</h4><h3 id="风险加权资产的计算">36.3 风险加权资产的计算</h3><h3 id="小结-34">36.4 小结</h3><h2 id="第-37-章---了解客户">第 37 章 - 了解客户</h2><h3 id="尽职调查要求">37.1 尽职调查要求</h3><h3 id="客户身份识别要求">37.2 客户身份识别要求</h3><h2 id="第-38-章---国家差异">第 38 章 - 国家差异</h2><h3 id="美国">38.1 美国</h3><h3 id="加拿大">38.2 加拿大</h3><h3 id="英国">38.3 英国</h3><h3 id="澳大利亚">38.4 澳大利亚</h3><h3 id="南非">38.5 南非</h3>]]></content>
    
    
    <categories>
      
      <category>risk control</category>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>credit</tag>
      
      <tag>scorecard</tag>
      
      <tag>risk control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 344 345</title>
    <link href="/2022/06/17/leetcode20220617/"/>
    <url>/2022/06/17/leetcode20220617/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串">344. 反转字符串</h1><p>简单交换。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        length = <span class="hljs-built_in">len</span>(s)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(length/<span class="hljs-number">2</span>)):            temp = s[i]            s[i] = s[length-i-<span class="hljs-number">1</span>]            s[length-i-<span class="hljs-number">1</span>] = temp</code></pre></div><h1 id="反转字符串中的元音字母">345. 反转字符串中的元音字母</h1><p>首先我们需要用<code>set</code>存储元音字母表（这里有个坑就是大写小写都要写进去），然后通过双指针，首尾指针一起往中间遍历。如果同时遇到或者同时没有遇到元音就交换并且都移动，否则只移动没有遇到元音的指针。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseVowels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        vovel = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;        res = <span class="hljs-built_in">list</span>(s)        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            <span class="hljs-keyword">if</span> res[left] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel <span class="hljs-keyword">and</span> res[right] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> res[left] <span class="hljs-keyword">in</span> vovel <span class="hljs-keyword">and</span> res[right] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel:                right -= <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> res[left] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vovel <span class="hljs-keyword">and</span> res[right] <span class="hljs-keyword">in</span> vovel:                left += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                temp = res[left]                res[left] = res[right]                res[right] = temp                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
      <tag>bubble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《消费信用模型：定价、利润与组合》 - 读书笔记</title>
    <link href="/2022/06/10/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/"/>
    <url>/2022/06/10/%E3%80%8A%E6%B6%88%E8%B4%B9%E4%BF%A1%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%AE%9A%E4%BB%B7%E3%80%81%E5%88%A9%E6%B6%A6%E4%B8%8E%E7%BB%84%E5%90%88%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本书集合了当前信用研究和应用面临的主要问题，从三大挑战——定价（pricing ）、利润（ profit ）与组合（ portfolio）出发，进行了详细的探讨和论述。</p><p>这些贷款机构在零售贷款中遇到的新问题三个主要的变化趋势是：</p><ul><li><p>贷款机构如何根据违约风险差异化定价。</p></li><li><p>贷款机构如何把违约评分变成利润评分。</p></li><li><p>如何不仅对单个贷款风险进行评估，还对贷款组合的风险进行评估。</p></li></ul><h1 id="消费信用和信用评分简介">1 消费信用和信用评分简介</h1><h2 id="引言消费信用的重要性和影响力">1.1引言：消费信用的重要性和影响力</h2><p>讲述信用的起源，给出消费信用贷款增长数据证明消费信用的重要性和影响力。</p><h2 id="违约信用评分的历史背景">1.2 违约信用评分的历史背景</h2><ul><li><p>申请评分 - A卡</p><p>信用评分技术诞生于 20 世纪 50年代，当时的学者认识到用来分类的<strong>统计学方法</strong>可以用来区分贷款的好坏。最初的信用评分应用于是否给新的申请者发放贷款（贷前评分-申请评分）。做法是贷款机构从以往的申请者（已知好坏）那里获取数据，建立模型，把新的申请者按违约风险高低排序。</p><p>这里也提到了最常见的风险是申请者在获得贷款后12个月内出现90天及以上的逾期，<strong>这个只是坏客户定义的一种</strong>。</p><p>根据这样的坏客户定义得到的模型分数，讲究<strong>排序正确</strong>。并提到接受申请者的合格分数（准入分数）是较为主观的选择，要权衡各项业务指标如期望利润、期望损失和市场份额等。</p></li><li><p>行为评分 - B卡</p><p>行为评分技术诞生于20世纪80年代早期，是申请评分的延伸（因为它发生于一笔贷款确定放贷开始之后，行为评分-贷中评分）。着眼于申请者的动态表现，而不单单是申请时的静态特征。</p></li></ul><h2 id="贷款机构的目标">1.3 贷款机构的目标</h2><h3 id="银行的目标">1.3.1 银行的目标</h3><p>主要目标之一是让贷款带来最多的利润，也就是需要利润率最优。 <spanclass="math display">\[profit\% = \frac{profit}{principal}\]</span>另一个目标是将贷款组合（可以理解为多笔贷款的总额）的风险回报控制在可接受的范围内。</p><p>第三个目标是扩大贷款组合的规模。</p><h3 id="贷款过程">1.3.2贷款过程</h3><ul><li><p>获得资金</p><p>通过多种途径获得资金：投资人、股东；向其他金融机构借；向储户借；用活期存款支付给储户合适的利率获得资金使用权。</p></li><li><p>建立消费贷款组合</p><p>找到借款人，管理这个贷款组合，让它产生合理的利润，使得扣除资金融资成本和其他开支后还有回报。</p></li></ul><blockquote><p>这里提到了风险定价的概念，风险定价是指利用风险信息给贷款定价（贷款利率），以增加利润。<strong>这里定价指的是定利率而不是额度。</strong></p><p>这里也提到了利润评分重点在于<strong>估计从借款人（ borrower）那里可能获得的现金流</strong>，进而估计借款人的期望价值，找到可以预测借款人利润率的因素，以及提高这一利润率的决策方式。</p></blockquote><h2 id="贷款决策的建模工具">1.4 贷款决策的建模工具</h2><p>银行借钱给客户，无论是给新申请者的信用卡、按揭贷款、个人消费贷款，还是在现有基础上提高信用额度，<strong>本质上都是决策问题</strong>。这里主要介绍了<strong>影响图（influence diagram ）</strong>和<strong>决策树（ decision tree）</strong>两种工具。</p><h3 id="影响图">1.4.1 影响图</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Influence_diagram">Influencediagram - Wikipedia</a></p></blockquote><p>一张影响图由三类节点（ node ）组成，之间由线（ arc）连接。三类节点是：</p><ul><li>决策（ 用矩形表示 ）</li><li>随机事件（ 用圆圈表示 ）</li><li>结果（ 用菱形表示 ）</li></ul><p>如果某个决策或随机事件 X 对另一个决策、随机事件或结果 Y会产生影响，就画一条 X 指向 Y 的弧线箭头，表示 X 影响 Y 。当 Y的节点不同时，具有以下三种不同的含义。</p><ul><li>Y 是一个决策，那么 X 中所包含的信息可能会改变这个决策。</li><li>Y 是一个随机事件，那么条件概率 <spanclass="math inline">\(P(Y|X)\)</span> 和非条件概率 <spanclass="math inline">\(P(Y)\)</span> 并不相同。</li><li>Y 是一个结果，那么说明该结果受到了 X 的影响。</li></ul><h3 id="消费信贷中的申请决策影响图">1.4.2消费信贷中的申请决策影响图</h3><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%BE.png"alt="消费信贷中的申请决策影响图" /><figcaption aria-hidden="true">消费信贷中的申请决策影响图</figcaption></figure><h3 id="决策树">1.4.3 决策树</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Decision_tree">Decision tree -Wikipedia</a></p></blockquote><p>决策树中同样有三种类型的节点：</p><ul><li>决策（用矩形表示）</li><li>随机事件（用圆圈表示）</li><li>回报（ pay off ，用每条路径末端的数值表示）</li></ul><p><strong>值得注意的是，在决策树中左边的决策或事件比右边的决策或事件先发生。正是有了这种先后关系，才不需要箭头了。</strong></p><h3 id="消费信贷决策树">1.4.4 消费信贷决策树</h3><figure><imgsrc="https://movis-blog.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%87%E5%87%86%E6%B6%88%E8%B4%B9%E4%BF%A1%E8%B4%B7%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91.png"alt="消费信贷决策树" /><figcaption aria-hidden="true">消费信贷决策树</figcaption></figure><p>假设借款人接受贷款概率 <span class="math inline">\(q\)</span>暂不影响决策。接受申请的条件是申请者的预测风险 <spanclass="math inline">\(X\)</span> （ <spanclass="math inline">\(X\)</span> 可能为高也可能为低）满足： <spanclass="math display">\[p(X)g+(1-p(X))(-l)&gt;0\]</span> 如果要考虑接受贷款的概率 <spanclass="math inline">\(q\)</span> 与每笔贷款的贷前管理费用 <spanclass="math inline">\(c\)</span> ，那么接受申请的条件变为： <spanclass="math display">\[q[p(X)g+(1-p(X))(-l)]&gt;c\]</span></p><h3 id="策略树">1.4.5 策略树</h3><h2 id="概率比率和分数">1.5 概率、比率和分数</h2><h3 id="概率和比率">1.5.1 概率和比率</h3><p>提到了三种相互关联的方法来描述好借款人的可能性：</p><ul><li>事件发生的概率（ probability ） <spanclass="math inline">\(P(good)\)</span> 。</li><li>事件发生的比率（ odds ，好坏比） <spanclass="math inline">\(odds=\frac{P(good)}{P(bad)}\)</span> 。</li><li>包含了估计事件发生比率的所需信息的分数（ score ）或指数（ index）。</li></ul><h3 id="总体比率和信息比率">1.5.2 总体比率和信息比率</h3><p><strong>这里很重要地提到了分离了总体比率和信息比率的概念，当总体样本好坏比发生变化时，信息比率不变，总体比率会变。</strong>我的理解是提到了信息比率可以用来带来排序，而并不会受行情影响。对于贷款来讲，行情变坏时，仅能保持排序不变。</p><p><strong>证据权重 WOE （ weights of evidence）的公式为：</strong><span class="math display">\[WOE=ln(odds)=ln(\frac{P(good)}{P(bad)})\]</span> 相较于原始总体比率，证据权重是具有信息 x 或分数 s的人群的好人比率的对数。WOE为正表明这个组的好人概率比全部总体要好；若为负，则表明这组比总体要差一些。</p><h3 id="分数一个充分统计量">1.5.3 分数：一个充分统计量</h3><h3 id="对数比率分数">1.5.4 对数比率分数</h3><h3 id="对数比率分数的分解">1.5.5 对数比率分数的分解</h3><h3 id="朴素-bayes-评分卡的构建">1.5.6 朴素 Bayes 评分卡的构建</h3><h3 id="分数分布">1.5.7 分数分布</h3><h2 id="分数的变换">1.6 分数的变换</h2><h3 id="缩放自然分数">1.6.1 缩放自然分数</h3><h3 id="缩放正态分布的分数">1.6.2 缩放正态分布的分数</h3><h3 id="多级评分卡">1.6.3 多级评分卡</h3><h3 id="风险率和时变分数">1.6.4 风险率和时变分数</h3><h3 id="离散时间风险概率">1.6.5 离散时间风险概率</h3><h2 id="贷款的回收和成本">1.7 贷款的回收和成本</h2><h3 id="单期贷款的回报率模型">1.7.1 单期贷款的回报率模型</h3><h3 id="单期企业债券的回报率模型">1.7.2 单期企业债券的回报率模型</h3><h3 id="消费贷款的利润率和回报率">1.7.3 消费贷款的利润率和回报率</h3><h3 id="两期回报率模型">1.7.4 两期回报率模型</h3><h3 id="多期贷款">1.7.5 多期贷款</h3><h2 id="评分卡构建的基本原理">1.8 评分卡构建的基本原理</h2><h3 id="建立评分卡的基本方法">1.8.1 建立评分卡的基本方法</h3><h3 id="拒绝推断">1.8.2 拒绝推断</h3><h3 id="行为评分">1.8.3 行为评分</h3><h3 id="数据样本">1.8.4 数据样本</h3><h3 id="数据检验和整理">1.8.5 数据检验和整理</h3><h3 id="样本细分">1.8.6 样本细分</h3><h3 id="训练和检验样本">1.8.7 训练和检验样本</h3><h3 id="剔除特征变量">1.8.8 剔除特征变量</h3><h3 id="特征粗分类">1.8.9 特征粗分类</h3><h3 id="卡方和信息统计量">1.8.10 卡方和信息统计量</h3><h3 id="粗分类生成新变量">1.8.11 粗分类生成新变量</h3><h3 id="评分卡最终形成和检验">1.8.12 评分卡最终形成和检验</h3><h2 id="逻辑回归评分卡">1.9 逻辑回归评分卡</h2><h2 id="其他建立评分卡的方法">1.10 其他建立评分卡的方法</h2><h3 id="线性回归">1.10.1 线性回归</h3><h3 id="散度最大化">1.10.2 散度最大化</h3><h3 id="线性规划">1.10.3 线性规划</h3><h3 id="分类树">1.10.4 分类树</h3><h1 id="评分系统的评估">2 评分系统的评估</h1><h2 id="评分卡质量的评估">2.1 评分卡质量的评估</h2><h3 id="交叉验证法">2.1.1 交叉验证法</h3><h3 id="自展法">2.1.2 自展法</h3><h2 id="判别能力的测量">2.2 判别能力的测量</h2><h3 id="散度与信息量">2.2.1 散度与信息量</h3><h3 id="马氏距离">2.2.2 马氏距离</h3><h3 id="ks-统计量">2.2.3 KS 统计量</h3><h3 id="d-一致性统计量与-u-统计量">2.2.4 D 一致性统计量与 U 统计量</h3><h2 id="roc-曲线和-gini-系数">2.3 ROC 曲线和 Gini 系数</h2><h3 id="gini-系数和-auroc">2.3.1 Gini 系数和 AUROC</h3><h3 id="roc-曲线与-d-统计量ks统计量的关系">2.3.2 ROC 曲线与 D统计量、KS统计量的关系</h3><h3 id="gini-系数的边界">2.3.3 Gini 系数的边界</h3><h3 id="roc-曲线和商业决策">2.3.4 ROC 曲线和商业决策</h3><h3 id="cap-曲线与准确率">2.3.5 CAP 曲线与准确率</h3><h2 id="评分卡细分对判别能力的影响">2.4 评分卡细分对判别能力的影响</h2><h3 id="样本细分对-gini-系数的影响">2.4.1 样本细分对 Gini系数的影响</h3><h3 id="样本细分对-ks-统计量的影响">2.4.2 样本细分对 KS统计量的影响</h3><h3 id="样本细分对散度的影响">2.4.3 样本细分对散度的影响</h3><h2 id="评分卡预测概率的校准">2.5 评分卡预测概率的校准</h2><h3 id="二项检验">2.5.1 二项检验</h3><h3 id="二项检验的正态近似">2.5.2 二项检验的正态近似</h3><h3 id="卡方检验">2.5.3 卡方检验</h3><h2 id="分类预测正确程度的衡量">2.6 分类预测正确程度的衡量</h2><h3 id="混淆矩阵">2.6.1 混淆矩阵</h3><h3 id="第一类错误和第二类错误敏感度和特异度">2.6.2第一类错误和第二类错误，敏感度和特异度</h3><h3 id="交换集合">2.6.3 交换集合</h3><h3 id="最小错误成本">2.6.4 最小错误成本</h3><h1 id="基于风险定价">3 基于风险定价</h1><h2 id="消费信贷中的可变定价">3.1 消费信贷中的可变定价</h2><h3 id="可变定价">3.1.1 可变定价</h3><h3 id="差异化定价">3.1.2 差异化定价</h3><h3 id="响应率和接受率">3.1.3 响应率和接受率</h3><h2 id="无风险利率响应函数和最优定价">3.2无风险利率响应函数和最优定价</h2><h3 id="无风险响应率">3.2.1 无风险响应率</h3><h3 id="弹性">3.2.2 弹性</h3><h3 id="最大支付意愿">3.2.3 最大支付意愿</h3><h3 id="常见的响应函数">3.2.4 常见的响应函数</h3><h3 id="最优定价">3.2.5 最优定价</h3><h2 id="风险响应关系逆向选择和负担能力">3.3风险响应关系，逆向选择和负担能力</h2><h3 id="风险响应关系">3.3.1 风险响应关系</h3><h3 id="逆向选择">3.3.2 逆向选择</h3><h3 id="风险响应关系和逆向选择的区别">3.3.3风险响应关系和逆向选择的区别</h3><h3 id="负担能力">3.3.4 负担能力</h3><h2 id="基于风险的响应函数和定价">3.4 基于风险的响应函数和定价</h2><h3 id="基于风险的好人概率">3.4.1 基于风险的好人概率</h3><h3 id="基于风险的最优利率">3.4.2 基于风险的最优利率</h3><h3 id="无逆向选择的最优利率">3.4.3 无逆向选择的最优利率</h3><h3 id="有逆向选择的最优利率">3.4.4 有逆向选择的最优利率</h3><h2 id="多种优惠条件下的接受概率">3.5 多种优惠条件下的接受概率</h2><h3 id="贷款的多种优惠条件">3.5.1 贷款的多种优惠条件</h3><h3 id="逻辑接受概率函数">3.5.2 逻辑接受概率函数</h3><h3 id="线性规划估计最大支付意愿">3.5.3 线性规划估计最大支付意愿</h3><h3 id="加速生命模型估计最大支付意愿">3.5.4加速生命模型估计最大支付意愿</h3><h2 id="借贷博弈定价模型">3.6 借贷博弈定价模型</h2><h1 id="利润评分和动态模型">4 利润评分和动态模型</h1><h2 id="行为评分和账户动态管理">4.1 行为评分和账户动态管理</h2><h3 id="账户管理和利润率">4.1.1 账户管理和利润率</h3><h3 id="行为分数">4.1.2 行为分数</h3><h2 id="利润评分和风险回报矩阵">4.2 利润评分和风险回报矩阵</h2><h3 id="客户层面和产品层面的评分">4.2.1 客户层面和产品层面的评分</h3><h3 id="风险回报矩阵">4.2.2 风险回报矩阵</h3><h3 id="风险回报矩阵里的最优策略">4.2.3 风险回报矩阵里的最优策略</h3><h3 id="消费行为的动态估计">4.2.4 消费行为的动态估计</h3><h2 id="账户行为的-markov-链模型">4.3 账户行为的 Markov 链模型</h2><h3 id="markov-链的定义">4.3.1 Markov 链的定义</h3><h3 id="消费信用中的-markov-链模型">4.3.2 消费信用中的 Markov链模型</h3><h3 id="markov-链的参数估计和假设检验">4.3.3 Markov链的参数估计和假设检验</h3><h3 id="markov-链模型的延伸">4.3.4 Markov 链模型的延伸</h3><h2 id="markov-的利润率决策模型">4.4 Markov 的利润率决策模型</h2><h2 id="生存分析的违约评分系统">4.5 生存分析的违约评分系统</h2><h3 id="何时违约">4.5.1 何时违约</h3><h3 id="生存分析">4.5.2 生存分析</h3><h3 id="比例风险模型">4.5.3 比例风险模型</h3><h3 id="cox-比例风险模型">4.5.4 Cox 比例风险模型</h3><h3 id="建立比例风险模型">4.5.5 建立比例风险模型</h3><h3 id="比例风险行为分数">4.5.6 比例风险行为分数</h3><h2 id="生存分析利润模型">4.6 生存分析利润模型</h2><h3 id="生存分析计算利润率">4.6.1 生存分析计算利润率</h3><h3 id="风险竞争">4.6.2 风险竞争</h3><h1 id="组合信用风险和巴塞尔协议">5 组合信用风险和巴塞尔协议</h1><h2 id="组合信用风险">5.1 组合信用风险</h2><h3 id="组合层面的度量">5.1.1 组合层面的度量</h3><h3 id="组合层面的违约概率">5.1.2 组合层面的违约概率</h3><h3 id="违约损失率和组合层面的损失">5.1.3违约损失率和组合层面的损失</h3><h2 id="经济和监管资本">5.2 经济和监管资本</h2><h3 id="资产和负债">5.2.1 资产和负债</h3><h3 id="贷款中的风险">5.2.2 贷款中的风险</h3><h3 id="监管和经济资本">5.2.3 监管和经济资本</h3><h2 id="巴塞尔资本协议概述">5.3 巴塞尔资本协议概述</h2><h3 id="历史">5.3.1 历史</h3><h3 id="期望损失意外损失监管资本和在险价值">5.3.2期望损失、意外损失、监管资本和在险价值</h3><h3 id="组合不变性">5.3.3 组合不变性</h3><h3 id="巴塞尔模型中的监管资本">5.3.4 巴塞尔模型中的监管资本</h3><h3 id="消费信用的巴塞尔方程">5.3.5 消费信用的巴塞尔方程</h3><h3 id="小结">5.3.6 小结</h3><h2 id="巴塞尔新资本协议对信用评分的影响">5.4巴塞尔新资本协议对信用评分的影响</h2><h3 id="三角关系">5.4.1 三角关系</h3><h3 id="违约的定义">5.4.2 违约的定义</h3><h3 id="时点和周期违约概率">5.4.3 时点和周期违约概率</h3><h3 id="校准">5.4.4 校准</h3><h3 id="消费贷款中的企业信用模型">5.4.5 消费贷款中的企业信用模型</h3><h3 id="违约暴露">5.4.6 违约暴露</h3><h3 id="违约损失率">5.4.7 违约损失率</h3><h2 id="监管资本和最优临界分数">5.5 监管资本和最优临界分数</h2><h3 id="个人贷款接受决策的建模">5.5.1 个人贷款接受决策的建模</h3><h3 id="给定股权资本的组合最优临界分数">5.5.2给定股权资本的组合最优临界分数</h3><h3 id="可变股权资本的组合最优临界分数">5.5.3可变股权资本的组合最优临界分数</h3><h3 id="巴塞尔协议对-roc-曲线的影响">5.5.4 巴塞尔协议对 ROC曲线的影响</h3><h2 id="消费和企业贷款组合的信用风险建模">5.6消费和企业贷款组合的信用风险建模</h2><h3 id="企业信用模型的发展">5.6.1 企业信用模型的发展</h3><h3 id="基于信誉的消费结构模型">5.6.2 基于信誉的消费结构模型</h3><h3 id="基于负担能力的消费结构模型">5.6.3基于负担能力的消费结构模型</h3><h3 id="基于风险函数的消费简约模型">5.6.4基于风险函数的消费简约模型</h3><h3 id="基于-markov-链的消费简约模型">5.6.5 基于 Markov链的消费简约模型</h3><h2 id="消费信贷组合的压力测试">5.7 消费信贷组合的压力测试</h2><h3 id="巴塞尔协议中的压力测试">5.7.1 巴塞尔协议中的压力测试</h3><h3 id="敏感分析和情景分析">5.7.2 敏感分析和情景分析</h3><h3 id="违约概率的静态压力测试方法">5.7.3违约概率的静态压力测试方法</h3><h3 id="动态相关模型">5.7.4 动态相关模型</h3><h3 id="基于模型的动态方法">5.7.5 基于模型的动态方法</h3><h3 id="lgd-和-ead-的压力测试">5.7.6 LGD 和 EAD 的压力测试</h3>]]></content>
    
    
    <categories>
      
      <category>risk control</category>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>credit</tag>
      
      <tag>decision</tag>
      
      <tag>economics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 283 290 292</title>
    <link href="/2022/06/07/leetcode20220607/"/>
    <url>/2022/06/07/leetcode20220607/</url>
    
    <content type="html"><![CDATA[<h1 id="移动零">283. 移动零</h1><p>第一种就是想办法绕过测试。其实还是复制数组而非原地算法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        array = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:                array.append(i)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array)):            nums[i] = array[i]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array),<span class="hljs-built_in">len</span>(nums)):            nums[i] = <span class="hljs-number">0</span></code></pre></div><p>第二种，快慢双指针。用快指针遍历整个数组，慢指针记录不为0的元素并更改数组中此位置的值。最后在快指针遍历完后，慢指针到数组末端都是0，再填充。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:        slow = <span class="hljs-number">0</span>        fast = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> fast&lt;length:            <span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span>:                nums[slow] = nums[fast]                fast += <span class="hljs-number">1</span>                slow += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                fast += <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> slow&lt;length:            nums[slow] = <span class="hljs-number">0</span>            slow += <span class="hljs-number">1</span></code></pre></div><h1 id="单词规律">290. 单词规律</h1><p>双哈希表，分为正向哈希记录<code>(pattern, string)</code>与逆向哈希记录<code>(string, pattern)</code>。值得注意的点有两个：一是正向哈希记录第一次看到的键值对，逆向哈希记录最后一次看到的键值对；二是正向哈希与逆向哈希的键值对数量应该是一样的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        dict_pos = &#123;&#125;        dict_nag = &#123;&#125;        lst_ptn = <span class="hljs-built_in">list</span>(pattern)        lst_s = s.split()        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst_ptn) != <span class="hljs-built_in">len</span>(lst_s):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(lst_ptn, lst_s):            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_pos:                dict_pos[k] = v            dict_nag[v] = k        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_pos) != <span class="hljs-built_in">len</span>(dict_nag):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_pos.items():            <span class="hljs-keyword">if</span> k != dict_nag[v]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="nim-游戏">292. Nim 游戏</h1><p>这是一个简单的博弈，在此模拟下博弈的过程。</p><div class="code-wrapper"><pre><code class="hljs text">1：自己拿走1块，赢。2：自己拿走2块，赢。3：自己拿走3块，赢。4：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是1、2、3中的一种。5：自己拿走1块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。6：自己拿走2块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。7：自己拿走3块，赢。构建对方4的局面，因为4时拿无论怎么都会输所以只要构造出来就赢。8：无论自己拿走多少块，都会输。因为无论自己拿多少块，对于对方来说，都是5、6、7中的一种。9：自己拿走1块，赢。构建对方8的局面，因为8时拿无论怎么都会输所以只要构造出来就赢。</code></pre></div><p>所以可以发现，当桌上还剩4的倍数的石头数目时，拿的那一方一定会输。所以一开始的时候，我先手的话只要桌上石头是4的倍数就一定会输。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canWinNim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> n%<span class="hljs-number">4</span> != <span class="hljs-number">0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 278</title>
    <link href="/2022/06/06/leetcode20220606/"/>
    <url>/2022/06/06/leetcode20220606/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个错误的版本">278. 第一个错误的版本</h1><p>二分查找可以解决，左指针<code>left</code>记录当前正确的版本，右指针<code>right</code>记录当前错误的版本，所以当<code>right-left=1</code>时，<code>right</code>所指的就是第一个错误的版本，也就是结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">self, n</span>):        left = <span class="hljs-number">0</span>        right = n        mid = (<span class="hljs-number">1</span>+n)//<span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> right-left&gt;<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> isBadVersion(mid):                right = mid            <span class="hljs-keyword">else</span>:                left = mid            mid = (left+right)//<span class="hljs-number">2</span>        <span class="hljs-keyword">return</span> right</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 263 268</title>
    <link href="/2022/06/05/leetcode20220605/"/>
    <url>/2022/06/05/leetcode20220605/</url>
    
    <content type="html"><![CDATA[<h1 id="丑数">263. 丑数</h1><p>根据丑数的定义，1是第一个丑数，而且质因数只有2、3、5，就有如下代码。优化的地方就是除2可以用位运算。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isUgly</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">while</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> n%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>:            n /= <span class="hljs-number">3</span>        <span class="hljs-keyword">while</span> n%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:            n /= <span class="hljs-number">5</span>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span></code></pre></div><h1 id="丢失的数字">268. 丢失的数字</h1><p>读题可以知道要找的那个数是在<code>[0, len(nums)]</code>里的，所以可以用<code>range</code>生成器生成一个未丢失的数组来遍历查找是否在<code>nums</code>里面确定那个丢失的数。然后发现很慢，很容易可以想到用<code>set</code>替代查找范围<code>list</code>会快一点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">missingNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums_set = <span class="hljs-built_in">set</span>(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nums_set:                <span class="hljs-keyword">return</span> i</code></pre></div><p>当然像这种对应关系很容易想到<code>enumerate</code>这个<code>python</code>内置的函数，也就是用排序的方法解决。值得注意的就是，如果恰好是<code>n</code>是丢失的数字，需要最后返回一下<code>n</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">missingNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        nums.sort()        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> i != v:                <span class="hljs-keyword">return</span> i        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>math</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 258</title>
    <link href="/2022/06/04/leetcode20220603/"/>
    <url>/2022/06/04/leetcode20220603/</url>
    
    <content type="html"><![CDATA[<h1 id="各位相加">258. 各位相加</h1><p>简单循环，模拟题目中描述的过程逐位相加直到<code>num</code>小于10。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">while</span> num &gt;= <span class="hljs-number">10</span>:            num_str = <span class="hljs-built_in">str</span>(num)            num = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num_str])        <span class="hljs-keyword">return</span> num</code></pre></div><p>但是题目中提到了有<code>O(1)</code>时间复杂度的解法，按照题目中所描述的思路，其实第一次各位相加之后相同位数和最大的情况就是所有位上都为9。因此有：</p><div class="code-wrapper"><pre><code class="hljs text">9-&gt;999-&gt;18-&gt;9999-&gt;27-&gt;9...假设9...9(n位)-&gt;9那么9...9(n+1位)-&gt;9(n+1)=9*n+9=18-&gt;9所以假设成立</code></pre></div><p>通过数学归纳法可以发现9的倍数各位相加的最终和都是9。那么当其中一个9变成8时，其实各位相加的和就由9变成8。所以可以得：<span class="math display">\[\begin{cases}    result=0,\ when\ n=0 \\    result=9,\ when\ n\%9=0\ and\ n\neq 0 \\    result=n\%9,\ when\ n\%9\neq0\\\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> num==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">9</span> <span class="hljs-keyword">if</span> num%<span class="hljs-number">9</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> num%<span class="hljs-number">9</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>recursion</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再次学习python</title>
    <link href="/2022/06/02/%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0python/"/>
    <url>/2022/06/02/%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0python/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容全部基于<ahref="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程 -廖雪峰的官方网站</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 242</title>
    <link href="/2022/06/01/leetcode20220601/"/>
    <url>/2022/06/01/leetcode20220601/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词">242. 有效的字母异位词</h1><p>排序，比较两个字符串排序后是否相同。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">import</span> operator        <span class="hljs-keyword">return</span> operator.eq(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(s)), <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(t)))</code></pre></div><p>哈希，用<code>dict</code>进行计数。比上一种快。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashmap[i] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> hashmap.values():            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 228 231</title>
    <link href="/2022/05/29/leetcode20220529/"/>
    <url>/2022/05/29/leetcode20220529/</url>
    
    <content type="html"><![CDATA[<h1 id="汇总区间">228. 汇总区间</h1><p>双指针 <code>start</code> 和 <code>end</code>，开始遍历数组，每次循环找到一组可以被添加的值，注意下里循环条件就好。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:        res = []        start = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> start &lt; length:            end = start            <span class="hljs-keyword">while</span> end &lt; length-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (nums[end+<span class="hljs-number">1</span>]-nums[end])==<span class="hljs-number">1</span>:                end += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> start == end:                res.append(<span class="hljs-built_in">str</span>(nums[start]))            <span class="hljs-keyword">else</span>:                res.append(<span class="hljs-built_in">str</span>(nums[start])+<span class="hljs-string">&#x27;-&gt;&#x27;</span>+<span class="hljs-built_in">str</span>(nums[end]))            start = end+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="的幂">231. 2 的幂</h1><p>先来个 c 的幂的万能解法，就是在定义域（但是必须是正整数）内 c的幂的最大值设为 <span class="math inline">\(x\)</span> ，必有 <spanclass="math inline">\(x\%c=0\)</span>，其实就是判断是不是最大值的约数。比如说这道题 2 的定义域内的最大值是<code>2&lt;&lt;30</code> ，就可以写成如下代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">30</span>)%n == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div><p>当然正规军的做法是位运算。首先 2的幂的二进制表示有个规律就是所有位只有一个 1，所以可以通过查找次数是否二进制只有一个 1 来确定它是不是 2的幂。这里有个小技巧<ahref="https://movisli.github.io/posts/2022/05/19/Solution.html">LeetCode191</a> ，<code>n &amp; (n - 1)</code> 可以将最后一个 1去掉，既然只有一个 1 所以去掉之后就没有了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPowerOfTwo</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &amp; (n - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 217 219</title>
    <link href="/2022/05/27/leetcode20220527/"/>
    <url>/2022/05/27/leetcode20220527/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素">217. 存在重复元素</h1><p>简单<code>hash</code>，建立一个<code>set</code>，遍历数组，如果元素不在里面就添加，如果在里面就返回<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><h1 id="存在重复元素-ii">219. 存在重复元素 II</h1><p>这次涉及到元素还有它的下标，也是简单<code>hash</code>，不过要建立的是<code>dict</code>，<code>dict</code>的<code>key</code>是元素值，<code>dict</code>的<code>value</code>是元素下标。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> n,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[v] = n            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> n-hashmap[v] &lt;= k:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>                <span class="hljs-keyword">else</span>:                    hashmap[v] = n        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 206</title>
    <link href="/2022/05/26/leetcode20220526/"/>
    <url>/2022/05/26/leetcode20220526/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表">206. 反转链表</h1><p>常见的用栈反转。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:        stack = []        node = head        <span class="hljs-keyword">while</span> node:            stack.append(node.val)            node = node.<span class="hljs-built_in">next</span>        res = ListNode()        node = res        <span class="hljs-keyword">while</span> stack:            node.<span class="hljs-built_in">next</span> = ListNode(stack.pop())            node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 203 205</title>
    <link href="/2022/05/25/leetcode20220525/"/>
    <url>/2022/05/25/leetcode20220525/</url>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素">203. 移除链表元素</h1><p>一道基础删链表节点的问题，需要注意的是头节点如果不做特殊处理就得在前面再加个新的头节点，方便头节点重复时删除。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:        res = ListNode()        res.<span class="hljs-built_in">next</span> = head        node = res        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>.val == val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div><p>也可以先对头节点进行处理，先保证头节点不是要删除的节点。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.val == val:            head = head.<span class="hljs-built_in">next</span>        node = head        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>.val == val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h1 id="同构字符串">205. 同构字符串</h1><p>分别建立正向映射关系<code>dict_forward</code>和逆向映射关系<code>dict_backward</code>，值得一提的是最好想象成正向映射是从字符串正向去建立映射关系，而逆向映射是从字符串逆向建立映射关系。否则，过不了这样的测试用例：</p><blockquote><p>"bbbaaaba"</p><p>"aaabbbba"</p></blockquote><p>这里有个技巧就是正向映射一旦建立就不可被覆盖，而逆向一直可以被覆盖。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        dict_forward = &#123;&#125;        dict_backward = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict_forward:                dict_forward[s[i]] = t[i]            dict_backward[t[i]] = s[i]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dict_forward) != <span class="hljs-built_in">len</span>(dict_backward):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dict_forward.items():            <span class="hljs-keyword">if</span> dict_backward[v] != k:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 202</title>
    <link href="/2022/05/24/leetcode20220524/"/>
    <url>/2022/05/24/leetcode20220524/</url>
    
    <content type="html"><![CDATA[<h1 id="快乐数">202. 快乐数</h1><p>首先简单找了下10以内的，满足快乐数定义的只有1和7。然后直接采取暴力解法，循环查找，如果当某次结果跳到10以内却不等于1或7时，就是<code>False</code>，否则就是<code>True</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">7</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        res = n        <span class="hljs-keyword">while</span> res&gt;=<span class="hljs-number">10</span>:            temp = <span class="hljs-built_in">str</span>(res)            res = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:                res += <span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> res == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> res == <span class="hljs-number">7</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><p>也可以从题目中所说的无限循环入手，那么什么时候知道这个无限循环已经开始了呢，这就用到了<code>hashset</code>，当这次运算结果出现在<code>set</code>里时，说明循环已经开始了，否则我们把这次结果加入<code>set</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        hashset = &#123;n&#125;        <span class="hljs-keyword">while</span> n!=<span class="hljs-number">1</span>:            temp = <span class="hljs-built_in">str</span>(n)            n = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:                n += <span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> hashset:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                hashset.add(n)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 191</title>
    <link href="/2022/05/19/leetcode20220519/"/>
    <url>/2022/05/19/leetcode20220519/</url>
    
    <content type="html"><![CDATA[<h1 id="位1的个数">191. 位1的个数</h1><p>首先来个循环检查每一位是否为1。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        bin_str = <span class="hljs-built_in">bin</span>(n)[<span class="hljs-number">2</span>:]        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> bin_str:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;1&#x27;</span>:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>当然显然这道题考察的是位运算，所以我们可以用位运算检查循环，逐位右移，判断最低位是不是1，python的右移运算符<code>&gt;&gt;</code>就是高位补0，低位舍去。所以移动32次，就可以得到结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += <span class="hljs-number">1</span>            n &gt;&gt;= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>但是在位运算里，还有个神奇的做法，可以通过<code>n&amp;(n-1)</code>把二进制中最后一个1改写成0。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            res += <span class="hljs-number">1</span>            n &amp;= n-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><p>参考<ahref="https://leetcode.cn/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/">【负雪明烛】详解位运算，附本题躲坑指南- 位1的个数 - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 190</title>
    <link href="/2022/05/18/leetcode20220518/"/>
    <url>/2022/05/18/leetcode20220518/</url>
    
    <content type="html"><![CDATA[<h1 id="颠倒二进制位">190. 颠倒二进制位</h1><p>注意下题目中的32位无符号整数。暴力解：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;0&#x27;</span>*(<span class="hljs-number">32</span>-<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))[<span class="hljs-number">2</span>:]))+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))[<span class="hljs-number">2</span>:])[::-<span class="hljs-number">1</span>], <span class="hljs-number">2</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 168 171 175 181 182 183</title>
    <link href="/2022/05/16/leetcode20220516/"/>
    <url>/2022/05/16/leetcode20220516/</url>
    
    <content type="html"><![CDATA[<h1 id="excel表列名称">168. Excel表列名称</h1><p>此题有点类似进制转换，从A到Z有26个字母也就是26进制，需要注意的是，A对应1而不是0，Z对应26而不是25，所以在做进制转换的时候，要先减1再取余再加1。即下面<code>temp = (columnNumber-1)%26+1</code>这行代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convertToTitle</span>(<span class="hljs-params">self, columnNumber: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">while</span> columnNumber != <span class="hljs-number">0</span>:            temp = (columnNumber-<span class="hljs-number">1</span>)%<span class="hljs-number">26</span>+<span class="hljs-number">1</span>            res += <span class="hljs-built_in">chr</span>(temp+<span class="hljs-number">64</span>)            columnNumber = (columnNumber-temp)//<span class="hljs-number">26</span>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]</code></pre></div><h1 id="excel-表列序号">171. Excel 表列序号</h1><p>与上题差不多，上题的逆向。本质上还是个进制转换。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">titleToNumber</span>(<span class="hljs-params">self, columnTitle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        n = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> columnTitle[::-<span class="hljs-number">1</span>]:            res += (<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">64</span>)*n            n *= <span class="hljs-number">26</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="组合两个表">175. 组合两个表</h1><p>依题意做一个简单左链接就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTt1.firstName,t1.lastName,t2.city,t2.state FROMPerson t1LEFT JOIN Address t2 ON t1.personId = t2.personId</code></pre></div><h1 id="超过经理收入的员工">181. 超过经理收入的员工</h1><p>表自链接就行了。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTl.NAME AS Employee FROMEmployee lINNER JOIN Employee r ON l.managerId = r.id WHEREl.salary &gt; r.salary</code></pre></div><h1 id="查找重复的电子邮箱">182. 查找重复的电子邮箱</h1><p>自链接</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCTt1.Email FROMPerson t1JOIN Person t2 ON t1.Email = t2.Email AND t1.Id != t2.Id</code></pre></div><p>子表查询</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTEmail FROM( SELECT Email, count( 1 ) AS ec FROM Person GROUP BY Email ) tec WHEREtec.ec &gt; 1</code></pre></div><h1 id="从不订购的客户">183. 从不订购的客户</h1><p>子表查询</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTn.NAME AS Customers FROM( SELECT t1.NAME, t2.Id FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId ) n WHEREn.id IS NULL</code></pre></div><p>子表查询和<code>NOT IN</code>语句</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTCustomers.Name AS Customers FROMCustomers WHERECustomers.Id NOT IN ( SELECT CustomerId FROM Orders )</code></pre></div><p>右链接</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECTa.NAME AS Customers FROMCustomers aLEFT JOIN Orders b ON a.Id = b.CustomerId WHEREb.CustomerId IS NULL</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>sql</tag>
      
      <tag>ascii</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 121 125 136 169</title>
    <link href="/2022/05/15/leetcode20220515/"/>
    <url>/2022/05/15/leetcode20220515/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p>遍历一次数组，更新数组的最小值<code>min_pcp</code>与当前值与数组最小值差的最大值<code>max_pft</code>。遍历完成后，当前值与数组最小值差的最大值就是交易的最大利润。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    max_pft = <span class="hljs-number">0</span>    min_pcp = prices[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:      <span class="hljs-keyword">if</span> i &lt; min_pcp:        min_pcp = i        <span class="hljs-keyword">continue</span>      <span class="hljs-keyword">if</span> (i-min_pcp)&gt;max_pft:        max_pft = i-min_pcp    <span class="hljs-keyword">return</span> max_pft</code></pre></div></p><h1 id="验证回文串">125. 验证回文串</h1><p>先进行数据清洗再比较。 <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    washed = <span class="hljs-string">&#x27;&#x27;</span>.join(ch.lower() <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> ch.isalnum())    <span class="hljs-keyword">return</span> washed == washed[::-<span class="hljs-number">1</span>]</code></pre></div></p><h1 id="只出现一次的数字">136. 只出现一次的数字</h1><p>蠢蠢hashset。 <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                res.append(i)                hashset.add(i)            <span class="hljs-keyword">else</span>:                res.remove(i)        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]</code></pre></div>题中讲到了只有一个元素出现了一次，其它元素都出现了两次。两个相同的数进行异或的结果为0，所以可以对所有元素都进行异或运算，最终得到的结果就是出现一次的元素。只能说有点想不到。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x^y, nums)</code></pre></div></p><h1 id="多数元素">169. 多数元素</h1><p>简单粗暴，直接用字典记录每个元素出现次数，然后遍历字典，找到那个多数元素。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashmap = &#123;&#125;        feq = <span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashmap:                hashmap[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hashmap[i] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> hashmap.items():            <span class="hljs-keyword">if</span> v &gt; feq:                <span class="hljs-keyword">return</span> k</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>dp</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 83 88 94 118 119</title>
    <link href="/2022/05/13/leetcode20220513/"/>
    <url>/2022/05/13/leetcode20220513/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h1><p>基本链表操作。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> head        node = head        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">if</span> node.val == node.<span class="hljs-built_in">next</span>.val:                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = node.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head</code></pre></div><h1 id="合并两个有序数组">88. 合并两个有序数组</h1><p>本题要求<code>inplace</code>，但是我们仍然可以用<code>不inplace</code>的思想做<code>inplace</code>的事情。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-number">0</span>        res = []        <span class="hljs-keyword">while</span> (left+right)&lt;(m+n):            <span class="hljs-keyword">if</span> left&gt;=m:                res.append(nums2[right])                right += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> right&gt;=n:                res.append(nums1[left])                left += <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> nums1[left] &lt;= nums2[right]:                res.append(nums1[left])                left += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                res.append(nums2[right])                right += <span class="hljs-number">1</span>        nums1[:]=res</code></pre></div><p>当然我们也可以逆向开始放数，空间复杂度会更低。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:        tail = m+n-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> m&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n&gt;=<span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> m&lt;<span class="hljs-number">1</span>:                nums1[tail] = nums2[n-<span class="hljs-number">1</span>]                tail -= <span class="hljs-number">1</span>                n -= <span class="hljs-number">1</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">1</span>:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> nums1[m-<span class="hljs-number">1</span>] &gt;= nums2[n-<span class="hljs-number">1</span>]:                nums1[tail] = nums1[m-<span class="hljs-number">1</span>]                m -= <span class="hljs-number">1</span>                tail -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                nums1[tail] = nums2[n-<span class="hljs-number">1</span>]                n -= <span class="hljs-number">1</span>                tail -= <span class="hljs-number">1</span></code></pre></div><h1 id="二叉树的中序遍历">94. 二叉树的中序遍历</h1><p>递归：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> root:            res.extend(self.inorderTraversal(root.left))            res.append(root.val)            res.extend(self.inorderTraversal(root.right))        <span class="hljs-keyword">return</span> res</code></pre></div><p>非递归：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = []        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> res        node = root        stack = []        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">or</span> stack:            <span class="hljs-keyword">if</span> node:                stack.append(node)                node = node.left            <span class="hljs-keyword">else</span>:                node = stack.pop()                res.append(node.val)                node = node.right        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="杨辉三角">118. 杨辉三角</h1><p>就按照杨辉三角的样子，从第三行开始，除了左右两个1，其他数等于上一行的邻近两个数的和。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]        res = [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]        curRow = <span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> curRow&lt;numRows:            temp = [<span class="hljs-number">1</span>]            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res[curRow-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>):                temp.append(res[curRow-<span class="hljs-number">1</span>][i]+res[curRow-<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>])            temp.append(<span class="hljs-number">1</span>)            res.append(temp)            curRow += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="杨辉三角-ii">119. 杨辉三角 II</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRow</span>(<span class="hljs-params">self, rowIndex: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        res = [<span class="hljs-number">1</span>]        cal_num = (rowIndex)//<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, cal_num+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            res.append(<span class="hljs-built_in">int</span>(res[i-<span class="hljs-number">1</span>]*(rowIndex-i+<span class="hljs-number">1</span>)/i))        <span class="hljs-keyword">if</span> rowIndex%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cal_num,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):                res.append(res[i])        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cal_num-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):                res.append(res[i])        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>linked list</tag>
      
      <tag>array</tag>
      
      <tag>binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 70</title>
    <link href="/2022/05/11/leetcode20220511/"/>
    <url>/2022/05/11/leetcode20220511/</url>
    
    <content type="html"><![CDATA[<h1 id="爬楼梯">70. 爬楼梯</h1><p>斐波那契数列，一个数等于他上一个数和上上的数的和。分为递归解和非递归解，如果有空间限制可以把列表看作一个栈。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        lst = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>):            lst.append(lst[i]+lst[i+<span class="hljs-number">1</span>])        <span class="hljs-keyword">return</span> lst[n]</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 66 67 69</title>
    <link href="/2022/05/10/leetcode20220510/"/>
    <url>/2022/05/10/leetcode20220510/</url>
    
    <content type="html"><![CDATA[<h1 id="加一">66. 加一</h1><p>从后往前加就行了，需要用一个<code>carry flag</code>控制是否进位，加一对末位来说就是进位的，所以当<code>carry flag</code>变为<code>False</code>时，跳出循环。如果循环走完还需进位，则需要在<code>list</code>第0个位置增添个元素1。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plusOne</span>(<span class="hljs-params">self, digits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        carry = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(digits)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> carry:                digits[i] += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> digits[i] &gt;= <span class="hljs-number">10</span>:                    digits[i] %= <span class="hljs-number">10</span>                <span class="hljs-keyword">else</span>:                    carry = <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">if</span> carry:            digits.insert(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> digits</code></pre></div><h1 id="二进制求和">67.二进制求和</h1><p>直接用内置函数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(a,<span class="hljs-number">2</span>)+<span class="hljs-built_in">int</span>(b,<span class="hljs-number">2</span>)))[<span class="hljs-number">2</span>:]</code></pre></div><h1 id="x-的平方根">69. x 的平方根</h1><p>牛顿迭代法：</p><p>为了方便区别问题写为求n的平方根，即 <span class="math display">\[x^2=n\\f(x)=x^2-n\]</span> 相当于求函数<spanclass="math inline">\(f(x)\)</span>的根，关于牛顿迭代的原理参照</p><blockquote><p><ahref="https://www.zhihu.com/question/20690553/answer/146104283">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p></blockquote><p>对<span class="math inline">\(x_0\)</span>点的切线为： <spanclass="math display">\[y = f(x_0)-2x_0(x-x0)\]</span> 令<span class="math inline">\(y=0\)</span>，迭代后的<spanclass="math inline">\(x_1\)</span>点值可算得： <spanclass="math display">\[x_1=x_0-\frac{x_0}{2}+\frac{n}{2x_0}\]</span> 每次迭代的误差为： <span class="math display">\[\varepsilon = |x0-x1|\]</span> 当误差小于0.1时跳出就行了。</p><p><strong>初值不能为0。</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            last = res            res = res - res/<span class="hljs-number">2</span> + x/<span class="hljs-number">2</span>/res            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(last-res) &lt; <span class="hljs-number">1</span>:                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(res)</code></pre></div><p>二分查找：</p><p><span class="math inline">\(x\)</span>的平方根整数部分是满足<spanclass="math inline">\(k^2\leq x\)</span>的最大<spanclass="math inline">\(k\)</span>值，所以只要保证这个条件可以进行赋值。经典二分查找代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left, right, res = <span class="hljs-number">0</span>, x, -<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &lt;= right:            mid = (left+right)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid*mid &lt;= x:                res = mid                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                right = mid-<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>binary search</tag>
      
      <tag>loop</tag>
      
      <tag>Newton&#39;s method</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 58</title>
    <link href="/2022/05/09/leetcode20220509/"/>
    <url>/2022/05/09/leetcode20220509/</url>
    
    <content type="html"><![CDATA[<h1 id="最后一个单词的长度">58. 最后一个单词的长度</h1><p>反向遍历，用一个<code>flag</code>稍微控制下流程就行了，注意几个<code>if</code>的顺序。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLastWord</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        start = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> s[i] != <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> start:                start = <span class="hljs-literal">True</span>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">and</span> start:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> start:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 27 28 35 53</title>
    <link href="/2022/05/07/leetcode20220507/"/>
    <url>/2022/05/07/leetcode20220507/</url>
    
    <content type="html"><![CDATA[<h1 id="移除元素">27. 移除元素</h1><p>双指针，一个指针<code>index</code>控制循环遍历，另一个指针<code>k</code>控制将正确的数填到正确的位置。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        index = <span class="hljs-number">0</span>        k = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">while</span> index&lt;length:            <span class="hljs-keyword">if</span> nums[index] != val:                nums[k] = nums[index]                k+=<span class="hljs-number">1</span>            index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> k</code></pre></div><h1 id="实现strstr">28. 实现strStr()</h1><p>只是用的话，调用python字符串的find函数就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        <span class="hljs-keyword">return</span> haystack.find(needle)</code></pre></div><p>思路就是逐位比较。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        length = <span class="hljs-built_in">len</span>(needle)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)-length+<span class="hljs-number">1</span>):            j = i            k = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> k&lt;length <span class="hljs-keyword">and</span> haystack[j] == needle[k]:                j += <span class="hljs-number">1</span>                k += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> j-i == length:                <span class="hljs-keyword">return</span> i                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre></div><h1 id="搜索插入位置">35. 搜索插入位置</h1><p>时间复杂度<code>O(log n)</code>，经典二分查找。但是这题如果没找到要返回插入的位置，当<span class="math inline">\(left&lt;x&lt;right\)</span>时，很明显该插入的位置是<code>right_index</code>，然后看一下经典二分查找代码，因为没找到的话<code>left</code>还是会加1，所以其实没找到的话<code>left</code>就是<code>right_index</code>，所以没找到返回<code>left</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;=right:            mid = (right+left)//<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                left = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:                right = mid-<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> mid                <span class="hljs-keyword">return</span> left</code></pre></div><h1 id="最大子数组和">53. 最大子数组和</h1><p>动态规划，首先数组里至少有一个数，那么最大子数组和肯定大于等于<code>nums[0]</code>，然后从左往右遍历，创建一个变量<code>temp_sum</code>用于记录遍历过程中某一段的最大和，如果此值大于0那么往后的数还可以在此值上加，如果小于等于0那对某一段的下一段来讲算最大和时就不太需要这个<code>temp_sum</code>了。每找出一段<code>temp_sum</code>都与<code>result</code>比较取大的作为新的<code>result</code>。遍历完成后，就可以得到最大的<code>result</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        res = nums[<span class="hljs-number">0</span>]        temp_sum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            temp_sum += i            <span class="hljs-keyword">if</span> temp_sum &gt; res:                res = temp_sum            <span class="hljs-keyword">if</span> temp_sum &lt; <span class="hljs-number">0</span>:                temp_sum = <span class="hljs-number">0</span>                <span class="hljs-keyword">return</span> res</code></pre></div><blockquote><p>时间复杂度 O(n)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>binary search</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 26</title>
    <link href="/2022/05/06/leetcode20220506/"/>
    <url>/2022/05/06/leetcode20220506/</url>
    
    <content type="html"><![CDATA[<h1 id="删除有序数组中的重复项">26. 删除有序数组中的重复项</h1><p>暴力解法，创建<code>set</code>用于记录出现过的唯一元素，创建<code>drop_lst</code>用于记录要删的位置，删元素的时候注意下<code>python</code>的<code>del</code>会更改后续元素的下标，所以建立一个<code>k</code>辅助找到真正的下标再删。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        hashset = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;&#x27;</span>)        drop_lst = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hashset:                hashset.add(nums[i])            <span class="hljs-keyword">else</span>:                drop_lst.append(i)        k = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> drop_lst:            <span class="hljs-keyword">del</span> nums[i-k]            k += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(hashset)</code></pre></div><blockquote><p>1068 ms</p></blockquote><p>核心在于前探指针，每次循环时生成一个前探指针<code>next_index</code>找寻下一个不重复的元素的<code>index</code>，用指针<code>k</code>代表下一个不重复元素（假如有）正确的位置，所以在找到正确的<code>next_index</code>后，将其赋值给<code>k</code>就行了，同时将<code>index</code>变为<code>next_index</code>，最后返回<code>k-1</code>因为多算了一次<code>k</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:        index = <span class="hljs-number">0</span>        length = <span class="hljs-built_in">len</span>(nums)        k = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> index &lt; length:            next_index = index+<span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> next_index&lt;length:                <span class="hljs-keyword">if</span> nums[next_index] != nums[index]:                    <span class="hljs-keyword">break</span>                next_index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> next_index != length:                nums[k] = nums[next_index]            k += <span class="hljs-number">1</span>            index = next_index        <span class="hljs-keyword">return</span> k-<span class="hljs-number">1</span></code></pre></div><blockquote><p>28 ms</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 13</title>
    <link href="/2022/05/05/leetcode20220505/"/>
    <url>/2022/05/05/leetcode20220505/</url>
    
    <content type="html"><![CDATA[<h1 id="罗马数字转整数">13. 罗马数字转整数</h1><p>比较直接的解法，一个指针指当前位，另一个指针指下一位。如果当前位和下一位凑成了4、9等数，就在结果中加上，然后当前指针指向下下位。如果当前位和下一位没有凑成特殊情况，就在结果中加上当前位的数，并把当前位指针指向下一位。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:        res = <span class="hljs-number">0</span>        s_len = <span class="hljs-built_in">len</span>(s)        index = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> index&lt;s_len:            <span class="hljs-keyword">if</span> s[index] == <span class="hljs-string">&#x27;I&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;V&#x27;</span>:                        res += <span class="hljs-number">4</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;X&#x27;</span>:                        res += <span class="hljs-number">9</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">1</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">1</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;X&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;L&#x27;</span>:                        res += <span class="hljs-number">40</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;C&#x27;</span>:                        res += <span class="hljs-number">90</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">10</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">10</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;C&#x27;</span>:                next_index = index+<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> next_index &lt; s_len:                    <span class="hljs-keyword">if</span> s[next_index] == <span class="hljs-string">&#x27;D&#x27;</span>:                        res += <span class="hljs-number">400</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">elif</span> s[next_index] == <span class="hljs-string">&#x27;M&#x27;</span>:                        res += <span class="hljs-number">900</span>                        index += <span class="hljs-number">2</span>                    <span class="hljs-keyword">else</span>:                        res += <span class="hljs-number">100</span>                        index += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">100</span>                    index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;V&#x27;</span>:                res += <span class="hljs-number">5</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;L&#x27;</span>:                res += <span class="hljs-number">50</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;D&#x27;</span>:                res += <span class="hljs-number">500</span>                index += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[index] == <span class="hljs-string">&#x27;M&#x27;</span>:                res += <span class="hljs-number">1000</span>                index += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>point</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 14 20 21</title>
    <link href="/2022/05/04/leetcode20220504/"/>
    <url>/2022/05/04/leetcode20220504/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共前缀">14. 最长公共前缀</h1><p>首先最长公共前缀肯定小于等于最短字符串长度，所以先找出最短字符串长度，然后双循环比较字符串每个位置的值，都相等就记录，不相等直接返回当前记录。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:        res = <span class="hljs-string">&quot;&quot;</span>        min_len = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:            min_len = <span class="hljs-built_in">min</span>(min_len, <span class="hljs-built_in">len</span>(i))        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_len):            tmp_target = strs[<span class="hljs-number">0</span>][i]            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:                <span class="hljs-keyword">if</span> s[i] != tmp_target:                    <span class="hljs-keyword">return</span> res            res += tmp_target                <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="有效的括号">20. 有效的括号</h1><p>有点类似栈的思想，遍历字符串，遇到前括号进栈，遇到后括号时判断因素2个，一是栈是否为空，后括号遇到空栈说明不匹配直接返回<code>False</code>，二是后括号是否对应出栈的前括号，不对应也返回<code>False</code>。遍历完后如果栈非空说明前括号没找到对应的后括号，也返回<code>False</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;&#123;&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;[&#x27;</span>:                stack.append(i)            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;]&#x27;</span> <span class="hljs-keyword">and</span> stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> stack:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="合并两个有序链表">21. 合并两个有序链表</h1><p>迭代，主要考察对链表的理解，要创建节点方便返回，然后在两个链表都有元素时，一次添加小的元素并移动对应链表的指针，直到两个链表的有一个的指针已经指向空了。最后看看如果另一个链表如果指向非空，直接把指针指过去。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:        res = ListNode(<span class="hljs-number">0</span>)        tmp = res        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:                tmp.<span class="hljs-built_in">next</span> = list1                tmp = tmp.<span class="hljs-built_in">next</span>                list1 = list1.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                tmp.<span class="hljs-built_in">next</span> = list2                tmp = tmp.<span class="hljs-built_in">next</span>                list2 = list2.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> list1:            tmp.<span class="hljs-built_in">next</span> = list1        <span class="hljs-keyword">elif</span> list2:            tmp.<span class="hljs-built_in">next</span> = list2        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>stack</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1 9</title>
    <link href="/2022/05/03/leetcode20220503/"/>
    <url>/2022/05/03/leetcode20220503/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和">1. 两数之和</h1><p>建立一个<code>dict</code>(map)，遍历一次数组，判断<code>目标值-当前值</code>是否在<code>dict</code>的<code>key</code>里，在就输出对应的<code>value</code>(index)与当前的<code>index</code>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:        hashmap = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):            temp_target = target - nums[i]            <span class="hljs-keyword">if</span> temp_target <span class="hljs-keyword">in</span> hashmap:                <span class="hljs-keyword">return</span> [hashmap[temp_target], i]            <span class="hljs-keyword">else</span>:                hashmap[nums[i]] = i        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><h1 id="回文数">9. 回文数</h1><p>转字符串判断正序和逆序是否相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(x)[::-<span class="hljs-number">1</span>]==<span class="hljs-built_in">str</span>(x)</code></pre></div><p> 左右指针逐步向中间移动判断每一步是否相等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:        string = <span class="hljs-built_in">str</span>(x)        left = <span class="hljs-number">0</span>        right = <span class="hljs-built_in">len</span>(string)-<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left&lt;right:            <span class="hljs-keyword">if</span> string[left] != string[right]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                left += <span class="hljs-number">1</span>                right -= <span class="hljs-number">1</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>leetcode answer</category>
      
      <category>easy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
      <tag>point</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>



<!DOCTYPE html>
<html lang="en" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#414142">
  <meta name="author" content="MovisLi">
  <meta name="keywords" content="ComputerScience, DataScience, Economics&amp;Finance, Management">
  
    <meta name="description" content="[toc] 基础 核心概念 Cypher 是一种专为图设计的查询语言。图由节点和关系构成。也被称为 CQL (Cypher Query Language) 。 节点 节点在 Cypher 中由括号 () 表示，节点的标签（类似一个类的类名）由冒号 : 表示。 (:Loan) 这就是一个类型为 Loan 的节点。  neo4j 推荐节点的标签使用大驼峰命名（类似 Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Cypher 与 neo4j">
<meta property="og:url" content="https://movisli.github.io/2024/04/16/neo4j/index.html">
<meta property="og:site_name" content="movis">
<meta property="og:description" content="[toc] 基础 核心概念 Cypher 是一种专为图设计的查询语言。图由节点和关系构成。也被称为 CQL (Cypher Query Language) 。 节点 节点在 Cypher 中由括号 () 表示，节点的标签（类似一个类的类名）由冒号 : 表示。 (:Loan) 这就是一个类型为 Loan 的节点。  neo4j 推荐节点的标签使用大驼峰命名（类似 Python">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-04-16T04:27:11.000Z">
<meta property="article:modified_time" content="2024-06-07T08:32:58.968Z">
<meta property="article:author" content="MovisLi">
<meta property="article:tag" content="python">
<meta property="article:tag" content="graph">
<meta property="article:tag" content="neo4j">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Cypher 与 neo4j - movis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"movisli.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Movis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Cypher 与 neo4j"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        MovisLi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-16 12:27" pubdate>
          April 16, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k words
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Cypher 与 neo4j</h1>
            
            <div class="markdown-body">
              
              <p>[toc]</p>
<h1 id="基础">基础</h1>
<h2 id="核心概念">核心概念</h2>
<p>Cypher 是一种专为图设计的查询语言。图由节点和关系构成。也被称为 CQL
(Cypher Query Language) 。</p>
<h3 id="节点">节点</h3>
<p><strong>节点</strong>在 Cypher 中由括号 <code>()</code>
表示，节点的<strong>标签</strong>（类似一个类的类名）由冒号
<code>:</code> 表示。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">(:Loan)</code></pre></div>
<p>这就是一个类型为 Loan 的节点。</p>
<blockquote>
<p>neo4j 推荐节点的标签使用<strong>大驼峰命名</strong>（类似 Python
的类命名）。</p>
</blockquote>
<p>节点的<strong>属性</strong>以类似 JSON
的语法指定，不过不一定需要双引号，单引号也可以。<strong>属性名称区分大小写。</strong></p>
<div class="code-wrapper"><pre><code class="hljs CQL">(:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)</code></pre></div>
<p>这就是一个带有属性的 Loan 节点。</p>
<blockquote>
<p>neo4j 推荐节点和关系的属性使用<strong>小驼峰命名</strong>（类似 Java
的变量名）。</p>
</blockquote>
<h3 id="关系">关系</h3>
<p>节点之间的<strong>关系</strong>由两个破折号表示 <code>--</code>
，关系的<strong>方向</strong>由大于符号 <code>&gt;</code> 或小于符号
<code>&lt;</code> 表示。关系的<strong>类型</strong>用方括号
<code>[]</code> 与冒号 <code>:</code> 表示。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">[:USE_IN]</code></pre></div>
<blockquote>
<p>neo4j 推荐关系的类型使用<strong>大写加下划线命名</strong>（类似
Python 的常量命名）。</p>
</blockquote>
<p>将节点与关系结合表示：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">(p:Person)-[:APPLIED]-&gt;[l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;]</code></pre></div>
<p>这里表示了一个 Person （ p 和 l 都不用管，这个是变量，相当于在这段
CQL 语句里的别名而已，节点本身跟这个没关系，有点像 SQL 查询时所用的
<code>AS</code> ）APPLIED 了一笔 Loan ，这笔 Loan 的 loanId 为 123，
createdAt 为 2024-04-10 。</p>
<h2 id="数据类型">数据类型</h2>
<h3 id="数据类型-1">数据类型</h3>
<p>neo4j 中有如下数据类型：</p>
<ul>
<li><p>String 字符串</p></li>
<li><p>Integer 整数</p>
<ul>
<li>在 neo4j 里其实是 Long 。</li>
</ul></li>
<li><p>Float 浮点数</p></li>
<li><p>Boolean 布尔值</p></li>
<li><p>Date/Datetime 日期/时间</p>
<ul>
<li>日期类型可以用 <code>x.year, x.month, x.day</code>
这样的方式提取信息。</li>
</ul></li>
<li><p>Point 点</p></li>
<li><p>Lists of values 列表</p>
<ul>
<li>在 neo4j 里其实是 StringArray 。</li>
<li>列表中的值必须具有相同的数据类型。</li>
</ul></li>
</ul>
<h3 id="类型转换函数">类型转换函数</h3>
<table>

<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>toBoolean(s)</code></td>
<td style="text-align: left;">将字符串转换为布尔值</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>toFloat(s)</code></td>
<td style="text-align: left;">将字符串转换为浮点数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>toInteger(s)</code></td>
<td style="text-align: left;">将字符串转换为整数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>toString(v)</code></td>
<td style="text-align: left;">将值转换为字符串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>date(s)</code></td>
<td style="text-align: left;">将字符串转换为日期</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>datetime(s)</code></td>
<td style="text-align: left;">将字符串转换为时间</td>
</tr>
<tr class="odd">
<td style="text-align: left;">split(s, x)</td>
<td style="text-align: left;">将字符串拆分为列表，其中 s
表示要拆分的字符串，x 表示分隔符</td>
</tr>
</tbody>
</table>
<h2 id="读取">读取</h2>
<h3 id="match-return-简单查询">MATCH RETURN 简单查询</h3>
<p>使用 <code>MATCH</code> 关键字匹配节点，可以在节点里面用 JSON
的方式做条件筛选。准确来讲更像是 <code>MATCH ... RETURN</code>
一起实现了 SQL 里类似 <code>SELECT</code> 的效果。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 查询在 2024-04-10 创建的 Loan 的 loanId 属性
MATCH (l:Loan &#123;createdAt: &#x27;2024-04-10&#x27;&#125;)
RETURN l.loanId</code></pre></div>
<p>除了匹配节点，也可以匹配关系，<strong>在匹配关系的时候，不一定需要指定方向</strong>。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 查询有人申请的 Loan 的 loanId 属性
MATCH (p:Person)-[:APPLIED]-&gt;(l:Loan)
RETURN l.loanId

// 查询所有指向其他节点的节点
MATCH (l)--&gt;() RETURN l</code></pre></div>
<p>可以使用 <code>;</code> 来执行多段查询。</p>
<h3 id="optional-match-选择性匹配">OPTIONAL MATCH 选择性匹配</h3>
<p>类似 MATCH ，但是对模式的缺失部分使用空值填充（ MATCH
是直接不匹配）。</p>
<h3 id="where-条件过滤">WHERE 条件过滤</h3>
<h4 id="and-和-or">AND 和 OR</h4>
<p>使用 <code>WHERE</code> 结合 <code>AND</code> ， <code>OR</code>
关键字可以进行更复杂的查询。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 查询在 2024-04-10 创建的 Loan 的 loanId 属性
MATCH (l:Loan &#123;createdAt: &#x27;2024-04-10&#x27;&#125;)
RETURN l.loanId

// 查询在 2024-04-10 创建的 Loan 的 loanId 属性
MATCH (l:Loan)
WHERE l.createdAt = &#x27;2024-04-10&#x27;
RETURN l.loanId

// 查询在 2024-04-10 创建的 Loan 的 loanId 属性
MATCH (l)
WHERE l:Loan AND l.createdAt = &#x27;2024-04-10&#x27;
RETURN l.loanId</code></pre></div>
<p>上面三段语句是等价的。</p>
<h4 id="和-和-和-和">&gt; 和 &lt; 和 &gt;= 和 &lt;= 和 &lt;&gt;</h4>
<p>在 <code>WHERE</code> 里还能使用类似 Python 一样的使用范围过滤。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 查询 loanId 大于 122 且小于等于 124 的 Loan 节点
MATCH (l:Loan)
WHERE l.loanId &gt; 122 AND l.loanId &lt;= 124
RETURN l

// 查询 loanId 大于 122 且小于等于 124 的 Loan 节点
MATCH (l:Loan)
WHERE 122 &lt; l.loanId &lt;= 124
RETURN l

// 查询 loanId 不等于 122 的节点
MATCH (l:Loan)
WHERE l.loanId &lt;&gt; 122
RETURN l</code></pre></div>
<p>上面两段语句是等价的。</p>
<h4 id="is-null-和-is-not-null">IS NULL 和 IS NOT NULL</h4>
<p>属性的值不能为空，如果属性的值为空等价于没有这个属性。这个语法也可以说是查询属性是否存在。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 查询没有 createdAt 属性 Loan 节点
MATCH (l:Loan)
WHERE l.createdAt IS NULL
RETURN l

// 查询有 createdAt 属性的 Loan 节点
MATCH (l:Loan)
WHERE l.createdAt IS NOT NULL
RETURN l</code></pre></div>
<h4 id="字符串函数-starts-with-和-end-with-和-contains">字符串函数
STARTS WITH 和 END WITH 和 CONTAINS</h4>
<p><code>toLower()</code> 函数和 <code>toUpper()</code>
函数能够将查询转换为小写/大写，但是如果查询过程中<strong>使用了大小写转换，索引会失效</strong>。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 返回人名以 mo 开头的 Person 节点
MATCH (p:Person)
WHERE toLower(p.name) STARTS WITH &#x27;mo&#x27;
RETURN p</code></pre></div>
<h4 id="使用列表进行过滤-in">使用列表进行过滤 IN</h4>
<p>有点类似 SQL 里的 IN 。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)
WHERE p.born IN [1965, 1966, 1970]
RETURN p.name</code></pre></div>
<h4 id="查询标签是否存在">查询标签是否存在</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)
WHERE l:ApprovedLoan
RETURN l</code></pre></div>
<h3 id="return-返回结果">RETURN 返回结果</h3>
<h4 id="排序-order-by">排序 ORDER BY</h4>
<p>这个和 SQL 的用法一样，ORDER BY 加上 ASC（升序） 或者 DESC（降序）
表示去控制返回顺序，如果不写默认就是升序。</p>
<h4 id="limit-与-skip">LIMIT 与 SKIP</h4>
<p>这个用法依然和 SQL
一样，表示对返回数量的限制或者是否执行跳过操作（常用于分页）。</p>
<h4 id="去重-distinct">去重 DISTINCT</h4>
<p>DISTINCT 用在 RETURN 后面表示去重。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (:Person)-[]-&gt;(l:Loan)
RETURN DISTINCT p.name</code></pre></div>
<h4 id="投影">投影</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 返回 Loan 节点的所有属性
MATCH (l:Loan)
RETURN l &#123;.*&#125; AS loan

// 仅返回 Loan 节点的 loanId 属性
MATCH (l:Loan)
RETURN l &#123;.loanId&#125; AS loan</code></pre></div>
<p>另外这里还可以额外定义一个不存在的属性作为返回的内容，就像这样：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 返回 Loan 节点的所有属性并加一个 isSuccess 的属性
// 注意这个 isSuccess 的附加属性前面没有 &#x27;.&#x27;
MATCH (l:Loan)
RETURN l &#123;.*, isSuccess: true&#125; AS loan</code></pre></div>
<p>直接返回节点的时候，实际上每行返回这 4 个内容：</p>
<ul>
<li>identity - 唯一标识符</li>
<li>labels - 列表形式的 Label （因为一个节点可以是多个 Label ）</li>
<li>elementId - 对象 Id</li>
<li>properties - 属性的键值对</li>
</ul>
<h4 id="case-when-...-then-条件返回">CASE WHEN ... THEN 条件返回</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 对不同年龄的 Person 分别返回不一样的标识
MATCH (p:Person)
RETURN
CASE
WHEN p.born.year &lt; 1960 THEN &#x27;old&#x27;
WHEN 1960 &lt;= p.born.year &lt; 2000 THEN &#x27;middle&#x27;
ELSE p.born.year &gt;= 2000 THEN &#x27;young&#x27;
END
AS ageGroup</code></pre></div>
<h4 id="返回路径">返回路径</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 返回所有 Person APPLIED Loan 的路径
MATCH p = ((p:Person)-[:APPLIED]-&gt;(l:Loan))
RETURN p</code></pre></div>
<p>有一些可以用于分析路径的函数：</p>
<ul>
<li><code>length(p)</code> - 返回路径长度（关系数）。</li>
<li><code>nodes(p)</code> - 返回一个包含路径上所有节点的列表。</li>
<li><code>relationship(p)</code> -
返回一个包含路径上所有关系的列表。</li>
</ul>
<h3 id="暂存结果-with">暂存结果 WITH</h3>
<p><code>WITH</code> 关键字类似 <code>RETURN</code>
关键字，能够返回中间结果，在需要一个中间变量存储的场景很有用。</p>
<p>另外由于聚合函数不能用在 <code>WHERE</code>
条件过滤中，因此这种情况下 <code>WITH</code> 会比较有用。</p>
<h3 id="union-与-union-all">UNION 与 UNION ALL</h3>
<p>使用 <code>UNION</code> 关键字连接查询结果，类似 SQL
，<code>UNION</code> 要去重，<code>UNION ALL</code> 不去重。</p>
<h3 id="函数">函数</h3>
<h4 id="exists-匹配模式">exists 匹配模式</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)-[:APPLIED]-&gt;(l:Loan)
WHERE NOT exists( (p)-[:DEFAULTED]-&gt;(l:Loan) )
RETURN p.name</code></pre></div>
<h4 id="labels-查看节点标签">labels 查看节点标签</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)
RETURN labels(l)</code></pre></div>
<h4 id="types-查看关系类型">types 查看关系类型</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH ()-[r:APPLIED]-&gt;()
RETURN types(r)</code></pre></div>
<h4 id="keys-查看属性名">keys 查看属性名</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)
RETURN keys(l)</code></pre></div>
<h4 id="count-计数">count 计数</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">//查看有多少个 Loan 节点
MATCH (l:Loan)
RETURN count(l)</code></pre></div>
<p><code>count(n)</code> 这种写法将不会包括 <code>n</code>
为空的情况，<code>count(*)</code> 会包括 <code>n</code> 为空的情况。</p>
<h4 id="type-查看类型">type 查看类型</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)-[r]-&gt;(l:Loan)
RETURN p.name AS personName, type(r) AS relationshipType</code></pre></div>
<h4 id="collect-转为列表">collect 转为列表</h4>
<p><code>collect</code> 函数将结果聚合为列表。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan)
RETURN collect(l.loanId) AS loanIds</code></pre></div>
<p>可以用 <code>listObj[index]</code>
这样的方式按索引访问列表的元素，比如上面的
<code>collect(l.loanId)[0]</code> 返回第一个 Loan 节点的 loanId
属性。</p>
<h4 id="unwind-列表展开">UNWIND 列表展开</h4>
<p><code>UNWIND</code> 关键字将列表转换为多行。</p>
<h4 id="日期与时间">日期与时间</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 返回当前日期
MATCH (n) RETURN date() LIMIT 1

// 返回当前日期与时间
MATCH (n) RETURN datetime() LIMIT 1

// 返回当前时间
MATCH (n) RETURN time() LIMIT 1</code></pre></div>
<p>这三个函数可以传参，<code>datetime()</code> 采用 ISO8601
的标准，假设不传时区，默认为 UTC 。</p>
<h4 id="时间间隔">时间间隔</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// duration.between(x.date1,x.date2)

// 天数间隔
// duration.inDays(x.datetime1,x.datetime2).days</code></pre></div>
<h3 id="分组与聚合">分组与聚合</h3>
<p>在 Cypher 中，分组是隐性完成的，不需要 SQL 中的 GROUP BY
关键字，一旦使用 <code>count()</code>
这样的聚合函数，所有非聚合结果的列就会成为分组键。</p>
<p>下面的生成式也会默认去聚合。</p>
<h4 id="列表生成式-list-comprehension">列表生成式 List
Comprehension</h4>
<p>有点类似于 Python 的列表生成式的语法，生成一个列表作为结果返回。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 以一个列表形式返回名字中有 M 或 V 的人名，否则返回空列表
MATCH (p:Person)
RETURN [x IN p.name WHERE x CONTAINS &#x27;M&#x27; OR x CONTAINS&#x27;V&#x27;]</code></pre></div>
<h4 id="模式生成式-pattern-comprehension">模式生成式 Pattern
Comprehension</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 以一个列表的形式返回申请 Loan 的人名，如果一笔 Loan 没人申请过，就会是一个空列表
MATCH (l:Loan)
RETURN [(a:Person)-[:APPLIED]-&gt;(l:Loan)|a.name] AS applier_name</code></pre></div>
<h3 id="图查询-call">图查询 CALL</h3>
<h4 id="查询图里有哪些属性">查询图里有哪些属性</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL db.propertyKeys()</code></pre></div>
<p>一旦定义了属性键，即使当前没有节点或关系使用该属性键，该属性键也会保留在图中。</p>
<h4 id="查询图里有哪些标签">查询图里有哪些标签</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL db.labels()</code></pre></div>
<h4 id="查询图的数据模型">查询图的数据模型</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL db.schema.visualization()</code></pre></div>
<h4 id="查询图里的节点属性类型">查询图里的节点属性类型</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL db.schema.nodeTypeProperties()</code></pre></div>
<h4 id="查询图里的关系属性类型">查询图里的关系属性类型</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL db.schema.relTypeProperties()</code></pre></div>
<h3 id="图遍历与查询调优">图遍历与查询调优</h3>
<h4 id="explain-与-profile">EXPLAIN 与 PROFILE</h4>
<p><code>EXPLAIN</code> 和 SQL
一样可以查看查询执行过程，是否走索引等。</p>
<p><code>PROFILE</code> 可以查看检索行数，内存使用，性能调优。</p>
<p>使用 EXPLAIN 和 PROFILE 的区别在于，EXPLAIN
提供的是查询步骤的估计值，而 PROFILE
提供的是查询的确切步骤和检索的行数。</p>
<h4 id="查询的一般过程">查询的一般过程</h4>
<ol type="1">
<li>选定锚点 - 创建执行计划时，neo4j
会先确定作为查询起点的节点集加载到内存，查询的锚点是节点集中最少的节点数（有的时候可能有多个锚点）。</li>
<li>展开路径 -
如果查询指定了路径，下一步就是沿着该路径前进，这一步被称为展开路径。</li>
<li>返回结果 - 根据条件遍历返回结果（类似深度优先遍历）。</li>
</ol>
<h4 id="变长遍历">变长遍历</h4>
<p><code>shortestPath()</code> 和 <code>allShortestPath()</code>
用于查询两个节点间的最短路径，如果有多条最短路径，<code>shortestPath()</code>
返回一条（具体哪条不确定），<code>allShortestPath()</code>
返回所有，用法如下：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 查找与 loanId 这条 Loan 有关系的所有 Loan 节点
MATCH p = shortestPath((l1:Loan)-[*]-(l2:Loan))
WHERE l1.loanId = 123
RETURN l2</code></pre></div>
<p>变长遍历写在关系里，用法如下：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 两个节点正好能用 2 段关系连接
()-[*2]-()

// 两个节点用于连接的关系数大于等于 1
()-[*1..]-()

// 两个节点用于连接的关系数小于等于 3
()-[*..3]-()

// 两个节点用于连接的关系数大于等于 1 小于等于 3
()-[*1..3]-()

// 两个节点用于连接的关系数大于等于 1 小于等于 3 并且关系都是 APPLIED
()-[:APPLIED*1..3]-()</code></pre></div>
<h4 id="优化点与思路">优化点与思路</h4>
<ul>
<li>避免指定非锚点的节点的标签（如果逻辑上可以），这一步的目的是避免做类型检查。</li>
</ul>
<h3 id="子查询">子查询</h3>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL &#123;
	子查询
&#125;</code></pre></div>
<h3 id="参数化">参数化</h3>
<p>在 Cypher 中，参数名以 <code>$</code> 开头。这样做的好处是对于</p>
<h4 id="设置参数">设置参数</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 设置单个参数 personName 为 Movis ，冒号后面一定要空格
:param personName: &#x27;Movis&#x27;

// 设置多个参数，以键值对的形式设置
:params &#123;paramOne: &#x27;A&#x27;, paramTwo: 2&#125;

// 设置整数最好使用 =&gt; 强制指定
:param number=&gt;10</code></pre></div>
<h4 id="查看参数">查看参数</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">:params</code></pre></div>
<h4 id="删除参数清空">删除参数（清空）</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">:params &#123;&#125;</code></pre></div>
<h4 id="参数化查询">参数化查询</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">// 设置参数 personName 为 Movis
:param personName: &#x27;Movis&#x27;

// 查询 Movis 申请的贷款的 loanId
MATCH (p:Person)-[:APPLIED]-&gt;(l:Loan)
WHERE p.name = $personName
RETURN l.loanId</code></pre></div>
<h2 id="写入">写入</h2>
<h3 id="创建-merge-和-create">创建 MERGE 和 CREATE</h3>
<h4 id="创建节点">创建节点</h4>
<p>建议使用 <code>MERGE</code>
关键字创建节点。另外一个也可以创建节点的关键字是 <code>CREATE</code>
，使用 <code>CREATE</code>
创建节点时，再添加节点之前不查找主键。如果确定数据时干净的，可以用
<code>CREATE</code> 获得更快的速度，而 <code>MERGE</code>
的优势是解决了重复问题。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MERGE (l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)</code></pre></div>
<p>也可以多个语句一起执行：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 创建 Loan 和 Person 节点并返回这两个节点
MERGE (l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)
MERGE (p:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)
RETURN l, p</code></pre></div>
<h4 id="创建关系">创建关系</h4>
<p>当为两个节点创建关系的时候，也可以用 <code>MERGE</code>
，但这个关系必须满足：</p>
<ul>
<li>有类型</li>
<li>有方向</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (l:Loan &#123;loanId: 123&#125;)
MATCH (p:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)
MERGE (p)-[:APPLIED]-&gt;(l)</code></pre></div>
<p>关系和节点一样也可以用 JSON
的格式创建属性，也可以同时创建节点和关系：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MERGE (l:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)
MERGE (p:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)
MERGE (p)-[:APPLIED]-&gt;(l)</code></pre></div>
<p>甚至同时创建节点和关系可以简化为一句：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MERGE (:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)&lt;-[:APPLIED]-(:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)</code></pre></div>
<p><strong>默认情况下，不指定方向时， <code>MERGE</code>
将按从左到右的方向创建关系。</strong></p>
<div class="code-wrapper"><pre><code class="hljs cql">// Person APPLIED Loan
MERGE (:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)-[:APPLIED]-&gt;(:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)

// Person APPLIED Loan
MERGE (:Person &#123;name: &#x27;movis&#x27;, born: 1997&#125;)-[:APPLIED]-(:Loan &#123;loanId: 123, createdAt: &#x27;2024-04-10&#x27;&#125;)</code></pre></div>
<p>上面两段语是等价的。</p>
<h4 id="merge-与-create">MERGE 与 CREATE</h4>
<p><code>MERGE</code>
在创建之前将会去图中寻找是否有相关的模式，如果要创建的数据点存在就不会创建。可以使用下面的方法自定义
<code>MERGE</code> 创建时的操作：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MERGE (l:Loan &#123;loanId:123&#125;)
ON CREATE SET l.createdAt = &#x27;2024-04-10&#x27;
ON MATCH SET l.createdAt = &#x27;2024-04-10&#x27;</code></pre></div>
<p>这样重复创建时将会有不同的属性。</p>
<h3 id="更新-set-和-remove">更新 SET 和 REMOVE</h3>
<h4 id="添加和更新-set">添加和更新 SET</h4>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)-[:APPLIED]-&gt;(l:Loan &#123;loanId: 123&#125;)
SET p.born = 1965, l.createdAt = &#x27;2024-04-11&#x27;, l:ApprovedLoan</code></pre></div>
<p>可以用逗号分隔，一次性更新或添加多个属性或者标签。</p>
<h4 id="移除-remove-或者-set">移除 REMOVE 或者 SET</h4>
<p>可以用 <code>REMOVE</code> 关键字来删除：</p>
<ul>
<li>属性</li>
<li>标签</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs CQL">// 移除 Person movis 的 born 属性
MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)
REMOVE p.born

// 移除 Person movis 的 born 属性
MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)
SET p.born = NULL

// 移除 Loan 的 ApprovedLoan 标签
MATCH (l:Loan &#123;loanId: 123&#125;)
REMOVE l:ApprovedLoan</code></pre></div>
<p><code>SET</code> 一个属性为空和 <code>REMOVE</code>
这个属性是等价的，都是移除一个属性。</p>
<h3 id="删除-delete">删除 DELETE</h3>
<p>可以用 <code>DELETE</code> 关键字来删除：</p>
<ul>
<li>节点</li>
<li>关系</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs CQL">// 删除节点
MATCH (l:Loan &#123;loanId: 123&#125;)
DELETE l

// 删除关系
MATCH (:Person &#123;name: &#x27;movis&#x27;&#125;)-[r:APPLIED]-&gt;(:Loan &#123;loanId: 123&#125;)
DELETE r

// 同时删除节点和关系
MATCH (p:Person &#123;name: &#x27;movis&#x27;&#125;)
DETACH DELETE p</code></pre></div>
<p>值得注意的是，一个节点如果还有关系的时候， <code>DELETE</code>
需要<strong>先删除关系再删除节点</strong>（节点与自己有关系也不能直接删）。除非使用
<code>DETACH DELETE</code> 。</p>
<h2 id="约束">约束</h2>
<h3 id="创建唯一约束">创建唯一约束</h3>
<div class="code-wrapper"><pre><code class="hljs CQL">CREATE CONSTRAINT [约束名] [IF NOT EXISTS]
FOR (n:Label名称)
REQUIRE n.属性 IS UNIQUE</code></pre></div>
<p>其中加括号表明是可选项：</p>
<ul>
<li>约束名 - 如果不指定约束名，neo4j 会自动生成名称。</li>
<li>IF NOT EXISTS - 如果不加这句，当约束存在时，会报错。</li>
</ul>
<h3 id="查看约束">查看约束</h3>
<div class="code-wrapper"><pre><code class="hljs CQL">SHOW CONSTRAINTS</code></pre></div>
<h3 id="删除约束">删除约束</h3>
<div class="code-wrapper"><pre><code class="hljs CQL">DROP CONSTRAINT 约束名 [IF EXISTS]</code></pre></div>
<p>其中加括号表明是可选项：</p>
<ul>
<li>IF EXISTS - 如果不加这句，当约束不存在时，会报错。</li>
</ul>
<h2 id="从-csv-文件建图">从 CSV 文件建图</h2>
<h3 id="从-csv-文件导入数据">从 CSV 文件导入数据</h3>
<p>从 CSV 文件导入数据的语法为：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">LOAD CSV [WITH HEADERS] FROM 文件地址 [AS 文件别名] [FIELDTERMINATOR 分隔符（这里要加引号）]</code></pre></div>
<p>其中加括号的表明是可选项：</p>
<ul>
<li><code>WITH HEADERS</code> - 声明是否有表头。</li>
<li><code>AS xxx</code> - 使用 xxx 作为别名。</li>
<li><code>FIELDTERMINATOR</code> - 指定分隔符，类似
<code>pandas.load_csv()</code> 函数里的 <code>sep</code> 参数。</li>
</ul>
<p>但是这里仅仅是将数据导入到图数据库中了，并没有创建节点和关系。</p>
<h3 id="创建节点-1">创建节点</h3>
<p>假设有一张表里有想创建的 Loan 节点：</p>
<table>
<thead>
<tr class="header">
<th>loan_id</th>
<th>created_at</th>
<th>amount</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>123</td>
<td>2024-01-02</td>
<td>200</td>
</tr>
<tr class="even">
<td>456</td>
<td>2024-01-03</td>
<td>500</td>
</tr>
<tr class="odd">
<td>789</td>
<td>2024-01-04</td>
<td>1000</td>
</tr>
</tbody>
</table>
<div class="code-wrapper"><pre><code class="hljs CQL">LOAD CSV WITH HEADERS FROM 文件地址 [AS 文件别名]
MERGE (l:Loan &#123;loanId: toInteger(文件别名.loan_id)&#125;)
SET
l.createdAt = 文件别名.created_at,
l.amount = toInteger(文件别名.amount)</code></pre></div>
<p>这样就创建了 3 个 Loan 类型的节点，值得注意的是<strong>多行
<code>SET</code> 是有逗号的</strong>。</p>
<h3 id="创建关系-1">创建关系</h3>
<p>假设有 Person 来 APPLIED Loan 这样的关系，在 APPLIED 关系上需要记录
appliedAt 这个时间。</p>
<p>从一张 CSV 表格创建关系如下：</p>
<table>
<thead>
<tr class="header">
<th>person_id</th>
<th>loan_id</th>
<th>applied_at</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>123</td>
<td>2024-01-01</td>
</tr>
<tr class="even">
<td>2</td>
<td>346</td>
<td>2024-01-02</td>
</tr>
<tr class="odd">
<td>3</td>
<td>789</td>
<td>2024-01-03</td>
</tr>
</tbody>
</table>
<div class="code-wrapper"><pre><code class="hljs CQL">LOAD CSV WITH HEADERS FROM 文件地址 AS row
MATCH (p:Person &#123;personId: toInteger(row.person_id)&#125;)
MATCH (l:Loan &#123;loanId: toInteger(row.loan_id)&#125;)
MERGE (p)-[r:APPLIED]-&gt;(l)
SET r.appliedAt = row.applied_at</code></pre></div>
<h2 id="附加标签">附加标签</h2>
<p>当查询有 Person APPLIED Loan 这种关系的 Person 时一般这样：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">MATCH (p:Person)-[:APPLIED]-&gt;(:Loan) RETURN p</code></pre></div>
<p>其实可以给 Person 创建一个 Applier
标签，这样在查询这种关系时会更快（查询标签比查询关系快）：</p>
<div class="code-wrapper"><pre><code class="hljs CQL">// 创建 Applier 标签
MATCH (p:Person)-[:APPLIED]-&gt;(:Loan) 
[WITH DISTINCT] SET p:Applier

// 查询 Person APPLIED Loan 的 Person
MATCH (p:Applier) RETURN p</code></pre></div>
<p>其中，使用 <code>WITH DISTINCT</code> 会更具有写入效率。</p>
<h2 id="存储过程">存储过程</h2>
<h3 id="事务">事务</h3>
<p>在一个事务中，如果出现了错误，数据就会回滚。但是在单个事务中执行大量写入操作可能会导致性能问题和潜在的故障。</p>
<p>因此 Cypher 提供了自己控制事务的语句。</p>
<div class="code-wrapper"><pre><code class="hljs CQL">CALL &#123;
  存储过程
&#125; IN TRANSACTIONS [OF 数量 ROWS]</code></pre></div>
<p>其中加括号的表明是可选项：</p>
<ul>
<li>OF 数量 ROWS - 指定要处理的行数以进行批处理。</li>
</ul>
<h3 id="eager">Eager</h3>
<p>neo4j 在导入数据时有一种名为 <code>Eager</code>
的机制，大概意思是在导入前会将数据全部加载到内存，这样的话可能会导致内存不足。避免
Eager 的方式是将数据分为很多小部分，比如分别创建节点和关系。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/DataScience/" class="category-chain-item">DataScience</a>
  
  
    <span>></span>
    
  <a href="/categories/DataScience/Database/" class="category-chain-item">Database</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/python/">#python</a>
      
        <a href="/tags/graph/">#graph</a>
      
        <a href="/tags/neo4j/">#neo4j</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Cypher 与 neo4j</div>
      <div>https://movisli.github.io/2024/04/16/neo4j/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>MovisLi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 16, 2024</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/01/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/" title="量化投资笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">量化投资笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/29/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/" title="《曼昆经济学原理（第八版） - 微观经济学》">
                        <span class="hidden-mobile">《曼昆经济学原理（第八版） - 微观经济学》</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://unpkg.com/mathjax@3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
